import { HttpClient } from '@angular/common/http';
import { ɵɵdefineInjectable, ɵɵinject, Injectable, InjectionToken, Inject, Component, ComponentFactoryResolver, ViewChild, ViewContainerRef, Input, ViewEncapsulation, ChangeDetectionStrategy, APP_INITIALIZER, NgModule } from '@angular/core';
import { __awaiter } from 'tslib';
import { BehaviorSubject } from 'rxjs';
import '@alfresco/js-api';

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ContentActionType;
(function (ContentActionType) {
    ContentActionType["default"] = "default";
    ContentActionType["button"] = "button";
    ContentActionType["separator"] = "separator";
    ContentActionType["menu"] = "menu";
    ContentActionType["custom"] = "custom";
})(ContentActionType || (ContentActionType = {}));

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getValue(target, key) {
    if (!target) {
        return undefined;
    }
    const keys = key.split('.');
    key = '';
    do {
        key += keys.shift();
        const value = target[key];
        if (value !== undefined &&
            (typeof value === 'object' || !keys.length)) {
            target = value;
            key = '';
        }
        else if (!keys.length) {
            target = undefined;
        }
        else {
            key += '.';
        }
    } while (keys.length);
    return target;
}
function filterEnabled(entry) {
    return !entry.disabled;
}
function sortByOrder(a, b) {
    const left = a.order === undefined ? Number.MAX_SAFE_INTEGER : a.order;
    const right = b.order === undefined ? Number.MAX_SAFE_INTEGER : b.order;
    return left - right;
}
function reduceSeparators(acc, el, i, arr) {
    if (i === 0) {
        if (arr[i].type === ContentActionType.separator) {
            return acc;
        }
    }
    if (i > 0) {
        const prev = arr[i - 1];
        if (prev.type === ContentActionType.separator &&
            el.type === ContentActionType.separator) {
            return acc;
        }
        if (i === arr.length - 1) {
            if (el.type === ContentActionType.separator) {
                return acc;
            }
        }
    }
    return acc.concat(el);
}
function reduceEmptyMenus(acc, el) {
    if (el.type === ContentActionType.menu) {
        if ((el.children || []).length === 0) {
            return acc;
        }
    }
    return acc.concat(el);
}
function mergeObjects(...objects) {
    const result = {};
    objects.forEach((source) => {
        Object.keys(source).forEach((prop) => {
            let replace = false;
            if (prop.endsWith('.$replace')) {
                replace = true;
                prop = prop.replace('.$replace', '');
            }
            if (!prop.startsWith('$')) {
                if (replace) {
                    result[prop] = source[`${prop}.$replace`];
                }
                else if (prop in result && Array.isArray(result[prop])) {
                    result[prop] = mergeArrays(result[prop], source[prop]);
                }
                else if (prop in result && typeof result[prop] === 'object') {
                    result[prop] = mergeObjects(result[prop], source[prop]);
                }
                else {
                    result[prop] = source[prop];
                }
            }
        });
    });
    return result;
}
function mergeArrays(left, right) {
    const result = [];
    const map = {};
    (left || []).forEach((entry) => {
        const element = entry;
        if (element && element.hasOwnProperty('id')) {
            map[element.id] = element;
        }
        else {
            result.push(element);
        }
    });
    (right || []).forEach((entry) => {
        const element = entry;
        if (element && element.hasOwnProperty('id') && map[element.id]) {
            const merged = mergeObjects(map[element.id], element);
            map[element.id] = merged;
        }
        else {
            result.push(element);
        }
    });
    return Object.keys(map).map((key) => map[key]).concat(result);
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RuleRef {
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class ExtensionLoaderService {
    constructor(http) {
        this.http = http;
    }
    load(configPath, pluginsPath, extensions) {
        return new Promise((resolve) => {
            this.loadConfig(configPath, 0).then((result) => {
                if (result) {
                    let config = result.config;
                    const override = sessionStorage.getItem('app.extension.config');
                    if (override) {
                        config = JSON.parse(override);
                    }
                    if (!config.$references || !config.$references.length) {
                        config.$references = this.filterIgnoredExtensions(extensions || [], config.$ignoreReferenceList);
                    }
                    else {
                        config.$references = this.filterIgnoredExtensions(config.$references, config.$ignoreReferenceList);
                    }
                    if (config.$references && config.$references.length > 0) {
                        const plugins = config.$references.map((name, idx) => this.loadConfig(`${pluginsPath}/${name}`, idx));
                        Promise.all(plugins).then((results) => {
                            const configs = results
                                .filter((entry) => entry)
                                .sort(sortByOrder)
                                .map((entry) => entry.config);
                            if (configs.length > 0) {
                                config = mergeObjects(config, ...configs);
                            }
                            config = Object.assign(Object.assign(Object.assign({}, config), this.getMetadata(result.config)), { $references: configs.map((ext) => this.getMetadata(ext)) });
                            resolve(config);
                        });
                    }
                    else {
                        resolve(config);
                    }
                }
            });
        });
    }
    getMetadata(config) {
        const result = {};
        Object
            .keys(config)
            .filter((key) => key.startsWith('$'))
            .forEach((key) => {
            result[key] = config[key];
        });
        return result;
    }
    loadConfig(url, order) {
        return new Promise((resolve) => {
            this.http.get(url).subscribe((config) => {
                resolve({
                    order,
                    config
                });
            }, () => {
                resolve(null);
            });
        });
    }
    getElements(config, key, fallback = []) {
        const values = getValue(config, key) || fallback || [];
        return values.filter(filterEnabled).sort(sortByOrder);
    }
    getContentActions(config, key) {
        return this.getElements(config, key).map(this.setActionDefaults);
    }
    getRules(config) {
        if (config && config.rules) {
            return config.rules;
        }
        return [];
    }
    getRoutes(config) {
        if (config) {
            return config.routes || [];
        }
        return [];
    }
    getActions(config) {
        if (config) {
            return config.actions || [];
        }
        return [];
    }
    getFeatures(config) {
        if (config) {
            return config.features || [];
        }
        return [];
    }
    setActionDefaults(action) {
        if (action) {
            action.type = action.type || ContentActionType.default;
            action.icon = action.icon || 'extension';
        }
        return action;
    }
    filterIgnoredExtensions(extensions, ignoreReferenceList) {
        if (!ignoreReferenceList || !ignoreReferenceList.length) {
            return extensions;
        }
        return extensions.map((file) => file.match('(?!.*\/).+')[0]).filter((fileName) => !ignoreReferenceList.includes(fileName));
    }
}
ExtensionLoaderService.ɵprov = ɵɵdefineInjectable({ factory: function ExtensionLoaderService_Factory() { return new ExtensionLoaderService(ɵɵinject(HttpClient)); }, token: ExtensionLoaderService, providedIn: "root" });
ExtensionLoaderService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
ExtensionLoaderService.ctorParameters = () => [
    { type: HttpClient }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function not(context, ...args) {
    if (!args || args.length === 0) {
        return false;
    }
    return args
        .every((arg) => {
        const evaluator = context.getEvaluator(arg.value);
        if (!evaluator) {
            console.warn('evaluator not found: ' + arg.value);
            return false;
        }
        return !evaluator(context, ...(arg.parameters || []));
    });
}
function every(context, ...args) {
    if (!args || args.length === 0) {
        return false;
    }
    return args
        .every((arg) => {
        const evaluator = context.getEvaluator(arg.value);
        if (!evaluator) {
            console.warn('evaluator not found: ' + arg.value);
            return false;
        }
        return evaluator(context, ...(arg.parameters || []));
    });
}
function some(context, ...args) {
    if (!args || args.length === 0) {
        return false;
    }
    return args
        .some((arg) => {
        const evaluator = context.getEvaluator(arg.value);
        if (!evaluator) {
            console.warn('evaluator not found: ' + arg.value);
            return false;
        }
        return evaluator(context, ...(arg.parameters || []));
    });
}

class ComponentRegisterService {
    constructor() {
        this.components = {};
    }
    setComponents(values) {
        if (values) {
            this.components = Object.assign({}, this.components, values);
        }
    }
    getComponentById(id) {
        return this.components[id];
    }
    hasComponentById(id) {
        return !!this.getComponentById(id);
    }
}
ComponentRegisterService.ɵprov = ɵɵdefineInjectable({ factory: function ComponentRegisterService_Factory() { return new ComponentRegisterService(); }, token: ComponentRegisterService, providedIn: "root" });
ComponentRegisterService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];

class RuleService {
    constructor(loader) {
        this.loader = loader;
        this.context = null;
        this.rules = [];
        this.evaluators = {};
    }
    setup(config) {
        this.rules = this.loader.getRules(config);
    }
    setEvaluators(values) {
        if (values) {
            this.evaluators = Object.assign({}, this.evaluators, values);
        }
    }
    getRuleById(id) {
        return this.rules.find((ref) => ref.id === id);
    }
    getEvaluator(key) {
        if (key && key.startsWith('!')) {
            const fn = this.evaluators[key.substring(1)];
            return (context, ...args) => {
                return !fn(context, ...args);
            };
        }
        return this.evaluators[key];
    }
    evaluateRule(ruleId, context) {
        const ruleRef = this.getRuleById(ruleId);
        context = context || this.context;
        if (ruleRef) {
            const evaluator = this.getEvaluator(ruleRef.type);
            if (evaluator) {
                return evaluator(context, ...ruleRef.parameters);
            }
        }
        else {
            const evaluator = this.getEvaluator(ruleId);
            if (evaluator) {
                return evaluator(context);
            }
        }
        return false;
    }
}
RuleService.ɵprov = ɵɵdefineInjectable({ factory: function RuleService_Factory() { return new RuleService(ɵɵinject(ExtensionLoaderService)); }, token: RuleService, providedIn: "root" });
RuleService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
RuleService.ctorParameters = () => [
    { type: ExtensionLoaderService }
];

function extensionJsonsFactory() {
    return [];
}
const EXTENSION_JSONS = new InjectionToken('extension-jsons', {
    providedIn: 'root',
    factory: extensionJsonsFactory
});
function provideExtensionConfig(jsons) {
    return {
        provide: EXTENSION_JSONS,
        useValue: jsons,
        multi: true
    };
}
class ExtensionService {
    constructor(loader, componentRegister, ruleService, extensionJsons) {
        this.loader = loader;
        this.componentRegister = componentRegister;
        this.ruleService = ruleService;
        this.extensionJsons = extensionJsons;
        this.config = null;
        this.configPath = 'assets/app.extensions.json';
        this.pluginsPath = 'assets/plugins';
        this.routes = [];
        this.actions = [];
        this.features = [];
        this.authGuards = {};
        this.onSetup$ = new BehaviorSubject(this.config);
        this.setup$ = this.onSetup$.asObservable();
    }
    load() {
        return __awaiter(this, void 0, void 0, function* () {
            const config = yield this.loader.load(this.configPath, this.pluginsPath, this.extensionJsons.flat());
            this.setup(config);
            return config;
        });
    }
    setup(config) {
        if (!config) {
            console.warn('Extension configuration not found');
            return;
        }
        this.config = config;
        this.setEvaluators({
            'core.every': every,
            'core.some': some,
            'core.not': not
        });
        this.actions = this.loader.getActions(config);
        this.routes = this.loader.getRoutes(config);
        this.features = this.loader.getFeatures(config);
        this.ruleService.setup(config);
        this.onSetup$.next(config);
    }
    getFeature(key) {
        const properties = Array.isArray(key) ? [key] : key.split('.');
        return properties.reduce((prev, curr) => prev && prev[curr], this.features) || [];
    }
    getElements(key, fallback = []) {
        return this.loader.getElements(this.config, key, fallback);
    }
    setEvaluators(values) {
        this.ruleService.setEvaluators(values);
    }
    setAuthGuards(values) {
        if (values) {
            this.authGuards = Object.assign({}, this.authGuards, values);
        }
    }
    setComponents(values) {
        this.componentRegister.setComponents(values);
    }
    getRouteById(id) {
        return this.routes.find((route) => route.id === id);
    }
    getAuthGuards(ids) {
        return (ids || [])
            .map((id) => this.authGuards[id])
            .filter((guard) => guard);
    }
    getActionById(id) {
        return this.actions.find((action) => action.id === id);
    }
    getEvaluator(key) {
        return this.ruleService.getEvaluator(key);
    }
    evaluateRule(ruleId, context) {
        return this.ruleService.evaluateRule(ruleId, context);
    }
    getComponentById(id) {
        return this.componentRegister.getComponentById(id);
    }
    getRuleById(id) {
        return this.ruleService.getRuleById(id);
    }
    runExpression(value, context) {
        if (typeof value === 'string') {
            return this.evaluateExpression(value, context);
        }
        else {
            const duplicate = Object.assign({}, value);
            Object.keys(duplicate).forEach((key) => {
                duplicate[key] = this.evaluateExpression(duplicate[key], context);
            });
            return duplicate;
        }
    }
    evaluateExpression(value, context) {
        const pattern = new RegExp(/\$\((.*\)?)\)/g);
        const matches = pattern.exec(value);
        if (matches && matches.length > 1) {
            const expression = matches[1];
            const fn = new Function('context', `return ${expression}`);
            const result = fn(context);
            return result;
        }
        return value;
    }
}
ExtensionService.ɵprov = ɵɵdefineInjectable({ factory: function ExtensionService_Factory() { return new ExtensionService(ɵɵinject(ExtensionLoaderService), ɵɵinject(ComponentRegisterService), ɵɵinject(RuleService), ɵɵinject(EXTENSION_JSONS)); }, token: ExtensionService, providedIn: "root" });
ExtensionService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
ExtensionService.ctorParameters = () => [
    { type: ExtensionLoaderService },
    { type: ComponentRegisterService },
    { type: RuleService },
    { type: Array, decorators: [{ type: Inject, args: [EXTENSION_JSONS,] }] }
];

class AppExtensionService {
    constructor(extensionService) {
        this.extensionService = extensionService;
        this._references = new BehaviorSubject([]);
        this.references$ = this._references.asObservable();
    }
    load() {
        return __awaiter(this, void 0, void 0, function* () {
            const config = yield this.extensionService.load();
            this.setup(config);
        });
    }
    setup(config) {
        if (!config) {
            return;
        }
        const references = (config.$references || [])
            .filter((entry) => typeof entry === 'object')
            .map((entry) => entry);
        this._references.next(references);
    }
    getDocumentListPreset(key) {
        return this.extensionService
            .getElements(`features.documentList.${key}`)
            .filter((entry) => !entry.disabled);
    }
    getViewerExtensions() {
        return this.extensionService
            .getElements('features.viewer.content')
            .filter((extension) => !this.isViewerExtensionDisabled(extension));
    }
    isViewerExtensionDisabled(extension) {
        if (extension) {
            if (extension.disabled) {
                return true;
            }
            if (extension.rules && extension.rules.disabled) {
                return this.extensionService.evaluateRule(extension.rules.disabled);
            }
        }
        return false;
    }
}
AppExtensionService.ɵprov = ɵɵdefineInjectable({ factory: function AppExtensionService_Factory() { return new AppExtensionService(ɵɵinject(ExtensionService)); }, token: AppExtensionService, providedIn: "root" });
AppExtensionService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
AppExtensionService.ctorParameters = () => [
    { type: ExtensionService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PreviewExtensionComponent {
    constructor(extensionService, componentFactoryResolver) {
        this.extensionService = extensionService;
        this.componentFactoryResolver = componentFactoryResolver;
    }
    ngOnInit() {
        if (!this.id) {
            return;
        }
        const componentType = this.extensionService.getComponentById(this.id);
        if (componentType) {
            const factory = this.componentFactoryResolver.resolveComponentFactory(componentType);
            if (factory) {
                this.content.clear();
                this.componentRef = this.content.createComponent(factory, 0);
                this.updateInstance();
            }
        }
    }
    ngOnChanges() {
        this.updateInstance();
    }
    ngOnDestroy() {
        if (this.componentRef) {
            this.componentRef.destroy();
            this.componentRef = null;
        }
    }
    updateInstance() {
        if (this.componentRef && this.componentRef.instance) {
            const instance = this.componentRef.instance;
            instance.node = this.node;
            instance.url = this.url;
            instance.extension = this.extension;
        }
    }
}
PreviewExtensionComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-preview-extension',
                template: `
    <div #content></div>
  `
            },] }
];
PreviewExtensionComponent.ctorParameters = () => [
    { type: ExtensionService },
    { type: ComponentFactoryResolver }
];
PreviewExtensionComponent.propDecorators = {
    content: [{ type: ViewChild, args: ['content', { read: ViewContainerRef, static: true },] }],
    id: [{ type: Input }],
    url: [{ type: Input }],
    extension: [{ type: Input }],
    node: [{ type: Input }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DynamicColumnComponent {
    constructor(extensions, componentFactoryResolver) {
        this.extensions = extensions;
        this.componentFactoryResolver = componentFactoryResolver;
    }
    ngOnInit() {
        const componentType = this.extensions.getComponentById(this.id);
        if (componentType) {
            const factory = this.componentFactoryResolver.resolveComponentFactory(componentType);
            if (factory) {
                this.content.clear();
                this.componentRef = this.content.createComponent(factory, 0);
                this.updateInstance();
            }
        }
    }
    ngOnChanges(changes) {
        if (changes.node) {
            this.updateInstance();
        }
    }
    ngOnDestroy() {
        if (this.componentRef) {
            this.componentRef.destroy();
            this.componentRef = null;
        }
    }
    updateInstance() {
        if (this.componentRef && this.componentRef.instance) {
            this.componentRef.instance.context = this.context;
        }
    }
}
DynamicColumnComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-dynamic-column',
                template: `
    <ng-container #content></ng-container>
  `,
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: { class: 'adf-dynamic-column' },
                styles: [`
      .adf-dynamic-column {
        display: flex;
        align-items: center;
      }
    `]
            },] }
];
DynamicColumnComponent.ctorParameters = () => [
    { type: ExtensionService },
    { type: ComponentFactoryResolver }
];
DynamicColumnComponent.propDecorators = {
    content: [{ type: ViewChild, args: ['content', { read: ViewContainerRef, static: true },] }],
    id: [{ type: Input }],
    context: [{ type: Input }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DynamicExtensionComponent {
    constructor(extensions, componentFactoryResolver) {
        this.extensions = extensions;
        this.componentFactoryResolver = componentFactoryResolver;
        this.loaded = false;
    }
    ngOnChanges(changes) {
        if (!this.loaded) {
            this.loadComponent();
            this.loaded = true;
        }
        if (changes.data) {
            this.data = changes.data.currentValue;
        }
        this.updateInstance();
        this.proxy('ngOnChanges', changes);
    }
    loadComponent() {
        const componentType = this.extensions.getComponentById(this.id);
        if (componentType) {
            const factory = this.componentFactoryResolver.resolveComponentFactory(componentType);
            if (factory) {
                this.content.clear();
                this.componentRef = this.content.createComponent(factory, 0);
            }
        }
    }
    ngOnDestroy() {
        if (this.componentCreated()) {
            this.componentRef.destroy();
            this.componentRef = null;
        }
    }
    updateInstance() {
        if (this.componentCreated()) {
            this.componentRef.instance.data = this.data;
        }
    }
    proxy(lifecycleMethod, ...args) {
        if (this.componentCreated() && this.lifecycleHookIsImplemented(lifecycleMethod)) {
            this.componentRef.instance[lifecycleMethod].apply(this.componentRef.instance, args);
        }
    }
    componentCreated() {
        return !!this.componentRef && !!this.componentRef.instance;
    }
    lifecycleHookIsImplemented(lifecycleMethod) {
        return !!this.componentRef.instance[lifecycleMethod];
    }
}
DynamicExtensionComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-dynamic-component',
                template: `<div #content></div>`
            },] }
];
DynamicExtensionComponent.ctorParameters = () => [
    { type: ExtensionService },
    { type: ComponentFactoryResolver }
];
DynamicExtensionComponent.propDecorators = {
    content: [{ type: ViewChild, args: ['content', { read: ViewContainerRef, static: true },] }],
    id: [{ type: Input }],
    data: [{ type: Input }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DynamicTabComponent {
    constructor(extensions, componentFactoryResolver) {
        this.extensions = extensions;
        this.componentFactoryResolver = componentFactoryResolver;
    }
    ngOnInit() {
        const componentType = this.extensions.getComponentById(this.id);
        if (componentType) {
            const factory = this.componentFactoryResolver.resolveComponentFactory(componentType);
            if (factory) {
                this.content.clear();
                this.componentRef = this.content.createComponent(factory, 0);
                this.updateInstance();
            }
        }
    }
    ngOnChanges(changes) {
        if (changes.node) {
            this.updateInstance();
        }
    }
    ngOnDestroy() {
        if (this.componentRef) {
            this.componentRef.destroy();
            this.componentRef = null;
        }
    }
    updateInstance() {
        if (this.componentRef && this.componentRef.instance) {
            this.componentRef.instance.node = this.node;
        }
    }
}
DynamicTabComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-dynamic-tab',
                template: `<div #content></div>`
            },] }
];
DynamicTabComponent.ctorParameters = () => [
    { type: ExtensionService },
    { type: ComponentFactoryResolver }
];
DynamicTabComponent.propDecorators = {
    content: [{ type: ViewChild, args: ['content', { read: ViewContainerRef, static: true },] }],
    id: [{ type: Input }],
    node: [{ type: Input }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function setupExtensions(appExtensionService) {
    return () => appExtensionService.load();
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ExtensionsModule {
    static forRoot() {
        return {
            ngModule: ExtensionsModule,
            providers: [
                {
                    provide: APP_INITIALIZER,
                    useFactory: setupExtensions,
                    deps: [AppExtensionService],
                    multi: true
                }
            ]
        };
    }
    static forChild() {
        return {
            ngModule: ExtensionsModule
        };
    }
}
ExtensionsModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    DynamicExtensionComponent,
                    DynamicTabComponent,
                    DynamicColumnComponent,
                    PreviewExtensionComponent
                ],
                exports: [
                    DynamicExtensionComponent,
                    DynamicTabComponent,
                    DynamicColumnComponent,
                    PreviewExtensionComponent
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { AppExtensionService, ComponentRegisterService, ContentActionType, DynamicColumnComponent, DynamicExtensionComponent, DynamicTabComponent, EXTENSION_JSONS, ExtensionLoaderService, ExtensionService, ExtensionsModule, PreviewExtensionComponent, RuleRef, RuleService, extensionJsonsFactory, filterEnabled, getValue, mergeArrays, mergeObjects, provideExtensionConfig, reduceEmptyMenus, reduceSeparators, sortByOrder, setupExtensions as ɵa };
//# sourceMappingURL=adf-extensions.js.map
