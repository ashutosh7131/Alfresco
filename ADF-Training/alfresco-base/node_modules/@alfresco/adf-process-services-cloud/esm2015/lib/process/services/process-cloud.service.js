import { AlfrescoApiService, LogService, AppConfigService } from '@alfresco/adf-core';
import { Injectable } from '@angular/core';
import { Subject, throwError } from 'rxjs';
import { catchError, map } from 'rxjs/operators';
import { BaseCloudService } from '../../services/base-cloud.service';
import { ProcessDefinitionCloud } from '../../models/process-definition-cloud.model';
import * as i0 from "@angular/core";
import * as i1 from "@alfresco/adf-core";
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@alfresco/adf-core';
export class ProcessCloudService extends BaseCloudService {
    constructor(apiService, appConfigService, logService) {
        super(apiService, appConfigService);
        this.logService = logService;
        this.dataChangesDetected = new Subject();
    }
    getProcessInstanceById(appName, processInstanceId) {
        if (appName && processInstanceId) {
            const url = `${this.getBasePath(appName)}/query/v1/process-instances/${processInstanceId}`;
            return this.get(url).pipe(map((res) => {
                this.dataChangesDetected.next(res.entry);
                return res.entry;
            }));
        }
        else {
            this.logService.error('AppName and ProcessInstanceId are mandatory for querying a process');
            return throwError('AppName/ProcessInstanceId not configured');
        }
    }
    getProcessDefinitions(appName) {
        if (appName || appName === '') {
            const url = `${this.getBasePath(appName)}/rb/v1/process-definitions`;
            return this.get(url).pipe(map((res) => {
                return res.list.entries.map((processDefs) => new ProcessDefinitionCloud(processDefs.entry));
            }));
        }
        else {
            this.logService.error('AppName is mandatory for querying task');
            return throwError('AppName not configured');
        }
    }
    getApplicationVersions(appName) {
        if (appName) {
            const url = `${this.getBasePath(appName)}/query/v1/applications`;
            return this.get(url).pipe(map((appEntities) => {
                return appEntities.list.entries;
            }), catchError((err) => this.handleError(err)));
        }
        else {
            this.logService.error('AppName is mandatory for querying the versions of an application');
            return throwError('AppName not configured');
        }
    }
    cancelProcess(appName, processInstanceId) {
        if (appName && processInstanceId) {
            const queryUrl = `${this.getBasePath(appName)}/rb/v1/process-instances/${processInstanceId}`;
            return this.delete(queryUrl).pipe(map((res) => {
                this.dataChangesDetected.next(res.entry);
                return res.entry;
            }));
        }
        else {
            this.logService.error('App name and Process id are mandatory for deleting a process');
            return throwError('App name and process id not configured');
        }
    }
    handleError(error) {
        this.logService.error(error);
        return throwError(error || 'Server error');
    }
}
ProcessCloudService.ɵfac = function ProcessCloudService_Factory(t) { return new (t || ProcessCloudService)(ɵngcc0.ɵɵinject(ɵngcc1.AlfrescoApiService), ɵngcc0.ɵɵinject(ɵngcc1.AppConfigService), ɵngcc0.ɵɵinject(ɵngcc1.LogService)); };
ProcessCloudService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ProcessCloudService_Factory() { return new ProcessCloudService(i0.ɵɵinject(i1.AlfrescoApiService), i0.ɵɵinject(i1.AppConfigService), i0.ɵɵinject(i1.LogService)); }, token: ProcessCloudService, providedIn: "root" });
ProcessCloudService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: AppConfigService },
    { type: LogService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ProcessCloudService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc1.AlfrescoApiService }, { type: ɵngcc1.AppConfigService }, { type: ɵngcc1.LogService }]; }, null); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvY2Vzcy1jbG91ZC5zZXJ2aWNlLmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9ob21lL3RyYXZpcy9idWlsZC9BbGZyZXNjby9hbGZyZXNjby1uZzItY29tcG9uZW50cy9saWIvcHJvY2Vzcy1zZXJ2aWNlcy1jbG91ZC9zcmMvbGliL3Byb2Nlc3Mvc2VydmljZXMvcHJvY2Vzcy1jbG91ZC5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWlCQSxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsVUFBVSxFQUFFLGdCQUFnQixFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFDdEYsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQyxPQUFPLEVBQWMsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUN2RCxPQUFPLEVBQUUsVUFBVSxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRWpELE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLG1DQUFtQyxDQUFDO0FBQ3JFLE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxNQUFNLDZDQUE2QyxDQUFDO0FBQ3JGO0FBQXFDOzs7QUFLckMsTUFBTSxPQUFPLG1CQUFvQixTQUFRLGdCQUFnQjtBQUN6RCxJQUdJLFlBQVksVUFBOEIsRUFDOUIsZ0JBQWtDLEVBQzFCLFVBQXNCO0FBQzlDLFFBQVEsS0FBSyxDQUFDLFVBQVUsRUFBRSxnQkFBZ0IsQ0FBQyxDQUFDO0FBQzVDLFFBRndCLGVBQVUsR0FBVixVQUFVLENBQVk7QUFBQyxRQUozQyx3QkFBbUIsR0FBRyxJQUFJLE9BQU8sRUFBd0IsQ0FBQztBQUM5RCxJQUtJLENBQUM7QUFDTCxJQU9JLHNCQUFzQixDQUFDLE9BQWUsRUFBRSxpQkFBeUI7QUFBSSxRQUNqRSxJQUFJLE9BQU8sSUFBSSxpQkFBaUIsRUFBRTtBQUMxQyxZQUFZLE1BQU0sR0FBRyxHQUFHLEdBQUcsSUFB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QUFDLEtBQUssQ0FBQyxDQUFDO0FBQzVELGdCQUFtQixPQUFPLEdBQUcsQ0FBQyxLQUFLLENBQUM7QUFDcEMsWUFBZ0IsQ0FBQyxDQUFDLENBQ0wsQ0FBQztBQUNkLFNBQVM7QUFBQyxhQUFLO0FBQ2YsWUFBWSxJQUFJLENBQUMsVUFBVSxDQUFDLEtBQUssQ0FBQyw4REFBOEQsQ0FBQyxDQUFDO0FBQ2xHLFlBQVksT0FBTyxVQUFVLENBQUMsd0NBQXdDLENBQUMsQ0FBQztBQUN4RSxTQUFTO0FBQ1QsSUFBSSxDQUFDO0FBQ0wsSUFDWSxXQUFXLENBQUMsS0FBVztBQUNuQyxRQUFRLElBQUksQ0FBQyxVQUFVLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQ3JDLFFBQVEsT0FBTyxVQUFVLENBQUMsS0FBSyxJQUFJLGNBQWMsQ0FBQyxDQUFDO0FBQ25ELElBQUksQ0FBQztBQUNMO3dPQUFDO0FBQ0QsNlJBbkdLO0FBQUM7RUFITCxVQUFVLFNBQUMsckJBR3VDLFlBWjFDLGtCQUFrQjtLQVV2QixVQUFVLEVBQUUsTUFBTSx2QkFWUyxZQUFVLGdCQUFnQjtLQVd4RCxMQVg0RCxZQUFoQyxVQUFVO0FBQUc7Ozs7OzttSkFBRTtBQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQWxmcmVzY29BcGlTZXJ2aWNlLCBMb2dTZXJ2aWNlLCBBcHBDb25maWdTZXJ2aWNlIH0gZnJvbSAnQGFsZnJlc2NvL2FkZi1jb3JlJztcbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIFN1YmplY3QsIHRocm93RXJyb3IgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IGNhdGNoRXJyb3IsIG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFByb2Nlc3NJbnN0YW5jZUNsb3VkIH0gZnJvbSAnLi4vc3RhcnQtcHJvY2Vzcy9tb2RlbHMvcHJvY2Vzcy1pbnN0YW5jZS1jbG91ZC5tb2RlbCc7XG5pbXBvcnQgeyBCYXNlQ2xvdWRTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvYmFzZS1jbG91ZC5zZXJ2aWNlJztcbmltcG9ydCB7IFByb2Nlc3NEZWZpbml0aW9uQ2xvdWQgfSBmcm9tICcuLi8uLi9tb2RlbHMvcHJvY2Vzcy1kZWZpbml0aW9uLWNsb3VkLm1vZGVsJztcbmltcG9ydCB7IEFwcGxpY2F0aW9uVmVyc2lvbk1vZGVsLCBBcHBsaWNhdGlvblZlcnNpb25SZXNwb25zZU1vZGVsIH0gZnJvbSAnLi4vLi4vbW9kZWxzL2FwcGxpY2F0aW9uLXZlcnNpb24ubW9kZWwnO1xuXG5ASW5qZWN0YWJsZSh7XG4gICAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIFByb2Nlc3NDbG91ZFNlcnZpY2UgZXh0ZW5kcyBCYXNlQ2xvdWRTZXJ2aWNlIHtcblxuICAgIGRhdGFDaGFuZ2VzRGV0ZWN0ZWQgPSBuZXcgU3ViamVjdDxQcm9jZXNzSW5zdGFuY2VDbG91ZD4oKTtcblxuICAgIGNvbnN0cnVjdG9yKGFwaVNlcnZpY2U6IEFsZnJlc2NvQXBpU2VydmljZSxcbiAgICAgICAgICAgICAgICBhcHBDb25maWdTZXJ2aWNlOiBBcHBDb25maWdTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgbG9nU2VydmljZTogTG9nU2VydmljZSkge1xuICAgICAgICBzdXBlcihhcGlTZXJ2aWNlLCBhcHBDb25maWdTZXJ2aWNlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGRldGFpbHMgb2YgYSBwcm9jZXNzIGluc3RhbmNlLlxuICAgICAqIEBwYXJhbSBhcHBOYW1lIE5hbWUgb2YgdGhlIGFwcFxuICAgICAqIEBwYXJhbSBwcm9jZXNzSW5zdGFuY2VJZCBJRCBvZiB0aGUgcHJvY2VzcyBpbnN0YW5jZSB3aG9zZSBkZXRhaWxzIHlvdSB3YW50XG4gICAgICogQHJldHVybnMgUHJvY2VzcyBpbnN0YW5jZSBkZXRhaWxzXG4gICAgICovXG4gICAgZ2V0UHJvY2Vzc0luc3RhbmNlQnlJZChhcHBOYW1lOiBzdHJpbmcsIHByb2Nlc3NJbnN0YW5jZUlkOiBzdHJpbmcpOiBPYnNlcnZhYmxlPFByb2Nlc3NJbnN0YW5jZUNsb3VkPiB7XG4gICAgICAgIGlmIChhcHBOYW1lICYmIHByb2Nlc3NJbnN0YW5jZUlkKSB7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmdldEJhc2VQYXRoKGFwcE5hbWUpfS9xdWVyeS92MS9wcm9jZXNzLWluc3RhbmNlcy8ke3Byb2Nlc3NJbnN0YW5jZUlkfWA7XG5cbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldDx7IGVudHJ5OiBQcm9jZXNzSW5zdGFuY2VDbG91ZCB9Pih1cmwpLnBpcGUoXG4gICAgICAgICAgICAgICAgbWFwKChyZXMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhQ2hhbmdlc0RldGVjdGVkLm5leHQocmVzLmVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcy5lbnRyeTtcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9nU2VydmljZS5lcnJvcignQXBwTmFtZSBhbmQgUHJvY2Vzc0luc3RhbmNlSWQgYXJlIG1hbmRhdG9yeSBmb3IgcXVlcnlpbmcgYSBwcm9jZXNzJyk7XG4gICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcignQXBwTmFtZS9Qcm9jZXNzSW5zdGFuY2VJZCBub3QgY29uZmlndXJlZCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcHJvY2VzcyBkZWZpbml0aW9ucyBhc3NvY2lhdGVkIHdpdGggYW4gYXBwLlxuICAgICAqIEBwYXJhbSBhcHBOYW1lIE5hbWUgb2YgdGhlIHRhcmdldCBhcHBcbiAgICAgKiBAcmV0dXJucyBBcnJheSBvZiBwcm9jZXNzIGRlZmluaXRpb25zXG4gICAgICovXG4gICAgZ2V0UHJvY2Vzc0RlZmluaXRpb25zKGFwcE5hbWU6IHN0cmluZyk6IE9ic2VydmFibGU8UHJvY2Vzc0RlZmluaXRpb25DbG91ZFtdPiB7XG4gICAgICAgIGlmIChhcHBOYW1lIHx8IGFwcE5hbWUgPT09ICcnKSB7XG4gICAgICAgICAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmdldEJhc2VQYXRoKGFwcE5hbWUpfS9yYi92MS9wcm9jZXNzLWRlZmluaXRpb25zYDtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHVybCkucGlwZShcbiAgICAgICAgICAgICAgICBtYXAoKHJlczogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXMubGlzdC5lbnRyaWVzLm1hcCgocHJvY2Vzc0RlZnMpID0+IG5ldyBQcm9jZXNzRGVmaW5pdGlvbkNsb3VkKHByb2Nlc3NEZWZzLmVudHJ5KSk7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvZ1NlcnZpY2UuZXJyb3IoJ0FwcE5hbWUgaXMgbWFuZGF0b3J5IGZvciBxdWVyeWluZyB0YXNrJyk7XG4gICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcignQXBwTmFtZSBub3QgY29uZmlndXJlZCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYXBwbGljYXRpb24gdmVyc2lvbnMgYXNzb2NpYXRlZCB3aXRoIGFuIGFwcC5cbiAgICAgKiBAcGFyYW0gYXBwTmFtZSBOYW1lIG9mIHRoZSB0YXJnZXQgYXBwXG4gICAgICogQHJldHVybnMgQXJyYXkgb2YgQXBwbGljYXRpb24gVmVyc2lvbiBNb2RlbHNcbiAgICAgKi9cbiAgICBnZXRBcHBsaWNhdGlvblZlcnNpb25zKGFwcE5hbWU6IHN0cmluZyk6IE9ic2VydmFibGU8QXBwbGljYXRpb25WZXJzaW9uTW9kZWxbXT4ge1xuICAgICAgICBpZiAoYXBwTmFtZSkge1xuICAgICAgICAgICAgY29uc3QgdXJsID0gYCR7dGhpcy5nZXRCYXNlUGF0aChhcHBOYW1lKX0vcXVlcnkvdjEvYXBwbGljYXRpb25zYDtcblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0PGFueT4odXJsKS5waXBlKFxuICAgICAgICAgICAgICAgIG1hcCgoYXBwRW50aXRpZXM6IEFwcGxpY2F0aW9uVmVyc2lvblJlc3BvbnNlTW9kZWwpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFwcEVudGl0aWVzLmxpc3QuZW50cmllcztcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBjYXRjaEVycm9yKChlcnIpID0+IHRoaXMuaGFuZGxlRXJyb3IoZXJyKSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvZ1NlcnZpY2UuZXJyb3IoJ0FwcE5hbWUgaXMgbWFuZGF0b3J5IGZvciBxdWVyeWluZyB0aGUgdmVyc2lvbnMgb2YgYW4gYXBwbGljYXRpb24nKTtcbiAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKCdBcHBOYW1lIG5vdCBjb25maWd1cmVkJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYW5jZWxzIGEgcHJvY2Vzcy5cbiAgICAgKiBAcGFyYW0gYXBwTmFtZSBOYW1lIG9mIHRoZSBhcHBcbiAgICAgKiBAcGFyYW0gcHJvY2Vzc0luc3RhbmNlSWQgSWQgb2YgdGhlIHByb2Nlc3MgdG8gY2FuY2VsXG4gICAgICogQHJldHVybnMgT3BlcmF0aW9uIEluZm9ybWF0aW9uXG4gICAgICovXG4gICAgY2FuY2VsUHJvY2VzcyhhcHBOYW1lOiBzdHJpbmcsIHByb2Nlc3NJbnN0YW5jZUlkOiBzdHJpbmcpOiBPYnNlcnZhYmxlPFByb2Nlc3NJbnN0YW5jZUNsb3VkPiB7XG4gICAgICAgIGlmIChhcHBOYW1lICYmIHByb2Nlc3NJbnN0YW5jZUlkKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVVybCA9IGAke3RoaXMuZ2V0QmFzZVBhdGgoYXBwTmFtZSl9L3JiL3YxL3Byb2Nlc3MtaW5zdGFuY2VzLyR7cHJvY2Vzc0luc3RhbmNlSWR9YDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRlbGV0ZShxdWVyeVVybCkucGlwZShcbiAgICAgICAgICAgICAgICBtYXAoKHJlczogYW55KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhQ2hhbmdlc0RldGVjdGVkLm5leHQocmVzLmVudHJ5KTtcbiAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzLmVudHJ5O1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5sb2dTZXJ2aWNlLmVycm9yKCdBcHAgbmFtZSBhbmQgUHJvY2VzcyBpZCBhcmUgbWFuZGF0b3J5IGZvciBkZWxldGluZyBhIHByb2Nlc3MnKTtcbiAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKCdBcHAgbmFtZSBhbmQgcHJvY2VzcyBpZCBub3QgY29uZmlndXJlZCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBoYW5kbGVFcnJvcihlcnJvcj86IGFueSkge1xuICAgICAgICB0aGlzLmxvZ1NlcnZpY2UuZXJyb3IoZXJyb3IpO1xuICAgICAgICByZXR1cm4gdGhyb3dFcnJvcihlcnJvciB8fCAnU2VydmVyIGVycm9yJyk7XG4gICAgfVxufVxuIl19