import { Injectable } from '@angular/core';
import { AlfrescoApiService, AppConfigService, LogService } from '@alfresco/adf-core';
import { throwError } from 'rxjs';
import { BaseCloudService } from '../../../services/base-cloud.service';
import { map } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "@alfresco/adf-core";
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@alfresco/adf-core';
export class ProcessListCloudService extends BaseCloudService {
    constructor(apiService, appConfigService, logService) {
        super(apiService, appConfigService);
        this.logService = logService;
    }
    getProcessByRequest(requestNode, queryUrl) {
        if (requestNode.appName || requestNode.appName === '') {
            queryUrl = queryUrl || `${this.getBasePath(requestNode.appName)}/query/v1/process-instances`;
            const queryParams = this.buildQueryParams(requestNode);
            const sortingParams = this.buildSortingParam(requestNode.sorting);
            if (sortingParams) {
                queryParams['sort'] = sortingParams;
            }
            return this.get(queryUrl, queryParams).pipe(map((response) => {
                const entries = response.list && response.list.entries;
                if (entries) {
                    response.list.entries = entries.map((entryData) => {
                        return entryData.entry;
                    });
                }
                return response;
            }));
        }
        else {
            this.logService.error('Appname is mandatory for querying task');
            return throwError('Appname not configured');
        }
    }
    isPropertyValueValid(requestNode, property) {
        return requestNode[property] !== '' && requestNode[property] !== null && requestNode[property] !== undefined;
    }
    buildQueryParams(requestNode) {
        const queryParam = {};
        for (const property in requestNode) {
            if (requestNode.hasOwnProperty(property) &&
                !this.isExcludedField(property) &&
                this.isPropertyValueValid(requestNode, property)) {
                queryParam[property] = requestNode[property];
            }
        }
        if (!queryParam['status']) {
            queryParam['status'] = this.buildFilterForAllStatus();
        }
        return queryParam;
    }
    buildFilterForAllStatus() {
        return ['RUNNING', 'SUSPENDED', 'CANCELLED', 'COMPLETED'];
    }
    isExcludedField(property) {
        return property === 'appName' || property === 'sorting';
    }
    buildSortingParam(models) {
        let finalSorting = '';
        if (models) {
            for (const sort of models) {
                if (!finalSorting) {
                    finalSorting = `${sort.orderBy},${sort.direction}`;
                }
                else {
                    finalSorting = `${finalSorting}&${sort.orderBy},${sort.direction}`;
                }
            }
        }
        return encodeURI(finalSorting);
    }
}
ProcessListCloudService.ɵfac = function ProcessListCloudService_Factory(t) { return new (t || ProcessListCloudService)(ɵngcc0.ɵɵinject(ɵngcc1.AlfrescoApiService), ɵngcc0.ɵɵinject(ɵngcc1.AppConfigService), ɵngcc0.ɵɵinject(ɵngcc1.LogService)); };
ProcessListCloudService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ProcessListCloudService_Factory() { return new ProcessListCloudService(i0.ɵɵinject(i1.AlfrescoApiService), i0.ɵɵinject(i1.AppConfigService), i0.ɵɵinject(i1.LogService)); }, token: ProcessListCloudService, providedIn: "root" });
ProcessListCloudService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: AppConfigService },
    { type: LogService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ProcessListCloudService, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return [{ type: ɵngcc1.AlfrescoApiService }, { type: ɵngcc1.AppConfigService }, { type: ɵngcc1.LogService }]; }, null); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvY2Vzcy1saXN0LWNsb3VkLnNlcnZpY2UuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL2hvbWUvdHJhdmlzL2J1aWxkL0FsZnJlc2NvL2FsZnJlc2NvLW5nMi1jb21wb25lbnRzL2xpYi9wcm9jZXNzLXNlcnZpY2VzLWNsb3VkL3NyYy9saWIvcHJvY2Vzcy9wcm9jZXNzLWxpc3Qvc2VydmljZXMvcHJvY2Vzcy1saXN0LWNsb3VkLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBZ0JBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUFFLGtCQUFrQixFQUFFLGdCQUFnQixFQUFFLFVBQVUsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBRXRGLE9BQU8sRUFBYyxVQUFVLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFFOUMsT0FBTyxFQUFFLGdCQUFnQixFQUFFLE1BQU0sc0NBQXNDLENBQUM7QUFDeEUsT0FBTyxFQUFFLEdBQUcsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3JDO0FBRUE7OztBQUFBLE1BQU0sT0FBTyx1QkFBd0IsU0FBUSxnQkFBZ0I7QUFDN0QsSUFDSSxZQUFZLFVBQThCLEVBQzlCLGdCQUFrQyxFQUMxQixVQUFzQjtBQUM5QyxRQUFRLEtBQUssQ0FBQyxVQUFVLEVBQUUsZ0JBQWdCLENBQUMsQ0FBQztBQUM1QyxRQUZ3QixlQUFVLEdBQVYsVUFBVSxDQUFZO0FBQUMsSUFFM0MsQ0FBQztBQUNMLElBT0ksbUJBQW1CLENBQUMsV0FBMEMsRUFBRSxRQUFpQjtBQUFJLFFBQ2pGLElBQUksV0FBVyxDQUFDLE9BQU8sSUFBSSxXQUFXLENBQUMsT0FBTyxLQUFLLEVBQUUsRUFBRTtBQUMvRCxZQUFZLFFBQVEsR0FBRyxRQUFRLElBQUksR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsNkJBQTZCLENBQUM7QUFD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QUFDdkMsZ0JBQWdCLElBQUksQ0FBQyxZQUFZLEVBQUU7QUFDbkMsb0JBQW9CLFlBQVksR0FBRyxHQUFHLElBQUksQ0FBQyxPQUFPLElBQUksSUFBSSxDQUFDLFNBQVMsRUFBRSxDQUFDO0FBQ3ZFLGlCQUFpQjtBQUFDLHFCQUFLO0FBQ3ZCLG9CQUFvQixZQUFZLEdBQUcsR0FBRyxZQUFZLElBQUksSUFBSSxDQUFDLE9BQU8sSUFBSSxJQUFJLENBQUMsU0FBUyxFQUFFLENBQUM7QUFDdkYsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYixTQUFTO0FBQ1QsUUFBUSxPQUFPLFNBQVMsQ0FBQyxZQUFZLENBQUMsQ0FBQztBQUN2QyxJQUFJLENBQUM7QUFDTDtvUEFBQztBQUNELDZTQXBGSztBQUFDO0VBREwsVUFBVSxTQUFDLEVBQUUsVUFBVSxqQ0FDK0IsWUFSOUMsa0JBQWtCO0NBT0QsTUFBTSxFQUFFLFRBUEgsWUFBRixnQkFBZ0I7QUFBSSxZQUFGLFVBQVU7QUFBRzs7OzttSkFBRTtBQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEFsZnJlc2NvQXBpU2VydmljZSwgQXBwQ29uZmlnU2VydmljZSwgTG9nU2VydmljZSB9IGZyb20gJ0BhbGZyZXNjby9hZGYtY29yZSc7XG5pbXBvcnQgeyBQcm9jZXNzUXVlcnlDbG91ZFJlcXVlc3RNb2RlbCB9IGZyb20gJy4uL21vZGVscy9wcm9jZXNzLWNsb3VkLXF1ZXJ5LXJlcXVlc3QubW9kZWwnO1xuaW1wb3J0IHsgT2JzZXJ2YWJsZSwgdGhyb3dFcnJvciB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgUHJvY2Vzc0xpc3RDbG91ZFNvcnRpbmdNb2RlbCB9IGZyb20gJy4uL21vZGVscy9wcm9jZXNzLWxpc3Qtc29ydGluZy5tb2RlbCc7XG5pbXBvcnQgeyBCYXNlQ2xvdWRTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vLi4vc2VydmljZXMvYmFzZS1jbG91ZC5zZXJ2aWNlJztcbmltcG9ydCB7IG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuQEluamVjdGFibGUoeyBwcm92aWRlZEluOiAncm9vdCcgfSlcbmV4cG9ydCBjbGFzcyBQcm9jZXNzTGlzdENsb3VkU2VydmljZSBleHRlbmRzIEJhc2VDbG91ZFNlcnZpY2Uge1xuXG4gICAgY29uc3RydWN0b3IoYXBpU2VydmljZTogQWxmcmVzY29BcGlTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIGFwcENvbmZpZ1NlcnZpY2U6IEFwcENvbmZpZ1NlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBsb2dTZXJ2aWNlOiBMb2dTZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGFwaVNlcnZpY2UsIGFwcENvbmZpZ1NlcnZpY2UpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbmRzIGEgcHJvY2VzcyB1c2luZyBhbiBvYmplY3Qgd2l0aCBvcHRpb25hbCBxdWVyeSBwcm9wZXJ0aWVzLlxuICAgICAqIEBwYXJhbSByZXF1ZXN0Tm9kZSBRdWVyeSBvYmplY3RcbiAgICAgKiBAcGFyYW0gcXVlcnlVcmwgUXVlcnkgdXJsXG4gICAgICogQHJldHVybnMgUHJvY2VzcyBpbmZvcm1hdGlvblxuICAgICAqL1xuICAgIGdldFByb2Nlc3NCeVJlcXVlc3QocmVxdWVzdE5vZGU6IFByb2Nlc3NRdWVyeUNsb3VkUmVxdWVzdE1vZGVsLCBxdWVyeVVybD86IHN0cmluZyk6IE9ic2VydmFibGU8YW55PiB7XG4gICAgICAgIGlmIChyZXF1ZXN0Tm9kZS5hcHBOYW1lIHx8IHJlcXVlc3ROb2RlLmFwcE5hbWUgPT09ICcnKSB7XG4gICAgICAgICAgICBxdWVyeVVybCA9IHF1ZXJ5VXJsIHx8IGAke3RoaXMuZ2V0QmFzZVBhdGgocmVxdWVzdE5vZGUuYXBwTmFtZSl9L3F1ZXJ5L3YxL3Byb2Nlc3MtaW5zdGFuY2VzYDtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW1zID0gdGhpcy5idWlsZFF1ZXJ5UGFyYW1zKHJlcXVlc3ROb2RlKTtcbiAgICAgICAgICAgIGNvbnN0IHNvcnRpbmdQYXJhbXMgPSB0aGlzLmJ1aWxkU29ydGluZ1BhcmFtKHJlcXVlc3ROb2RlLnNvcnRpbmcpO1xuICAgICAgICAgICAgaWYgKHNvcnRpbmdQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBxdWVyeVBhcmFtc1snc29ydCddID0gc29ydGluZ1BhcmFtcztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KHF1ZXJ5VXJsLCBxdWVyeVBhcmFtcykucGlwZShcbiAgICAgICAgICAgICAgICBtYXAoKHJlc3BvbnNlOiBhbnkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW50cmllcyA9IHJlc3BvbnNlLmxpc3QgJiYgcmVzcG9uc2UubGlzdC5lbnRyaWVzO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZW50cmllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UubGlzdC5lbnRyaWVzID0gZW50cmllcy5tYXAoKGVudHJ5RGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlbnRyeURhdGEuZW50cnk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxvZ1NlcnZpY2UuZXJyb3IoJ0FwcG5hbWUgaXMgbWFuZGF0b3J5IGZvciBxdWVyeWluZyB0YXNrJyk7XG4gICAgICAgICAgICByZXR1cm4gdGhyb3dFcnJvcignQXBwbmFtZSBub3QgY29uZmlndXJlZCcpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGlzUHJvcGVydHlWYWx1ZVZhbGlkKHJlcXVlc3ROb2RlOiBhbnksIHByb3BlcnR5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHJlcXVlc3ROb2RlW3Byb3BlcnR5XSAhPT0gJycgJiYgcmVxdWVzdE5vZGVbcHJvcGVydHldICE9PSBudWxsICYmIHJlcXVlc3ROb2RlW3Byb3BlcnR5XSAhPT0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBidWlsZFF1ZXJ5UGFyYW1zKHJlcXVlc3ROb2RlOiBQcm9jZXNzUXVlcnlDbG91ZFJlcXVlc3RNb2RlbCk6IE9iamVjdCB7XG4gICAgICAgIGNvbnN0IHF1ZXJ5UGFyYW0gPSB7fTtcblxuICAgICAgICBmb3IgKGNvbnN0IHByb3BlcnR5IGluIHJlcXVlc3ROb2RlKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdE5vZGUuaGFzT3duUHJvcGVydHkocHJvcGVydHkpICYmXG4gICAgICAgICAgICAgICAgIXRoaXMuaXNFeGNsdWRlZEZpZWxkKHByb3BlcnR5KSAmJlxuICAgICAgICAgICAgICAgIHRoaXMuaXNQcm9wZXJ0eVZhbHVlVmFsaWQocmVxdWVzdE5vZGUsIHByb3BlcnR5KSkge1xuICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1bcHJvcGVydHldID0gcmVxdWVzdE5vZGVbcHJvcGVydHldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFxdWVyeVBhcmFtWydzdGF0dXMnXSkge1xuICAgICAgICAgICAgcXVlcnlQYXJhbVsnc3RhdHVzJ10gPSB0aGlzLmJ1aWxkRmlsdGVyRm9yQWxsU3RhdHVzKCk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gcXVlcnlQYXJhbTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgYnVpbGRGaWx0ZXJGb3JBbGxTdGF0dXMoKTogc3RyaW5nW10ge1xuICAgICAgICByZXR1cm4gWydSVU5OSU5HJywgJ1NVU1BFTkRFRCcsICdDQU5DRUxMRUQnLCAnQ09NUExFVEVEJ107XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGlzRXhjbHVkZWRGaWVsZChwcm9wZXJ0eTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0eSA9PT0gJ2FwcE5hbWUnIHx8IHByb3BlcnR5ID09PSAnc29ydGluZyc7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGJ1aWxkU29ydGluZ1BhcmFtKG1vZGVsczogUHJvY2Vzc0xpc3RDbG91ZFNvcnRpbmdNb2RlbFtdKTogc3RyaW5nIHtcbiAgICAgICAgbGV0IGZpbmFsU29ydGluZzogc3RyaW5nID0gJyc7XG4gICAgICAgIGlmIChtb2RlbHMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgc29ydCBvZiBtb2RlbHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWZpbmFsU29ydGluZykge1xuICAgICAgICAgICAgICAgICAgICBmaW5hbFNvcnRpbmcgPSBgJHtzb3J0Lm9yZGVyQnl9LCR7c29ydC5kaXJlY3Rpb259YDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmaW5hbFNvcnRpbmcgPSBgJHtmaW5hbFNvcnRpbmd9JiR7c29ydC5vcmRlckJ5fSwke3NvcnQuZGlyZWN0aW9ufWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbmNvZGVVUkkoZmluYWxTb3J0aW5nKTtcbiAgICB9XG59XG4iXX0=