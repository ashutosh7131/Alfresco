import { Injectable } from '@angular/core';
import { AlfrescoApiService, AppConfigService } from '@alfresco/adf-core';
import { map } from 'rxjs/operators';
import { StartTaskCloudRequestModel } from '../start-task/models/start-task-cloud-request.model';
import { BaseCloudService } from '../../services/base-cloud.service';
import * as i0 from "@angular/core";
import * as i1 from "@alfresco/adf-core";
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@alfresco/adf-core';
export class StartTaskCloudService extends BaseCloudService {
    constructor(apiService, appConfigService) {
        super(apiService, appConfigService);
    }
    createNewTask(taskDetails) {
        const url = `${this.getBasePath(taskDetails.appName)}/rb/v1/tasks`;
        const payload = JSON.stringify(new StartTaskCloudRequestModel(taskDetails));
        return this.post(url, payload)
            .pipe(map(response => response.entry));
    }
}
StartTaskCloudService.ɵfac = function StartTaskCloudService_Factory(t) { return new (t || StartTaskCloudService)(ɵngcc0.ɵɵinject(ɵngcc1.AlfrescoApiService), ɵngcc0.ɵɵinject(ɵngcc1.AppConfigService)); };
StartTaskCloudService.ɵprov = i0.ɵɵdefineInjectable({ factory: function StartTaskCloudService_Factory() { return new StartTaskCloudService(i0.ɵɵinject(i1.AlfrescoApiService), i0.ɵɵinject(i1.AppConfigService)); }, token: StartTaskCloudService, providedIn: "root" });
StartTaskCloudService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: AppConfigService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(StartTaskCloudService, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return [{ type: ɵngcc1.AlfrescoApiService }, { type: ɵngcc1.AppConfigService }]; }, null); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic3RhcnQtdGFzay1jbG91ZC5zZXJ2aWNlLmpzIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi8uLi9ob21lL3RyYXZpcy9idWlsZC9BbGZyZXNjby9hbGZyZXNjby1uZzItY29tcG9uZW50cy9saWIvcHJvY2Vzcy1zZXJ2aWNlcy1jbG91ZC9zcmMvbGliL3Rhc2svc2VydmljZXMvc3RhcnQtdGFzay1jbG91ZC5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWlCQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBRTFFLE9BQU8sRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNyQyxPQUFPLEVBQUUsMEJBQTBCLEVBQUUsTUFBTSxxREFBcUQsQ0FBQztBQUVqRyxPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxtQ0FBbUMsQ0FBQztBQUNyRTtBQUVBOzs7QUFBQSxNQUFNLE9BQU8scUJBQXNCLFNBQVEsZ0JBQWdCO0FBQzNELElBQ0ksWUFDSSxVQUE4QixFQUM5QixnQkFBa0M7QUFDMUMsUUFBUSxLQUFLLENBQUMsVUFBVSxFQUFFLGdCQUFnQixDQUFDLENBQUM7QUFDNUMsSUFBSSxDQUFDO0FBQ0wsSUFPSSxhQUFhLENBQUMsV0FBa0M7QUFBSSxRQUNoRCxNQUFNLEdBQUcsR0FBRyxHQUFHLElBQUksQ0FBQyxXQUFXLENBQUMsV0FBVyxDQUFDLE9BQU8sQ0FBQyxjQUFjLENBQUM7QUFDM0UsUUFBUSxNQUFNLE9BQU8sR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksMEJBQTBCLENBQUMsV0FBVyxDQUFDLENBQUMsQ0FBQztBQUNwRixRQUNRLE9BQU8sSUFBSSxDQUFDLElBQUksQ0FBbUMsR0FBRyxFQUFFLE9BQU8sQ0FBQztBQUN4RSxhQUFhLElBQUksQ0FDRCxHQUFHLENBQUMsUUFBUSxDQUFDLEVBQUUsQ0FBQyxRQUFRLENBQUMsS0FBSyxDQUFDLENBQ2xDLENBQUM7QUFDZCxJQUFJLENBQUM7QUFDTDswTUFBQztBQUNELHlRQXhCSztBQUFDO0VBREwsVUFBVSxTQUFDLEVBQUUsVUFBVSxqQ0FDNkIsWUFSNUMsa0JBQWtCO0NBT0QsTUFBTSxFQUFFLFRBUEgsWUFBRixnQkFBZ0I7QUFBRzs7OztzSEFBRTtBQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgQWxmcmVzY29BcGlTZXJ2aWNlLCBBcHBDb25maWdTZXJ2aWNlIH0gZnJvbSAnQGFsZnJlc2NvL2FkZi1jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IG1hcCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFN0YXJ0VGFza0Nsb3VkUmVxdWVzdE1vZGVsIH0gZnJvbSAnLi4vc3RhcnQtdGFzay9tb2RlbHMvc3RhcnQtdGFzay1jbG91ZC1yZXF1ZXN0Lm1vZGVsJztcbmltcG9ydCB7IFRhc2tEZXRhaWxzQ2xvdWRNb2RlbCwgU3RhcnRUYXNrQ2xvdWRSZXNwb25zZU1vZGVsIH0gZnJvbSAnLi4vc3RhcnQtdGFzay9tb2RlbHMvdGFzay1kZXRhaWxzLWNsb3VkLm1vZGVsJztcbmltcG9ydCB7IEJhc2VDbG91ZFNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9iYXNlLWNsb3VkLnNlcnZpY2UnO1xuXG5ASW5qZWN0YWJsZSh7IHByb3ZpZGVkSW46ICdyb290JyB9KVxuZXhwb3J0IGNsYXNzIFN0YXJ0VGFza0Nsb3VkU2VydmljZSBleHRlbmRzIEJhc2VDbG91ZFNlcnZpY2Uge1xuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIGFwaVNlcnZpY2U6IEFsZnJlc2NvQXBpU2VydmljZSxcbiAgICAgICAgYXBwQ29uZmlnU2VydmljZTogQXBwQ29uZmlnU2VydmljZSkge1xuICAgICAgICBzdXBlcihhcGlTZXJ2aWNlLCBhcHBDb25maWdTZXJ2aWNlKTtcbiAgICB9XG5cbiAgICAgLyoqXG4gICAgICAqIEBkZXByZWNhdGVkIGluIDMuNS4wLCB1c2UgVGFza0Nsb3VkU2VydmljZSBpbnN0ZWFkLlxuICAgICAgKiBDcmVhdGVzIGEgbmV3IHN0YW5kYWxvbmUgdGFzay5cbiAgICAgICogQHBhcmFtIHRhc2tEZXRhaWxzIERldGFpbHMgb2YgdGhlIHRhc2sgdG8gY3JlYXRlXG4gICAgICAqIEByZXR1cm5zIERldGFpbHMgb2YgdGhlIG5ld2x5IGNyZWF0ZWQgdGFza1xuICAgICAgKi9cbiAgICBjcmVhdGVOZXdUYXNrKHRhc2tEZXRhaWxzOiBUYXNrRGV0YWlsc0Nsb3VkTW9kZWwpOiBPYnNlcnZhYmxlPFRhc2tEZXRhaWxzQ2xvdWRNb2RlbD4ge1xuICAgICAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmdldEJhc2VQYXRoKHRhc2tEZXRhaWxzLmFwcE5hbWUpfS9yYi92MS90YXNrc2A7XG4gICAgICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnN0cmluZ2lmeShuZXcgU3RhcnRUYXNrQ2xvdWRSZXF1ZXN0TW9kZWwodGFza0RldGFpbHMpKTtcblxuICAgICAgICByZXR1cm4gdGhpcy5wb3N0PGFueSwgU3RhcnRUYXNrQ2xvdWRSZXNwb25zZU1vZGVsPih1cmwsIHBheWxvYWQpXG4gICAgICAgICAgICAucGlwZShcbiAgICAgICAgICAgICAgICBtYXAocmVzcG9uc2UgPT4gcmVzcG9uc2UuZW50cnkpXG4gICAgICAgICAgICApO1xuICAgIH1cbn1cbiJdfQ==