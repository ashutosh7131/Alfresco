import { Injectable } from '@angular/core';
import { AlfrescoApiService, AppConfigService, LogService } from '@alfresco/adf-core';
import { throwError } from 'rxjs';
import { BaseCloudService } from '../../../services/base-cloud.service';
import { map } from 'rxjs/operators';
import * as i0 from "@angular/core";
import * as i1 from "@alfresco/adf-core";
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@alfresco/adf-core';
export class ServiceTaskListCloudService extends BaseCloudService {
    constructor(apiService, appConfigService, logService) {
        super(apiService, appConfigService);
        this.logService = logService;
    }
    getServiceTaskByRequest(requestNode) {
        if (requestNode.appName || requestNode.appName === '') {
            const queryUrl = `${this.getBasePath(requestNode.appName)}/query/admin/v1/service-tasks`;
            const queryParams = this.buildQueryParams(requestNode);
            const sortingParams = this.buildSortingParam(requestNode.sorting);
            if (sortingParams) {
                queryParams['sort'] = sortingParams;
            }
            return this.get(queryUrl, queryParams);
        }
        else {
            this.logService.error('Appname is mandatory for querying task');
            return throwError('Appname not configured');
        }
    }
    getServiceTaskStatus(appName, serviceTaskId) {
        if (appName) {
            const queryUrl = `${this.getBasePath(appName)}/query/admin/v1/service-tasks/${serviceTaskId}/integration-context`;
            return this.get(queryUrl).pipe(map((response) => response.entry));
        }
        else {
            this.logService.error('Appname is mandatory for querying task');
            return throwError('Appname not configured');
        }
    }
    buildQueryParams(requestNode) {
        const queryParam = {};
        for (const property in requestNode) {
            if (requestNode.hasOwnProperty(property) &&
                !this.isExcludedField(property) &&
                this.isPropertyValueValid(requestNode, property)) {
                queryParam[property] = requestNode[property];
            }
        }
        return queryParam;
    }
    isExcludedField(property) {
        return property === 'appName' || property === 'sorting';
    }
    isPropertyValueValid(requestNode, property) {
        return requestNode[property] !== '' && requestNode[property] !== null && requestNode[property] !== undefined;
    }
    buildSortingParam(models) {
        let finalSorting = '';
        if (models) {
            for (const sort of models) {
                if (!finalSorting) {
                    finalSorting = `${sort.orderBy},${sort.direction}`;
                }
                else {
                    finalSorting = `${finalSorting}&${sort.orderBy},${sort.direction}`;
                }
            }
        }
        return encodeURI(finalSorting);
    }
}
ServiceTaskListCloudService.ɵfac = function ServiceTaskListCloudService_Factory(t) { return new (t || ServiceTaskListCloudService)(ɵngcc0.ɵɵinject(ɵngcc1.AlfrescoApiService), ɵngcc0.ɵɵinject(ɵngcc1.AppConfigService), ɵngcc0.ɵɵinject(ɵngcc1.LogService)); };
ServiceTaskListCloudService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ServiceTaskListCloudService_Factory() { return new ServiceTaskListCloudService(i0.ɵɵinject(i1.AlfrescoApiService), i0.ɵɵinject(i1.AppConfigService), i0.ɵɵinject(i1.LogService)); }, token: ServiceTaskListCloudService, providedIn: "root" });
ServiceTaskListCloudService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: AppConfigService },
    { type: LogService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(ServiceTaskListCloudService, [{
        type: Injectable,
        args: [{ providedIn: 'root' }]
    }], function () { return [{ type: ɵngcc1.AlfrescoApiService }, { type: ɵngcc1.AppConfigService }, { type: ɵngcc1.LogService }]; }, null); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VydmljZS10YXNrLWxpc3QtY2xvdWQuc2VydmljZS5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vaG9tZS90cmF2aXMvYnVpbGQvQWxmcmVzY28vYWxmcmVzY28tbmcyLWNvbXBvbmVudHMvbGliL3Byb2Nlc3Mtc2VydmljZXMtY2xvdWQvc3JjL2xpYi90YXNrL3Rhc2stbGlzdC9zZXJ2aWNlcy9zZXJ2aWNlLXRhc2stbGlzdC1jbG91ZC5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWlCQSxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxnQkFBZ0IsRUFBRSxVQUFVLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQztBQUV0RixPQUFPLEVBQWMsVUFBVSxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBRTlDLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHNDQUFzQyxDQUFDO0FBQ3hFLE9BQU8sRUFBRSxHQUFHLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQztBQUNyQztBQUVBOzs7QUFBQSxNQUFNLE9BQU8sMkJBQTRCLFNBQVEsZ0JBQWdCO0FBQ2pFLElBQ0ksWUFBWSxVQUE4QixFQUM5QixnQkFBa0MsRUFDMUIsVUFBc0I7QUFDOUMsUUFBUSxLQUFLLENBQUMsVUFBVSxFQUFFLGdCQUFnQixDQUFDLENBQUM7QUFDNUMsUUFGd0IsZUFBVSxHQUFWLFVBQVUsQ0FBWTtBQUFDLElBRTNDLENBQUM7QUFDTCxJQU1JLHVCQUF1QixDQUFDLFdBQThDO0FBQUksUUFDdEUsSUFBSSxXQUFXLENBQUMsT0FBTyxJQUFJLFdBQVcsQ0FBQyxPQUFPLEtBQUssRUFBRSxFQUFFO0FBQy9ELFlBQVksTUFBTSxRQUFRLEdBQUcsR0FBRyxJQUFJLENBQUMsV0FBVyxDQUFDLFdBQVcsQ0FBQyxPQUFPLENBQUMsK0JBQStCLENBQUM7QUFDckcsWUFBWSxNQUFN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QUMsT0FBTyxJQUFJLElBQUksQ0FBQyxTQUFTLEVBQUUsQ0FBQztBQUN2RixpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVM7QUFDVCxRQUFRLE9BQU8sU0FBUyxDQUFDLFlBQVksQ0FBQyxDQUFDO0FBQ3ZDLElBQUksQ0FBQztBQUNMO2dRQUFDO0FBQ0QsNlRBaEZLO0FBQUM7RUFETCxVQUFVLFNBQUMsRUFBRSxVQUFVLGpDQUNtQyxZQVJsRCxrQkFBa0I7Q0FPRCxNQUFNLEVBQUUsVEFQSCxZQUFGLGdCQUFnQjtBQUFJLFlBQUYsVUFBVTtBQUFHOzs7O21KQUFFO0FBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBBbGZyZXNjb0FwaVNlcnZpY2UsIEFwcENvbmZpZ1NlcnZpY2UsIExvZ1NlcnZpY2UgfSBmcm9tICdAYWxmcmVzY28vYWRmLWNvcmUnO1xuaW1wb3J0IHsgU2VydmljZVRhc2tRdWVyeUNsb3VkUmVxdWVzdE1vZGVsLCBTZXJ2aWNlVGFza0ludGVncmF0aW9uQ29udGV4dENsb3VkTW9kZWwgfSBmcm9tICcuLi9tb2RlbHMvc2VydmljZS10YXNrLWNsb3VkLm1vZGVsJztcbmltcG9ydCB7IE9ic2VydmFibGUsIHRocm93RXJyb3IgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IFRhc2tMaXN0Q2xvdWRTb3J0aW5nTW9kZWwgfSBmcm9tICcuLi9tb2RlbHMvdGFzay1saXN0LXNvcnRpbmcubW9kZWwnO1xuaW1wb3J0IHsgQmFzZUNsb3VkU2VydmljZSB9IGZyb20gJy4uLy4uLy4uL3NlcnZpY2VzL2Jhc2UtY2xvdWQuc2VydmljZSc7XG5pbXBvcnQgeyBtYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XG5cbkBJbmplY3RhYmxlKHsgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pXG5leHBvcnQgY2xhc3MgU2VydmljZVRhc2tMaXN0Q2xvdWRTZXJ2aWNlIGV4dGVuZHMgQmFzZUNsb3VkU2VydmljZSB7XG5cbiAgICBjb25zdHJ1Y3RvcihhcGlTZXJ2aWNlOiBBbGZyZXNjb0FwaVNlcnZpY2UsXG4gICAgICAgICAgICAgICAgYXBwQ29uZmlnU2VydmljZTogQXBwQ29uZmlnU2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIGxvZ1NlcnZpY2U6IExvZ1NlcnZpY2UpIHtcbiAgICAgICAgc3VwZXIoYXBpU2VydmljZSwgYXBwQ29uZmlnU2VydmljZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmluZHMgYSB0YXNrIHVzaW5nIGFuIG9iamVjdCB3aXRoIG9wdGlvbmFsIHF1ZXJ5IHByb3BlcnRpZXMuXG4gICAgICogQHBhcmFtIHJlcXVlc3ROb2RlIFF1ZXJ5IG9iamVjdFxuICAgICAqIEByZXR1cm5zIFRhc2sgaW5mb3JtYXRpb25cbiAgICAgKi9cbiAgICBnZXRTZXJ2aWNlVGFza0J5UmVxdWVzdChyZXF1ZXN0Tm9kZTogU2VydmljZVRhc2tRdWVyeUNsb3VkUmVxdWVzdE1vZGVsKTogT2JzZXJ2YWJsZTxhbnk+IHtcbiAgICAgICAgaWYgKHJlcXVlc3ROb2RlLmFwcE5hbWUgfHwgcmVxdWVzdE5vZGUuYXBwTmFtZSA9PT0gJycpIHtcbiAgICAgICAgICAgIGNvbnN0IHF1ZXJ5VXJsID0gYCR7dGhpcy5nZXRCYXNlUGF0aChyZXF1ZXN0Tm9kZS5hcHBOYW1lKX0vcXVlcnkvYWRtaW4vdjEvc2VydmljZS10YXNrc2A7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVBhcmFtcyA9IHRoaXMuYnVpbGRRdWVyeVBhcmFtcyhyZXF1ZXN0Tm9kZSk7XG4gICAgICAgICAgICBjb25zdCBzb3J0aW5nUGFyYW1zID0gdGhpcy5idWlsZFNvcnRpbmdQYXJhbShyZXF1ZXN0Tm9kZS5zb3J0aW5nKTtcbiAgICAgICAgICAgIGlmIChzb3J0aW5nUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbXNbJ3NvcnQnXSA9IHNvcnRpbmdQYXJhbXM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5nZXQocXVlcnlVcmwsIHF1ZXJ5UGFyYW1zKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9nU2VydmljZS5lcnJvcignQXBwbmFtZSBpcyBtYW5kYXRvcnkgZm9yIHF1ZXJ5aW5nIHRhc2snKTtcbiAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKCdBcHBuYW1lIG5vdCBjb25maWd1cmVkJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBGaW5kcyBhIHNlcnZpY2UgdGFzayBpbnRlZ3JhdGlvbiBjb250ZXh0IHVzaW5nIGFuIG9iamVjdCB3aXRoIG9wdGlvbmFsIHF1ZXJ5IHByb3BlcnRpZXMuXG4gICAgICogQHBhcmFtIGFwcE5hbWUgc3RyaW5nXG4gICAgICogQHBhcmFtIHNlcnZpY2VUYXNrSWQgc3RyaW5nXG4gICAgICogQHJldHVybnMgU2VydmljZSBUYXNrIEludGVncmF0aW9uIENvbnRleHQgaW5mb3JtYXRpb25cbiAgICAgKi9cbiAgICBnZXRTZXJ2aWNlVGFza1N0YXR1cyhhcHBOYW1lOiBzdHJpbmcsIHNlcnZpY2VUYXNrSWQ6IHN0cmluZyk6IE9ic2VydmFibGU8U2VydmljZVRhc2tJbnRlZ3JhdGlvbkNvbnRleHRDbG91ZE1vZGVsPiB7XG4gICAgICAgIGlmIChhcHBOYW1lKSB7XG4gICAgICAgICAgICBjb25zdCBxdWVyeVVybCA9IGAke3RoaXMuZ2V0QmFzZVBhdGgoYXBwTmFtZSl9L3F1ZXJ5L2FkbWluL3YxL3NlcnZpY2UtdGFza3MvJHtzZXJ2aWNlVGFza0lkfS9pbnRlZ3JhdGlvbi1jb250ZXh0YDtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmdldChxdWVyeVVybCkucGlwZShcbiAgICAgICAgICAgICAgICBtYXAoKHJlc3BvbnNlOiBhbnkpID0+IHJlc3BvbnNlLmVudHJ5KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubG9nU2VydmljZS5lcnJvcignQXBwbmFtZSBpcyBtYW5kYXRvcnkgZm9yIHF1ZXJ5aW5nIHRhc2snKTtcbiAgICAgICAgICAgIHJldHVybiB0aHJvd0Vycm9yKCdBcHBuYW1lIG5vdCBjb25maWd1cmVkJyk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgYnVpbGRRdWVyeVBhcmFtcyhyZXF1ZXN0Tm9kZTogU2VydmljZVRhc2tRdWVyeUNsb3VkUmVxdWVzdE1vZGVsKTogT2JqZWN0IHtcbiAgICAgICAgY29uc3QgcXVlcnlQYXJhbTogT2JqZWN0ID0ge307XG4gICAgICAgIGZvciAoY29uc3QgcHJvcGVydHkgaW4gcmVxdWVzdE5vZGUpIHtcbiAgICAgICAgICAgIGlmIChyZXF1ZXN0Tm9kZS5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eSkgJiZcbiAgICAgICAgICAgICAgICAhdGhpcy5pc0V4Y2x1ZGVkRmllbGQocHJvcGVydHkpICYmXG4gICAgICAgICAgICAgICAgdGhpcy5pc1Byb3BlcnR5VmFsdWVWYWxpZChyZXF1ZXN0Tm9kZSwgcHJvcGVydHkpKSB7XG4gICAgICAgICAgICAgICAgcXVlcnlQYXJhbVtwcm9wZXJ0eV0gPSByZXF1ZXN0Tm9kZVtwcm9wZXJ0eV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHF1ZXJ5UGFyYW07XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGlzRXhjbHVkZWRGaWVsZChwcm9wZXJ0eTogc3RyaW5nKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0eSA9PT0gJ2FwcE5hbWUnIHx8IHByb3BlcnR5ID09PSAnc29ydGluZyc7XG4gICAgfVxuXG4gICAgcHJvdGVjdGVkIGlzUHJvcGVydHlWYWx1ZVZhbGlkKHJlcXVlc3ROb2RlOiBhbnksIHByb3BlcnR5OiBzdHJpbmcpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIHJlcXVlc3ROb2RlW3Byb3BlcnR5XSAhPT0gJycgJiYgcmVxdWVzdE5vZGVbcHJvcGVydHldICE9PSBudWxsICYmIHJlcXVlc3ROb2RlW3Byb3BlcnR5XSAhPT0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHByb3RlY3RlZCBidWlsZFNvcnRpbmdQYXJhbShtb2RlbHM6IFRhc2tMaXN0Q2xvdWRTb3J0aW5nTW9kZWxbXSk6IHN0cmluZyB7XG4gICAgICAgIGxldCBmaW5hbFNvcnRpbmc6IHN0cmluZyA9ICcnO1xuICAgICAgICBpZiAobW9kZWxzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHNvcnQgb2YgbW9kZWxzKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFmaW5hbFNvcnRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgZmluYWxTb3J0aW5nID0gYCR7c29ydC5vcmRlckJ5fSwke3NvcnQuZGlyZWN0aW9ufWA7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZmluYWxTb3J0aW5nID0gYCR7ZmluYWxTb3J0aW5nfSYke3NvcnQub3JkZXJCeX0sJHtzb3J0LmRpcmVjdGlvbn1gO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZW5jb2RlVVJJKGZpbmFsU29ydGluZyk7XG4gICAgfVxufVxuIl19