import { __awaiter } from "tslib";
import { Directive, Input, HostListener, Output, EventEmitter } from '@angular/core';
import { TaskCloudService } from '../services/task-cloud.service';
export class CompleteTaskDirective {
    constructor(taskListService) {
        this.taskListService = taskListService;
        this.appName = '';
        this.success = new EventEmitter();
        this.error = new EventEmitter();
        this.invalidParams = [];
    }
    ngOnInit() {
        this.validateInputs();
    }
    validateInputs() {
        if (!this.isTaskValid()) {
            this.invalidParams.push('taskId');
        }
        if (!this.isAppValid()) {
            this.invalidParams.push('appName');
        }
        if (this.invalidParams.length) {
            throw new Error(`Attribute ${this.invalidParams.join(', ')} is required`);
        }
    }
    isTaskValid() {
        return this.taskId && this.taskId.length > 0;
    }
    isAppValid() {
        return !!this.appName || this.appName === '';
    }
    onClick() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const result = yield this.taskListService.completeTask(this.appName, this.taskId).toPromise();
                if (result) {
                    this.success.emit(result);
                }
            }
            catch (error) {
                this.error.emit(error);
            }
        });
    }
}
CompleteTaskDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-cloud-complete-task]'
            },] }
];
CompleteTaskDirective.ctorParameters = () => [
    { type: TaskCloudService }
];
CompleteTaskDirective.propDecorators = {
    taskId: [{ type: Input }],
    appName: [{ type: Input }],
    success: [{ type: Output }],
    error: [{ type: Output }],
    onClick: [{ type: HostListener, args: ['click',] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tcGxldGUtdGFzay5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290IjoiL2hvbWUvdHJhdmlzL2J1aWxkL0FsZnJlc2NvL2FsZnJlc2NvLW5nMi1jb21wb25lbnRzL2xpYi9wcm9jZXNzLXNlcnZpY2VzLWNsb3VkL3NyYy8iLCJzb3VyY2VzIjpbImxpYi90YXNrL2RpcmVjdGl2ZXMvY29tcGxldGUtdGFzay5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQWdCQSxPQUFPLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBRSxZQUFZLEVBQUUsTUFBTSxFQUFFLFlBQVksRUFBVSxNQUFNLGVBQWUsQ0FBQztBQUM3RixPQUFPLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxnQ0FBZ0MsQ0FBQztBQU1sRSxNQUFNLE9BQU8scUJBQXFCO0lBb0I5QixZQUFvQixlQUFpQztRQUFqQyxvQkFBZSxHQUFmLGVBQWUsQ0FBa0I7UUFackQsWUFBTyxHQUFXLEVBQUUsQ0FBQztRQUlyQixZQUFPLEdBQXNCLElBQUksWUFBWSxFQUFPLENBQUM7UUFJckQsVUFBSyxHQUFzQixJQUFJLFlBQVksRUFBTyxDQUFDO1FBRW5ELGtCQUFhLEdBQWEsRUFBRSxDQUFDO0lBRTJCLENBQUM7SUFFekQsUUFBUTtRQUNKLElBQUksQ0FBQyxjQUFjLEVBQUUsQ0FBQztJQUMxQixDQUFDO0lBRUQsY0FBYztRQUVWLElBQUksQ0FBQyxJQUFJLENBQUMsV0FBVyxFQUFFLEVBQUU7WUFDckIsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLENBQUM7U0FDckM7UUFDRCxJQUFJLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxFQUFFO1lBQ3BCLElBQUksQ0FBQyxhQUFhLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO1NBQ3RDO1FBQ0QsSUFBSSxJQUFJLENBQUMsYUFBYSxDQUFDLE1BQU0sRUFBRTtZQUMzQixNQUFNLElBQUksS0FBSyxDQUFDLGFBQWEsSUFBSSxDQUFDLGFBQWEsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLGNBQWMsQ0FBQyxDQUFDO1NBQzdFO0lBQ0wsQ0FBQztJQUVELFdBQVc7UUFDUCxPQUFPLElBQUksQ0FBQyxNQUFNLElBQUksSUFBSSxDQUFDLE1BQU0sQ0FBQyxNQUFNLEdBQUcsQ0FBQyxDQUFDO0lBQ2pELENBQUM7SUFFRCxVQUFVO1FBQ04sT0FBTyxDQUFDLENBQUMsSUFBSSxDQUFDLE9BQU8sSUFBSSxJQUFJLENBQUMsT0FBTyxLQUFLLEVBQUUsQ0FBQztJQUNqRCxDQUFDO0lBR0ssT0FBTzs7WUFDVCxJQUFJO2dCQUNBLE1BQU0sTUFBTSxHQUFHLE1BQU0sSUFBSSxDQUFDLGVBQWUsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLE9BQU8sRUFBRSxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsU0FBUyxFQUFFLENBQUM7Z0JBQzlGLElBQUksTUFBTSxFQUFFO29CQUNSLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO2lCQUM3QjthQUNKO1lBQUMsT0FBTyxLQUFLLEVBQUU7Z0JBQ1osSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7YUFDMUI7UUFFTCxDQUFDO0tBQUE7OztZQTlESixTQUFTLFNBQUM7Z0JBRVAsUUFBUSxFQUFFLDJCQUEyQjthQUN4Qzs7O1lBTFEsZ0JBQWdCOzs7cUJBU3BCLEtBQUs7c0JBSUwsS0FBSztzQkFJTCxNQUFNO29CQUlOLE1BQU07c0JBZ0NOLFlBQVksU0FBQyxPQUFPIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cbmltcG9ydCB7IERpcmVjdGl2ZSwgSW5wdXQsIEhvc3RMaXN0ZW5lciwgT3V0cHV0LCBFdmVudEVtaXR0ZXIsIE9uSW5pdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgVGFza0Nsb3VkU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL3Rhc2stY2xvdWQuc2VydmljZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTogZGlyZWN0aXZlLXNlbGVjdG9yXG4gICAgc2VsZWN0b3I6ICdbYWRmLWNsb3VkLWNvbXBsZXRlLXRhc2tdJ1xufSlcbmV4cG9ydCBjbGFzcyBDb21wbGV0ZVRhc2tEaXJlY3RpdmUgaW1wbGVtZW50cyBPbkluaXQge1xuXG4gICAgLyoqIChSZXF1aXJlZCkgVGhlIGlkIG9mIHRoZSB0YXNrLiAqL1xuICAgIEBJbnB1dCgpXG4gICAgdGFza0lkOiBzdHJpbmc7XG5cbiAgICAvKiogKFJlcXVpcmVkKSBUaGUgbmFtZSBvZiB0aGUgYXBwbGljYXRpb24uICovXG4gICAgQElucHV0KClcbiAgICBhcHBOYW1lOiBzdHJpbmcgPSAnJztcblxuICAgIC8qKiBFbWl0dGVkIHdoZW4gdGhlIHRhc2sgaXMgY29tcGxldGVkLiAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHN1Y2Nlc3M6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgICAvKiogRW1pdHRlZCB3aGVuIHRoZSB0YXNrIGNhbm5vdCBiZSBjb21wbGV0ZWQuICovXG4gICAgQE91dHB1dCgpXG4gICAgZXJyb3I6IEV2ZW50RW1pdHRlcjxhbnk+ID0gbmV3IEV2ZW50RW1pdHRlcjxhbnk+KCk7XG5cbiAgICBpbnZhbGlkUGFyYW1zOiBzdHJpbmdbXSA9IFtdO1xuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSB0YXNrTGlzdFNlcnZpY2U6IFRhc2tDbG91ZFNlcnZpY2UpIHt9XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy52YWxpZGF0ZUlucHV0cygpO1xuICAgIH1cblxuICAgIHZhbGlkYXRlSW5wdXRzKCkge1xuXG4gICAgICAgIGlmICghdGhpcy5pc1Rhc2tWYWxpZCgpKSB7XG4gICAgICAgICAgICB0aGlzLmludmFsaWRQYXJhbXMucHVzaCgndGFza0lkJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLmlzQXBwVmFsaWQoKSkge1xuICAgICAgICAgICAgdGhpcy5pbnZhbGlkUGFyYW1zLnB1c2goJ2FwcE5hbWUnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pbnZhbGlkUGFyYW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBBdHRyaWJ1dGUgJHt0aGlzLmludmFsaWRQYXJhbXMuam9pbignLCAnKX0gaXMgcmVxdWlyZWRgKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlzVGFza1ZhbGlkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy50YXNrSWQgJiYgdGhpcy50YXNrSWQubGVuZ3RoID4gMDtcbiAgICB9XG5cbiAgICBpc0FwcFZhbGlkKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gISF0aGlzLmFwcE5hbWUgfHwgdGhpcy5hcHBOYW1lID09PSAnJztcbiAgICB9XG5cbiAgICBASG9zdExpc3RlbmVyKCdjbGljaycpXG4gICAgYXN5bmMgb25DbGljaygpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHRoaXMudGFza0xpc3RTZXJ2aWNlLmNvbXBsZXRlVGFzayh0aGlzLmFwcE5hbWUsIHRoaXMudGFza0lkKS50b1Byb21pc2UoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1Y2Nlc3MuZW1pdChyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdGhpcy5lcnJvci5lbWl0KGVycm9yKTtcbiAgICAgICAgfVxuXG4gICAgfVxufVxuIl19