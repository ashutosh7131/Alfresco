import { NgModule, EventEmitter, Component, ViewEncapsulation, Input, Output, ɵɵdefineInjectable, ɵɵinject, Injectable, ContentChild, Directive, InjectionToken, Inject, ChangeDetectionStrategy, ViewChild, Pipe, HostListener, ElementRef } from '@angular/core';
import { AlfrescoApiService, LogService, AppConfigService, CustomEmptyContentTemplateDirective, TemplateModule, CoreModule, TranslationService, IdentityUserService, DataTableSchema, UserPreferenceValues, UserPreferencesService, FullNamePipe, IdentityGroupService, MOMENT_DATE_FORMATS, MomentDateAdapter, FormModel, FormOutcomeModel, FormBaseComponent, FORM_FIELD_VALIDATORS, UploadWidgetContentLinkModel, FormOutcomeEvent, FormService, WidgetVisibilityService, WidgetComponent, FormFieldEvent, FormFieldTypes, NotificationService, ContentService, DownloadService, ThumbnailService, ContentLinkModel, NodesApiService, LocalizedDatePipe, CardViewTextItemModel, CardViewSelectItemModel, CardViewDatetimeItemModel, CardViewDateItemModel, CardViewArrayItemModel, CardViewUpdateService, FormRenderingService, DataTableComponent, CustomLoadingContentTemplateDirective, StorageService, TRANSLATION_PROVIDER } from '@alfresco/adf-core';
import { FlexLayoutModule } from '@angular/flex-layout';
import { MatAutocompleteModule, MatAutocompleteTrigger } from '@angular/material/autocomplete';
import { MatButtonModule } from '@angular/material/button';
import { MatCardModule } from '@angular/material/card';
import { MatCheckboxModule } from '@angular/material/checkbox';
import { MatChipsModule } from '@angular/material/chips';
import { MatOptionModule, MatNativeDateModule, MatRippleModule, DateAdapter, MAT_DATE_FORMATS } from '@angular/material/core';
import { MAT_FORM_FIELD_DEFAULT_OPTIONS } from '@angular/material/form-field';
import { MatDatepickerModule } from '@angular/material/datepicker';
import { MatDialogModule, MatDialogRef, MAT_DIALOG_DATA, MatDialog } from '@angular/material/dialog';
import { MatExpansionModule } from '@angular/material/expansion';
import { MatGridListModule } from '@angular/material/grid-list';
import { MatIconModule } from '@angular/material/icon';
import { MatInputModule } from '@angular/material/input';
import { MatListModule } from '@angular/material/list';
import { MatMenuModule } from '@angular/material/menu';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatRadioModule } from '@angular/material/radio';
import { MatSelectModule } from '@angular/material/select';
import { MatSlideToggleModule } from '@angular/material/slide-toggle';
import { MatTableModule } from '@angular/material/table';
import { MatTabsModule } from '@angular/material/tabs';
import { MatTooltipModule } from '@angular/material/tooltip';
import { CommonModule } from '@angular/common';
import { of, from, throwError, Subject, BehaviorSubject, forkJoin } from 'rxjs';
import { map, catchError, takeUntil, switchMap, debounceTime, filter, tap, distinctUntilChanged, mergeMap, finalize, mapTo, concatMap } from 'rxjs/operators';
import { FormGroup, FormControl, FormsModule, ReactiveFormsModule, Validators, FormBuilder } from '@angular/forms';
import moment from 'moment-es6';
import { Apollo } from 'apollo-angular';
import { HttpLink } from 'apollo-angular/http';
import { split, ApolloLink, InMemoryCache, gql } from '@apollo/client/core';
import { WebSocketLink } from '@apollo/client/link/ws';
import { onError } from '@apollo/client/link/error';
import { getMainDefinition } from '@apollo/client/utilities';
import { HttpClientModule } from '@angular/common/http';
import { __awaiter } from 'tslib';
import { trigger, state, style, transition, animate } from '@angular/animations';
import moment$1 from 'moment';
import { UploadApi, NodesApi, AuthenticationApi } from '@alfresco/js-api';
import { NodeAction, ContentNodeSelectorComponent, ContentNodeSelectorPanelService, ContentNodeSelectorModule, ContentMetadataModule } from '@alfresco/adf-content-services';

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ɵ0 = { floatLabel: 'never' };
class MaterialModule {
}
MaterialModule.decorators = [
    { type: NgModule, args: [{
                providers: [
                    { provide: MAT_FORM_FIELD_DEFAULT_OPTIONS, useValue: ɵ0 }
                ],
                imports: [
                    MatAutocompleteModule, MatButtonModule, MatCardModule, MatDialogModule,
                    MatCheckboxModule, MatDatepickerModule, MatGridListModule, MatIconModule, MatInputModule,
                    MatListModule, MatOptionModule, MatRadioModule, MatSelectModule, MatSlideToggleModule, MatTableModule,
                    MatTabsModule, MatProgressSpinnerModule, MatNativeDateModule, MatRippleModule, MatTooltipModule,
                    MatChipsModule, MatMenuModule, MatExpansionModule
                ],
                exports: [
                    MatAutocompleteModule, MatButtonModule, MatCardModule, MatDialogModule,
                    MatCheckboxModule, MatDatepickerModule, MatGridListModule, MatIconModule, MatInputModule,
                    MatListModule, MatOptionModule, MatRadioModule, MatSelectModule, MatSlideToggleModule, MatTableModule,
                    MatTabsModule, MatProgressSpinnerModule, MatNativeDateModule, MatRippleModule, MatTooltipModule,
                    MatChipsModule, MatMenuModule, MatExpansionModule
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DEFAULT_APP_INSTANCE_THEME = 'theme-2';
const DEFAULT_APP_INSTANCE_ICON = 'favorite_border';

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AppDetailsCloudComponent {
    constructor() {
        this.selectedApp = new EventEmitter();
    }
    onSelectApp(app) {
        this.selectedApp.emit(app);
    }
    getTheme() {
        return this.applicationInstance.theme || DEFAULT_APP_INSTANCE_THEME;
    }
    getIcon() {
        return this.applicationInstance.icon || DEFAULT_APP_INSTANCE_ICON;
    }
}
AppDetailsCloudComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-cloud-app-details',
                template: "<div class=\"adf-app-listgrid\">\n    <div class=\"adf-app-listgrid-item\">\n        <mat-card tabindex=\"0\"\n            fxLayout=\"column\"\n            role=\"button\"\n            class=\"adf-app-listgrid-item-card\"\n            title=\"{{applicationInstance.name}}\"\n            [ngClass]=\"getTheme()\"\n            (click)=\"onSelectApp(applicationInstance)\"\n            (keyup.enter)=\"onSelectApp(applicationInstance)\">\n            <div class=\"adf-app-listgrid-item-card-logo\">\n                <mat-icon class=\"adf-app-listgrid-item-card-logo-icon\">{{ getIcon() }}</mat-icon>\n            </div>\n            <div mat-card-title class=\"adf-app-listgrid-item-card-title\">\n                <h1>{{applicationInstance.name}}</h1>\n            </div>\n            <mat-card-subtitle class=\"adf-app-listgrid-item-card-subtitle\" fxFlex=\"1 0 auto\">\n                <div class=\"adf-line-clamp\">{{applicationInstance.description}}</div>\n            </mat-card-subtitle>\n        </mat-card>\n    </div>\n  </div>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-app-listgrid{padding:8px}.adf-app-listgrid-item{box-sizing:border-box;outline:none;padding:8px}.adf-app-listgrid-item-card{min-height:200px;outline:none;padding:0!important;transition:transform .28s cubic-bezier(.4,0,.2,1),box-shadow .28s cubic-bezier(.4,0,.2,1)}.adf-app-listgrid-item-card.theme-1{background-color:#269abc}.adf-app-listgrid-item-card.theme-2{background-color:#7da9b0}.adf-app-listgrid-item-card.theme-3{background-color:#7689ab}.adf-app-listgrid-item-card.theme-4{background-color:#c74e3e}.adf-app-listgrid-item-card.theme-5{background-color:#fab96c}.adf-app-listgrid-item-card.theme-6{background-color:#759d4c}.adf-app-listgrid-item-card.theme-7{background-color:#b1b489}.adf-app-listgrid-item-card.theme-8{background-color:#a17299}.adf-app-listgrid-item-card.theme-9{background-color:#696c67}.adf-app-listgrid-item-card.theme-10{background-color:#cabb33}.adf-app-listgrid-item-card:hover{box-shadow:0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12),0 5px 5px -3px rgba(0,0,0,.2);cursor:pointer;transform:scale(1.015)}.adf-app-listgrid-item-card-logo{padding:16px;position:absolute;right:20px;top:20px;z-index:9}.adf-app-listgrid-item-card-logo-icon{font-size:70px;height:1em!important;width:1em!important}.theme-1 .adf-app-listgrid-item-card-logo-icon{color:#168aac}.theme-2 .adf-app-listgrid-item-card-logo-icon{color:#6d99a0}.theme-3 .adf-app-listgrid-item-card-logo-icon{color:#66799b}.theme-4 .adf-app-listgrid-item-card-logo-icon{color:#b73e2e}.theme-5 .adf-app-listgrid-item-card-logo-icon{color:#eaa95c}.theme-6 .adf-app-listgrid-item-card-logo-icon{color:#658d3c}.theme-7 .adf-app-listgrid-item-card-logo-icon{color:#a1a479}.theme-8 .adf-app-listgrid-item-card-logo-icon{color:#916289}.theme-9 .adf-app-listgrid-item-card-logo-icon{color:#595c57}.theme-10 .adf-app-listgrid-item-card-logo-icon{color:#baab23}.adf-app-listgrid-item-card-title{margin-bottom:0!important;padding:16px;z-index:9999}.adf-app-listgrid-item-card-title h1{color:#fff;font-size:24px;line-height:normal;margin:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:80%}.adf-app-listgrid-item-card-subtitle{color:#fff;padding:16px;z-index:9999}.adf-app-listgrid-item-card-subtitle .adf-line-clamp{line-height:1.25;overflow:hidden;padding:0!important;position:relative;text-overflow:ellipsis}@supports (-webkit-line-clamp:1){.adf-app-listgrid-item-card-subtitle .adf-line-clamp{-webkit-box-orient:vertical;-webkit-line-clamp:3;display:-webkit-box;height:3.7125em}}@supports not (-webkit-line-clamp:1){.adf-app-listgrid-item-card-subtitle .adf-line-clamp{white-space:nowrap;width:100%}}.adf-app-listgrid-item-card-actions{border-top:1px solid rgba(0,0,0,.1);box-sizing:border-box;min-height:48px;padding:0 16px 16px!important}.adf-app-listgrid-item-card-actions-icon{color:#e9f1f3}.adf-app-listgrid-item-card-actions.mat-card-actions{margin-left:0;margin-right:0}.adf-app-listgrid-item-card-actions.mat-card-actions:last-child{margin-bottom:0!important}"]
            },] }
];
AppDetailsCloudComponent.propDecorators = {
    applicationInstance: [{ type: Input }],
    selectedApp: [{ type: Output }]
};

class AppsProcessCloudService {
    constructor(apiService, logService, appConfigService) {
        this.apiService = apiService;
        this.logService = logService;
        this.appConfigService = appConfigService;
        this.loadApps();
    }
    getDeployedApplicationsByStatus(status, role) {
        return this.hasDeployedApps() ? of(this.deployedApps) : this.getApplicationsByStatus(status, role);
    }
    hasDeployedApps() {
        return this.deployedApps && this.deployedApps.length > 0;
    }
    loadApps() {
        const apps = this.appConfigService.get('alfresco-deployed-apps', []);
        apps.map((app) => {
            app.theme = app.theme ? app.theme : 'theme-1';
            app.icon = app.icon ? app.icon : 'favorite';
        });
        this.deployedApps = apps;
    }
    getApplicationsByStatus(status, role) {
        if (status === '') {
            return of([]);
        }
        const api = this.apiService.getInstance().oauth2Auth;
        const path = this.getApplicationUrl();
        const pathParams = {}, queryParams = { status: status, roles: role, sort: 'name' }, headerParams = {}, formParams = {}, bodyParam = {}, contentTypes = ['application/json'], accepts = ['application/json'];
        return from(api.callCustomApi(path, 'GET', pathParams, queryParams, headerParams, formParams, bodyParam, contentTypes, accepts))
            .pipe(map((applications) => {
            return applications.list.entries.map((application) => application.entry);
        }), catchError((err) => this.handleError(err)));
    }
    getApplicationUrl() {
        return `${this.appConfigService.get('bpmHost')}/deployment-service/v1/applications`;
    }
    handleError(error) {
        this.logService.error(error);
        return throwError(error || 'Server error');
    }
}
AppsProcessCloudService.ɵprov = ɵɵdefineInjectable({ factory: function AppsProcessCloudService_Factory() { return new AppsProcessCloudService(ɵɵinject(AlfrescoApiService), ɵɵinject(LogService), ɵɵinject(AppConfigService)); }, token: AppsProcessCloudService, providedIn: "root" });
AppsProcessCloudService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
AppsProcessCloudService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: LogService },
    { type: AppConfigService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AppListCloudComponent {
    constructor(appsProcessCloudService) {
        this.appsProcessCloudService = appsProcessCloudService;
        this.layoutType = AppListCloudComponent.LAYOUT_GRID;
        this.appClick = new EventEmitter();
        this.loadingError$ = new Subject();
        this.hasEmptyCustomContentTemplate = false;
    }
    ngOnInit() {
        if (!this.isValidType()) {
            this.setDefaultLayoutType();
        }
        this.apps$ = this.appsProcessCloudService.getDeployedApplicationsByStatus(AppListCloudComponent.RUNNING_STATUS)
            .pipe(catchError(() => {
            this.loadingError$.next(true);
            return of();
        }));
    }
    ngAfterContentInit() {
        if (this.emptyCustomContent) {
            this.hasEmptyCustomContentTemplate = true;
        }
    }
    onSelectApp(app) {
        this.appClick.emit(app);
    }
    isValidType() {
        if (this.layoutType && (this.layoutType === AppListCloudComponent.LAYOUT_LIST || this.layoutType === AppListCloudComponent.LAYOUT_GRID)) {
            return true;
        }
        return false;
    }
    setDefaultLayoutType() {
        this.layoutType = AppListCloudComponent.LAYOUT_GRID;
    }
    isList() {
        return this.layoutType === AppListCloudComponent.LAYOUT_LIST;
    }
    isGrid() {
        return this.layoutType === AppListCloudComponent.LAYOUT_GRID;
    }
}
AppListCloudComponent.LAYOUT_LIST = 'LIST';
AppListCloudComponent.LAYOUT_GRID = 'GRID';
AppListCloudComponent.RUNNING_STATUS = 'RUNNING';
AppListCloudComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-cloud-app-list',
                template: "<div class=\"menu-container\" *ngIf=\"apps$ | async as appsList; else loadingOrError\">\n    <ng-container *ngIf=\"appsList.length > 0; else noApps\">\n        <div *ngIf=\"isGrid(); else appList\" fxLayout=\"row wrap\">\n            <adf-cloud-app-details fxFlex=\"33.33333%\" fxFlex.lt-md=\"50%\" fxFlex.lt-sm=\"100%\"\n                *ngFor=\"let app of appsList\" [applicationInstance]=\"app\" (selectedApp)=\"onSelectApp($event)\">\n            </adf-cloud-app-details>\n        </div>\n\n        <ng-template #appList>\n            <mat-list class=\"adf-app-list\">\n                <mat-list-item class=\"adf-app-list-item\" (click)=\"onSelectApp(app)\" (keyup.enter)=\"onSelectApp(app)\"\n                    *ngFor=\"let app of appsList\" tabindex=\"0\" role=\"button\" title=\"{{app.name}}\">\n                    <mat-icon matListIcon>touch_app</mat-icon>\n                    <span matLine>{{app.name}}</span>\n                </mat-list-item>\n            </mat-list>\n        </ng-template>\n    </ng-container>\n</div>\n<ng-template #noApps>\n    <div class=\"adf-app-list-empty\">\n        <ng-content select=\"adf-custom-empty-content-template\" *ngIf=\"hasEmptyCustomContentTemplate; else defaultEmptyTemplate\"\n            class=\"adf-custom-empty-template\">\n        </ng-content>\n\n        <ng-template #defaultEmptyTemplate>\n            <adf-empty-content icon=\"apps\" [title]=\"'ADF_CLOUD_TASK_LIST.APPS.NO_APPS.TITLE' | translate\"\n                [subtitle]=\"'ADF_CLOUD_TASK_LIST.APPS.NO_APPS.SUBTITLE' | translate\">\n            </adf-empty-content>\n        </ng-template>\n    </div>\n</ng-template>\n<ng-template #loadingOrError>\n    <div *ngIf=\"loadingError$ | async; else loading\" class=\"adf-app-list-error\">\n        <adf-empty-content icon=\"error_outline\" [title]=\"'ADF_CLOUD_TASK_LIST.APPS.ERROR.TITLE' | translate\"\n            [subtitle]=\"'ADF_CLOUD_TASK_LIST.APPS.ERROR.SUBTITLE' | translate\">\n        </adf-empty-content>\n    </div>\n    <ng-template #loading>\n    <ng-container>\n        <div class=\"adf-app-list-spinner\">\n            <mat-spinner></mat-spinner>\n        </div>\n    </ng-container>\n</ng-template>\n</ng-template>\n",
                styles: [":host{width:100%}.adf-app-list-item{cursor:pointer}.adf-app-list-empty,.adf-app-list-error,.adf-app-list-spinner{align-items:center;display:flex;flex-direction:column;height:85vh;justify-content:center}.adf-app-list-empty .mat-spinner,.adf-app-list-error .mat-spinner,.adf-app-list-spinner .mat-spinner{margin:0 auto}"]
            },] }
];
AppListCloudComponent.ctorParameters = () => [
    { type: AppsProcessCloudService }
];
AppListCloudComponent.propDecorators = {
    emptyCustomContent: [{ type: ContentChild, args: [CustomEmptyContentTemplateDirective,] }],
    layoutType: [{ type: Input }],
    appClick: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AppListCloudModule {
}
AppListCloudModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    TemplateModule,
                    MaterialModule,
                    FlexLayoutModule,
                    CoreModule
                ],
                declarations: [
                    AppListCloudComponent,
                    AppDetailsCloudComponent
                ],
                exports: [
                    AppListCloudComponent,
                    AppDetailsCloudComponent
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TaskQueryCloudRequestModel {
    constructor(obj) {
        if (obj) {
            this.appName = obj.appName;
            this.appVersion = obj.appVersion;
            this.assignee = obj.assignee;
            this.claimedDate = obj.claimedDate;
            this.createdDate = obj.createdDate;
            this.createdFrom = obj.createdFrom;
            this.createdTo = obj.createdTo;
            this.description = obj.description;
            this.dueDate = obj.dueDate;
            this.lastModifiedFrom = obj.lastModifiedFrom;
            this.lastModifiedTo = obj.lastModifiedTo;
            this.dueDateFrom = obj.dueDateFrom;
            this.dueDateTo = obj.dueDateTo;
            this.id = obj.id;
            this.name = obj.name;
            this.owner = obj.owner;
            this.parentTaskId = obj.parentTaskId;
            this.standalone = obj.standalone;
            this.priority = obj.priority;
            this.processDefinitionId = obj.processDefinitionId;
            this.processDefinitionName = obj.processDefinitionName;
            this.processInstanceId = obj.processInstanceId;
            this.status = obj.status;
            this.completedBy = obj.completedBy;
            this.maxItems = obj.maxItems;
            this.skipCount = obj.skipCount;
            this.sorting = obj.sorting;
            this.completedFrom = obj.completedFrom;
            this.completedTo = obj.completedTo;
            this.completedDate = obj.completedDate;
            this.candidateGroupId = obj.candidateGroupId;
        }
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class BaseCloudService {
    constructor(apiService, appConfigService) {
        this.apiService = apiService;
        this.appConfigService = appConfigService;
        this.defaultParams = {
            path: '',
            httpMethod: '',
            contentTypes: ['application/json'],
            accepts: ['application/json'],
            returnType: Object
        };
    }
    getBasePath(appName) {
        return appName
            ? `${this.contextRoot}/${appName}`
            : this.contextRoot;
    }
    post(url, data) {
        return from(this.callApi(Object.assign(Object.assign({}, this.defaultParams), { path: url, httpMethod: 'POST', bodyParam: data })));
    }
    put(url, data) {
        return from(this.callApi(Object.assign(Object.assign({}, this.defaultParams), { path: url, httpMethod: 'PUT', bodyParam: data })));
    }
    delete(url) {
        return from(this.callApi(Object.assign(Object.assign({}, this.defaultParams), { path: url, httpMethod: 'DELETE' })));
    }
    get(url, queryParams) {
        return from(this.callApi(Object.assign(Object.assign({}, this.defaultParams), { path: url, httpMethod: 'GET', queryParams })));
    }
    callApi(params) {
        return this.apiService.getInstance()
            .oauth2Auth.callCustomApi(params.path, params.httpMethod, params.pathParams, params.queryParams, params.headerParams, params.formParams, params.bodyParam, params.contentTypes, params.accepts, params.returnType, params.contextRoot, params.responseType);
    }
    get contextRoot() {
        return this.appConfigService.get('bpmHost', '');
    }
}

class TaskListCloudService extends BaseCloudService {
    constructor(apiService, appConfigService, logService) {
        super(apiService, appConfigService);
        this.logService = logService;
    }
    getTaskByRequest(requestNode, queryUrl) {
        if (requestNode.appName || requestNode.appName === '') {
            queryUrl = queryUrl || `${this.getBasePath(requestNode.appName)}/query/v1/tasks`;
            const queryParams = this.buildQueryParams(requestNode);
            const sortingParams = this.buildSortingParam(requestNode.sorting);
            if (sortingParams) {
                queryParams['sort'] = sortingParams;
            }
            return this.get(queryUrl, queryParams).pipe(map((response) => {
                const entries = response.list && response.list.entries;
                if (entries) {
                    response.list.entries = entries.map((entryData) => entryData.entry);
                }
                return response;
            }));
        }
        else {
            this.logService.error('Appname is mandatory for querying task');
            return throwError('Appname not configured');
        }
    }
    buildQueryParams(requestNode) {
        const queryParam = {};
        for (const property in requestNode) {
            if (requestNode.hasOwnProperty(property) &&
                !this.isExcludedField(property) &&
                this.isPropertyValueValid(requestNode, property)) {
                queryParam[property] = requestNode[property];
            }
        }
        return queryParam;
    }
    isExcludedField(property) {
        return property === 'appName' || property === 'sorting';
    }
    isPropertyValueValid(requestNode, property) {
        return requestNode[property] !== '' && requestNode[property] !== null && requestNode[property] !== undefined;
    }
    buildSortingParam(models) {
        let finalSorting = '';
        if (models) {
            for (const sort of models) {
                if (!finalSorting) {
                    finalSorting = `${sort.orderBy},${sort.direction}`;
                }
                else {
                    finalSorting = `${finalSorting}&${sort.orderBy},${sort.direction}`;
                }
            }
        }
        return encodeURI(finalSorting);
    }
}
TaskListCloudService.ɵprov = ɵɵdefineInjectable({ factory: function TaskListCloudService_Factory() { return new TaskListCloudService(ɵɵinject(AlfrescoApiService), ɵɵinject(AppConfigService), ɵɵinject(LogService)); }, token: TaskListCloudService, providedIn: "root" });
TaskListCloudService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
TaskListCloudService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: AppConfigService },
    { type: LogService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const taskPresetsCloudDefaultModel = {
    'default': [
        {
            'key': 'name',
            'type': 'text',
            'title': 'ADF_CLOUD_TASK_LIST.PROPERTIES.NAME',
            'sortable': true
        },
        {
            'key': 'created',
            'type': 'text',
            'title': 'ADF_CLOUD_TASK_LIST.PROPERTIES.CREATED',
            'cssClass': 'hidden',
            'sortable': true
        },
        {
            'key': 'assignee',
            'type': 'text',
            'title': 'ADF_CLOUD_TASK_LIST.PROPERTIES.ASSIGNEE',
            'cssClass': 'hidden',
            'sortable': true
        }
    ]
};
const serviceTaskPresetsCloudDefaultModel = {
    'default': [
        {
            'key': 'activityName',
            'type': 'text',
            'title': 'ADF_CLOUD_SERVICE_TASK_LIST.PROPERTIES.ACTIVITY_NAME',
            'sortable': true
        },
        {
            'key': 'status',
            'type': 'text',
            'title': 'ADF_CLOUD_SERVICE_TASK_LIST.PROPERTIES.STATUS',
            'sortable': true
        },
        {
            'key': 'startedDate',
            'type': 'text',
            'title': 'ADF_CLOUD_SERVICE_TASK_LIST.PROPERTIES.STARTED_DATE',
            'cssClass': 'hidden',
            'sortable': true
        },
        {
            'key': 'completedDate',
            'type': 'text',
            'title': 'ADF_CLOUD_SERVICE_TASK_LIST.PROPERTIES.COMPLETED_DATE',
            'cssClass': 'hidden',
            'sortable': true
        }
    ]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TaskListCloudSortingModel {
    constructor(obj) {
        if (obj) {
            this.orderBy = obj.orderBy;
            this.direction = obj.direction;
        }
    }
}

class StartTaskCloudRequestModel {
    constructor(obj) {
        if (obj) {
            this.name = obj.name || null;
            this.description = obj.description || null;
            this.assignee = obj.assignee || null;
            this.priority = obj.priority || null;
            this.dueDate = obj.dueDate || null;
            this.candidateUsers = obj.candidateUsers || null;
            this.candidateGroups = obj.candidateGroups || null;
            this.formKey = obj.formKey || null;
            this.payloadType = 'CreateTaskPayload';
        }
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessDefinitionCloud {
    constructor(obj) {
        this.id = obj && obj.id || null;
        this.name = obj && obj.name || null;
        this.appName = obj && obj.appName || null;
        this.key = obj && obj.key || null;
        this.formKey = obj && obj.formKey || null;
        this.version = obj && obj.version || 0;
        this.appVersion = obj && obj.appVersion || 0;
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var ClaimTaskEnum;
(function (ClaimTaskEnum) {
    ClaimTaskEnum["claim"] = "claim";
    ClaimTaskEnum["unclaim"] = "unclaim";
})(ClaimTaskEnum || (ClaimTaskEnum = {}));
const DEFAULT_TASK_PRIORITIES = [
    { label: 'ADF_CLOUD_TASK_LIST.PROPERTIES.PRIORITY_VALUES.NONE', value: '0', key: '0' },
    { label: 'ADF_CLOUD_TASK_LIST.PROPERTIES.PRIORITY_VALUES.LOW', value: '1', key: '1' },
    { label: 'ADF_CLOUD_TASK_LIST.PROPERTIES.PRIORITY_VALUES.NORMAL', value: '2', key: '2' },
    { label: 'ADF_CLOUD_TASK_LIST.PROPERTIES.PRIORITY_VALUES.HIGH', value: '3', key: '3' }
];
const TASK_ASSIGNED_STATE = 'ASSIGNED';
const TASK_CREATED_STATE = 'CREATED';

class TaskCloudService extends BaseCloudService {
    constructor(apiService, appConfigService, logService, translateService, identityUserService) {
        super(apiService, appConfigService);
        this.logService = logService;
        this.translateService = translateService;
        this.identityUserService = identityUserService;
        this.dataChangesDetected$ = new Subject();
    }
    completeTask(appName, taskId) {
        if ((appName || appName === '') && taskId) {
            const url = `${this.getBasePath(appName)}/rb/v1/tasks/${taskId}/complete`;
            const payload = { 'payloadType': 'CompleteTaskPayload' };
            return this.post(url, payload);
        }
        else {
            this.logService.error('AppName and TaskId are mandatory for complete a task');
            return throwError('AppName/TaskId not configured');
        }
    }
    canCompleteTask(taskDetails) {
        return taskDetails && taskDetails.status === TASK_ASSIGNED_STATE && this.isAssignedToMe(taskDetails.assignee);
    }
    isTaskEditable(taskDetails) {
        return taskDetails && taskDetails.status === TASK_ASSIGNED_STATE && this.isAssignedToMe(taskDetails.assignee);
    }
    isAssigneePropertyClickable(taskDetails, candidateUsers, candidateGroups) {
        let isClickable = false;
        const states = [TASK_ASSIGNED_STATE];
        if ((candidateUsers === null || candidateUsers === void 0 ? void 0 : candidateUsers.length) || (candidateGroups === null || candidateGroups === void 0 ? void 0 : candidateGroups.length)) {
            isClickable = states.includes(taskDetails.status);
        }
        return isClickable;
    }
    canClaimTask(taskDetails) {
        return taskDetails && taskDetails.status === TASK_CREATED_STATE;
    }
    canUnclaimTask(taskDetails) {
        const currentUser = this.identityUserService.getCurrentUserInfo().username;
        return taskDetails && taskDetails.status === TASK_ASSIGNED_STATE && taskDetails.assignee === currentUser;
    }
    claimTask(appName, taskId, assignee) {
        if ((appName || appName === '') && taskId) {
            const queryUrl = `${this.getBasePath(appName)}/rb/v1/tasks/${taskId}/claim?assignee=${assignee}`;
            return this.post(queryUrl).pipe(map((res) => {
                this.dataChangesDetected$.next();
                return res.entry;
            }));
        }
        else {
            this.logService.error('AppName and TaskId are mandatory for querying a task');
            return throwError('AppName/TaskId not configured');
        }
    }
    unclaimTask(appName, taskId) {
        if ((appName || appName === '') && taskId) {
            const queryUrl = `${this.getBasePath(appName)}/rb/v1/tasks/${taskId}/release`;
            return this.post(queryUrl).pipe(map((res) => {
                this.dataChangesDetected$.next();
                return res.entry;
            }));
        }
        else {
            this.logService.error('AppName and TaskId are mandatory for querying a task');
            return throwError('AppName/TaskId not configured');
        }
    }
    getTaskById(appName, taskId) {
        if ((appName || appName === '') && taskId) {
            const queryUrl = `${this.getBasePath(appName)}/query/v1/tasks/${taskId}`;
            return this.get(queryUrl).pipe(map((res) => res.entry));
        }
        else {
            this.logService.error('AppName and TaskId are mandatory for querying a task');
            return throwError('AppName/TaskId not configured');
        }
    }
    createNewTask(startTaskRequest, appName) {
        const queryUrl = `${this.getBasePath(appName)}/rb/v1/tasks`;
        const payload = JSON.stringify(new StartTaskCloudRequestModel(startTaskRequest));
        return this.post(queryUrl, payload)
            .pipe(map(response => response.entry));
    }
    updateTask(appName, taskId, payload) {
        if ((appName || appName === '') && taskId) {
            payload.payloadType = 'UpdateTaskPayload';
            const queryUrl = `${this.getBasePath(appName)}/rb/v1/tasks/${taskId}`;
            return this.put(queryUrl, payload).pipe(map((res) => res.entry));
        }
        else {
            this.logService.error('AppName and TaskId are mandatory for querying a task');
            return throwError('AppName/TaskId not configured');
        }
    }
    getCandidateUsers(appName, taskId) {
        if ((appName || appName === '') && taskId) {
            const queryUrl = `${this.getBasePath(appName)}/query/v1/tasks/${taskId}/candidate-users`;
            return this.get(queryUrl);
        }
        else {
            this.logService.error('AppName and TaskId are mandatory to get candidate user');
            return of([]);
        }
    }
    getCandidateGroups(appName, taskId) {
        if ((appName || appName === '') && taskId) {
            const queryUrl = `${this.getBasePath(appName)}/query/v1/tasks/${taskId}/candidate-groups`;
            return this.get(queryUrl);
        }
        else {
            this.logService.error('AppName and TaskId are mandatory to get candidate groups');
            return of([]);
        }
    }
    getProcessDefinitions(appName) {
        if (appName || appName === '') {
            const url = `${this.getBasePath(appName)}/rb/v1/process-definitions`;
            return this.get(url).pipe(map((res) => {
                return res.list.entries.map((processDefs) => new ProcessDefinitionCloud(processDefs.entry));
            }));
        }
        else {
            this.logService.error('AppName is mandatory for querying task');
            return throwError('AppName not configured');
        }
    }
    assign(appName, taskId, assignee) {
        if (appName && taskId) {
            const payLoad = { 'assignee': assignee, 'taskId': taskId, 'payloadType': 'AssignTaskPayload' };
            const url = `${this.getBasePath(appName)}/rb/v1/tasks/${taskId}/assign`;
            return this.post(url, payLoad).pipe(map((res) => {
                return res.entry;
            }));
        }
        else {
            this.logService.error('AppName and TaskId are mandatory to change/update the task assignee');
            return throwError('AppName/TaskId not configured');
        }
    }
    getPriorityLabel(priority) {
        const priorityItem = this.priorities.find(item => item.value === priority.toString()) || this.priorities[0];
        return this.translateService.instant(priorityItem.label);
    }
    get priorities() {
        return this.appConfigService.get('adf-cloud-priority-values') || DEFAULT_TASK_PRIORITIES;
    }
    isAssignedToMe(assignee) {
        const currentUser = this.identityUserService.getCurrentUserInfo().username;
        return assignee === currentUser;
    }
}
TaskCloudService.ɵprov = ɵɵdefineInjectable({ factory: function TaskCloudService_Factory() { return new TaskCloudService(ɵɵinject(AlfrescoApiService), ɵɵinject(AppConfigService), ɵɵinject(LogService), ɵɵinject(TranslationService), ɵɵinject(IdentityUserService)); }, token: TaskCloudService, providedIn: "root" });
TaskCloudService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
TaskCloudService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: AppConfigService },
    { type: LogService },
    { type: TranslationService },
    { type: IdentityUserService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class BaseTaskListCloudComponent extends DataTableSchema {
    constructor(appConfigService, taskCloudService, userPreferences, presetKey) {
        super(appConfigService, presetKey, taskPresetsCloudDefaultModel);
        this.taskCloudService = taskCloudService;
        this.userPreferences = userPreferences;
        this.appName = '';
        this.selectionMode = 'single';
        this.multiselect = false;
        this.stickyHeader = false;
        this.showActions = false;
        this.actionsPosition = 'right';
        this.showContextMenu = false;
        this.showRowContextMenu = new EventEmitter();
        this.showRowActionsMenu = new EventEmitter();
        this.executeRowAction = new EventEmitter();
        this.rowClick = new EventEmitter();
        this.rowsSelected = new EventEmitter();
        this.success = new EventEmitter();
        this.error = new EventEmitter();
        this.rows = [];
        this.skipCount = 0;
        this.isLoading = true;
        this.defaultSorting = { key: 'startDate', direction: 'desc' };
        this.onDestroy$ = new Subject();
        this.size = userPreferences.paginationSize;
        this.pagination = new BehaviorSubject({
            maxItems: this.size,
            skipCount: 0,
            totalItems: 0
        });
        this.boundReplacePriorityValues = this.replacePriorityValues.bind(this);
    }
    ngOnInit() {
        this.userPreferences
            .select(UserPreferenceValues.PaginationSize)
            .pipe(takeUntil(this.onDestroy$))
            .subscribe(pageSize => this.size = pageSize);
    }
    ngOnChanges(changes) {
        if (changes['sorting']) {
            this.formatSorting(changes['sorting'].currentValue);
        }
        this.reload();
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
    ngAfterContentInit() {
        this.createDatatableSchema();
    }
    reload() {
        this.requestNode = this.createRequestNode();
        if (this.requestNode.appName || this.requestNode.appName === '') {
            this.load(this.requestNode);
        }
        else {
            this.rows = [];
        }
    }
    isListEmpty() {
        return !this.rows || this.rows.length === 0;
    }
    resetPagination() {
        this.skipCount = 0;
        this.size = this.userPreferences.paginationSize;
        this.pagination.next({
            skipCount: 0,
            maxItems: this.size
        });
    }
    updatePagination(pagination) {
        this.size = pagination.maxItems;
        this.skipCount = pagination.skipCount;
        this.pagination.next(pagination);
        this.reload();
    }
    onSortingChanged(event) {
        this.setSorting(event.detail);
        this.formatSorting(this.sorting);
        this.reload();
    }
    onRowClick(item) {
        this.currentInstanceId = item.value.getValue('id');
        this.rowClick.emit(this.currentInstanceId);
    }
    onRowSelect(event) {
        this.selectedInstances = [...event.detail.selection];
        this.rowsSelected.emit(this.selectedInstances);
    }
    onRowUnselect(event) {
        this.selectedInstances = [...event.detail.selection];
        this.rowsSelected.emit(this.selectedInstances);
    }
    onRowKeyUp(event) {
        if (event.detail.keyboardEvent.key === 'Enter') {
            event.preventDefault();
            this.currentInstanceId = event.detail.row.getValue('id');
            this.rowClick.emit(this.currentInstanceId);
        }
    }
    onShowRowActionsMenu(event) {
        this.showRowActionsMenu.emit(event);
    }
    onShowRowContextMenu(event) {
        this.showRowContextMenu.emit(event);
    }
    onExecuteRowAction(row) {
        this.executeRowAction.emit(row);
    }
    setSorting(sortDetail) {
        const sorting = sortDetail ? {
            orderBy: sortDetail.key,
            direction: sortDetail.direction.toUpperCase()
        } : Object.assign({}, this.defaultSorting);
        this.sorting = [new TaskListCloudSortingModel(sorting)];
    }
    formatSorting(sorting) {
        this.formattedSorting = this.isValidSorting(sorting) ? [
            sorting[0].orderBy,
            sorting[0].direction.toLocaleLowerCase()
        ] : null;
    }
    isValidSorting(sorting) {
        return sorting && sorting.length && sorting[0].orderBy && sorting[0].direction;
    }
    replacePriorityValues(row, column) {
        return column.key.split('.').reduce((source, key) => {
            if (key === 'priority' && source && typeof (source[key]) === 'number') {
                return source[key] = this.taskCloudService.getPriorityLabel(source[key]);
            }
            return source && typeof (source) === 'object' ? source[key] : undefined;
        }, row.obj);
    }
}
BaseTaskListCloudComponent.decorators = [
    { type: Directive }
];
BaseTaskListCloudComponent.ctorParameters = () => [
    { type: AppConfigService },
    { type: TaskCloudService },
    { type: UserPreferencesService },
    { type: String }
];
BaseTaskListCloudComponent.propDecorators = {
    emptyCustomContent: [{ type: ContentChild, args: [CustomEmptyContentTemplateDirective,] }],
    appName: [{ type: Input }],
    selectionMode: [{ type: Input }],
    multiselect: [{ type: Input }],
    stickyHeader: [{ type: Input }],
    sorting: [{ type: Input }],
    showActions: [{ type: Input }],
    actionsPosition: [{ type: Input }],
    showContextMenu: [{ type: Input }],
    showRowContextMenu: [{ type: Output }],
    showRowActionsMenu: [{ type: Output }],
    executeRowAction: [{ type: Output }],
    rowClick: [{ type: Output }],
    rowsSelected: [{ type: Output }],
    success: [{ type: Output }],
    error: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TaskListCloudComponent extends BaseTaskListCloudComponent {
    constructor(taskListCloudService, appConfigService, taskCloudService, userPreferences) {
        super(appConfigService, taskCloudService, userPreferences, TaskListCloudComponent.PRESET_KEY);
        this.taskListCloudService = taskListCloudService;
        this.assignee = '';
        this.createdFrom = '';
        this.createdTo = '';
        this.lastModifiedFrom = '';
        this.lastModifiedTo = '';
        this.dueDateFrom = '';
        this.dueDateTo = '';
        this.id = '';
        this.name = '';
        this.parentTaskId = '';
        this.processDefinitionName = '';
        this.processDefinitionId = '';
        this.processInstanceId = '';
        this.status = '';
        this.owner = '';
        this.standalone = false;
        this.completedDate = '';
        this.completedFrom = '';
        this.completedTo = '';
        this.candidateGroupId = '';
    }
    load(requestNode) {
        this.isLoading = true;
        this.taskListCloudService.getTaskByRequest(requestNode).subscribe((tasks) => {
            this.rows = tasks.list.entries;
            this.success.emit(tasks);
            this.isLoading = false;
            this.pagination.next(tasks.list.pagination);
        }, (error) => {
            this.error.emit(error);
            this.isLoading = false;
        });
    }
    createRequestNode() {
        const requestNode = {
            appName: this.appName,
            assignee: this.assignee,
            id: this.id,
            name: this.name,
            parentTaskId: this.parentTaskId,
            processDefinitionName: this.processDefinitionName,
            processDefinitionId: this.processDefinitionId,
            processInstanceId: this.processInstanceId,
            owner: this.owner,
            priority: this.priority,
            lastModifiedFrom: this.lastModifiedFrom,
            lastModifiedTo: this.lastModifiedTo,
            dueDateFrom: this.dueDateFrom,
            dueDateTo: this.dueDateTo,
            status: this.status,
            dueDate: this.dueDate,
            createdDate: this.createdDate,
            createdFrom: this.createdFrom,
            createdTo: this.createdTo,
            maxItems: this.size,
            skipCount: this.skipCount,
            sorting: this.sorting,
            standalone: this.standalone,
            completedBy: this.completedBy,
            completedFrom: this.completedFrom,
            completedTo: this.completedTo,
            completedDate: this.completedDate,
            candidateGroupId: this.candidateGroupId
        };
        return new TaskQueryCloudRequestModel(requestNode);
    }
}
TaskListCloudComponent.PRESET_KEY = 'adf-cloud-task-list.presets';
TaskListCloudComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-cloud-task-list',
                template: "<div *ngIf=\"!rows\">{{ 'ADF_CLOUD_TASK_LIST.FILTERS.MESSAGES.NONE' | translate }}</div>\n<ng-container *ngIf=\"rows\">\n        <adf-datatable\n            [rows]=\"rows\"\n            [columns]=\"columns\"\n            [loading]=\"isLoading\"\n            [sorting]=\"formattedSorting\"\n            [multiselect]=\"multiselect\"\n            [selectionMode]=\"selectionMode\"\n            [stickyHeader]=\"stickyHeader\"\n            [actions]=\"showActions\"\n            [actionsPosition]=\"actionsPosition\"\n            [contextMenu]=\"showContextMenu\"\n            [resolverFn]=\"boundReplacePriorityValues\"\n            (showRowActionsMenu)=\"onShowRowActionsMenu($event)\"\n            (showRowContextMenu)=\"onShowRowContextMenu($event)\"\n            (executeRowAction)=\"onExecuteRowAction($event)\"\n            (row-select)=\"onRowSelect($any($event))\"\n            (row-unselect)=\"onRowUnselect($any($event))\"\n            (rowClick)=\"onRowClick($any($event))\"\n            (row-keyup)=\"onRowKeyUp($any($event))\"\n            (sorting-changed)=\"onSortingChanged($any($event))\">\n            <adf-loading-content-template>\n                <ng-template>\n                    <!-- Add your custom loading template here -->\n                    <mat-progress-spinner class=\"adf-cloud-task-list-loading-margin\"\n                                          [color]=\"'primary'\"\n                                          [mode]=\"'indeterminate'\">\n                    </mat-progress-spinner>\n                </ng-template>\n            </adf-loading-content-template>\n            <adf-no-content-template>\n                <ng-template>\n                    <adf-empty-content *ngIf=\"!emptyCustomContent\"\n                                       icon=\"assignment\"\n                                       [title]=\"'ADF_CLOUD_TASK_LIST.LIST.MESSAGES.TITLE' | translate\"\n                                       [subtitle]=\"'ADF_CLOUD_TASK_LIST.LIST.MESSAGES.SUBTITLE' | translate\">\n                    </adf-empty-content>\n                    <ng-content select=\"adf-custom-empty-content-template\"></ng-content>\n                </ng-template>\n            </adf-no-content-template>\n        </adf-datatable>\n</ng-container>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-cloud-task-list-loading-margin{margin-left:calc(50% - 50px);margin-right:calc(50% - 50px)}"]
            },] }
];
TaskListCloudComponent.ctorParameters = () => [
    { type: TaskListCloudService },
    { type: AppConfigService },
    { type: TaskCloudService },
    { type: UserPreferencesService }
];
TaskListCloudComponent.propDecorators = {
    assignee: [{ type: Input }],
    createdDate: [{ type: Input }],
    createdFrom: [{ type: Input }],
    createdTo: [{ type: Input }],
    dueDate: [{ type: Input }],
    lastModifiedFrom: [{ type: Input }],
    lastModifiedTo: [{ type: Input }],
    dueDateFrom: [{ type: Input }],
    dueDateTo: [{ type: Input }],
    id: [{ type: Input }],
    name: [{ type: Input }],
    parentTaskId: [{ type: Input }],
    processDefinitionName: [{ type: Input }],
    processDefinitionId: [{ type: Input }],
    processInstanceId: [{ type: Input }],
    status: [{ type: Input }],
    owner: [{ type: Input }],
    priority: [{ type: Input }],
    completedBy: [{ type: Input }],
    standalone: [{ type: Input }],
    completedDate: [{ type: Input }],
    completedFrom: [{ type: Input }],
    completedTo: [{ type: Input }],
    candidateGroupId: [{ type: Input }]
};

class ServiceTaskListCloudService extends BaseCloudService {
    constructor(apiService, appConfigService, logService) {
        super(apiService, appConfigService);
        this.logService = logService;
    }
    getServiceTaskByRequest(requestNode) {
        if (requestNode.appName || requestNode.appName === '') {
            const queryUrl = `${this.getBasePath(requestNode.appName)}/query/admin/v1/service-tasks`;
            const queryParams = this.buildQueryParams(requestNode);
            const sortingParams = this.buildSortingParam(requestNode.sorting);
            if (sortingParams) {
                queryParams['sort'] = sortingParams;
            }
            return this.get(queryUrl, queryParams);
        }
        else {
            this.logService.error('Appname is mandatory for querying task');
            return throwError('Appname not configured');
        }
    }
    getServiceTaskStatus(appName, serviceTaskId) {
        if (appName) {
            const queryUrl = `${this.getBasePath(appName)}/query/admin/v1/service-tasks/${serviceTaskId}/integration-context`;
            return this.get(queryUrl).pipe(map((response) => response.entry));
        }
        else {
            this.logService.error('Appname is mandatory for querying task');
            return throwError('Appname not configured');
        }
    }
    buildQueryParams(requestNode) {
        const queryParam = {};
        for (const property in requestNode) {
            if (requestNode.hasOwnProperty(property) &&
                !this.isExcludedField(property) &&
                this.isPropertyValueValid(requestNode, property)) {
                queryParam[property] = requestNode[property];
            }
        }
        return queryParam;
    }
    isExcludedField(property) {
        return property === 'appName' || property === 'sorting';
    }
    isPropertyValueValid(requestNode, property) {
        return requestNode[property] !== '' && requestNode[property] !== null && requestNode[property] !== undefined;
    }
    buildSortingParam(models) {
        let finalSorting = '';
        if (models) {
            for (const sort of models) {
                if (!finalSorting) {
                    finalSorting = `${sort.orderBy},${sort.direction}`;
                }
                else {
                    finalSorting = `${finalSorting}&${sort.orderBy},${sort.direction}`;
                }
            }
        }
        return encodeURI(finalSorting);
    }
}
ServiceTaskListCloudService.ɵprov = ɵɵdefineInjectable({ factory: function ServiceTaskListCloudService_Factory() { return new ServiceTaskListCloudService(ɵɵinject(AlfrescoApiService), ɵɵinject(AppConfigService), ɵɵinject(LogService)); }, token: ServiceTaskListCloudService, providedIn: "root" });
ServiceTaskListCloudService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
ServiceTaskListCloudService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: AppConfigService },
    { type: LogService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ServiceTaskListCloudComponent extends BaseTaskListCloudComponent {
    constructor(serviceTaskListCloudService, appConfigService, taskCloudService, userPreferences) {
        super(appConfigService, taskCloudService, userPreferences, ServiceTaskListCloudComponent.PRESET_KEY);
        this.serviceTaskListCloudService = serviceTaskListCloudService;
        this.queryParams = {};
    }
    load(requestNode) {
        this.isLoading = true;
        this.serviceTaskListCloudService.getServiceTaskByRequest(requestNode).subscribe((tasks) => {
            this.rows = tasks.list.entries;
            this.success.emit(tasks);
            this.isLoading = false;
            this.pagination.next(tasks.list.pagination);
        }, (error) => {
            this.error.emit(error);
            this.isLoading = false;
        });
    }
    createRequestNode() {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q;
        const requestNode = {
            appName: this.appName,
            maxItems: this.size,
            skipCount: this.skipCount,
            sorting: this.sorting,
            id: (_a = this.queryParams) === null || _a === void 0 ? void 0 : _a.serviceTaskId,
            activityName: (_b = this.queryParams) === null || _b === void 0 ? void 0 : _b.activityName,
            activityType: (_c = this.queryParams) === null || _c === void 0 ? void 0 : _c.activityType,
            completedDate: (_d = this.queryParams) === null || _d === void 0 ? void 0 : _d.completedDate,
            elementId: (_e = this.queryParams) === null || _e === void 0 ? void 0 : _e.elementId,
            executionId: (_f = this.queryParams) === null || _f === void 0 ? void 0 : _f.executionId,
            processDefinitionId: (_g = this.queryParams) === null || _g === void 0 ? void 0 : _g.processDefinitionId,
            processDefinitionKey: (_h = this.queryParams) === null || _h === void 0 ? void 0 : _h.processDefinitionKey,
            processDefinitionVersion: (_j = this.queryParams) === null || _j === void 0 ? void 0 : _j.processDefinitionVersion,
            processInstanceId: (_k = this.queryParams) === null || _k === void 0 ? void 0 : _k.processInstanceId,
            serviceFullName: (_l = this.queryParams) === null || _l === void 0 ? void 0 : _l.serviceFullName,
            serviceName: (_m = this.queryParams) === null || _m === void 0 ? void 0 : _m.serviceName,
            serviceVersion: (_o = this.queryParams) === null || _o === void 0 ? void 0 : _o.serviceVersion,
            startedDate: (_p = this.queryParams) === null || _p === void 0 ? void 0 : _p.startedDate,
            status: (_q = this.queryParams) === null || _q === void 0 ? void 0 : _q.status
        };
        return requestNode;
    }
}
ServiceTaskListCloudComponent.PRESET_KEY = 'adf-cloud-service-task-list.presets';
ServiceTaskListCloudComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-cloud-service-task-list',
                template: "<div *ngIf=\"!rows\">{{ 'ADF_CLOUD_TASK_LIST.FILTERS.MESSAGES.NONE' | translate }}</div>\n<ng-container *ngIf=\"rows\">\n        <adf-datatable\n            [rows]=\"rows\"\n            [columns]=\"columns\"\n            [loading]=\"isLoading\"\n            [sorting]=\"formattedSorting\"\n            [multiselect]=\"multiselect\"\n            [selectionMode]=\"selectionMode\"\n            [stickyHeader]=\"stickyHeader\"\n            [actions]=\"showActions\"\n            [actionsPosition]=\"actionsPosition\"\n            [contextMenu]=\"showContextMenu\"\n            [resolverFn]=\"boundReplacePriorityValues\"\n            (showRowActionsMenu)=\"onShowRowActionsMenu($event)\"\n            (showRowContextMenu)=\"onShowRowContextMenu($event)\"\n            (executeRowAction)=\"onExecuteRowAction($event)\"\n            (row-select)=\"onRowSelect($any($event))\"\n            (row-unselect)=\"onRowUnselect($any($event))\"\n            (rowClick)=\"onRowClick($any($event))\"\n            (row-keyup)=\"onRowKeyUp($any($event))\"\n            (sorting-changed)=\"onSortingChanged($any($event))\">\n            <adf-loading-content-template>\n                <ng-template>\n                    <!-- Add your custom loading template here -->\n                    <mat-progress-spinner class=\"adf-cloud-task-list-loading-margin\"\n                                          [color]=\"'primary'\"\n                                          [mode]=\"'indeterminate'\">\n                    </mat-progress-spinner>\n                </ng-template>\n            </adf-loading-content-template>\n            <adf-no-content-template>\n                <ng-template>\n                    <adf-empty-content *ngIf=\"!emptyCustomContent\"\n                                       icon=\"assignment\"\n                                       [title]=\"'ADF_CLOUD_TASK_LIST.LIST.MESSAGES.TITLE' | translate\"\n                                       [subtitle]=\"'ADF_CLOUD_TASK_LIST.LIST.MESSAGES.SUBTITLE' | translate\">\n                    </adf-empty-content>\n                    <ng-content select=\"adf-custom-empty-content-template\"></ng-content>\n                </ng-template>\n            </adf-no-content-template>\n        </adf-datatable>\n</ng-container>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-cloud-task-list-loading-margin{margin-left:calc(50% - 50px);margin-right:calc(50% - 50px)}"]
            },] }
];
ServiceTaskListCloudComponent.ctorParameters = () => [
    { type: ServiceTaskListCloudService },
    { type: AppConfigService },
    { type: TaskCloudService },
    { type: UserPreferencesService }
];
ServiceTaskListCloudComponent.propDecorators = {
    queryParams: [{ type: Input }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TaskListCloudModule {
}
TaskListCloudModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    CoreModule
                ],
                declarations: [
                    TaskListCloudComponent,
                    ServiceTaskListCloudComponent
                ],
                exports: [
                    TaskListCloudComponent,
                    ServiceTaskListCloudComponent
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var DateCloudFilterType;
(function (DateCloudFilterType) {
    DateCloudFilterType["NO_DATE"] = "NO_DATE";
    DateCloudFilterType["TODAY"] = "TODAY";
    DateCloudFilterType["TOMORROW"] = "TOMORROW";
    DateCloudFilterType["NEXT_7_DAYS"] = "NEXT_7_DAYS";
    DateCloudFilterType["WEEK"] = "WEEK";
    DateCloudFilterType["MONTH"] = "MONTH";
    DateCloudFilterType["QUARTER"] = "QUARTER";
    DateCloudFilterType["YEAR"] = "YEAR";
    DateCloudFilterType["RANGE"] = "RANGE";
})(DateCloudFilterType || (DateCloudFilterType = {}));

class DateRangeFilterService {
    constructor() {
        this.currentDate = new Date();
    }
    getDateRange(type) {
        switch (type) {
            case DateCloudFilterType.TODAY: return this.getTodayDateRange();
            case DateCloudFilterType.TOMORROW: return this.getTomorrowDateRange();
            case DateCloudFilterType.NEXT_7_DAYS: return this.getNext7DaysDateRange();
            case DateCloudFilterType.WEEK: return this.getCurrentWeekRange();
            case DateCloudFilterType.MONTH: return this.getCurrentMonthDateRange();
            case DateCloudFilterType.QUARTER: return this.getQuarterDateRange();
            case DateCloudFilterType.YEAR: return this.getCurrentYearDateRange();
            default: return this.resetDateRange();
        }
    }
    isDateRangeType(type) {
        return type === DateCloudFilterType.RANGE;
    }
    resetDateRange() {
        return {
            startDate: null,
            endDate: null
        };
    }
    getNext7DaysDateRange() {
        return {
            startDate: moment().startOf('day').toISOString(true),
            endDate: moment().add(7, 'days').endOf('day').toISOString(true)
        };
    }
    getTomorrowDateRange() {
        return {
            startDate: moment().endOf('day').toISOString(true),
            endDate: moment().add(1, 'days').endOf('day').toISOString(true)
        };
    }
    getCurrentYearDateRange() {
        return {
            startDate: moment().startOf('year').toISOString(true),
            endDate: moment().endOf('year').toISOString(true)
        };
    }
    getTodayDateRange() {
        return {
            startDate: moment().startOf('day').toISOString(true),
            endDate: moment().endOf('day').toISOString(true)
        };
    }
    getCurrentWeekRange() {
        return {
            startDate: moment().startOf('week').toISOString(true),
            endDate: moment().endOf('week').toISOString(true)
        };
    }
    getCurrentMonthDateRange() {
        return {
            startDate: moment().startOf('month').toISOString(true),
            endDate: moment().endOf('month').toISOString(true)
        };
    }
    getQuarterDateRange() {
        return {
            startDate: moment().startOf('quarter').toISOString(true),
            endDate: moment().endOf('quarter').toISOString(true)
        };
    }
}
DateRangeFilterService.ɵprov = ɵɵdefineInjectable({ factory: function DateRangeFilterService_Factory() { return new DateRangeFilterService(); }, token: DateRangeFilterService, providedIn: "root" });
DateRangeFilterService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TaskFilterCloudModel {
    constructor(obj) {
        this.dateRangeFilterService = new DateRangeFilterService();
        if (obj) {
            this.id = obj.id || Math.random().toString(36).substr(2, 9);
            this.name = obj.name || null;
            this.key = obj.key || null;
            this.icon = obj.icon || null;
            this.index = obj.index || null;
            this.appName = obj.appName || obj.appName === '' ? obj.appName : null;
            this.status = obj.status || null;
            this.sort = obj.sort || null;
            this.assignee = obj.assignee || null;
            this.order = obj.order || null;
            this.owner = obj.owner || null;
            this.processDefinitionName = obj.processDefinitionName || null;
            this.processDefinitionId = obj.processDefinitionId || null;
            this.processInstanceId = obj.processInstanceId || null;
            this.createdDate = obj.createdDate || null;
            this.dueDateType = obj.dueDateType || null;
            this.dueDate = obj.dueDate || null;
            this._dueDateFrom = obj._dueDateFrom || null;
            this._dueDateTo = obj._dueDateTo || null;
            this.taskName = obj.taskName || null;
            this.taskId = obj.taskId || null;
            this.parentTaskId = obj.parentTaskId || null;
            this.priority = obj.priority || null;
            this.standalone = obj.standalone || null;
            this.lastModifiedFrom = obj.lastModifiedFrom || null;
            this.lastModifiedTo = obj.lastModifiedTo || null;
            this.completedBy = obj.completedBy || null;
            this.completedDateType = obj.completedDateType || null;
            this.completedFrom = obj._completedFrom || null;
            this.completedTo = obj._completedTo || null;
            this.completedDate = obj.completedDate || null;
            this.createdDateType = obj.createdDateType || null;
            this.createdFrom = obj._createdFrom || null;
            this.createdTo = obj._createdTo || null;
            this.candidateGroups = obj.candidateGroups || null;
            this.showCounter = obj.showCounter || false;
        }
    }
    set dueDateFrom(dueDateFrom) {
        this._dueDateFrom = dueDateFrom;
    }
    set dueDateTo(dueDateTo) {
        this._dueDateTo = dueDateTo;
    }
    get dueDateFrom() {
        if (this.isDateRangeType(this.dueDateType)) {
            return this._dueDateFrom;
        }
        return this.getStartDate(this.dueDateType);
    }
    get dueDateTo() {
        if (this.isDateRangeType(this.dueDateType)) {
            return this._dueDateTo;
        }
        return this.getEndDate(this.dueDateType);
    }
    set completedFrom(completedFrom) {
        this._completedFrom = completedFrom;
    }
    set completedTo(completedTo) {
        this._completedTo = completedTo;
    }
    get completedFrom() {
        if (this.isDateRangeType(this.completedDateType)) {
            return this._completedFrom;
        }
        return this.getStartDate(this.completedDateType);
    }
    get completedTo() {
        if (this.isDateRangeType(this.completedDateType)) {
            return this._completedTo;
        }
        return this.getEndDate(this.completedDateType);
    }
    set createdFrom(createdFrom) {
        this._createdFrom = createdFrom;
    }
    set createdTo(createdTo) {
        this._createdTo = createdTo;
    }
    get createdFrom() {
        if (this.isDateRangeType(this.createdDateType)) {
            return this._createdFrom;
        }
        return this.getStartDate(this.createdDateType);
    }
    get createdTo() {
        if (this.isDateRangeType(this.createdDateType)) {
            return this._createdTo;
        }
        return this.getEndDate(this.createdDateType);
    }
    getStartDate(key) {
        return this.dateRangeFilterService.getDateRange(key).startDate;
    }
    getEndDate(key) {
        return this.dateRangeFilterService.getDateRange(key).endDate;
    }
    isDateRangeType(type) {
        return !!this.dateRangeFilterService.isDateRangeType(type);
    }
}
var AssignmentType;
(function (AssignmentType) {
    AssignmentType["CURRENT_USER"] = "CURRENT_USER";
    AssignmentType["UNASSIGNED"] = "UNASSIGNED";
    AssignmentType["CANDIDATE_GROUPS"] = "CANDIDATE_GROUPS";
})(AssignmentType || (AssignmentType = {}));

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const PROCESS_FILTERS_SERVICE_TOKEN = new InjectionToken('proccess-filters-cloud');
const TASK_FILTERS_SERVICE_TOKEN = new InjectionToken('task-filters-cloud');

class NotificationCloudService extends BaseCloudService {
    constructor(apiService, appConfigService, apollo, http) {
        super(apiService, appConfigService);
        this.apollo = apollo;
        this.http = http;
        this.appsListening = [];
    }
    get webSocketHost() {
        return this.contextRoot.split('://')[1];
    }
    get protocol() {
        return this.contextRoot.split('://')[0] === 'https' ? 'wss' : 'ws';
    }
    initNotificationsForApp(appName) {
        if (!this.appsListening.includes(appName)) {
            this.appsListening.push(appName);
            const httpLink = this.http.create({
                uri: `${this.getBasePath(appName)}/notifications/graphql`
            });
            const webSocketLink = new WebSocketLink({
                uri: `${this.protocol}://${this.webSocketHost}/${appName}/notifications/ws/graphql`,
                options: {
                    reconnect: true,
                    lazy: true,
                    connectionParams: {
                        kaInterval: 2000,
                        'X-Authorization': 'Bearer ' + this.apiService.getInstance().oauth2Auth.token
                    }
                }
            });
            const link = split(({ query }) => {
                const definition = getMainDefinition(query);
                return definition.kind === 'OperationDefinition' && definition.operation === 'subscription';
            }, webSocketLink, httpLink);
            const errorLink = onError(({ graphQLErrors, operation, forward }) => {
                if (graphQLErrors) {
                    for (const err of graphQLErrors) {
                        switch (err.extensions.code) {
                            case 'UNAUTHENTICATED':
                                const oldHeaders = operation.getContext().headers;
                                operation.setContext({
                                    headers: Object.assign(Object.assign({}, oldHeaders), { 'X-Authorization': 'Bearer ' + this.apiService.getInstance().oauth2Auth.token })
                                });
                                forward(operation);
                                break;
                            default:
                        }
                    }
                }
            });
            this.apollo.createNamed(appName, {
                link: ApolloLink.from([errorLink, link]),
                cache: new InMemoryCache({ merge: true }),
                defaultOptions: {
                    watchQuery: {
                        errorPolicy: 'all'
                    }
                }
            });
        }
    }
    makeGQLQuery(appName, gqlQuery) {
        this.initNotificationsForApp(appName);
        return this.apollo.use(appName).subscribe({ query: gql(gqlQuery) });
    }
}
NotificationCloudService.ɵprov = ɵɵdefineInjectable({ factory: function NotificationCloudService_Factory() { return new NotificationCloudService(ɵɵinject(AlfrescoApiService), ɵɵinject(AppConfigService), ɵɵinject(Apollo), ɵɵinject(HttpLink)); }, token: NotificationCloudService, providedIn: "root" });
NotificationCloudService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
NotificationCloudService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: AppConfigService },
    { type: Apollo },
    { type: HttpLink }
];

const TASK_EVENT_SUBSCRIPTION_QUERY = `
    subscription {
        engineEvents(eventType: [
            TASK_COMPLETED
            TASK_ASSIGNED
            TASK_ACTIVATED
            TASK_SUSPENDED
            TASK_CANCELLED,
            TASK_CREATED
        ]) {
            eventType
            entity
        }
    }
`;
class TaskFilterCloudService extends BaseCloudService {
    constructor(identityUserService, preferenceService, apiService, appConfigService, notificationCloudService) {
        super(apiService, appConfigService);
        this.identityUserService = identityUserService;
        this.preferenceService = preferenceService;
        this.notificationCloudService = notificationCloudService;
        this.filtersSubject = new BehaviorSubject([]);
        this.filters$ = this.filtersSubject.asObservable();
    }
    createDefaultFilters(appName) {
        const key = this.prepareKey(appName);
        this.preferenceService.getPreferences(appName, key).pipe(switchMap((response) => {
            const preferences = (response && response.list && response.list.entries) ? response.list.entries : [];
            if (!this.hasPreferences(preferences) || !this.hasTaskFilters(preferences, key)) {
                return this.createTaskFilters(appName, key, this.defaultTaskFilters(appName));
            }
            else {
                return of(this.findFiltersByKeyInPreferences(preferences, key));
            }
        })).subscribe((filters) => {
            this.addFiltersToStream(filters);
        });
    }
    hasPreferences(preferences) {
        return preferences && preferences.length > 0;
    }
    hasTaskFilters(preferences, key) {
        const filters = preferences.find((filter) => { return filter.entry.key === key; });
        return (filters && filters.entry) ? JSON.parse(filters.entry.value).length > 0 : false;
    }
    createTaskFilters(appName, key, filters) {
        return this.preferenceService.createPreference(appName, key, filters);
    }
    getTaskFiltersByKey(appName, key) {
        return this.preferenceService.getPreferenceByKey(appName, key);
    }
    getTaskListFilters(appName) {
        this.createDefaultFilters(appName);
        return this.filters$;
    }
    getTaskFilterById(appName, id) {
        const key = this.prepareKey(appName);
        return this.getTaskFiltersByKey(appName, key).pipe(switchMap((filters) => {
            if (filters && filters.length === 0) {
                return this.createTaskFilters(appName, key, this.defaultTaskFilters(appName));
            }
            else {
                return of(filters);
            }
        }), map((filters) => {
            return filters.filter((filter) => {
                return filter.id === id;
            })[0];
        }));
    }
    addFilter(newFilter) {
        const key = this.prepareKey(newFilter.appName);
        return this.getTaskFiltersByKey(newFilter.appName, key).pipe(switchMap((filters) => {
            if (filters && filters.length === 0) {
                return this.createTaskFilters(newFilter.appName, key, [newFilter]);
            }
            else {
                filters.push(newFilter);
                return this.preferenceService.updatePreference(newFilter.appName, key, filters);
            }
        }), map((filters) => {
            this.addFiltersToStream(filters);
            return filters;
        }));
    }
    addFiltersToStream(filters) {
        this.filtersSubject.next(filters);
    }
    updateFilter(updatedFilter) {
        const key = this.prepareKey(updatedFilter.appName);
        return this.getTaskFiltersByKey(updatedFilter.appName, key).pipe(switchMap((filters) => {
            if (filters && filters.length === 0) {
                return this.createTaskFilters(updatedFilter.appName, key, [updatedFilter]);
            }
            else {
                const itemIndex = filters.findIndex((filter) => filter.id === updatedFilter.id);
                filters[itemIndex] = updatedFilter;
                return this.updateTaskFilters(updatedFilter.appName, key, filters);
            }
        }), map((updatedFilters) => {
            this.addFiltersToStream(updatedFilters);
            return updatedFilters;
        }));
    }
    deleteFilter(deletedFilter) {
        const key = this.prepareKey(deletedFilter.appName);
        return this.getTaskFiltersByKey(deletedFilter.appName, key).pipe(switchMap((filters) => {
            if (filters && filters.length > 0) {
                filters = filters.filter(filter => filter.id !== deletedFilter.id);
                return this.updateTaskFilters(deletedFilter.appName, key, filters);
            }
            return of([]);
        }), map(filters => {
            this.addFiltersToStream(filters);
            return filters;
        }));
    }
    isDefaultFilter(filterName) {
        const defaultFilters = this.defaultTaskFilters();
        return defaultFilters.findIndex((filter) => filterName === filter.name) !== -1;
    }
    getTaskFilterCounter(taskFilter) {
        if (taskFilter.appName || taskFilter.appName === '') {
            const queryUrl = `${this.getBasePath(taskFilter.appName)}/query/v1/tasks`;
            const queryParams = {
                assignee: taskFilter.assignee,
                status: taskFilter.status,
                appName: taskFilter.appName,
                maxItems: 1
            };
            return this.get(queryUrl, queryParams).pipe(map((tasks) => tasks.list.pagination.totalItems));
        }
        else {
            return throwError('Appname not configured');
        }
    }
    updateTaskFilters(appName, key, filters) {
        return this.preferenceService.updatePreference(appName, key, filters);
    }
    prepareKey(appName) {
        return `task-filters-${appName}-${this.identityUserService.getCurrentUserInfo().username}`;
    }
    findFiltersByKeyInPreferences(preferences, key) {
        const result = preferences.find((filter) => { return filter.entry.key === key; });
        return result && result.entry ? JSON.parse(result.entry.value) : [];
    }
    defaultTaskFilters(appName) {
        return [
            new TaskFilterCloudModel({
                name: 'ADF_CLOUD_TASK_FILTERS.MY_TASKS',
                key: 'my-tasks',
                icon: 'inbox',
                appName,
                status: 'ASSIGNED',
                assignee: this.identityUserService.getCurrentUserInfo().username,
                sort: 'createdDate',
                order: 'DESC',
                showCounter: true
            }),
            new TaskFilterCloudModel({
                name: 'ADF_CLOUD_TASK_FILTERS.QUEUED_TASKS',
                key: 'queued-tasks',
                icon: 'queue',
                appName,
                status: 'CREATED',
                assignee: '',
                sort: 'createdDate',
                order: 'DESC',
                showCounter: true
            }),
            new TaskFilterCloudModel({
                name: 'ADF_CLOUD_TASK_FILTERS.COMPLETED_TASKS',
                key: 'completed-tasks',
                icon: 'done',
                appName,
                status: 'COMPLETED',
                assignee: '',
                sort: 'createdDate',
                order: 'DESC'
            })
        ];
    }
    getTaskNotificationSubscription(appName) {
        return this.notificationCloudService.makeGQLQuery(appName, TASK_EVENT_SUBSCRIPTION_QUERY)
            .pipe(map((events) => events.data.engineEvents));
    }
}
TaskFilterCloudService.ɵprov = ɵɵdefineInjectable({ factory: function TaskFilterCloudService_Factory() { return new TaskFilterCloudService(ɵɵinject(IdentityUserService), ɵɵinject(TASK_FILTERS_SERVICE_TOKEN), ɵɵinject(AlfrescoApiService), ɵɵinject(AppConfigService), ɵɵinject(NotificationCloudService)); }, token: TaskFilterCloudService, providedIn: "root" });
TaskFilterCloudService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
TaskFilterCloudService.ctorParameters = () => [
    { type: IdentityUserService },
    { type: undefined, decorators: [{ type: Inject, args: [TASK_FILTERS_SERVICE_TOKEN,] }] },
    { type: AlfrescoApiService },
    { type: AppConfigService },
    { type: NotificationCloudService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class BaseTaskFiltersCloudComponent {
    constructor() {
        this.appName = '';
        this.showIcons = false;
        this.success = new EventEmitter();
        this.error = new EventEmitter();
        this.counters$ = {};
        this.updatedCounters = [];
        this.onDestroy$ = new Subject();
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
    wasFilterUpdated(filterKey) {
        return this.updatedCounters.includes(filterKey);
    }
    addToUpdatedCounters(filterKey) {
        if (!this.updatedCounters.includes(filterKey)) {
            this.updatedCounters.push(filterKey);
        }
    }
    resetFilterCounter(filterKey) {
        const filterIndex = this.updatedCounters.indexOf(filterKey);
        if (filterIndex > -1) {
            this.updatedCounters.splice(filterIndex, 1);
        }
    }
}
BaseTaskFiltersCloudComponent.decorators = [
    { type: Directive }
];
BaseTaskFiltersCloudComponent.propDecorators = {
    appName: [{ type: Input }],
    filterParam: [{ type: Input }],
    showIcons: [{ type: Input }],
    success: [{ type: Output }],
    error: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TaskFiltersCloudComponent extends BaseTaskFiltersCloudComponent {
    constructor(taskFilterCloudService, translationService, appConfigService) {
        super();
        this.taskFilterCloudService = taskFilterCloudService;
        this.translationService = translationService;
        this.appConfigService = appConfigService;
        this.filterSelected = new EventEmitter();
        this.filterClicked = new EventEmitter();
        this.filterCounterUpdated = new EventEmitter();
        this.filters = [];
    }
    ngOnInit() {
        this.enableNotifications = this.appConfigService.get('notifications', true);
        this.initFilterCounterNotifications();
        this.getFilters(this.appName);
    }
    ngOnChanges(changes) {
        const appName = changes['appName'];
        const filter = changes['filterParam'];
        if (appName && appName.currentValue !== appName.previousValue) {
            this.getFilters(appName.currentValue);
        }
        else if (filter && filter.currentValue !== filter.previousValue) {
            this.selectFilterAndEmit(filter.currentValue);
        }
    }
    getFilters(appName) {
        this.filters$ = this.taskFilterCloudService.getTaskListFilters(appName);
        this.filters$.pipe(takeUntil(this.onDestroy$)).subscribe((res) => {
            this.resetFilter();
            this.filters = res || [];
            this.selectFilterAndEmit(this.filterParam);
            this.updateFilterCounters();
            this.success.emit(res);
        }, (err) => {
            this.error.emit(err);
        });
    }
    updateFilterCounters() {
        this.filters.forEach((filter) => this.updateFilterCounter(filter));
    }
    updateFilterCounter(filter) {
        if (filter === null || filter === void 0 ? void 0 : filter.showCounter) {
            this.counters$[filter.key] = this.taskFilterCloudService.getTaskFilterCounter(filter);
        }
    }
    initFilterCounterNotifications() {
        if (this.appName && this.enableNotifications) {
            this.taskFilterCloudService.getTaskNotificationSubscription(this.appName)
                .pipe(debounceTime(3000))
                .subscribe((result) => {
                result.map((taskEvent) => {
                    this.checkFilterCounter(taskEvent.entity);
                });
                if (this.updatedCounters.length) {
                    this.updateFilterCounters();
                    this.filterCounterUpdated.emit(result);
                }
            });
        }
    }
    checkFilterCounter(filterNotification) {
        this.filters.map((filter) => {
            if (this.isFilterPresent(filter, filterNotification)) {
                this.addToUpdatedCounters(filter.key);
            }
        });
    }
    isFilterPresent(filter, filterNotification) {
        return filter.status === filterNotification.status
            && (filter.assignee === filterNotification.assignee || filterNotification.assignee === undefined);
    }
    selectFilter(paramFilter) {
        if (paramFilter) {
            this.currentFilter = this.filters.find((filter, index) => paramFilter.index === index ||
                paramFilter.key === filter.key ||
                paramFilter.id === filter.id ||
                (paramFilter.name &&
                    (paramFilter.name.toLocaleLowerCase() === this.translationService.instant(filter.name).toLocaleLowerCase())));
        }
    }
    selectFilterAndEmit(newParamFilter) {
        if (newParamFilter) {
            this.selectFilter(newParamFilter);
            if (this.currentFilter) {
                this.resetFilterCounter(this.currentFilter.key);
                this.filterSelected.emit(this.currentFilter);
            }
        }
        else {
            this.currentFilter = undefined;
        }
    }
    onFilterClick(filter) {
        if (filter) {
            this.selectFilter(filter);
            this.updateFilterCounter(this.currentFilter);
            this.filterClicked.emit(this.currentFilter);
        }
        else {
            this.currentFilter = undefined;
        }
    }
    selectDefaultTaskFilter() {
        if (!this.isFilterListEmpty()) {
            this.currentFilter = this.filters[0];
        }
    }
    isFilterListEmpty() {
        return this.filters === undefined || (this.filters && this.filters.length === 0);
    }
    resetFilter() {
        this.filters = [];
        this.currentFilter = undefined;
    }
}
TaskFiltersCloudComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-cloud-task-filters',
                template: "<ng-container *ngIf=\"filters$ | async as filterList; else loading\">\n    <div *ngFor=\"let filter of filterList\"\n         class=\"adf-task-filters__entry\">\n        <button (click)=\"onFilterClick(filter)\"\n                [attr.aria-label]=\"filter.name | translate\"\n                [id]=\"filter.id\"\n                [attr.data-automation-id]=\"filter.key + '_filter'\"\n                mat-button\n                [class.adf-active]=\"currentFilter === filter\"\n                class=\"adf-filter-action-button adf-full-width\"\n                fxLayout=\"row\"\n                fxLayoutAlign=\"space-between center\">\n            <adf-icon data-automation-id=\"adf-filter-icon\"\n                      *ngIf=\"showIcons\"\n                      [value]=\"filter.icon\"></adf-icon>\n            <span data-automation-id=\"adf-filter-label\"\n                  class=\"adf-filter-action-button__label\">{{ filter.name | translate }}</span>\n        </button>\n        <span *ngIf=\"counters$[filter.key]\"\n              [attr.data-automation-id]=\"filter.key + '_filter-counter'\"\n              class=\"adf-filter-action-button__counter\"\n              [class.adf-active]=wasFilterUpdated(filter.key)>\n            {{ counters$[filter.key] | async }}\n        </span>\n    </div>\n</ng-container>\n<ng-template #loading>\n    <ng-container>\n        <div class=\"adf-app-list-spinner\">\n            <mat-spinner></mat-spinner>\n        </div>\n    </ng-container>\n</ng-template>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-task-filters__entry{display:flex;font-size:14px!important;font-weight:700;height:24px;opacity:1;padding:12px 0!important;width:100%}.adf-task-filters__entry .adf-full-width{display:flex;width:100%}.adf-task-filters__entry .adf-filter-action-button{cursor:pointer;opacity:.54;padding:16px}.adf-task-filters__entry .adf-filter-action-button .adf-filter-action-button__label{margin:0 8px!important;padding-left:20px}.adf-task-filters__entry .adf-filter-action-button__counter{margin-left:10px;margin-top:6px;opacity:.54;padding:0 5px}.adf-task-filters__entry .adf-filter-action-button__counter.adf-active{background-color:var(--theme-accent-color);border-radius:15px;color:var(--theme-colors-mag-grey-light);font-size:smaller;margin-left:8px;margin-top:5px;padding:0 5px}.adf-task-filters__entry:hover{color:var(--theme-primary-color)}.adf-task-filters__entry:hover .adf-filter-action-button,.adf-task-filters__entry:hover .adf-filter-action-button__counter{opacity:1}.adf-task-filters__entry .adf-active{color:var(--theme-primary-color);opacity:1}"]
            },] }
];
TaskFiltersCloudComponent.ctorParameters = () => [
    { type: TaskFilterCloudService },
    { type: TranslationService },
    { type: AppConfigService }
];
TaskFiltersCloudComponent.propDecorators = {
    filterSelected: [{ type: Output }],
    filterClicked: [{ type: Output }],
    filterCounterUpdated: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DateRangeFilterComponent {
    constructor() {
        this.dateChanged = new EventEmitter();
        this.dateTypeChange = new EventEmitter();
        this.filteredProperties = [];
        this.dateRangeForm = new FormGroup({
            from: new FormControl(),
            to: new FormControl()
        });
    }
    ngOnInit() {
        this.options = this.options ? this.options : this.createDefaultRangeOptions();
        const defaultProperties = this.createDefaultDateOptions();
        this.filteredProperties = defaultProperties.filter((filterProperty) => this.isValidProperty(this.options, filterProperty.value.toString()));
        if (this.hasPreselectedValues()) {
            this.setPreselectedValues();
        }
    }
    onSelectionChange(option) {
        this.type = option.value;
        if (!this.isDateRangeType()) {
            this.dateTypeChange.emit(this.type);
        }
    }
    isDateRangeType() {
        return this.type === DateCloudFilterType.RANGE;
    }
    onDateRangeClosed() {
        const dateRange = {
            startDate: moment(this.dateRangeForm.controls.from.value).startOf('day').toISOString(true),
            endDate: moment(this.dateRangeForm.controls.to.value).endOf('day').toISOString(true)
        };
        this.dateChanged.emit(dateRange);
    }
    hasPreselectedValues() {
        var _a, _b;
        return !!((_a = this.processFilterProperty) === null || _a === void 0 ? void 0 : _a.attributes) && !!((_b = this.processFilterProperty) === null || _b === void 0 ? void 0 : _b.value);
    }
    setPreselectedValues() {
        const from = this.getFilterAttribute('from');
        const to = this.getFilterAttribute('to');
        const type = this.getFilterAttribute('dateType');
        this.dateRangeForm.get('from').setValue(moment(this.getFilterValue(from)));
        this.dateRangeForm.get('to').setValue(moment(this.getFilterValue(to)));
        this.type = this.getFilterValue(type);
    }
    getFilterAttribute(key) {
        return this.processFilterProperty.attributes[key];
    }
    getFilterValue(attribute) {
        return this.processFilterProperty.value[attribute];
    }
    isValidProperty(filterProperties, key) {
        return filterProperties ? filterProperties.indexOf(key) >= 0 : true;
    }
    createDefaultRangeOptions() {
        return [
            DateCloudFilterType.NO_DATE,
            DateCloudFilterType.TODAY,
            DateCloudFilterType.WEEK,
            DateCloudFilterType.MONTH,
            DateCloudFilterType.QUARTER,
            DateCloudFilterType.YEAR,
            DateCloudFilterType.RANGE
        ];
    }
    createDefaultDateOptions() {
        return [
            {
                value: DateCloudFilterType.NO_DATE,
                label: 'ADF_CLOUD_EDIT_PROCESS_FILTER.LABEL.DATE_RANGE.NO_DATE'
            },
            {
                value: DateCloudFilterType.TODAY,
                label: 'ADF_CLOUD_EDIT_PROCESS_FILTER.LABEL.DATE_RANGE.TODAY'
            },
            {
                value: DateCloudFilterType.TOMORROW,
                label: 'ADF_CLOUD_EDIT_PROCESS_FILTER.LABEL.DATE_RANGE.TOMORROW'
            },
            {
                value: DateCloudFilterType.NEXT_7_DAYS,
                label: 'ADF_CLOUD_EDIT_PROCESS_FILTER.LABEL.DATE_RANGE.NEXT_7_DAYS'
            },
            {
                value: DateCloudFilterType.WEEK,
                label: 'ADF_CLOUD_EDIT_PROCESS_FILTER.LABEL.DATE_RANGE.WEEK'
            },
            {
                value: DateCloudFilterType.MONTH,
                label: 'ADF_CLOUD_EDIT_PROCESS_FILTER.LABEL.DATE_RANGE.MONTH'
            },
            {
                value: DateCloudFilterType.QUARTER,
                label: 'ADF_CLOUD_EDIT_PROCESS_FILTER.LABEL.DATE_RANGE.QUARTER'
            },
            {
                value: DateCloudFilterType.YEAR,
                label: 'ADF_CLOUD_EDIT_PROCESS_FILTER.LABEL.DATE_RANGE.YEAR'
            },
            {
                value: DateCloudFilterType.RANGE,
                label: 'ADF_CLOUD_EDIT_PROCESS_FILTER.LABEL.DATE_RANGE.RANGE'
            }
        ];
    }
}
DateRangeFilterComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-cloud-date-range-filter',
                template: "\n<mat-form-field [floatLabel]=\"'auto'\" [attr.data-automation-id]=\"processFilterProperty.key\">\n    <mat-select\n        placeholder=\"{{ processFilterProperty.label | translate }}\"\n        [value]=\"type\"\n        (selectionChange)=\"onSelectionChange($event)\"\n        [attr.data-automation-id]=\"'adf-cloud-edit-process-property-' + processFilterProperty.key\">\n        <mat-option *ngFor=\"let propertyOption of filteredProperties\" [value]=\"propertyOption.value\" [attr.data-automation-id]=\"'adf-cloud-edit-process-property-options-' + propertyOption.value.toString()\">\n            {{ propertyOption.label | translate }}\n        </mat-option>\n    </mat-select>\n</mat-form-field>\n\n<ng-container *ngIf=\"isDateRangeType()\">\n    <mat-form-field [floatLabel]=\"'auto'\" class=\"adf-cloud-date-range-picker\">\n        <mat-label>{{ 'ADF_CLOUD_EDIT_PROCESS_FILTER.LABEL.DATE_RANGE_TITLE' | translate }}</mat-label>\n        <mat-date-range-input [formGroup]=\"dateRangeForm\" [rangePicker]=\"picker\">\n          <input matStartDate formControlName=\"from\" placeholder=\"{{ 'ADF_CLOUD_EDIT_PROCESS_FILTER.LABEL.START_DATE' | translate }}\">\n          <input matEndDate formControlName=\"to\" placeholder=\"{{ 'ADF_CLOUD_EDIT_PROCESS_FILTER.LABEL.END_DATE' | translate }}\">\n        </mat-date-range-input>\n        <mat-datepicker-toggle\n            matSuffix\n            [for]=\"picker\"\n            [attr.data-automation-id]=\"'adf-cloud-edit-process-property-date-range-' + processFilterProperty.key\"></mat-datepicker-toggle>\n        <mat-date-range-picker #picker (closed)=\"onDateRangeClosed()\"></mat-date-range-picker>\n    </mat-form-field>\n</ng-container>\n",
                styles: [".adf-cloud-date-range-picker{margin:0 10px}"]
            },] }
];
DateRangeFilterComponent.propDecorators = {
    processFilterProperty: [{ type: Input }],
    options: [{ type: Input }],
    dateChanged: [{ type: Output }],
    dateTypeChange: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessCommonModule {
}
ProcessCommonModule.decorators = [
    { type: NgModule, args: [{
                declarations: [DateRangeFilterComponent],
                imports: [
                    CommonModule,
                    CoreModule,
                    MaterialModule
                ],
                exports: [
                    DateRangeFilterComponent
                ],
                providers: [
                    DateRangeFilterService
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PeopleCloudComponent {
    constructor(identityUserService, logService) {
        this.identityUserService = identityUserService;
        this.logService = logService;
        this.mode = 'single';
        this.validate = false;
        this.readOnly = false;
        this.preSelectUsers = [];
        this.excludedUsers = [];
        this.userChipsCtrl = new FormControl({ value: '', disabled: false });
        this.searchUserCtrl = new FormControl({ value: '', disabled: false });
        this.selectUser = new EventEmitter();
        this.removeUser = new EventEmitter();
        this.changedUsers = new EventEmitter();
        this.warning = new EventEmitter();
        this._searchUsers = [];
        this.onDestroy$ = new Subject();
        this.selectedUsers = [];
        this.invalidUsers = [];
        this.searchUsers$ = new BehaviorSubject(this._searchUsers);
        this._subscriptAnimationState = 'enter';
        this.searchedValue = '';
        this.validationLoading = false;
        this.searchLoading = false;
    }
    ngOnInit() {
        this.loadClientId();
        this.initSearch();
    }
    ngOnChanges(changes) {
        if (this.valueChanged(changes.preSelectUsers)
            || this.valueChanged(changes.mode)
            || this.valueChanged(changes.validate)) {
            if (this.hasPreSelectUsers()) {
                this.loadPreSelectUsers();
            }
            else if (this.hasPreselectedUsersCleared(changes)) {
                this.selectedUsers = [];
                this.invalidUsers = [];
            }
            if (!this.isValidationEnabled()) {
                this.invalidUsers = [];
            }
        }
        if (changes.appName && this.isAppNameChanged(changes.appName)) {
            this.loadClientId();
        }
    }
    loadClientId() {
        return __awaiter(this, void 0, void 0, function* () {
            this.clientId = yield this.identityUserService.getClientIdByApplicationName(this.appName).toPromise();
            if (this.clientId) {
                this.searchUserCtrl.enable();
            }
        });
    }
    initSearch() {
        this.searchUserCtrl.valueChanges.pipe(filter((value) => {
            this.searchLoading = true;
            return typeof value === 'string';
        }), tap((value) => {
            if (value) {
                this.setTypingError();
            }
        }), debounceTime(500), distinctUntilChanged(), tap((value) => {
            if (value.trim()) {
                this.searchedValue = value;
            }
            else {
                this.searchUserCtrl.markAsPristine();
                this.searchUserCtrl.markAsUntouched();
            }
        }), tap(() => {
            this.resetSearchUsers();
        }), switchMap((search) => this.identityUserService.findUsersByName(search.trim())), mergeMap((users) => {
            this.resetSearchUsers();
            this.searchLoading = false;
            return users;
        }), filter(user => !this.isUserAlreadySelected(user) && !this.isExcludedUser(user)), mergeMap(user => {
            if (this.appName) {
                return this.checkUserHasAccess(user.id).pipe(mergeMap(hasRole => hasRole ? of(user) : of()));
            }
            else if (this.hasRoles()) {
                return this.filterUsersByRoles(user);
            }
            else {
                return of(user);
            }
        }), takeUntil(this.onDestroy$)).subscribe(user => {
            this._searchUsers.push(user);
            this.searchUsers$.next(this._searchUsers);
        });
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
    isAppNameChanged(change) {
        return change && change.previousValue !== change.currentValue && this.appName && this.appName.length > 0;
    }
    isValidationEnabled() {
        return this.validate === true;
    }
    checkUserHasAccess(userId) {
        if (this.hasRoles()) {
            return this.identityUserService.checkUserHasAnyClientAppRole(userId, this.clientId, this.roles);
        }
        else {
            return this.identityUserService.checkUserHasClientApp(userId, this.clientId);
        }
    }
    hasRoles() {
        return this.roles && this.roles.length > 0;
    }
    filterUsersByRoles(user) {
        return this.identityUserService.checkUserHasRole(user.id, this.roles).pipe(map((hasRole) => ({ hasRole: hasRole, user: user })), filter((filteredUser) => filteredUser.hasRole), map((filteredUser) => filteredUser.user));
    }
    isUserAlreadySelected(searchUser) {
        if (this.selectedUsers && this.selectedUsers.length > 0) {
            const result = this.selectedUsers.find((selectedUser) => {
                return this.compare(selectedUser, searchUser);
            });
            return !!result;
        }
        return false;
    }
    isExcludedUser(searchUser) {
        var _a;
        if (((_a = this.excludedUsers) === null || _a === void 0 ? void 0 : _a.length) > 0) {
            return !!this.excludedUsers.find(excludedUser => this.compare(excludedUser, searchUser));
        }
        return false;
    }
    loadPreSelectUsers() {
        return __awaiter(this, void 0, void 0, function* () {
            this.selectedUsers = [];
            if (this.isSingleMode()) {
                this.selectedUsers = [this.preSelectUsers[0]];
            }
            else {
                this.selectedUsers = this.removeDuplicatedUsers(this.preSelectUsers);
            }
            this.userChipsCtrl.setValue(this.selectedUsers[0].username);
            if (this.isValidationEnabled()) {
                this.validationLoading = true;
                yield this.validatePreselectUsers();
                this.validationLoading = false;
            }
        });
    }
    getPreselectedUsers() {
        if (this.isSingleMode()) {
            return [this.preSelectUsers[0]];
        }
        else {
            return this.removeDuplicatedUsers(this.preSelectUsers);
        }
    }
    validatePreselectUsers() {
        return __awaiter(this, void 0, void 0, function* () {
            this.invalidUsers = [];
            const validUsers = [];
            for (const user of this.getPreselectedUsers()) {
                try {
                    const validationResult = yield this.searchUser(user);
                    if (this.compare(user, validationResult)) {
                        validationResult.readonly = user.readonly;
                        validUsers.push(validationResult);
                    }
                    else {
                        this.invalidUsers.push(user);
                    }
                }
                catch (error) {
                    this.invalidUsers.push(user);
                    this.logService.error(error);
                }
            }
            this.checkPreselectValidationErrors();
            this.selectedUsers = validUsers.concat(this.invalidUsers);
        });
    }
    compare(preselectedUser, identityUser) {
        if (preselectedUser && identityUser) {
            const uniquePropertyIdentifiers = ['id', 'username', 'email'];
            for (const property of Object.keys(preselectedUser)) {
                if (preselectedUser[property] !== undefined && uniquePropertyIdentifiers.includes(property)) {
                    return preselectedUser[property] === identityUser[property];
                }
            }
        }
        return false;
    }
    getSearchKey(user) {
        if (user.id) {
            return 'id';
        }
        else if (user.email) {
            return 'email';
        }
        else if (user.username) {
            return 'username';
        }
        else {
            return null;
        }
    }
    searchUser(user) {
        return __awaiter(this, void 0, void 0, function* () {
            const key = this.getSearchKey(user);
            switch (key) {
                case 'id':
                    return this.identityUserService.findUserById(user[key]).toPromise();
                case 'username':
                    return (yield this.identityUserService.findUserByUsername(user[key]).toPromise())[0];
                case 'email':
                    return (yield this.identityUserService.findUserByEmail(user[key]).toPromise())[0];
                default:
                    return null;
            }
        });
    }
    removeDuplicatedUsers(users) {
        return users.filter((user, index, self) => index === self.findIndex(auxUser => user.id === auxUser.id && user.username === auxUser.username && user.email === auxUser.email));
    }
    checkPreselectValidationErrors() {
        this.invalidUsers = this.removeDuplicatedUsers(this.invalidUsers);
        if (this.invalidUsers.length > 0) {
            this.generateInvalidUsersMessage();
        }
        this.warning.emit({
            message: 'INVALID_PRESELECTED_USERS',
            users: this.invalidUsers
        });
    }
    onSelect(user) {
        if (user) {
            this.selectUser.emit(user);
            if (this.isMultipleMode()) {
                if (!this.isUserAlreadySelected(user)) {
                    this.selectedUsers.push(user);
                }
            }
            else {
                this.invalidUsers = [];
                this.selectedUsers = [user];
            }
            this.userInput.nativeElement.value = '';
            this.searchUserCtrl.setValue('');
            this.userChipsCtrlValue(this.selectedUsers[0].username);
            this.changedUsers.emit(this.selectedUsers);
            this.resetSearchUsers();
        }
    }
    onRemove(userToRemove) {
        this.removeUser.emit(userToRemove);
        this.removeUserFromSelected(userToRemove);
        this.changedUsers.emit(this.selectedUsers);
        if (this.selectedUsers.length === 0) {
            this.userChipsCtrlValue('');
        }
        else {
            this.userChipsCtrlValue(this.selectedUsers[0].username);
        }
        this.searchUserCtrl.markAsDirty();
        this.searchUserCtrl.markAsTouched();
        if (this.isValidationEnabled()) {
            this.removeUserFromValidation(userToRemove);
            this.checkPreselectValidationErrors();
        }
    }
    userChipsCtrlValue(value) {
        this.userChipsCtrl.setValue(value);
        this.userChipsCtrl.markAsDirty();
        this.userChipsCtrl.markAsTouched();
    }
    removeUserFromSelected({ id, username, email }) {
        const indexToRemove = this.selectedUsers.findIndex(user => {
            return user.id === id
                && user.username === username
                && user.email === email;
        });
        if (indexToRemove !== -1) {
            this.selectedUsers.splice(indexToRemove, 1);
        }
    }
    removeUserFromValidation({ id, username, email }) {
        const indexToRemove = this.invalidUsers.findIndex(user => {
            return user.id === id
                && user.username === username
                && user.email === email;
        });
        if (indexToRemove !== -1) {
            this.invalidUsers.splice(indexToRemove, 1);
        }
    }
    generateInvalidUsersMessage() {
        this.validateUsersMessage = '';
        this.invalidUsers.forEach((invalidUser, index) => {
            if (index === this.invalidUsers.length - 1) {
                this.validateUsersMessage += `${invalidUser.username} `;
            }
            else {
                this.validateUsersMessage += `${invalidUser.username}, `;
            }
        });
    }
    setTypingError() {
        this.searchUserCtrl.setErrors(Object.assign({ searchTypingError: true }, this.searchUserCtrl.errors));
    }
    hasPreselectError() {
        return this.invalidUsers
            && this.invalidUsers.length > 0;
    }
    getDisplayName(user) {
        return FullNamePipe.prototype.transform(user);
    }
    isMultipleMode() {
        return this.mode === 'multiple';
    }
    isSingleMode() {
        return this.mode === 'single';
    }
    isSingleSelectionReadonly() {
        return this.isSingleMode()
            && this.selectedUsers.length === 1
            && this.selectedUsers[0].readonly === true;
    }
    hasPreSelectUsers() {
        return this.preSelectUsers
            && this.preSelectUsers.length > 0;
    }
    valueChanged(change) {
        return change
            && change.currentValue !== change.previousValue;
    }
    hasPreselectedUsersCleared(changes) {
        return changes
            && changes.preSelectUsers
            && changes.preSelectUsers.currentValue
            && changes.preSelectUsers.currentValue.length === 0;
    }
    resetSearchUsers() {
        this._searchUsers = [];
        this.searchUsers$.next(this._searchUsers);
    }
    getSelectedUsers() {
        return this.selectedUsers;
    }
    isReadonly() {
        return this.readOnly || this.isSingleSelectionReadonly();
    }
    isValidationLoading() {
        return this.isValidationEnabled() && this.validationLoading;
    }
    setFocus(isFocused) {
        this.isFocused = isFocused;
    }
    hasError() {
        return !!this.searchUserCtrl.errors;
    }
    getValidationPattern() {
        return this.searchUserCtrl.errors.pattern.requiredPattern;
    }
    getValidationMaxLength() {
        return this.searchUserCtrl.errors.maxlength.requiredLength;
    }
    getValidationMinLength() {
        return this.searchUserCtrl.errors.minlength.requiredLength;
    }
}
PeopleCloudComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-cloud-people',
                template: "<form>\n    <mat-form-field [floatLabel]=\"'auto'\" class=\"adf-people-cloud\">\n        <mat-label *ngIf=\"!isReadonly()\" id=\"adf-people-cloud-title-id\">{{ title | translate }}</mat-label>\n        <mat-chip-list #userMultipleChipList [disabled]=\"isReadonly() || isValidationLoading()\" data-automation-id=\"adf-cloud-people-chip-list\">\n            <mat-chip\n                *ngFor=\"let user of selectedUsers\"\n                [removable]=\"!(user.readonly)\"\n                [attr.data-automation-id]=\"'adf-people-cloud-chip-' + user.username\"\n                (removed)=\"onRemove(user)\"\n                matTooltip=\"{{ (user.readonly ? 'ADF_CLOUD_GROUPS.MANDATORY' : '') | translate }}\">\n                {{user | fullName}}\n                <mat-icon\n                    matChipRemove\n                    *ngIf=\"!(user.readonly || readOnly)\"\n                    [attr.data-automation-id]=\"'adf-people-cloud-chip-remove-icon-' + user.username\">\n                    cancel\n                </mat-icon>\n            </mat-chip>\n            <input *ngIf=\"!isReadonly()\" matInput\n                   [formControl]=\"searchUserCtrl\"\n                   [matAutocomplete]=\"auto\"\n                   [matChipInputFor]=\"userMultipleChipList\"\n                   (focus)=\"setFocus(true)\"\n                   (blur)=\"setFocus(false)\"\n                   class=\"adf-cloud-input\"\n                   data-automation-id=\"adf-people-cloud-search-input\" #userInput>\n        </mat-chip-list>\n\n        <mat-autocomplete autoActiveFirstOption class=\"adf-people-cloud-list\"\n                          #auto=\"matAutocomplete\"\n                          (optionSelected)=\"onSelect($event.option.value)\"\n                          [displayWith]=\"getDisplayName\">\n            <ng-container *ngIf=\"(searchUsers$ | async)?.length else noResults\" >\n            <mat-option *ngFor=\"let user of searchUsers$ | async; let i = index\" [value]=\"user\">\n                <div class=\"adf-people-cloud-row\" id=\"adf-people-cloud-user-{{user.username}}\"\n                     data-automation-id=\"adf-people-cloud-row\">\n                    <div [outerHTML]=\"user | usernameInitials:'adf-people-cloud-pic'\"></div>\n                    <span class=\"adf-people-label-name\"> {{user | fullName}}</span>\n                </div>\n            </mat-option>\n            </ng-container>\n            <ng-template #noResults>\n                <mat-option *ngIf=\"searchUserCtrl.hasError('searchTypingError') && !searchLoading\" disabled\n                            class=\"adf-people-cloud-option-not-active\"\n                            data-automation-id=\"adf-people-cloud-no-results\">\n                    <span> {{ 'ADF_CLOUD_USERS.ERROR.NOT_FOUND' | translate : { userName: searchedValue } }}</span>\n                </mat-option>\n            </ng-template>\n        </mat-autocomplete>\n    </mat-form-field>\n    <mat-progress-bar\n        *ngIf=\"validationLoading\"\n        mode=\"indeterminate\">\n    </mat-progress-bar>\n\n    <mat-error *ngIf=\"hasPreselectError() && !isValidationLoading()\">\n        <mat-icon class=\"adf-start-task-cloud-error-icon\">warning</mat-icon>\n        {{ 'ADF_CLOUD_USERS.ERROR.NOT_FOUND' | translate : { userName : validateUsersMessage } }}</mat-error>\n    <mat-error *ngIf=\"searchUserCtrl.hasError('pattern')\">\n        <mat-icon class=\"adf-start-task-cloud-error-icon\">warning</mat-icon>\n        {{ 'ADF_CLOUD_PEOPLE_GROUPS.ERROR.INVALID_PATTERN' | translate: { pattern: getValidationPattern() } }}</mat-error>\n    <mat-error *ngIf=\"searchUserCtrl.hasError('maxlength')\">\n        <mat-icon class=\"adf-start-task-cloud-error-icon\">warning</mat-icon>\n        {{ 'ADF_CLOUD_PEOPLE_GROUPS.ERROR.INVALID_MAX_LENGTH' | translate: { requiredLength: getValidationMaxLength() } }}\n    </mat-error>\n    <mat-error *ngIf=\"searchUserCtrl.hasError('minlength')\">\n        <mat-icon class=\"adf-start-task-cloud-error-icon\">warning</mat-icon>\n        {{ 'ADF_CLOUD_PEOPLE_GROUPS.ERROR.INVALID_MIN_LENGTH' | translate: { requiredLength: getValidationMinLength() } }}</mat-error>\n    <mat-error *ngIf=\"searchUserCtrl.hasError('required') || userChipsCtrl.hasError('required')\">\n        <mat-icon class=\"adf-start-task-cloud-error-icon\">warning</mat-icon>\n        {{ 'ADF_CLOUD_PEOPLE_GROUPS.ERROR.REQUIRED' | translate }} </mat-error>\n    <mat-error *ngIf=\"searchUserCtrl.hasError('searchTypingError') && !this.isFocused\" data-automation-id=\"invalid-users-typing-error\">\n        <mat-icon class=\"adf-start-task-cloud-error-icon\">warning</mat-icon>\n        {{ 'ADF_CLOUD_USERS.ERROR.NOT_FOUND' | translate : { userName : searchedValue } }}</mat-error>\n</form>\n",
                animations: [
                    trigger('transitionMessages', [
                        state('enter', style({ opacity: 1, transform: 'translateY(0%)' })),
                        transition('void => enter', [
                            style({ opacity: 0, transform: 'translateY(-100%)' }),
                            animate('300ms cubic-bezier(0.55, 0, 0.55, 0.2)')
                        ])
                    ])
                ],
                providers: [FullNamePipe],
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-people-cloud{width:100%}.adf-people-cloud-option-not-active{background:inherit!important}.adf-people-cloud-list{margin:5px 0;padding:10px 0}.adf-people-cloud-row{align-items:center;column-gap:10px;display:flex}.adf-people-cloud-pic{align-items:center;background:var(--theme-primary-color);border-radius:100px;color:var(--theme-text-fg-color);display:flex;font-size:18px;font-weight:bolder;height:40px;justify-content:center;text-transform:uppercase;width:40px}.adf-start-task-cloud-error{height:20px;margin-top:-10px;position:absolute}.adf-start-task-cloud-error-message{color:var(--theme-warn-color);font-size:12px;height:16px;line-height:1.33;padding-right:8px;width:auto}.adf-start-task-cloud-error-icon{color:var(--theme-warn-color);font-size:17px}"]
            },] }
];
PeopleCloudComponent.ctorParameters = () => [
    { type: IdentityUserService },
    { type: LogService }
];
PeopleCloudComponent.propDecorators = {
    appName: [{ type: Input }],
    mode: [{ type: Input }],
    roles: [{ type: Input }],
    validate: [{ type: Input }],
    readOnly: [{ type: Input }],
    preSelectUsers: [{ type: Input }],
    excludedUsers: [{ type: Input }],
    userChipsCtrl: [{ type: Input }],
    searchUserCtrl: [{ type: Input }],
    title: [{ type: Input }],
    selectUser: [{ type: Output }],
    removeUser: [{ type: Output }],
    changedUsers: [{ type: Output }],
    warning: [{ type: Output }],
    userInput: [{ type: ViewChild, args: ['userInput',] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PeopleCloudModule {
}
PeopleCloudModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FlexLayoutModule,
                    MaterialModule,
                    FormsModule,
                    ReactiveFormsModule,
                    CoreModule
                ],
                declarations: [PeopleCloudComponent],
                exports: [
                    PeopleCloudComponent
                ]
            },] }
];

class ServiceTaskFilterCloudService {
    constructor(identityUserService, preferenceService) {
        this.identityUserService = identityUserService;
        this.preferenceService = preferenceService;
        this.filtersSubject = new BehaviorSubject([]);
        this.filters$ = this.filtersSubject.asObservable();
    }
    createDefaultFilters(appName) {
        const key = this.prepareKey(appName);
        this.preferenceService.getPreferences(appName, key).pipe(switchMap((response) => {
            const preferences = (response && response.list && response.list.entries) ? response.list.entries : [];
            if (!this.hasPreferences(preferences) || !this.hasTaskFilters(preferences, key)) {
                return this.createTaskFilters(appName, key, this.defaultServiceTaskFilters(appName));
            }
            else {
                return of(this.findFiltersByKeyInPreferences(preferences, key));
            }
        })).subscribe((filters) => {
            this.addFiltersToStream(filters);
        });
    }
    hasPreferences(preferences) {
        return preferences && preferences.length > 0;
    }
    hasTaskFilters(preferences, key) {
        const filters = preferences.find((filter) => { return filter.entry.key === key; });
        return (filters && filters.entry) ? JSON.parse(filters.entry.value).length > 0 : false;
    }
    createTaskFilters(appName, key, filters) {
        return this.preferenceService.createPreference(appName, key, filters);
    }
    getTaskFiltersByKey(appName, key) {
        return this.preferenceService.getPreferenceByKey(appName, key);
    }
    getTaskListFilters(appName) {
        this.createDefaultFilters(appName);
        return this.filters$;
    }
    getTaskFilterById(appName, id) {
        const key = this.prepareKey(appName);
        return this.getTaskFiltersByKey(appName, key).pipe(switchMap((filters) => {
            if (filters && filters.length === 0) {
                return this.createTaskFilters(appName, key, this.defaultServiceTaskFilters(appName));
            }
            else {
                return of(filters);
            }
        }), map((filters) => {
            return filters.filter((filter) => {
                return filter.id === id;
            })[0];
        }));
    }
    addFilter(newFilter) {
        const key = this.prepareKey(newFilter.appName);
        return this.getTaskFiltersByKey(newFilter.appName, key).pipe(switchMap((filters) => {
            if (filters && filters.length === 0) {
                return this.createTaskFilters(newFilter.appName, key, [newFilter]);
            }
            else {
                filters.push(newFilter);
                return this.preferenceService.updatePreference(newFilter.appName, key, filters);
            }
        }), map((filters) => {
            this.addFiltersToStream(filters);
            return filters;
        }));
    }
    addFiltersToStream(filters) {
        this.filtersSubject.next(filters);
    }
    updateFilter(updatedFilter) {
        const key = this.prepareKey(updatedFilter.appName);
        return this.getTaskFiltersByKey(updatedFilter.appName, key).pipe(switchMap((filters) => {
            if (filters && filters.length === 0) {
                return this.createTaskFilters(updatedFilter.appName, key, [updatedFilter]);
            }
            else {
                const itemIndex = filters.findIndex((filter) => filter.id === updatedFilter.id);
                filters[itemIndex] = updatedFilter;
                return this.updateTaskFilters(updatedFilter.appName, key, filters);
            }
        }), map((updatedFilters) => {
            this.addFiltersToStream(updatedFilters);
            return updatedFilters;
        }));
    }
    deleteFilter(deletedFilter) {
        const key = this.prepareKey(deletedFilter.appName);
        return this.getTaskFiltersByKey(deletedFilter.appName, key).pipe(switchMap((filters) => {
            if (filters && filters.length > 0) {
                filters = filters.filter(filter => filter.id !== deletedFilter.id);
                return this.updateTaskFilters(deletedFilter.appName, key, filters);
            }
            return of([]);
        }), map(filters => {
            this.addFiltersToStream(filters);
            return filters;
        }));
    }
    isDefaultFilter(filterName) {
        const defaultFilters = this.defaultServiceTaskFilters();
        return defaultFilters.findIndex((filter) => filterName === filter.name) !== -1;
    }
    updateTaskFilters(appName, key, filters) {
        return this.preferenceService.updatePreference(appName, key, filters);
    }
    prepareKey(appName) {
        return `service-task-filters-${appName}-${this.identityUserService.getCurrentUserInfo().username}`;
    }
    findFiltersByKeyInPreferences(preferences, key) {
        const result = preferences.find((filter) => { return filter.entry.key === key; });
        return result && result.entry ? JSON.parse(result.entry.value) : [];
    }
    defaultServiceTaskFilters(appName) {
        return [
            {
                id: this.generateRandomId(),
                name: 'ADF_CLOUD_SERVICE_TASK_FILTERS.ALL_SERVICE_TASKS',
                key: 'my-service-tasks',
                icon: 'inbox',
                appName,
                status: '',
                sort: 'startedDate',
                order: 'DESC'
            },
            {
                id: this.generateRandomId(),
                name: 'ADF_CLOUD_SERVICE_TASK_FILTERS.COMPLETED_TASKS',
                key: 'completed-tasks',
                icon: 'done',
                appName,
                status: 'COMPLETED',
                sort: 'completedDate',
                order: 'DESC'
            },
            {
                id: this.generateRandomId(),
                name: 'ADF_CLOUD_SERVICE_TASK_FILTERS.ERRORED_TASKS',
                key: 'errored-service-tasks',
                icon: 'error',
                appName,
                status: 'ERROR',
                sort: 'startedDate',
                order: 'DESC'
            }
        ];
    }
    generateRandomId() {
        return Math.random().toString(36).substr(2, 9);
    }
}
ServiceTaskFilterCloudService.ɵprov = ɵɵdefineInjectable({ factory: function ServiceTaskFilterCloudService_Factory() { return new ServiceTaskFilterCloudService(ɵɵinject(IdentityUserService), ɵɵinject(TASK_FILTERS_SERVICE_TOKEN)); }, token: ServiceTaskFilterCloudService, providedIn: "root" });
ServiceTaskFilterCloudService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
ServiceTaskFilterCloudService.ctorParameters = () => [
    { type: IdentityUserService },
    { type: undefined, decorators: [{ type: Inject, args: [TASK_FILTERS_SERVICE_TOKEN,] }] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TaskFilterDialogCloudComponent {
    constructor(fb, dialogRef, data) {
        this.fb = fb;
        this.dialogRef = dialogRef;
        this.data = data;
        this.defaultIcon = 'inbox';
    }
    ngOnInit() {
        this.filterForm = this.fb.group({
            name: [this.data.name, Validators.required]
        });
    }
    onSaveClick() {
        this.dialogRef.close({
            action: TaskFilterDialogCloudComponent.ACTION_SAVE,
            icon: this.defaultIcon,
            name: this.nameController.value
        });
    }
    onCancelClick() {
        this.dialogRef.close();
    }
    get nameController() {
        return this.filterForm.get('name');
    }
    isValid() {
        return this.filterForm.valid;
    }
}
TaskFilterDialogCloudComponent.ACTION_SAVE = 'SAVE';
TaskFilterDialogCloudComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-cloud-task-filter-dialog',
                template: "<div class=\"adf-task-filter-dialog\">\n    <span mat-dialog-title id=\"adf-task-filter-dialog-title\">\n         {{ 'ADF_CLOUD_EDIT_TASK_FILTER.DIALOG.TITLE' | translate}}\n    </span>\n    <mat-card>\n        <mat-card-content>\n        <form [formGroup]=\"filterForm\">\n            <mat-form-field fxFlex [floatLabel]=\"'auto'\">\n                <input matInput placeholder=\"{{ 'ADF_CLOUD_EDIT_TASK_FILTER.FILTER_NAME' | translate }}\" formControlName=\"name\" id=\"adf-filter-name-id\">\n            </mat-form-field>\n        </form>\n        </mat-card-content>\n        <mat-card-actions fxLayout=\"row\" fxLayoutAlign=\"end end\">\n            <button mat-button (click)=\"onSaveClick()\" id=\"adf-save-button-id\" [disabled]=\"!isValid()\">\n                {{ 'ADF_CLOUD_EDIT_TASK_FILTER.DIALOG.SAVE' | translate}}\n            </button>\n            <button mat-button (click)=\"onCancelClick()\" id=\"adf-cancel-button-id\">\n               {{ 'ADF_CLOUD_EDIT_TASK_FILTER.DIALOG.CANCEL' | translate}}\n            </button>\n        </mat-card-actions>\n    </mat-card>\n</div>\n",
                styles: [".adf-task-filter-dialog .mat-card,.adf-task-filter-dialog .mat-card-content{box-shadow:none;padding:0}"]
            },] }
];
TaskFilterDialogCloudComponent.ctorParameters = () => [
    { type: FormBuilder },
    { type: MatDialogRef },
    { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] }] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class BaseEditTaskFilterCloudComponent {
    constructor(formBuilder, dateAdapter, userPreferencesService, appsProcessCloudService, taskCloudService, dialog, translateService) {
        this.formBuilder = formBuilder;
        this.dateAdapter = dateAdapter;
        this.userPreferencesService = userPreferencesService;
        this.appsProcessCloudService = appsProcessCloudService;
        this.taskCloudService = taskCloudService;
        this.dialog = dialog;
        this.translateService = translateService;
        this.appName = '';
        this.showTitle = true;
        this.showTaskFilterName = true;
        this.filterProperties = [];
        this.role = '';
        this.showFilterActions = true;
        this.actions = BaseEditTaskFilterCloudComponent.DEFAULT_ACTIONS;
        this.sortProperties = [];
        this.action = new EventEmitter();
        this.applicationNames = [];
        this.processDefinitionNames = [];
        this.formHasBeenChanged = false;
        this.taskFilterProperties = [];
        this.taskFilterActions = [];
        this.toggleFilterActions = false;
        this.sortDirections = [
            { value: 'ASC', label: 'ADF_CLOUD_TASK_FILTERS.DIRECTION.ASCENDING' },
            { value: 'DESC', label: 'ADF_CLOUD_TASK_FILTERS.DIRECTION.DESCENDING' }
        ];
        this.allProcessDefinitionNamesOption = {
            value: '',
            label: 'ADF_CLOUD_TASK_FILTERS.STATUS.ALL'
        };
        this.filterChange = new EventEmitter();
        this.onDestroy$ = new Subject();
        this.isLoading = false;
    }
    ngOnInit() {
        this.userPreferencesService
            .select(UserPreferenceValues.Locale)
            .pipe(takeUntil(this.onDestroy$))
            .subscribe(locale => this.dateAdapter.setLocale(locale));
    }
    ngOnChanges(changes) {
        const id = changes['id'];
        if (id && id.currentValue !== id.previousValue) {
            this.retrieveTaskFilterAndBuildForm();
        }
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
    createFilterActions() {
        return [
            {
                actionType: BaseEditTaskFilterCloudComponent.ACTION_SAVE,
                icon: 'adf:save',
                tooltip: 'ADF_CLOUD_EDIT_TASK_FILTER.TOOL_TIP.SAVE'
            },
            {
                actionType: BaseEditTaskFilterCloudComponent.ACTION_SAVE_AS,
                icon: 'adf:save-as',
                tooltip: 'ADF_CLOUD_EDIT_TASK_FILTER.TOOL_TIP.SAVE_AS'
            },
            {
                actionType: BaseEditTaskFilterCloudComponent.ACTION_DELETE,
                icon: 'delete',
                tooltip: 'ADF_CLOUD_EDIT_TASK_FILTER.TOOL_TIP.DELETE'
            }
        ];
    }
    hasFormChanged(action) {
        if (action.actionType === BaseEditTaskFilterCloudComponent.ACTION_SAVE) {
            return !this.formHasBeenChanged;
        }
        if (action.actionType === BaseEditTaskFilterCloudComponent.ACTION_SAVE_AS) {
            return !this.formHasBeenChanged;
        }
        if (action.actionType === BaseEditTaskFilterCloudComponent.ACTION_DELETE) {
            return false;
        }
        return false;
    }
    onExpand() {
        this.toggleFilterActions = true;
    }
    onClose() {
        this.toggleFilterActions = false;
    }
    isDisabledAction(action) {
        return this.isDisabledForDefaultFilters(action) ? true : this.hasFormChanged(action);
    }
    deepCompare(left, right) {
        return JSON.stringify(left).toLowerCase() === JSON.stringify(right).toLowerCase();
    }
    getSanitizeFilterName(filterName) {
        const nameWithHyphen = this.replaceSpaceWithHyphen(filterName.trim());
        return nameWithHyphen.toLowerCase();
    }
    replaceSpaceWithHyphen(name) {
        const regExt = new RegExp(' ', 'g');
        return name.replace(regExt, '-');
    }
    executeFilterActions(action) {
        if (action.actionType === BaseEditTaskFilterCloudComponent.ACTION_SAVE) {
            this.save(action);
        }
        else if (action.actionType === BaseEditTaskFilterCloudComponent.ACTION_SAVE_AS) {
            this.saveAs(action);
        }
        else if (action.actionType === BaseEditTaskFilterCloudComponent.ACTION_DELETE) {
            this.delete(action);
        }
    }
    getRunningApplications() {
        this.appsProcessCloudService
            .getDeployedApplicationsByStatus(BaseEditTaskFilterCloudComponent.APP_RUNNING_STATUS, this.role)
            .subscribe((applications) => {
            if (applications && applications.length > 0) {
                applications.map((application) => {
                    this.applicationNames.push({ label: application.name, value: application.name });
                });
            }
        });
    }
    getProcessDefinitions() {
        this.taskCloudService.getProcessDefinitions(this.appName)
            .subscribe((processDefinitions) => {
            if (processDefinitions && processDefinitions.length > 0) {
                this.processDefinitionNames.push(this.allProcessDefinitionNamesOption);
                processDefinitions.map((processDefinition) => {
                    this.processDefinitionNames.push({ label: processDefinition.name, value: processDefinition.name });
                });
            }
        });
    }
    checkMandatoryActions() {
        if (this.actions === undefined || this.actions.length === 0) {
            this.actions = BaseEditTaskFilterCloudComponent.DEFAULT_ACTIONS;
        }
    }
    isValidAction(actions, action) {
        return actions ? actions.indexOf(action.actionType) >= 0 : true;
    }
    isFormValid() {
        return this.editTaskFilterForm.valid;
    }
    getPropertyController(property) {
        return this.editTaskFilterForm.get(property.key);
    }
    onDateChanged(newDateValue, dateProperty) {
        if (newDateValue) {
            const momentDate = moment$1(newDateValue, BaseEditTaskFilterCloudComponent.FORMAT_DATE, true);
            const controller = this.getPropertyController(dateProperty);
            if (momentDate.isValid()) {
                controller.setValue(momentDate.toISOString(true));
                controller.setErrors(null);
            }
            else {
                controller.setErrors({ invalid: true });
            }
        }
    }
    onDateRangeFilterChanged(dateRange, property) {
        var _a, _b;
        this.editTaskFilterForm.get((_a = property.attributes) === null || _a === void 0 ? void 0 : _a.from).setValue(dateRange.startDate ? dateRange.startDate : null);
        this.editTaskFilterForm.get((_b = property.attributes) === null || _b === void 0 ? void 0 : _b.to).setValue(dateRange.endDate ? dateRange.endDate : null);
        this.editTaskFilterForm.get(property.attributes.dateType).setValue(DateCloudFilterType.RANGE);
    }
    onChangedUser(users, userProperty) {
        let selectedUsers;
        if (userProperty.selectionMode === 'single') {
            selectedUsers = users[0];
        }
        else {
            selectedUsers = users;
        }
        this.getPropertyController(userProperty).setValue(selectedUsers);
    }
    onAssignedChange(assignedValue) {
        this.editTaskFilterForm.get('candidateGroups').setValue([]);
        this.editTaskFilterForm.get('assignee').setValue(assignedValue === null || assignedValue === void 0 ? void 0 : assignedValue.username);
    }
    onAssignedGroupsChange(groups) {
        this.editTaskFilterForm.get('assignee').setValue(null);
        this.editTaskFilterForm.get('candidateGroups').setValue(groups);
    }
    hasError(property) {
        const controller = this.getPropertyController(property);
        return controller.errors && controller.errors.invalid;
    }
    hasLastModifiedProperty() {
        return this.filterProperties.indexOf(BaseEditTaskFilterCloudComponent.LAST_MODIFIED) >= 0;
    }
    get createSortProperties() {
        this.checkMandatorySortProperties();
        return this.sortProperties.map((property) => {
            return { label: property, value: property };
        });
    }
    createAndFilterActions() {
        this.checkMandatoryActions();
        return this.createFilterActions().filter(action => this.isValidAction(this.actions, action));
    }
    isValidProperty(filterProperties, key) {
        return filterProperties ? filterProperties.indexOf(key) >= 0 : true;
    }
    checkForProperty(property) {
        return this.filterProperties ? this.filterProperties.indexOf(property) >= 0 : false;
    }
    hasSortProperty() {
        return this.filterProperties.indexOf(BaseEditTaskFilterCloudComponent.SORT) >= 0;
    }
    removeOrderProperty(filteredProperties) {
        if (filteredProperties && filteredProperties.length > 0) {
            return filteredProperties.filter(property => property.key !== BaseEditTaskFilterCloudComponent.ORDER);
        }
        return [];
    }
    createAndFilterProperties() {
        this.checkMandatoryFilterProperties();
        if (this.checkForProperty(BaseEditTaskFilterCloudComponent.APPLICATION_NAME)) {
            this.applicationNames = [];
            this.getRunningApplications();
        }
        if (this.checkForProperty(BaseEditTaskFilterCloudComponent.PROCESS_DEFINITION_NAME)) {
            this.processDefinitionNames = [];
            this.getProcessDefinitions();
        }
        const defaultProperties = this.createTaskFilterProperties();
        let filteredProperties = defaultProperties.filter((filterProperty) => this.isValidProperty(this.filterProperties, filterProperty.key));
        if (!this.hasSortProperty()) {
            filteredProperties = this.removeOrderProperty(filteredProperties);
        }
        return filteredProperties;
    }
    onFilterChange() {
        this.editTaskFilterForm.valueChanges
            .pipe(debounceTime(500), filter(() => this.isFormValid()), takeUntil(this.onDestroy$))
            .subscribe((formValues) => {
            this.assignNewFilter(formValues);
        });
    }
    getFormControlsConfig(taskFilterProperties) {
        const properties = taskFilterProperties.map((property) => {
            if (!!property.attributes) {
                return this.getAttributesControlConfig(property);
            }
            else {
                return { [property.key]: property.value };
            }
        });
        return properties.reduce(((result, current) => Object.assign(result, current)), {});
    }
    getAttributesControlConfig(property) {
        return Object.values(property.attributes).reduce((result, key) => {
            result[key] = property.value[key];
            return result;
        }, {});
    }
    buildForm(taskFilterProperties) {
        this.formHasBeenChanged = false;
        this.editTaskFilterForm = this.formBuilder.group(this.getFormControlsConfig(taskFilterProperties));
        this.onFilterChange();
    }
    onDateTypeChange(dateType, property) {
        this.editTaskFilterForm.get(property.attributes.dateType).setValue(dateType);
    }
    retrieveTaskFilterAndBuildForm() {
        this.isLoading = true;
        this.getTaskFilterById(this.appName, this.id)
            .pipe(finalize(() => this.isLoading = false), takeUntil(this.onDestroy$))
            .subscribe(response => {
            this.taskFilter = response;
            this.taskFilterProperties = this.createAndFilterProperties();
            this.taskFilterActions = this.createAndFilterActions();
            this.buildForm(this.taskFilterProperties);
        });
    }
    delete(deleteAction) {
        this.deleteFilter(this.taskFilter)
            .pipe(filter((filters) => {
            deleteAction.filter = this.taskFilter;
            this.action.emit(deleteAction);
            return filters.length === 0;
        }), switchMap(() => this.restoreDefaultTaskFilters()), takeUntil(this.onDestroy$))
            .subscribe(() => { });
    }
    save(saveAction) {
        this.updateFilter(this.changedTaskFilter)
            .pipe(takeUntil(this.onDestroy$))
            .subscribe(() => {
            saveAction.filter = this.changedTaskFilter;
            this.action.emit(saveAction);
            this.formHasBeenChanged = this.deepCompare(this.changedTaskFilter, this.taskFilter);
        });
    }
    saveAs(saveAsAction) {
        var _a;
        const dialogRef = this.dialog.open(TaskFilterDialogCloudComponent, {
            data: {
                name: this.translateService.instant((_a = this.taskFilter) === null || _a === void 0 ? void 0 : _a.name)
            },
            height: 'auto',
            minWidth: '30%'
        });
        dialogRef.afterClosed().subscribe((result) => {
            if (result && result.action === TaskFilterDialogCloudComponent.ACTION_SAVE) {
                const filterId = Math.random().toString(36).substr(2, 9);
                const filterKey = this.getSanitizeFilterName(result.name);
                const newFilter = {
                    name: result.name,
                    icon: result.icon,
                    id: filterId,
                    key: 'custom-' + filterKey
                };
                const resultFilter = Object.assign({}, this.changedTaskFilter, newFilter);
                this.addFilter(resultFilter).subscribe(() => {
                    saveAsAction.filter = resultFilter;
                    this.action.emit(saveAsAction);
                });
            }
        });
    }
    checkMandatoryFilterProperties() {
        if (this.filterProperties === undefined || this.filterProperties.length === 0) {
            this.filterProperties = this.getDefaultFilterProperties();
        }
    }
    checkMandatorySortProperties() {
        if (this.sortProperties === undefined || this.sortProperties.length === 0) {
            this.sortProperties = this.getDefaultSortProperties();
        }
    }
}
BaseEditTaskFilterCloudComponent.ACTION_SAVE = 'save';
BaseEditTaskFilterCloudComponent.ACTION_SAVE_AS = 'saveAs';
BaseEditTaskFilterCloudComponent.ACTION_DELETE = 'delete';
BaseEditTaskFilterCloudComponent.APP_RUNNING_STATUS = 'RUNNING';
BaseEditTaskFilterCloudComponent.APPLICATION_NAME = 'appName';
BaseEditTaskFilterCloudComponent.PROCESS_DEFINITION_NAME = 'processDefinitionName';
BaseEditTaskFilterCloudComponent.LAST_MODIFIED = 'lastModified';
BaseEditTaskFilterCloudComponent.SORT = 'sort';
BaseEditTaskFilterCloudComponent.ORDER = 'order';
BaseEditTaskFilterCloudComponent.DEFAULT_ACTIONS = ['save', 'saveAs', 'delete'];
BaseEditTaskFilterCloudComponent.FORMAT_DATE = 'DD/MM/YYYY';
BaseEditTaskFilterCloudComponent.ACTIONS_DISABLED_BY_DEFAULT = [
    BaseEditTaskFilterCloudComponent.ACTION_SAVE,
    BaseEditTaskFilterCloudComponent.ACTION_DELETE
];
BaseEditTaskFilterCloudComponent.decorators = [
    { type: Directive }
];
BaseEditTaskFilterCloudComponent.ctorParameters = () => [
    { type: FormBuilder },
    { type: DateAdapter },
    { type: UserPreferencesService },
    { type: AppsProcessCloudService },
    { type: TaskCloudService },
    { type: MatDialog },
    { type: TranslationService }
];
BaseEditTaskFilterCloudComponent.propDecorators = {
    appName: [{ type: Input }],
    id: [{ type: Input }],
    showTitle: [{ type: Input }],
    showTaskFilterName: [{ type: Input }],
    filterProperties: [{ type: Input }],
    role: [{ type: Input }],
    showFilterActions: [{ type: Input }],
    actions: [{ type: Input }],
    sortProperties: [{ type: Input }],
    action: [{ type: Output }],
    filterChange: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class EditServiceTaskFilterCloudComponent extends BaseEditTaskFilterCloudComponent {
    constructor(formBuilder, dialog, translateService, serviceTaskFilterCloudService, dateAdapter, userPreferencesService, appsProcessCloudService, taskCloudService) {
        super(formBuilder, dateAdapter, userPreferencesService, appsProcessCloudService, taskCloudService, dialog, translateService);
        this.serviceTaskFilterCloudService = serviceTaskFilterCloudService;
    }
    assignNewFilter(model) {
        this.changedTaskFilter = Object.assign(Object.assign({}, this.taskFilter), model);
        this.formHasBeenChanged = !this.deepCompare(this.changedTaskFilter, this.taskFilter);
        this.filterChange.emit(this.changedTaskFilter);
    }
    getTaskFilterById(appName, id) {
        return this.serviceTaskFilterCloudService.getTaskFilterById(appName, id);
    }
    getDefaultFilterProperties() {
        return ['appName', 'activityName', 'status', 'sort', 'order'];
    }
    getDefaultSortProperties() {
        return ['id', 'activityName', 'startedDate', 'completedDate'];
    }
    updateFilter(filterToUpdate) {
        return this.serviceTaskFilterCloudService.updateFilter(filterToUpdate);
    }
    deleteFilter(filterToDelete) {
        return this.serviceTaskFilterCloudService.deleteFilter(filterToDelete);
    }
    addFilter(filterToAdd) {
        return this.serviceTaskFilterCloudService
            .addFilter(filterToAdd)
            .pipe(takeUntil(this.onDestroy$));
    }
    isDisabledForDefaultFilters(action) {
        return (this.serviceTaskFilterCloudService.isDefaultFilter(this.taskFilter.name) &&
            EditServiceTaskFilterCloudComponent.ACTIONS_DISABLED_BY_DEFAULT.includes(action.actionType));
    }
    restoreDefaultTaskFilters() {
        return this.serviceTaskFilterCloudService.getTaskListFilters(this.appName);
    }
    getStatusOptions() {
        return [
            { value: '', label: 'ADF_CLOUD_SERVICE_TASK_FILTERS.STATUS.ALL' },
            { value: 'STARTED', label: 'ADF_CLOUD_SERVICE_TASK_FILTERS.STATUS.STARTED' },
            { value: 'COMPLETED', label: 'ADF_CLOUD_SERVICE_TASK_FILTERS.STATUS.COMPLETED' },
            { value: 'CANCELLED', label: 'ADF_CLOUD_SERVICE_TASK_FILTERS.STATUS.CANCELLED' },
            { value: 'ERROR', label: 'ADF_CLOUD_SERVICE_TASK_FILTERS.STATUS.ERROR' }
        ];
    }
    createTaskFilterProperties() {
        const statusOptions = this.getStatusOptions();
        return [
            {
                label: 'ADF_CLOUD_EDIT_SERVICE_TASK_FILTER.LABEL.APP_NAME',
                type: 'select',
                key: 'appName',
                value: this.taskFilter.appName || '',
                options: this.applicationNames
            },
            {
                label: 'ADF_CLOUD_EDIT_SERVICE_TASK_FILTER.LABEL.SERVICE_TASK_ID',
                type: 'text',
                key: 'serviceTaskId',
                value: this.taskFilter.serviceTaskId || ''
            },
            {
                label: 'ADF_CLOUD_EDIT_SERVICE_TASK_FILTER.LABEL.ELEMENT_ID',
                type: 'text',
                key: 'elementId',
                value: this.taskFilter.elementId || ''
            },
            {
                label: 'ADF_CLOUD_EDIT_SERVICE_TASK_FILTER.LABEL.ACTIVITY_NAME',
                type: 'text',
                key: 'activityName',
                value: this.taskFilter.activityName || ''
            },
            {
                label: 'ADF_CLOUD_EDIT_SERVICE_TASK_FILTER.LABEL.ACTIVITY_TYPE',
                type: 'text',
                key: 'activityType',
                value: this.taskFilter.activityType || ''
            },
            {
                label: 'ADF_CLOUD_EDIT_SERVICE_TASK_FILTER.LABEL.SORT',
                type: 'select',
                key: 'sort',
                value: this.taskFilter.sort || this.createSortProperties[0].value,
                options: this.createSortProperties
            },
            {
                label: 'ADF_CLOUD_EDIT_SERVICE_TASK_FILTER.LABEL.DIRECTION',
                type: 'select',
                key: 'order',
                value: this.taskFilter.order || this.sortDirections[0].value,
                options: [...this.sortDirections]
            },
            {
                label: 'ADF_CLOUD_EDIT_SERVICE_TASK_FILTER.LABEL.STATUS',
                type: 'select',
                key: 'status',
                value: this.taskFilter.status || statusOptions[0].value,
                options: statusOptions
            },
            {
                label: 'ADF_CLOUD_EDIT_SERVICE_TASK_FILTER.LABEL.STARTED_DATE',
                type: 'date',
                key: 'startedDate',
                value: this.taskFilter.completedDate || false
            },
            {
                label: 'ADF_CLOUD_EDIT_SERVICE_TASK_FILTER.LABEL.COMPLETED_DATE',
                type: 'date',
                key: 'completedDate',
                value: this.taskFilter.completedDate || false
            },
            {
                label: 'ADF_CLOUD_EDIT_SERVICE_TASK_FILTER.LABEL.PROCESS_INSTANCE_ID',
                type: 'text',
                key: 'processInstanceId',
                value: this.taskFilter.processInstanceId || ''
            },
            {
                label: 'ADF_CLOUD_EDIT_SERVICE_TASK_FILTER.LABEL.PROCESS_DEF_ID',
                type: 'text',
                key: 'processDefinitionId',
                value: this.taskFilter.processDefinitionId || ''
            },
            {
                label: 'ADF_CLOUD_EDIT_SERVICE_TASK_FILTER.LABEL.SERVICE_NAME',
                type: 'text',
                key: 'serviceName',
                value: this.taskFilter.serviceName || ''
            }
        ];
    }
}
EditServiceTaskFilterCloudComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-cloud-edit-service-task-filter',
                template: "<mat-accordion [hideToggle]=\"isLoading\">\n    <mat-expansion-panel (afterExpand)=\"onExpand()\" (closed)=\"onClose()\">\n        <mat-expansion-panel-header *ngIf=\"taskFilter\" id=\"adf-edit-task-filter-expansion-header\">\n            <ng-container *ngIf=\"!isLoading; else loadingTemplate\">\n                <mat-panel-title *ngIf=\"showTaskFilterName\" fxLayoutAlign=\"space-between center\" id=\"adf-edit-task-filter-title-id\"\n                    >{{taskFilter.name | translate}}</mat-panel-title>\n                <mat-panel-description fxLayoutAlign=\"space-between center\" id=\"adf-edit-task-filter-sub-title-id\">\n                    <span *ngIf=\"showTitle\">{{ 'ADF_CLOUD_EDIT_TASK_FILTER.TITLE' | translate}}</span>\n                    <div *ngIf=\"showFilterActions\" class=\"adf-cloud-edit-task-filter-actions\">\n                        <ng-container *ngIf=\"toggleFilterActions\">\n                            <button *ngFor=\"let filterAction of taskFilterActions\"\n                                    mat-icon-button\n                                    matTooltip=\"{{ filterAction.tooltip | translate}}\"\n                                    [attr.data-automation-id]=\"'adf-filter-action-' + filterAction.actionType\"\n                                    [disabled]=\"isDisabledAction(filterAction)\"\n                                    (click)=\"executeFilterActions(filterAction)\">\n                                <adf-icon [value]=\"filterAction.icon\"></adf-icon>\n                            </button>\n                        </ng-container>\n                    </div>\n                </mat-panel-description>\n            </ng-container>\n            <ng-template #loadingTemplate>\n                <div class=\"adf-cloud-edit-task-filter-loading-margin\">\n                    <mat-spinner [diameter]=\"30\"></mat-spinner>\n                </div>\n            </ng-template>\n        </mat-expansion-panel-header>\n        <ng-container *ngIf=\"!isLoading;\">\n            <form *ngIf=\"editTaskFilterForm\" [formGroup]=\"editTaskFilterForm\">\n                <div fxLayout=\"row wrap\" fxLayout.xs=\"column\" fxLayoutGap=\"10px\" fxLayoutAlign=\"start center\">\n                    <ng-container *ngFor=\"let taskFilterProperty of taskFilterProperties\">\n                        <mat-form-field fxFlex=\"23%\"\n                                        [floatLabel]=\"'auto'\"\n                                        *ngIf=\"taskFilterProperty.type === 'select'\"\n                                        [attr.data-automation-id]=\"taskFilterProperty.key\">\n                            <mat-select placeholder=\"{{taskFilterProperty.label | translate}}\"\n                                        [formControlName]=\"taskFilterProperty.key\"\n                                        [attr.data-automation-id]=\"'adf-cloud-edit-task-property-' + taskFilterProperty.key\">\n                                <mat-option *ngFor=\"let propertyOption of taskFilterProperty.options\"\n                                            [value]=\"propertyOption.value\"\n                                            [attr.data-automation-id]=\"'adf-cloud-edit-task-property-options-' + taskFilterProperty.key\">\n                                    {{ propertyOption.label | translate }}\n                                </mat-option>\n                            </mat-select>\n                        </mat-form-field>\n                        <mat-form-field fxFlex=\"23%\"\n                                        [floatLabel]=\"'auto'\"\n                                        *ngIf=\"taskFilterProperty.type === 'text'\"\n                                        [attr.data-automation-id]=\"taskFilterProperty.key\">\n                            <input matInput\n                                   [formControlName]=\"taskFilterProperty.key\"\n                                   type=\"text\"\n                                   placeholder=\"{{taskFilterProperty.label | translate}}\"\n                                   [attr.data-automation-id]=\"'adf-cloud-edit-task-property-' + taskFilterProperty.key\" />\n                        </mat-form-field>\n                        <mat-form-field fxFlex=\"23%\"\n                                        [floatLabel]=\"'auto'\"\n                                        *ngIf=\"taskFilterProperty.type === 'date'\"\n                                        [attr.data-automation-id]=\"taskFilterProperty.key\">\n                            <mat-label>{{taskFilterProperty.label | translate}}</mat-label>\n                            <input matInput\n                                   (keyup)=\"onDateChanged($any($event).srcElement.value, taskFilterProperty)\"\n                                   (dateChange)=\"onDateChanged($event.value, taskFilterProperty)\"\n                                   [matDatepicker]=\"dateController\"\n                                   placeholder=\"{{taskFilterProperty.label | translate}}\"\n                                   [attr.data-automation-id]=\"'adf-cloud-edit-task-property-' + taskFilterProperty.key\">\n                            <mat-datepicker-toggle matSuffix\n                                                   [for]=\"dateController\"\n                                                   [attr.data-automation-id]=\"'adf-cloud-edit-task-property-date-toggle-' + taskFilterProperty.key\">\n                            </mat-datepicker-toggle>\n                            <mat-datepicker #dateController\n                                            [attr.data-automation-id]=\"'adf-cloud-edit-task-property-date-picker-' + taskFilterProperty.key\">\n                            </mat-datepicker>\n                            <div class=\"adf-edit-task-filter-date-error-container\">\n                                <div *ngIf=\"hasError(taskFilterProperty)\">\n                                    <div class=\"adf-error-text\">{{'ADF_TASK_LIST.START_TASK.FORM.ERROR.DATE'|translate}}</div>\n                                    <mat-icon class=\"adf-error-icon\">warning</mat-icon>\n                                </div>\n                            </div>\n                        </mat-form-field>\n                        <div class=\"adf-edit-task-filter-checkbox\"\n                             *ngIf=\"taskFilterProperty.type === 'checkbox'\">\n                            <mat-checkbox color=\"primary\"\n                                          [formControlName]=\"taskFilterProperty.key\"\n                                          [attr.data-automation-id]=\"taskFilterProperty.key\"\n                            >{{taskFilterProperty.label | translate}}</mat-checkbox>\n                        </div>\n\n                        <adf-cloud-date-range-filter #dateRange\n                            *ngIf=\"taskFilterProperty.type === 'date-range'\"\n                            [processFilterProperty]=\"taskFilterProperty\"\n                            [options]=\"taskFilterProperty.dateFilterOptions\"\n                            (dateTypeChange)=\"onDateTypeChange($event, taskFilterProperty)\"\n                            (dateChanged)=\"onDateRangeFilterChanged($event, taskFilterProperty)\">\n                        </adf-cloud-date-range-filter>\n\n                        <div fxFlex=\"23%\" class=\"{{ 'adf-edit-task-filter-' + taskFilterProperty.key }}\" *ngIf=\"taskFilterProperty.type === 'people'\">\n                            <adf-cloud-people\n                                [preSelectUsers]=\"taskFilterProperty.value\"\n                                [title]=\"taskFilterProperty.label\"\n                                [validate]=\"true\"\n                                [appName]=\"appName\"\n                                [mode]=\"taskFilterProperty.selectionMode\"\n                                (changedUsers)=\"onChangedUser($event, taskFilterProperty)\">\n                            </adf-cloud-people>\n                        </div>\n\n                        <adf-cloud-task-assignment-filter fxFlex=\"23%\"\n                            *ngIf=\"taskFilterProperty.type === 'assignment'\"\n                            [taskFilterProperty]=\"taskFilterProperty\"\n                            (assignedChange)=\"onAssignedChange($event)\"\n                            (assignedGroupChange)=\"onAssignedGroupsChange($event)\">\n                        </adf-cloud-task-assignment-filter>\n                    </ng-container>\n                </div>\n            </form>\n        </ng-container>\n    </mat-expansion-panel>\n</mat-accordion>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-edit-task-filter-checkbox{flex:1 23%;font-size:16px;padding-top:10px;text-align:center}.adf-edit-task-filter-date-error-container{height:20px;margin-top:12px;position:absolute;width:100%}.adf-edit-task-filter-date-error-container>div{display:flex;flex-flow:row;justify-content:flex-start}.adf-edit-task-filter-date-error-container .adf-error-text{color:var(--theme-warn-color);font-size:10px;height:16px;line-height:1.33;padding-right:8px;width:auto}.adf-edit-task-filter-date-error-container .adf-error-icon{color:var(--theme-warn-color);font-size:16px}.adf-edit-task-filter-dateRange mat-grid-list{width:450px}.adf-cloud-edit-task-filter-loading-margin{margin-left:calc(50% - 50px);margin-right:calc(50% - 50px)}"]
            },] }
];
EditServiceTaskFilterCloudComponent.ctorParameters = () => [
    { type: FormBuilder },
    { type: MatDialog },
    { type: TranslationService },
    { type: ServiceTaskFilterCloudService },
    { type: DateAdapter },
    { type: UserPreferencesService },
    { type: AppsProcessCloudService },
    { type: TaskCloudService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class EditTaskFilterCloudComponent extends BaseEditTaskFilterCloudComponent {
    constructor(formBuilder, dialog, translateService, taskFilterCloudService, dateAdapter, userPreferencesService, appsProcessCloudService, taskCloudService) {
        super(formBuilder, dateAdapter, userPreferencesService, appsProcessCloudService, taskCloudService, dialog, translateService);
        this.taskFilterCloudService = taskFilterCloudService;
    }
    assignNewFilter(model) {
        this.setLastModifiedToFilter(model);
        this.changedTaskFilter = new TaskFilterCloudModel(Object.assign({}, this.taskFilter, model));
        this.formHasBeenChanged = !this.deepCompare(this.changedTaskFilter, this.taskFilter);
        this.filterChange.emit(this.changedTaskFilter);
    }
    getTaskFilterById(appName, id) {
        return this.taskFilterCloudService
            .getTaskFilterById(appName, id)
            .pipe(map(response => new TaskFilterCloudModel(response)));
    }
    createAndFilterProperties() {
        const result = super.createAndFilterProperties();
        if (this.hasLastModifiedProperty()) {
            return [
                ...result,
                ...this.createLastModifiedProperty()
            ];
        }
        return result;
    }
    getDefaultFilterProperties() {
        return ['status', 'assignee', 'sort', 'order'];
    }
    getDefaultSortProperties() {
        return ['id', 'name', 'createdDate', 'priority'];
    }
    setLastModifiedToFilter(formValues) {
        if (formValues.lastModifiedTo && Date.parse(formValues.lastModifiedTo.toString())) {
            const lastModifiedToFilterValue = moment(formValues.lastModifiedTo);
            lastModifiedToFilterValue.set({
                hour: 23,
                minute: 59,
                second: 59
            });
            formValues.lastModifiedTo = lastModifiedToFilterValue.toISOString(true);
        }
    }
    updateFilter(filterToUpdate) {
        return this.taskFilterCloudService.updateFilter(filterToUpdate);
    }
    deleteFilter(filterToDelete) {
        return this.taskFilterCloudService.deleteFilter(filterToDelete);
    }
    addFilter(filterToAdd) {
        return this.taskFilterCloudService
            .addFilter(filterToAdd)
            .pipe(takeUntil(this.onDestroy$));
    }
    isDisabledForDefaultFilters(action) {
        return (this.taskFilterCloudService.isDefaultFilter(this.taskFilter.name) &&
            EditTaskFilterCloudComponent.ACTIONS_DISABLED_BY_DEFAULT.includes(action.actionType));
    }
    restoreDefaultTaskFilters() {
        return this.taskFilterCloudService.getTaskListFilters(this.appName);
    }
    createLastModifiedProperty() {
        return [
            {
                label: 'ADF_CLOUD_EDIT_TASK_FILTER.LABEL.LAST_MODIFIED_FROM',
                type: 'date',
                key: 'lastModifiedFrom',
                value: ''
            },
            {
                label: 'ADF_CLOUD_EDIT_TASK_FILTER.LABEL.LAST_MODIFIED_TO',
                type: 'date',
                key: 'lastModifiedTo',
                value: ''
            }
        ];
    }
    getStatusOptions() {
        return [
            { value: '', label: 'ADF_CLOUD_TASK_FILTERS.STATUS.ALL' },
            { value: 'CREATED', label: 'ADF_CLOUD_TASK_FILTERS.STATUS.CREATED' },
            { value: 'ASSIGNED', label: 'ADF_CLOUD_TASK_FILTERS.STATUS.ASSIGNED' },
            { value: 'SUSPENDED', label: 'ADF_CLOUD_TASK_FILTERS.STATUS.SUSPENDED' },
            { value: 'CANCELLED', label: 'ADF_CLOUD_TASK_FILTERS.STATUS.CANCELLED' },
            { value: 'COMPLETED', label: 'ADF_CLOUD_TASK_FILTERS.STATUS.COMPLETED' }
        ];
    }
    createTaskFilterProperties() {
        const statusOptions = this.getStatusOptions();
        const sortProperties = this.createSortProperties;
        return [
            {
                label: 'ADF_CLOUD_EDIT_TASK_FILTER.LABEL.APP_NAME',
                type: 'select',
                key: 'appName',
                value: this.taskFilter.appName || '',
                options: this.applicationNames
            },
            {
                label: 'ADF_CLOUD_EDIT_TASK_FILTER.LABEL.TASK_ID',
                type: 'text',
                key: 'taskId',
                value: ''
            },
            {
                label: 'ADF_CLOUD_EDIT_TASK_FILTER.LABEL.STATUS',
                type: 'select',
                key: 'status',
                value: this.taskFilter.status || statusOptions[0].value,
                options: statusOptions
            },
            {
                label: 'ADF_CLOUD_EDIT_TASK_FILTER.LABEL.ASSIGNMENT',
                type: 'text',
                key: 'assignee',
                value: this.taskFilter.assignee || ''
            },
            {
                label: 'ADF_CLOUD_EDIT_TASK_FILTER.LABEL.PROCESS_DEF_NAME',
                type: 'select',
                key: 'processDefinitionName',
                value: this.taskFilter.processDefinitionName || '',
                options: this.processDefinitionNames
            },
            {
                label: 'ADF_CLOUD_EDIT_TASK_FILTER.LABEL.PROCESS_INSTANCE_ID',
                type: 'text',
                key: 'processInstanceId',
                value: this.taskFilter.processInstanceId || ''
            },
            {
                label: 'ADF_CLOUD_EDIT_TASK_FILTER.LABEL.PROCESS_DEF_ID',
                type: 'text',
                key: 'processDefinitionId',
                value: this.taskFilter.processDefinitionId || ''
            },
            {
                label: 'ADF_CLOUD_EDIT_TASK_FILTER.LABEL.TASK_NAME',
                type: 'text',
                key: 'taskName',
                value: this.taskFilter.taskName || ''
            },
            {
                label: 'ADF_CLOUD_EDIT_TASK_FILTER.LABEL.PARENT_TASK_ID',
                type: 'text',
                key: 'parentTaskId',
                value: this.taskFilter.parentTaskId || ''
            },
            {
                label: 'ADF_CLOUD_EDIT_TASK_FILTER.LABEL.PRIORITY',
                type: 'select',
                key: 'priority',
                value: this.taskFilter.priority || '',
                options: this.taskCloudService.priorities
            },
            {
                label: 'ADF_CLOUD_EDIT_TASK_FILTER.LABEL.OWNER',
                type: 'text',
                key: 'owner',
                value: this.taskFilter.owner || ''
            },
            {
                label: 'ADF_CLOUD_EDIT_TASK_FILTER.LABEL.CREATED_DATE',
                type: 'date',
                key: 'createdDate',
                value: ''
            },
            {
                label: 'ADF_CLOUD_EDIT_TASK_FILTER.LABEL.SORT',
                type: 'select',
                key: 'sort',
                value: this.taskFilter.sort || sortProperties[0].value,
                options: sortProperties
            },
            {
                label: 'ADF_CLOUD_EDIT_TASK_FILTER.LABEL.DIRECTION',
                type: 'select',
                key: 'order',
                value: this.taskFilter.order || this.sortDirections[0].value,
                options: [...this.sortDirections]
            },
            {
                label: 'ADF_CLOUD_EDIT_TASK_FILTER.LABEL.STAND_ALONE',
                type: 'checkbox',
                key: 'standalone',
                value: this.taskFilter.standalone || false
            },
            {
                label: 'ADF_CLOUD_EDIT_TASK_FILTER.LABEL.DUE_DATE',
                type: 'date-range',
                key: 'dueDateRange',
                attributes: { dateType: 'dueDateType', from: '_dueDateFrom', to: '_dueDateTo' },
                value: {
                    dueDateType: this.taskFilter.dueDateType || null,
                    _dueDateFrom: this.taskFilter.dueDateFrom || null,
                    _dueDateTo: this.taskFilter.dueDateTo || null
                },
                dateFilterOptions: [
                    DateCloudFilterType.NO_DATE,
                    DateCloudFilterType.TODAY,
                    DateCloudFilterType.TOMORROW,
                    DateCloudFilterType.NEXT_7_DAYS,
                    DateCloudFilterType.RANGE
                ]
            },
            {
                label: 'ADF_CLOUD_EDIT_TASK_FILTER.LABEL.COMPLETED_DATE',
                type: 'date-range',
                key: 'completedDateRange',
                attributes: { dateType: 'completedDateType', from: '_completedFrom', to: '_completedTo' },
                value: {
                    completedDateType: this.taskFilter.completedDateType || null,
                    _completedFrom: this.taskFilter.completedFrom || null,
                    _completedTo: this.taskFilter.completedTo || null
                }
            },
            {
                label: 'ADF_CLOUD_EDIT_TASK_FILTER.LABEL.CREATED_DATE',
                type: 'date-range',
                key: 'createdDateRange',
                attributes: { dateType: 'createdDateType', from: '_createdFrom', to: '_createdTo' },
                value: {
                    createdDateType: this.taskFilter.createdDateType || null,
                    _createdFrom: this.taskFilter.createdFrom || null,
                    _createdTo: this.taskFilter.createdTo || null
                }
            },
            {
                label: 'ADF_CLOUD_EDIT_TASK_FILTER.LABEL.COMPLETED_BY',
                type: 'people',
                key: 'completedBy',
                value: this.taskFilter.completedBy ? [this.taskFilter.completedBy] : null,
                selectionMode: 'single'
            },
            {
                label: 'ADF_CLOUD_EDIT_TASK_FILTER.LABEL.ASSIGNMENT',
                type: 'assignment',
                key: 'assignment',
                attributes: { assignee: 'assignee', candidateGroups: 'candidateGroups' },
                value: {
                    assignee: this.taskFilter.assignee || null,
                    candidateGroups: this.taskFilter.candidateGroups || []
                }
            }
        ];
    }
}
EditTaskFilterCloudComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-cloud-edit-task-filter',
                template: "<mat-accordion [hideToggle]=\"isLoading\">\n    <mat-expansion-panel (afterExpand)=\"onExpand()\" (closed)=\"onClose()\">\n        <mat-expansion-panel-header *ngIf=\"taskFilter\" id=\"adf-edit-task-filter-expansion-header\">\n            <ng-container *ngIf=\"!isLoading; else loadingTemplate\">\n                <mat-panel-title *ngIf=\"showTaskFilterName\" fxLayoutAlign=\"space-between center\" id=\"adf-edit-task-filter-title-id\"\n                    >{{taskFilter.name | translate}}</mat-panel-title>\n                <mat-panel-description fxLayoutAlign=\"space-between center\" id=\"adf-edit-task-filter-sub-title-id\">\n                    <span *ngIf=\"showTitle\">{{ 'ADF_CLOUD_EDIT_TASK_FILTER.TITLE' | translate}}</span>\n                    <div *ngIf=\"showFilterActions\" class=\"adf-cloud-edit-task-filter-actions\">\n                        <ng-container *ngIf=\"toggleFilterActions\">\n                            <button *ngFor=\"let filterAction of taskFilterActions\"\n                                    mat-icon-button\n                                    matTooltip=\"{{ filterAction.tooltip | translate}}\"\n                                    [attr.data-automation-id]=\"'adf-filter-action-' + filterAction.actionType\"\n                                    [disabled]=\"isDisabledAction(filterAction)\"\n                                    (click)=\"executeFilterActions(filterAction)\">\n                                <adf-icon [value]=\"filterAction.icon\"></adf-icon>\n                            </button>\n                        </ng-container>\n                    </div>\n                </mat-panel-description>\n            </ng-container>\n            <ng-template #loadingTemplate>\n                <div class=\"adf-cloud-edit-task-filter-loading-margin\">\n                    <mat-spinner [diameter]=\"30\"></mat-spinner>\n                </div>\n            </ng-template>\n        </mat-expansion-panel-header>\n        <ng-container *ngIf=\"!isLoading;\">\n            <form *ngIf=\"editTaskFilterForm\" [formGroup]=\"editTaskFilterForm\">\n                <div fxLayout=\"row wrap\" fxLayout.xs=\"column\" fxLayoutGap=\"10px\" fxLayoutAlign=\"start center\">\n                    <ng-container *ngFor=\"let taskFilterProperty of taskFilterProperties\">\n                        <mat-form-field fxFlex=\"23%\"\n                                        [floatLabel]=\"'auto'\"\n                                        *ngIf=\"taskFilterProperty.type === 'select'\"\n                                        [attr.data-automation-id]=\"taskFilterProperty.key\">\n                            <mat-select placeholder=\"{{taskFilterProperty.label | translate}}\"\n                                        [formControlName]=\"taskFilterProperty.key\"\n                                        [attr.data-automation-id]=\"'adf-cloud-edit-task-property-' + taskFilterProperty.key\">\n                                <mat-option *ngFor=\"let propertyOption of taskFilterProperty.options\"\n                                            [value]=\"propertyOption.value\"\n                                            [attr.data-automation-id]=\"'adf-cloud-edit-task-property-options-' + taskFilterProperty.key\">\n                                    {{ propertyOption.label | translate }}\n                                </mat-option>\n                            </mat-select>\n                        </mat-form-field>\n                        <mat-form-field fxFlex=\"23%\"\n                                        [floatLabel]=\"'auto'\"\n                                        *ngIf=\"taskFilterProperty.type === 'text'\"\n                                        [attr.data-automation-id]=\"taskFilterProperty.key\">\n                            <input matInput\n                                   [formControlName]=\"taskFilterProperty.key\"\n                                   type=\"text\"\n                                   placeholder=\"{{taskFilterProperty.label | translate}}\"\n                                   [attr.data-automation-id]=\"'adf-cloud-edit-task-property-' + taskFilterProperty.key\" />\n                        </mat-form-field>\n                        <mat-form-field fxFlex=\"23%\"\n                                        [floatLabel]=\"'auto'\"\n                                        *ngIf=\"taskFilterProperty.type === 'date'\"\n                                        [attr.data-automation-id]=\"taskFilterProperty.key\">\n                            <mat-label>{{taskFilterProperty.label | translate}}</mat-label>\n                            <input matInput\n                                   (keyup)=\"onDateChanged($any($event).srcElement.value, taskFilterProperty)\"\n                                   (dateChange)=\"onDateChanged($event.value, taskFilterProperty)\"\n                                   [matDatepicker]=\"dateController\"\n                                   placeholder=\"{{taskFilterProperty.label | translate}}\"\n                                   [attr.data-automation-id]=\"'adf-cloud-edit-task-property-' + taskFilterProperty.key\">\n                            <mat-datepicker-toggle matSuffix\n                                                   [for]=\"dateController\"\n                                                   [attr.data-automation-id]=\"'adf-cloud-edit-task-property-date-toggle-' + taskFilterProperty.key\">\n                            </mat-datepicker-toggle>\n                            <mat-datepicker #dateController\n                                            [attr.data-automation-id]=\"'adf-cloud-edit-task-property-date-picker-' + taskFilterProperty.key\">\n                            </mat-datepicker>\n                            <div class=\"adf-edit-task-filter-date-error-container\">\n                                <div *ngIf=\"hasError(taskFilterProperty)\">\n                                    <div class=\"adf-error-text\">{{'ADF_TASK_LIST.START_TASK.FORM.ERROR.DATE'|translate}}</div>\n                                    <mat-icon class=\"adf-error-icon\">warning</mat-icon>\n                                </div>\n                            </div>\n                        </mat-form-field>\n                        <div class=\"adf-edit-task-filter-checkbox\"\n                             *ngIf=\"taskFilterProperty.type === 'checkbox'\">\n                            <mat-checkbox color=\"primary\"\n                                          [formControlName]=\"taskFilterProperty.key\"\n                                          [attr.data-automation-id]=\"taskFilterProperty.key\"\n                            >{{taskFilterProperty.label | translate}}</mat-checkbox>\n                        </div>\n\n                        <adf-cloud-date-range-filter #dateRange\n                            *ngIf=\"taskFilterProperty.type === 'date-range'\"\n                            [processFilterProperty]=\"taskFilterProperty\"\n                            [options]=\"taskFilterProperty.dateFilterOptions\"\n                            (dateTypeChange)=\"onDateTypeChange($event, taskFilterProperty)\"\n                            (dateChanged)=\"onDateRangeFilterChanged($event, taskFilterProperty)\">\n                        </adf-cloud-date-range-filter>\n\n                        <div fxFlex=\"23%\" class=\"{{ 'adf-edit-task-filter-' + taskFilterProperty.key }}\" *ngIf=\"taskFilterProperty.type === 'people'\">\n                            <adf-cloud-people\n                                [preSelectUsers]=\"taskFilterProperty.value\"\n                                [title]=\"taskFilterProperty.label\"\n                                [validate]=\"true\"\n                                [appName]=\"appName\"\n                                [mode]=\"taskFilterProperty.selectionMode\"\n                                (changedUsers)=\"onChangedUser($event, taskFilterProperty)\">\n                            </adf-cloud-people>\n                        </div>\n\n                        <adf-cloud-task-assignment-filter fxFlex=\"23%\"\n                            *ngIf=\"taskFilterProperty.type === 'assignment'\"\n                            [taskFilterProperty]=\"taskFilterProperty\"\n                            (assignedChange)=\"onAssignedChange($event)\"\n                            (assignedGroupChange)=\"onAssignedGroupsChange($event)\">\n                        </adf-cloud-task-assignment-filter>\n                    </ng-container>\n                </div>\n            </form>\n        </ng-container>\n    </mat-expansion-panel>\n</mat-accordion>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-edit-task-filter-checkbox{flex:1 23%;font-size:16px;padding-top:10px;text-align:center}.adf-edit-task-filter-date-error-container{height:20px;margin-top:12px;position:absolute;width:100%}.adf-edit-task-filter-date-error-container>div{display:flex;flex-flow:row;justify-content:flex-start}.adf-edit-task-filter-date-error-container .adf-error-text{color:var(--theme-warn-color);font-size:10px;height:16px;line-height:1.33;padding-right:8px;width:auto}.adf-edit-task-filter-date-error-container .adf-error-icon{color:var(--theme-warn-color);font-size:16px}.adf-edit-task-filter-dateRange mat-grid-list{width:450px}.adf-cloud-edit-task-filter-loading-margin{margin-left:calc(50% - 50px);margin-right:calc(50% - 50px)}"]
            },] }
];
EditTaskFilterCloudComponent.ctorParameters = () => [
    { type: FormBuilder },
    { type: MatDialog },
    { type: TranslationService },
    { type: TaskFilterCloudService },
    { type: DateAdapter },
    { type: UserPreferencesService },
    { type: AppsProcessCloudService },
    { type: TaskCloudService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ServiceTaskFiltersCloudComponent extends BaseTaskFiltersCloudComponent {
    constructor(serviceTaskFilterCloudService, translationService) {
        super();
        this.serviceTaskFilterCloudService = serviceTaskFilterCloudService;
        this.translationService = translationService;
        this.filterSelected = new EventEmitter();
        this.filterClicked = new EventEmitter();
        this.filters = [];
    }
    ngOnInit() {
        this.getFilters(this.appName);
    }
    ngOnChanges(changes) {
        const appName = changes['appName'];
        const filter = changes['filterParam'];
        if (appName && appName.currentValue !== appName.previousValue) {
            this.getFilters(appName.currentValue);
        }
        else if (filter && filter.currentValue !== filter.previousValue) {
            this.selectFilterAndEmit(filter.currentValue);
        }
    }
    getFilters(appName) {
        this.filters$ = this.serviceTaskFilterCloudService.getTaskListFilters(appName);
        this.filters$.pipe(takeUntil(this.onDestroy$)).subscribe((res) => {
            this.resetFilter();
            this.filters = res || [];
            this.selectFilterAndEmit(this.filterParam);
            this.success.emit(res);
        }, (err) => {
            this.error.emit(err);
        });
    }
    selectFilter(paramFilter) {
        if (paramFilter) {
            this.currentFilter = this.filters.find((filter, index) => paramFilter.index === index ||
                paramFilter.key === filter.key ||
                paramFilter.id === filter.id ||
                (paramFilter.name &&
                    (paramFilter.name.toLocaleLowerCase() === this.translationService.instant(filter.name).toLocaleLowerCase())));
        }
    }
    selectFilterAndEmit(newParamFilter) {
        if (newParamFilter) {
            this.selectFilter(newParamFilter);
            if (this.currentFilter) {
                this.filterSelected.emit(this.currentFilter);
            }
        }
        else {
            this.currentFilter = undefined;
        }
    }
    onFilterClick(filter) {
        if (filter) {
            this.selectFilter(filter);
            this.filterClicked.emit(this.currentFilter);
        }
        else {
            this.currentFilter = undefined;
        }
    }
    selectDefaultTaskFilter() {
        if (!this.isFilterListEmpty()) {
            this.currentFilter = this.filters[0];
        }
    }
    isFilterListEmpty() {
        return this.filters === undefined || (this.filters && this.filters.length === 0);
    }
    resetFilter() {
        this.filters = [];
        this.currentFilter = undefined;
    }
}
ServiceTaskFiltersCloudComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-cloud-service-task-filters',
                template: "<ng-container *ngIf=\"filters$ | async as filterList; else loading\">\n    <div *ngFor=\"let filter of filterList\"\n         class=\"adf-task-filters__entry\">\n        <button (click)=\"onFilterClick(filter)\"\n                [attr.aria-label]=\"filter.name | translate\"\n                [id]=\"filter.id\"\n                [attr.data-automation-id]=\"filter.key + '_filter'\"\n                mat-button\n                [class.adf-active]=\"currentFilter === filter\"\n                class=\"adf-filter-action-button adf-full-width\"\n                fxLayout=\"row\"\n                fxLayoutAlign=\"space-between center\">\n            <adf-icon data-automation-id=\"adf-filter-icon\"\n                      *ngIf=\"showIcons\"\n                      [value]=\"filter.icon\"></adf-icon>\n            <span data-automation-id=\"adf-filter-label\"\n                  class=\"adf-filter-action-button__label\">{{ filter.name | translate }}</span>\n        </button>\n        <span *ngIf=\"counters$[filter.key]\"\n              [attr.data-automation-id]=\"filter.key + '_filter-counter'\"\n              class=\"adf-filter-action-button__counter\"\n              [class.adf-active]=wasFilterUpdated(filter.key)>\n            {{ counters$[filter.key] | async }}\n        </span>\n    </div>\n</ng-container>\n<ng-template #loading>\n    <ng-container>\n        <div class=\"adf-app-list-spinner\">\n            <mat-spinner></mat-spinner>\n        </div>\n    </ng-container>\n</ng-template>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-task-filters__entry{display:flex;font-size:14px!important;font-weight:700;height:24px;opacity:1;padding:12px 0!important;width:100%}.adf-task-filters__entry .adf-full-width{display:flex;width:100%}.adf-task-filters__entry .adf-filter-action-button{cursor:pointer;opacity:.54;padding:16px}.adf-task-filters__entry .adf-filter-action-button .adf-filter-action-button__label{margin:0 8px!important;padding-left:20px}.adf-task-filters__entry .adf-filter-action-button__counter{margin-left:10px;margin-top:6px;opacity:.54;padding:0 5px}.adf-task-filters__entry .adf-filter-action-button__counter.adf-active{background-color:var(--theme-accent-color);border-radius:15px;color:var(--theme-colors-mag-grey-light);font-size:smaller;margin-left:8px;margin-top:5px;padding:0 5px}.adf-task-filters__entry:hover{color:var(--theme-primary-color)}.adf-task-filters__entry:hover .adf-filter-action-button,.adf-task-filters__entry:hover .adf-filter-action-button__counter{opacity:1}.adf-task-filters__entry .adf-active{color:var(--theme-primary-color);opacity:1}"]
            },] }
];
ServiceTaskFiltersCloudComponent.ctorParameters = () => [
    { type: ServiceTaskFilterCloudService },
    { type: TranslationService }
];
ServiceTaskFiltersCloudComponent.propDecorators = {
    filterSelected: [{ type: Output }],
    filterClicked: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TaskAssignmentFilterCloudComponent {
    constructor(identityUserService) {
        this.identityUserService = identityUserService;
        this.assignedChange = new EventEmitter();
        this.assignedGroupChange = new EventEmitter();
        this.candidateGroups = [];
        this.groupForm = new FormControl('');
        this.assignmentTypeList = {
            unassigned: AssignmentType.UNASSIGNED,
            currentUser: AssignmentType.CURRENT_USER,
            candidateGroups: AssignmentType.CANDIDATE_GROUPS
        };
    }
    ngOnInit() {
        if (this.isFilterPropertyDefined()) {
            this.setDefaultAssignedGroups();
            this.setDefaultAssignmentType();
        }
    }
    isCandidateGroupsType() {
        return this.assignmentType === AssignmentType.CANDIDATE_GROUPS;
    }
    onAssignmentTypeChange(type) {
        this.candidateGroups = [];
        if (type === AssignmentType.CURRENT_USER) {
            this.assignedChange.emit(this.identityUserService.getCurrentUserInfo());
        }
        else if (type === AssignmentType.UNASSIGNED) {
            this.assignedChange.emit(null);
        }
    }
    onChangedGroups(groups) {
        this.assignedGroupChange.emit(groups);
    }
    setDefaultAssignmentType() {
        const assignmentAttr = this.taskFilterProperty.attributes['assignee'];
        const assignee = this.taskFilterProperty.value[assignmentAttr];
        if (this.candidateGroups.length > 0) {
            this.assignmentType = AssignmentType.CANDIDATE_GROUPS;
        }
        else if (assignee) {
            this.assignmentType = AssignmentType.CURRENT_USER;
        }
        else {
            this.assignmentType = AssignmentType.UNASSIGNED;
        }
    }
    setDefaultAssignedGroups() {
        const assignmentGroupsAttr = this.taskFilterProperty.attributes['candidateGroups'];
        this.candidateGroups = this.taskFilterProperty.value[assignmentGroupsAttr];
    }
    isFilterPropertyDefined() {
        return !!this.taskFilterProperty.attributes && !!this.taskFilterProperty.value;
    }
}
TaskAssignmentFilterCloudComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-cloud-task-assignment-filter',
                template: "<div class=\"adf-cloud-assignment-container\" fxLayout=\"row\">\n    <mat-form-field [floatLabel]=\"'auto'\">\n        <mat-select class=\"adf-task-assignment-filter\"\n                    placeholder=\"{{ 'ADF_CLOUD_TASK_ASSIGNEMNT_FILTER.ASSIGNMENT_TYPE' | translate }}\"\n                    [(ngModel)]=\"assignmentType\"\n                    (ngModelChange)=\"onAssignmentTypeChange(assignmentType)\">\n            <mat-option [value]=\"assignmentTypeList.currentUser\">{{ 'ADF_CLOUD_TASK_ASSIGNEMNT_FILTER.ASSIGNED_TO_ME' | translate }} </mat-option>\n            <mat-option [value]=\"assignmentTypeList.unassigned\">{{ 'ADF_CLOUD_TASK_ASSIGNEMNT_FILTER.UNASSIGNED' | translate }} </mat-option>\n            <mat-option [value]=\"assignmentTypeList.candidateGroups\">{{ 'ADF_CLOUD_TASK_ASSIGNEMNT_FILTER.LIST_OF_CANDIDATE_GROUPS' | translate }} </mat-option>\n        </mat-select>\n    </mat-form-field>\n\n    <adf-cloud-group class=\"adf-group-cloud-filter\" *ngIf=\"isCandidateGroupsType()\"\n        [mode]=\"'multiple'\"\n        [appName]=\"appName\"\n        [preSelectGroups]=\"candidateGroups\"\n        [searchGroupsControl]=\"groupForm\"\n        (changedGroups)=\"onChangedGroups($event)\"\n        [title]=\"'ADF_CLOUD_TASK_LIST.START_TASK.FORM.LABEL.CANDIDATE_GROUP'\"></adf-cloud-group>\n</div>\n",
                styles: [".adf-cloud-assignment-container{align-items:center}.adf-cloud-assignment-container mat-form-field{width:100%}.adf-task-assignment-filter{margin-right:10px}.adf-group-cloud-filter{flex:1;margin-left:15px;width:100%}"]
            },] }
];
TaskAssignmentFilterCloudComponent.ctorParameters = () => [
    { type: IdentityUserService }
];
TaskAssignmentFilterCloudComponent.propDecorators = {
    appName: [{ type: Input }],
    taskFilterProperty: [{ type: Input }],
    assignedChange: [{ type: Output }],
    assignedGroupChange: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class GroupCloudComponent {
    constructor(identityGroupService, logService) {
        this.identityGroupService = identityGroupService;
        this.logService = logService;
        this.mode = 'single';
        this.preSelectGroups = [];
        this.validate = false;
        this.readOnly = false;
        this.groupChipsCtrl = new FormControl({ value: '', disabled: false });
        this.searchGroupsControl = new FormControl({ value: '', disabled: false });
        this.roles = [];
        this.selectGroup = new EventEmitter();
        this.removeGroup = new EventEmitter();
        this.changedGroups = new EventEmitter();
        this.warning = new EventEmitter();
        this.searchGroups = [];
        this.onDestroy$ = new Subject();
        this.selectedGroups = [];
        this.invalidGroups = [];
        this.searchGroups$ = new BehaviorSubject(this.searchGroups);
        this._subscriptAnimationState = 'enter';
        this.searchedValue = '';
        this.validationLoading = false;
        this.searchLoading = false;
    }
    ngOnInit() {
        this.loadClientId();
        this.initSearch();
    }
    ngOnChanges(changes) {
        if (this.hasPreselectedGroupsChanged(changes) || this.hasModeChanged(changes) || this.isValidationChanged(changes)) {
            if (this.hasPreSelectGroups()) {
                this.loadPreSelectGroups();
            }
            else if (this.hasPreselectedGroupsCleared(changes)) {
                this.selectedGroups = [];
                this.invalidGroups = [];
            }
            if (!this.isValidationEnabled()) {
                this.invalidGroups = [];
            }
        }
        if (changes.appName && this.isAppNameChanged(changes.appName)) {
            this.loadClientId();
        }
    }
    isAppNameChanged(change) {
        return change
            && change.previousValue !== change.currentValue
            && this.appName
            && this.appName.length > 0;
    }
    loadClientId() {
        return __awaiter(this, void 0, void 0, function* () {
            this.clientId = yield this.identityGroupService.getClientIdByApplicationName(this.appName).toPromise();
            if (this.clientId) {
                this.searchGroupsControl.enable();
            }
        });
    }
    initSearch() {
        this.searchGroupsControl.valueChanges.pipe(filter((value) => {
            this.searchLoading = true;
            return typeof value === 'string';
        }), tap((value) => {
            if (value) {
                this.setTypingError();
            }
        }), debounceTime(500), distinctUntilChanged(), tap((value) => {
            if (value.trim()) {
                this.searchedValue = value;
            }
            else {
                this.searchGroupsControl.markAsPristine();
                this.searchGroupsControl.markAsUntouched();
            }
        }), tap(() => this.resetSearchGroups()), switchMap((name) => this.identityGroupService.findGroupsByName({ name: name.trim() })), mergeMap((groups) => {
            this.resetSearchGroups();
            this.searchLoading = false;
            return groups;
        }), filter(group => !this.isGroupAlreadySelected(group)), mergeMap(group => {
            if (this.appName) {
                return this.checkGroupHasAccess(group.id).pipe(mergeMap(hasRole => hasRole ? of(group) : of()));
            }
            else if (this.hasRoles()) {
                return this.filterGroupsByRoles(group);
            }
            else {
                return of(group);
            }
        }), takeUntil(this.onDestroy$)).subscribe(searchedGroup => {
            this.searchGroups.push(searchedGroup);
            this.searchGroups$.next(this.searchGroups);
        });
    }
    checkGroupHasAccess(groupId) {
        if (this.hasRoles()) {
            return this.identityGroupService.checkGroupHasAnyClientAppRole(groupId, this.clientId, this.roles);
        }
        else {
            return this.identityGroupService.checkGroupHasClientApp(groupId, this.clientId);
        }
    }
    isGroupAlreadySelected(group) {
        if (this.selectedGroups && this.selectedGroups.length > 0) {
            const result = this.selectedGroups.find((selectedGroup) => {
                return selectedGroup.name === group.name;
            });
            return !!result;
        }
        return false;
    }
    searchGroup(name) {
        return __awaiter(this, void 0, void 0, function* () {
            return (yield this.identityGroupService.findGroupsByName({ name }).toPromise())[0];
        });
    }
    getPreselectedGroups() {
        if (this.isSingleMode()) {
            return [this.preSelectGroups[0]];
        }
        else {
            return this.removeDuplicatedGroups(this.preSelectGroups);
        }
    }
    validatePreselectGroups() {
        return __awaiter(this, void 0, void 0, function* () {
            this.invalidGroups = [];
            for (const group of this.getPreselectedGroups()) {
                try {
                    const validationResult = yield this.searchGroup(group.name);
                    if (this.isPreselectedGroupInvalid(group, validationResult)) {
                        this.invalidGroups.push(group);
                    }
                }
                catch (error) {
                    this.invalidGroups.push(group);
                    this.logService.error(error);
                }
            }
            this.checkPreselectValidationErrors();
        });
    }
    checkPreselectValidationErrors() {
        this.invalidGroups = this.removeDuplicatedGroups(this.invalidGroups);
        if (this.invalidGroups.length > 0) {
            this.generateInvalidGroupsMessage();
        }
        this.warning.emit({
            message: 'INVALID_PRESELECTED_GROUPS',
            groups: this.invalidGroups
        });
    }
    generateInvalidGroupsMessage() {
        this.validateGroupsMessage = '';
        this.invalidGroups.forEach((invalidGroup, index) => {
            if (index === this.invalidGroups.length - 1) {
                this.validateGroupsMessage += `${invalidGroup.name} `;
            }
            else {
                this.validateGroupsMessage += `${invalidGroup.name}, `;
            }
        });
    }
    loadPreSelectGroups() {
        return __awaiter(this, void 0, void 0, function* () {
            this.selectedGroups = [];
            if (this.isSingleMode()) {
                this.selectedGroups = [this.preSelectGroups[0]];
            }
            else {
                this.selectedGroups = this.removeDuplicatedGroups(this.preSelectGroups);
            }
            this.groupChipsCtrl.setValue(this.selectedGroups[0].name);
            if (this.isValidationEnabled()) {
                this.validationLoading = true;
                yield this.validatePreselectGroups();
                this.validationLoading = false;
            }
        });
    }
    filterGroupsByRoles(group) {
        return this.identityGroupService.checkGroupHasRole(group.id, this.roles).pipe(map((hasRole) => ({ hasRole: hasRole, group: group })), filter((filteredGroup) => filteredGroup.hasRole), map((filteredGroup) => filteredGroup.group));
    }
    onSelect(group) {
        if (group) {
            this.selectGroup.emit(group);
            if (this.isMultipleMode()) {
                if (!this.isGroupAlreadySelected(group)) {
                    this.selectedGroups.push(group);
                }
            }
            else {
                this.invalidGroups = [];
                this.selectedGroups = [group];
            }
            this.groupInput.nativeElement.value = '';
            this.searchGroupsControl.setValue('');
            this.groupChipsCtrlValue(this.selectedGroups[0].name);
            this.changedGroups.emit(this.selectedGroups);
            this.resetSearchGroups();
        }
    }
    onRemove(groupToRemove) {
        this.removeGroup.emit(groupToRemove);
        this.removeGroupFromSelected(groupToRemove);
        this.changedGroups.emit(this.selectedGroups);
        if (this.selectedGroups.length === 0) {
            this.groupChipsCtrlValue('');
        }
        else {
            this.groupChipsCtrlValue(this.selectedGroups[0].name);
        }
        this.searchGroupsControl.markAsDirty();
        this.searchGroupsControl.markAsTouched();
        if (this.isValidationEnabled()) {
            this.removeGroupFromValidation(groupToRemove);
            this.checkPreselectValidationErrors();
        }
    }
    groupChipsCtrlValue(value) {
        this.groupChipsCtrl.setValue(value);
        this.groupChipsCtrl.markAsDirty();
        this.groupChipsCtrl.markAsTouched();
    }
    removeGroupFromSelected({ id, name }) {
        const indexToRemove = this.selectedGroups.findIndex(group => {
            return group.id === id && group.name === name;
        });
        if (indexToRemove !== -1) {
            this.selectedGroups.splice(indexToRemove, 1);
        }
    }
    removeGroupFromValidation({ id, name }) {
        const indexToRemove = this.invalidGroups.findIndex(group => {
            return group.id === id && group.name === name;
        });
        if (indexToRemove !== -1) {
            this.invalidGroups.splice(indexToRemove, 1);
        }
    }
    resetSearchGroups() {
        this.searchGroups = [];
        this.searchGroups$.next(this.searchGroups);
    }
    isPreselectedGroupInvalid(preselectedGroup, validatedGroup) {
        if (validatedGroup && validatedGroup.name !== undefined) {
            return preselectedGroup.name !== validatedGroup.name;
        }
        else {
            return true;
        }
    }
    isSingleMode() {
        return this.mode === 'single';
    }
    isSingleSelectionReadonly() {
        return this.isSingleMode() && this.selectedGroups.length === 1 && this.selectedGroups[0].readonly === true;
    }
    hasPreselectError() {
        return this.invalidGroups && this.invalidGroups.length > 0;
    }
    isReadonly() {
        return this.readOnly || this.isSingleSelectionReadonly();
    }
    isMultipleMode() {
        return this.mode === 'multiple';
    }
    getDisplayName(group) {
        return group ? group.name : '';
    }
    removeDuplicatedGroups(groups) {
        return groups.filter((group, index, self) => index === self.findIndex((auxGroup) => {
            return group.id === auxGroup.id && group.name === auxGroup.name;
        }));
    }
    hasPreSelectGroups() {
        return this.preSelectGroups && this.preSelectGroups.length > 0;
    }
    hasModeChanged(changes) {
        return changes
            && changes.mode
            && changes.mode.currentValue !== changes.mode.previousValue;
    }
    isValidationChanged(changes) {
        return changes
            && changes.validate
            && changes.validate.currentValue !== changes.validate.previousValue;
    }
    hasPreselectedGroupsChanged(changes) {
        return changes
            && changes.preSelectGroups
            && changes.preSelectGroups.currentValue !== changes.preSelectGroups.previousValue;
    }
    hasPreselectedGroupsCleared(changes) {
        return changes
            && changes.preSelectGroups
            && changes.preSelectGroups.currentValue.length === 0;
    }
    hasRoles() {
        return this.roles && this.roles.length > 0;
    }
    setTypingError() {
        this.searchGroupsControl.setErrors(Object.assign({ searchTypingError: true }, this.searchGroupsControl.errors));
    }
    hasError() {
        return !!this.searchGroupsControl.errors;
    }
    isValidationLoading() {
        return this.isValidationEnabled() && this.validationLoading;
    }
    setFocus(isFocused) {
        this.isFocused = isFocused;
    }
    isValidationEnabled() {
        return this.validate === true;
    }
    getValidationPattern() {
        return this.searchGroupsControl.errors.pattern.requiredPattern;
    }
    getValidationMaxLength() {
        return this.searchGroupsControl.errors.maxlength.requiredLength;
    }
    getValidationMinLength() {
        return this.searchGroupsControl.errors.minlength.requiredLength;
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
}
GroupCloudComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-cloud-group',
                template: "<form>\n    <mat-form-field class=\"adf-cloud-group\">\n        <mat-label *ngIf=\"!isReadonly()\"\n            id=\"adf-group-cloud-title-id\">{{ (title || 'ADF_CLOUD_GROUPS.SEARCH-GROUP') | translate }}</mat-label>\n        <mat-chip-list #groupChipList [disabled]=\"isReadonly() || isValidationLoading()\" data-automation-id=\"adf-cloud-group-chip-list\">\n            <mat-chip\n                *ngFor=\"let group of selectedGroups\"\n                [removable]=\"!(group.readonly)\"\n                [attr.data-automation-id]=\"'adf-cloud-group-chip-' + group.name\"\n                (removed)=\"onRemove(group)\"\n                matTooltip=\"{{ (group.readonly ? 'ADF_CLOUD_GROUPS.MANDATORY' : '') | translate }}\">\n                {{group.name}}\n                <mat-icon\n                    *ngIf=\"!(group.readonly || readOnly)\"\n                    matChipRemove [attr.data-automation-id]=\"'adf-cloud-group-chip-remove-icon-' + group.name\">\n                    cancel\n                </mat-icon>\n            </mat-chip>\n            <input *ngIf=\"!isReadonly()\" matInput\n                   [formControl]=\"searchGroupsControl\"\n                   [matAutocomplete]=\"auto\"\n                   [matChipInputFor]=\"groupChipList\"\n                   (focus)=\"setFocus(true)\"\n                   (blur)=\"setFocus(false)\"\n                   class=\"adf-group-input\"\n                   data-automation-id=\"adf-cloud-group-search-input\" #groupInput>\n        </mat-chip-list>\n\n        <mat-autocomplete\n            autoActiveFirstOption\n            #auto=\"matAutocomplete\"\n            class=\"adf-cloud-group-list\"\n            (optionSelected)=\"onSelect($event.option.value)\"\n            [displayWith]=\"getDisplayName\"\n            data-automation-id=\"adf-cloud-group-autocomplete\">\n            <ng-container *ngIf=\"(searchGroups$ | async)?.length else noResults\">\n                <mat-option *ngFor=\"let group of searchGroups$ | async; let i = index\" [value]=\"group\"\n                            [attr.data-automation-id]=\"'adf-cloud-group-chip-' + group.name\">\n                    <div class=\"adf-cloud-group-row\" id=\"adf-group-{{i}}\" fxLayout=\"row\" fxLayoutAlign=\"start center\"\n                         data-automation-id=\"adf-cloud-group-row\"\n                         fxLayoutGap=\"20px\">\n                        <button class=\"adf-group-short-name\" mat-fab>{{group | groupNameInitial }}</button>\n                        <span>{{group.name}}</span>\n                    </div>\n                </mat-option>\n            </ng-container>\n            <ng-template #noResults>\n                <mat-option *ngIf=\"searchGroupsControl.hasError('searchTypingError') && !searchLoading\" disabled\n                            class=\"adf-cloud-group-option-not-active\"\n                            data-automation-id=\"adf-cloud-group-no-results\">\n                    <span> {{ 'ADF_CLOUD_GROUPS.ERROR.NOT_FOUND' | translate : { groupName: searchedValue } }}</span>\n                </mat-option>\n            </ng-template>\n        </mat-autocomplete>\n    </mat-form-field>\n    <mat-progress-bar\n        *ngIf=\"validationLoading\"\n        mode=\"indeterminate\">\n    </mat-progress-bar>\n\n    <mat-error *ngIf=\"hasPreselectError() &&  !isValidationLoading()\">\n        <mat-icon class=\"adf-start-task-cloud-error-icon\">warning</mat-icon>\n        {{ 'ADF_CLOUD_GROUPS.ERROR.NOT_FOUND' | translate : { groupName : validateGroupsMessage } }}</mat-error>\n    <mat-error *ngIf=\"searchGroupsControl.hasError('pattern')\">\n        <mat-icon class=\"adf-start-task-cloud-error-icon\">warning</mat-icon>\n        {{ 'ADF_CLOUD_PEOPLE_GROUPS.ERROR.INVALID_PATTERN' | translate: { pattern: getValidationPattern() } }}</mat-error>\n    <mat-error *ngIf=\"searchGroupsControl.hasError('maxlength')\">\n        <mat-icon class=\"adf-start-task-cloud-error-icon\">warning</mat-icon>\n        {{ 'ADF_CLOUD_PEOPLE_GROUPS.ERROR.INVALID_MAX_LENGTH' | translate: { requiredLength: getValidationMaxLength() } }}\n    </mat-error>\n    <mat-error *ngIf=\"searchGroupsControl.hasError('minlength')\">\n        <mat-icon class=\"adf-start-task-cloud-error-icon\">warning</mat-icon>\n        {{ 'ADF_CLOUD_PEOPLE_GROUPS.ERROR.INVALID_MIN_LENGTH' | translate: { requiredLength: getValidationMinLength() } }}</mat-error>\n    <mat-error *ngIf=\"searchGroupsControl.hasError('required') || groupChipsCtrl.hasError('required')\">\n        <mat-icon class=\"adf-start-task-cloud-error-icon\">warning</mat-icon>\n        {{ 'ADF_CLOUD_PEOPLE_GROUPS.ERROR.REQUIRED' | translate }} </mat-error>\n    <mat-error *ngIf=\"searchGroupsControl.hasError('searchTypingError') && !this.isFocused\" data-automation-id=\"invalid-groups-typing-error\">\n        <mat-icon class=\"adf-start-task-cloud-error-icon\">warning</mat-icon>\n        {{ 'ADF_CLOUD_GROUPS.ERROR.NOT_FOUND' | translate : { groupName : searchedValue } }}</mat-error>\n</form>\n",
                animations: [
                    trigger('transitionMessages', [
                        state('enter', style({ opacity: 1, transform: 'translateY(0%)' })),
                        transition('void => enter', [
                            style({ opacity: 0, transform: 'translateY(-100%)' }),
                            animate('300ms cubic-bezier(0.55, 0, 0.55, 0.2)')
                        ])
                    ])
                ],
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-cloud-group-list{margin:5px 0;padding:10px 0}.adf-cloud-group{width:100%}.adf-cloud-group-option-not-active{background:inherit!important}.adf-cloud-group .mat-form-field{width:100%}.adf-cloud-group-error{height:20px;margin-top:-10px;position:absolute}.adf-cloud-group-error-message{color:var(--theme-warn-color);font-size:12px;height:16px;line-height:1.33;padding-right:8px;width:auto}.adf-cloud-group-error-icon{color:var(--theme-warn-color);font-size:17px}.mat-autocomplete-panel .mat-fab{background:var(--theme-primary-color);box-shadow:none!important;font-size:18px;font-weight:bolder;height:40px;width:40px}.mat-autocomplete-panel .mat-fab .mat-button-wrapper{display:inline!important}"]
            },] }
];
GroupCloudComponent.ctorParameters = () => [
    { type: IdentityGroupService },
    { type: LogService }
];
GroupCloudComponent.propDecorators = {
    appName: [{ type: Input }],
    title: [{ type: Input }],
    mode: [{ type: Input }],
    preSelectGroups: [{ type: Input }],
    validate: [{ type: Input }],
    readOnly: [{ type: Input }],
    groupChipsCtrl: [{ type: Input }],
    searchGroupsControl: [{ type: Input }],
    roles: [{ type: Input }],
    selectGroup: [{ type: Output }],
    removeGroup: [{ type: Output }],
    changedGroups: [{ type: Output }],
    warning: [{ type: Output }],
    groupInput: [{ type: ViewChild, args: ['groupInput',] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class InitialGroupNamePipe {
    transform(group) {
        let result = '';
        if (group) {
            result = this.getInitialGroupName(group.name).toUpperCase();
        }
        return result;
    }
    getInitialGroupName(groupName) {
        groupName = (groupName ? groupName[0] : '');
        return groupName;
    }
}
InitialGroupNamePipe.decorators = [
    { type: Pipe, args: [{
                name: 'groupNameInitial'
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class GroupCloudModule {
}
GroupCloudModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FlexLayoutModule,
                    MaterialModule,
                    FormsModule,
                    ReactiveFormsModule,
                    CoreModule
                ],
                declarations: [GroupCloudComponent, InitialGroupNamePipe],
                exports: [GroupCloudComponent, InitialGroupNamePipe]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ɵ0$1 = MOMENT_DATE_FORMATS;
class TaskFiltersCloudModule {
}
TaskFiltersCloudModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    FormsModule,
                    ReactiveFormsModule,
                    HttpClientModule,
                    CommonModule,
                    FlexLayoutModule,
                    MaterialModule,
                    AppListCloudModule,
                    CoreModule,
                    GroupCloudModule,
                    ProcessCommonModule,
                    PeopleCloudModule
                ],
                declarations: [
                    TaskFiltersCloudComponent,
                    ServiceTaskFiltersCloudComponent,
                    EditTaskFilterCloudComponent,
                    EditServiceTaskFilterCloudComponent,
                    TaskFilterDialogCloudComponent,
                    TaskAssignmentFilterCloudComponent
                ],
                exports: [
                    TaskFiltersCloudComponent,
                    ServiceTaskFiltersCloudComponent,
                    EditTaskFilterCloudComponent,
                    EditServiceTaskFilterCloudComponent
                ],
                providers: [
                    { provide: DateAdapter, useClass: MomentDateAdapter },
                    { provide: MAT_DATE_FORMATS, useValue: ɵ0$1 }
                ]
            },] }
];

const ɵ0$2 = MOMENT_DATE_FORMATS;
class StartTaskCloudComponent {
    constructor(taskService, dateAdapter, userPreferencesService, formBuilder, identityUserService, logService) {
        this.taskService = taskService;
        this.dateAdapter = dateAdapter;
        this.userPreferencesService = userPreferencesService;
        this.formBuilder = formBuilder;
        this.identityUserService = identityUserService;
        this.logService = logService;
        this.DATE_FORMAT = 'DD/MM/YYYY';
        this.appName = '';
        this.maxNameLength = StartTaskCloudComponent.MAX_NAME_LENGTH;
        this.name = '';
        this.success = new EventEmitter();
        this.cancel = new EventEmitter();
        this.error = new EventEmitter();
        this.submitted = false;
        this.candidateGroupNames = [];
        this.assigneeForm = new FormControl('');
        this.groupForm = new FormControl('');
        this.onDestroy$ = new Subject();
    }
    ngOnInit() {
        this.userPreferencesService
            .select(UserPreferenceValues.Locale)
            .pipe(takeUntil(this.onDestroy$))
            .subscribe(locale => this.dateAdapter.setLocale(locale));
        this.loadCurrentUser();
        this.buildForm();
        this.loadDefaultPriorities();
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
    buildForm() {
        this.taskForm = this.formBuilder.group({
            name: new FormControl(this.name, [Validators.required, Validators.maxLength(this.getMaxNameLength()), this.whitespaceValidator]),
            priority: new FormControl(''),
            description: new FormControl('', [this.whitespaceValidator]),
            formKey: new FormControl()
        });
    }
    getMaxNameLength() {
        return this.maxNameLength > StartTaskCloudComponent.MAX_NAME_LENGTH ?
            StartTaskCloudComponent.MAX_NAME_LENGTH : this.maxNameLength;
    }
    loadCurrentUser() {
        this.currentUser = this.identityUserService.getCurrentUserInfo();
        this.assigneeName = this.currentUser.username;
    }
    loadDefaultPriorities() {
        this.priorities = this.taskService.priorities;
    }
    saveTask() {
        this.submitted = true;
        const newTask = Object.assign(this.taskForm.value);
        newTask.dueDate = this.dueDate;
        newTask.assignee = this.assigneeName;
        newTask.formKey = this.formKey;
        newTask.candidateGroups = this.candidateGroupNames;
        this.createNewTask(new StartTaskCloudRequestModel(newTask));
    }
    createNewTask(newTask) {
        this.taskService.createNewTask(newTask, this.appName)
            .subscribe((res) => {
            this.submitted = false;
            this.success.emit(res);
        }, (err) => {
            this.submitted = false;
            this.error.emit(err);
            this.logService.error('An error occurred while creating new task');
        });
    }
    onCancel() {
        this.cancel.emit();
    }
    onDateChanged(newDateValue) {
        this.dateError = false;
        if (newDateValue) {
            const momentDate = moment(newDateValue, this.DATE_FORMAT, true);
            if (!momentDate.isValid()) {
                this.dateError = true;
            }
        }
    }
    onAssigneeSelect(assignee) {
        this.assigneeName = assignee ? assignee.username : '';
    }
    onAssigneeRemove() {
        this.assigneeName = '';
    }
    onCandidateGroupSelect(candidateGroup) {
        if (candidateGroup.name) {
            this.candidateGroupNames.push(candidateGroup.name);
        }
    }
    onCandidateGroupRemove(candidateGroup) {
        if (candidateGroup.name) {
            this.candidateGroupNames = this.candidateGroupNames.filter((name) => {
                return name !== candidateGroup.name;
            });
        }
    }
    canStartTask() {
        return !(this.dateError ||
            !this.taskForm.valid ||
            this.submitted ||
            this.assignee.hasError() ||
            this.candidateGroups.hasError());
    }
    whitespaceValidator(control) {
        const isWhitespace = (control.value || '').trim().length === 0;
        const isValid = control.value.length === 0 || !isWhitespace;
        return isValid ? null : { 'whitespace': true };
    }
    get nameController() {
        return this.taskForm.get('name');
    }
    get priorityController() {
        return this.taskForm.get('priority');
    }
    get assigneeFormControl() {
        return this.assigneeForm;
    }
    get candidateUserFormControl() {
        return this.groupForm;
    }
    onFormSelect(formKey) {
        this.formKey = formKey || '';
    }
}
StartTaskCloudComponent.MAX_NAME_LENGTH = 255;
StartTaskCloudComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-cloud-start-task',
                template: "<mat-card>\n    <mat-card-header fxLayout=\"row\" fxLayoutAlign=\"start center\" fxLayoutGap=\"10px\"\n                     class=\"adf-cloud-start-task-heading\">\n        <mat-card-title>{{'ADF_CLOUD_TASK_LIST.START_TASK.FORM.TITLE' | translate}}</mat-card-title>\n    </mat-card-header>\n    <form [formGroup]=\"taskForm\" fxLayout=\"column\" (ngSubmit)=\"saveTask()\">\n\n        <mat-card-content>\n            <div class=\"adf-task-name\">\n                <mat-form-field fxFlex>\n                    <mat-label>{{'ADF_CLOUD_TASK_LIST.START_TASK.FORM.LABEL.NAME' | translate }}</mat-label>\n                    <input\n                        matInput\n                        id=\"name_id\"\n                        class=\"form-control\"\n                        formControlName=\"name\">\n                    <mat-error *ngIf=\"nameController.hasError('required')\">\n                        {{ 'ADF_CLOUD_START_TASK.ERROR.REQUIRED' | translate }}\n                    </mat-error>\n                    <mat-error *ngIf=\"nameController.hasError('maxlength')\">\n                        {{ 'ADF_CLOUD_START_TASK.ERROR.MAXIMUM_LENGTH' | translate : {characters: maxNameLength} }}\n                    </mat-error>\n                </mat-form-field>\n            </div>\n            <div fxLayout=\"row\" fxLayout.lt-md=\"column\" fxLayoutGap=\"20px\" fxLayoutGap.lt-md=\"0px\">\n                <mat-form-field fxFlex>\n                    <mat-label>{{'ADF_CLOUD_TASK_LIST.START_TASK.FORM.LABEL.DESCRIPTION' | translate}}</mat-label>\n                    <textarea\n                        matInput\n                        class=\"form-control\"\n                        id=\"description_id\"\n                        formControlName=\"description\">\n                    </textarea>\n                </mat-form-field>\n\n                <mat-form-field fxFlex class=\"adf-cloud-priority-container\">\n                    <mat-label>{{ 'ADF_CLOUD_TASK_LIST.START_TASK.FORM.LABEL.PRIORITY' | translate }}</mat-label>\n                    <mat-select formControlName=\"priority\">\n                        <mat-option *ngFor=\"let priorityOption of priorities\" [value]=\"priorityOption.value\">{{ priorityOption.label | translate }}</mat-option>\n                    </mat-select>\n                </mat-form-field>\n            </div>\n            <div fxLayout=\"row\" fxLayout.lt-md=\"column\" fxLayoutGap=\"20px\" fxLayoutGap.lt-md=\"0px\">\n                <mat-form-field fxFlex>\n                    <input matInput\n                           [matDatepicker]=\"taskDatePicker\"\n                           (keydown)=\"true\"\n                           (focusout)=\"onDateChanged($any($event).srcElement.value)\"\n                           placeholder=\"{{'ADF_CLOUD_TASK_LIST.START_TASK.FORM.LABEL.DATE'|translate}}\"\n                           [(ngModel)]=\"dueDate\"\n                           [ngModelOptions]=\"{standalone: true}\"\n                           id=\"date_id\">\n                    <mat-datepicker-toggle matSuffix [for]=\"taskDatePicker\"></mat-datepicker-toggle>\n                    <mat-datepicker #taskDatePicker\n                                    [touchUi]=\"true\"\n                                    (dateChanged)=\"onDateChanged($event)\">\n                    </mat-datepicker>\n                    <div class=\"adf-cloud-date-error-container\">\n                        <div *ngIf=\"dateError\">\n                            <div class=\"adf-error-text\">{{'ADF_CLOUD_START_TASK.ERROR.DATE' | translate}}</div>\n                            <mat-icon class=\"adf-error-icon\">warning</mat-icon>\n                        </div>\n                    </div>\n                </mat-form-field>\n                <adf-cloud-people fxFlex #peopleInput *ngIf=\"currentUser\"\n                                  [appName]=\"appName\"\n                                  [preSelectUsers]=\"[currentUser]\"\n                                  [searchUserCtrl]=\"assigneeFormControl\"\n                                  (selectUser)=\"onAssigneeSelect($event)\"\n                                  [title]=\"'ADF_CLOUD_TASK_LIST.START_TASK.FORM.LABEL.ASSIGNEE'\"\n                                  (removeUser)=\"onAssigneeRemove()\"></adf-cloud-people>\n            </div>\n\n            <div fxLayout=\"row\" fxLayout.lt-md=\"column\" fxLayoutGap=\"20px\" fxLayoutGap.lt-md=\"0px\">\n                <adf-cloud-group fxFlex #groupInput *ngIf=\"currentUser\"\n                                 [mode]=\"'multiple'\"\n                                 [title]=\"'ADF_CLOUD_TASK_LIST.START_TASK.FORM.LABEL.CANDIDATE_GROUP'\"\n                                 [appName]=\"appName\"\n                                 [searchGroupsControl]=\"candidateUserFormControl\"\n                                 (selectGroup)=\"onCandidateGroupSelect($event)\"\n                                 (removeGroup)=\"onCandidateGroupRemove($event)\">\n                </adf-cloud-group>\n                <adf-cloud-form-definition-selector *ngIf=\"appName\"\n                                                    fxFlex\n                                                    [appName]=\"appName\"\n                                                    (selectForm)=\"onFormSelect($event)\">\n                </adf-cloud-form-definition-selector>\n            </div>\n        </mat-card-content>\n\n        <mat-card-actions>\n            <div class=\"adf-cloud-start-task-footer\" fxLayout=\"row\" fxLayoutAlign=\"end end\">\n                <button\n                    mat-button\n                    type=\"button\"\n                    (click)=\"onCancel()\"\n                    id=\"button-cancel\">\n                    {{'ADF_CLOUD_TASK_LIST.START_TASK.FORM.ACTION.CANCEL'|translate}}\n                </button>\n                <button\n                    color=\"primary\"\n                    type=\"submit\"\n                    [disabled]=\"!canStartTask()\"\n                    mat-button\n                    id=\"button-start\">\n                    {{'ADF_CLOUD_TASK_LIST.START_TASK.FORM.ACTION.START'|translate}}\n                </button>\n            </div>\n        </mat-card-actions>\n    </form>\n</mat-card>\n",
                providers: [
                    { provide: DateAdapter, useClass: MomentDateAdapter },
                    { provide: MAT_DATE_FORMATS, useValue: ɵ0$2 }
                ],
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-cloud-start-task-heading{border-bottom:1px solid var(--theme-fg-divider);margin-bottom:10px}.adf-cloud-start-task-heading .mat-card-title{font-size:18px;font-weight:700}.adf-cloud-priority-container{padding-top:1.1em}.adf-cloud-date-error-container{height:20px;margin-top:12px;position:absolute;width:100%}.adf-cloud-date-error-container>div{display:flex;flex-flow:row;justify-content:flex-start}.adf-cloud-date-error-container .adf-error-text{color:var(--theme-warn-color);font-size:12px;height:16px;line-height:1.33;padding-right:8px;width:auto}.adf-cloud-date-error-container .adf-error-icon{color:var(--theme-warn-color);font-size:17px}.adf-cloud-start-task-footer{border-top:1px solid #eee;font-size:18px;padding:4px}adf-cloud-start-task .adf-cloud-start-task-footer .mat-button{text-transform:uppercase!important}"]
            },] }
];
StartTaskCloudComponent.ctorParameters = () => [
    { type: TaskCloudService },
    { type: DateAdapter },
    { type: UserPreferencesService },
    { type: FormBuilder },
    { type: IdentityUserService },
    { type: LogService }
];
StartTaskCloudComponent.propDecorators = {
    appName: [{ type: Input }],
    maxNameLength: [{ type: Input }],
    name: [{ type: Input }],
    success: [{ type: Output }],
    cancel: [{ type: Output }],
    error: [{ type: Output }],
    assignee: [{ type: ViewChild, args: ['peopleInput',] }],
    candidateGroups: [{ type: ViewChild, args: ['groupInput',] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TaskVariableCloud {
    constructor(obj) {
        this.id = obj.name || null;
        this.name = obj.name || null;
        this.value = this.hasValue(obj) ? obj.value : null;
        this.type = obj.type || null;
    }
    hasValue(obj) {
        return typeof obj.value !== undefined && obj.value !== null;
    }
}

class FormCloudService extends BaseCloudService {
    constructor(apiService, appConfigService) {
        super(apiService, appConfigService);
    }
    get uploadApi() {
        var _a;
        this._uploadApi = (_a = this._uploadApi) !== null && _a !== void 0 ? _a : new UploadApi(this.apiService.getInstance());
        return this._uploadApi;
    }
    getTaskForm(appName, taskId, version) {
        return this.getTask(appName, taskId).pipe(switchMap(task => {
            return this.getForm(appName, task.formKey, version).pipe(map((form) => {
                const flattenForm = Object.assign(Object.assign(Object.assign({}, form.formRepresentation), form.formRepresentation.formDefinition), { taskId: task.id, taskName: task.name, processDefinitionId: task.processDefinitionId, processInstanceId: task.processInstanceId });
                delete flattenForm.formDefinition;
                return flattenForm;
            }));
        }));
    }
    saveTaskForm(appName, taskId, processInstanceId, formId, values) {
        const apiUrl = `${this.getBasePath(appName)}/form/v1/forms/${formId}/save`;
        const saveFormRepresentation = {
            values,
            taskId,
            processInstanceId
        };
        return this.post(apiUrl, saveFormRepresentation).pipe(map((res) => res.entry));
    }
    createTemporaryRawRelatedContent(file, nodeId, contentHost) {
        const changedConfig = this.apiService.lastConfig;
        changedConfig.provider = 'ALL';
        changedConfig.hostEcm = contentHost.replace('/alfresco', '');
        this.apiService.getInstance().setConfig(changedConfig);
        return from(this.uploadApi.uploadFile(file, '', nodeId, '', { overwrite: true })).pipe(map((res) => res.entry));
    }
    completeTaskForm(appName, taskId, processInstanceId, formId, formValues, outcome, version) {
        const apiUrl = `${this.getBasePath(appName)}/form/v1/forms/${formId}/submit/versions/${version}`;
        const completeFormRepresentation = {
            values: formValues,
            taskId: taskId,
            processInstanceId: processInstanceId
        };
        if (outcome) {
            completeFormRepresentation.outcome = outcome;
        }
        return this.post(apiUrl, completeFormRepresentation).pipe(map((res) => res.entry));
    }
    getTask(appName, taskId) {
        const apiUrl = `${this.getBasePath(appName)}/query/v1/tasks/${taskId}`;
        return this.get(apiUrl).pipe(map((res) => res.entry));
    }
    getTaskVariables(appName, taskId) {
        const apiUrl = `${this.getBasePath(appName)}/query/v1/tasks/${taskId}/variables`;
        return this.get(apiUrl).pipe(map((res) => {
            return res.list.entries.map((variable) => new TaskVariableCloud(variable.entry));
        }));
    }
    getForm(appName, formKey, version) {
        let url = `${this.getBasePath(appName)}/form/v1/forms/${formKey}`;
        if (version) {
            url += `/versions/${version}`;
        }
        return this.get(url);
    }
    getRestWidgetData(formName, widgetId, body = {}) {
        var _a;
        const appName = (_a = this.appConfigService.get('alfresco-deployed-apps')[0]) === null || _a === void 0 ? void 0 : _a.name;
        const apiUrl = `${this.getBasePath(appName)}/form/v1/forms/${formName}/values/${widgetId}`;
        return this.post(apiUrl, body);
    }
    parseForm(json, data, readOnly = false) {
        if (json) {
            const flattenForm = Object.assign(Object.assign({}, json.formRepresentation), json.formRepresentation.formDefinition);
            delete flattenForm.formDefinition;
            const formValues = {};
            (data || []).forEach(variable => {
                formValues[variable.name] = variable.value;
            });
            const form = new FormModel(flattenForm, formValues, readOnly);
            if (!json.fields) {
                form.outcomes = [
                    new FormOutcomeModel(form, {
                        id: '$save',
                        name: FormOutcomeModel.SAVE_ACTION,
                        isSystem: true
                    })
                ];
            }
            return form;
        }
        return null;
    }
}
FormCloudService.ɵprov = ɵɵdefineInjectable({ factory: function FormCloudService_Factory() { return new FormCloudService(ɵɵinject(AlfrescoApiService), ɵɵinject(AppConfigService)); }, token: FormCloudService, providedIn: "root" });
FormCloudService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
FormCloudService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: AppConfigService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FormCloudComponent extends FormBaseComponent {
    constructor(formCloudService, formService, visibilityService) {
        super();
        this.formCloudService = formCloudService;
        this.formService = formService;
        this.visibilityService = visibilityService;
        this.appName = '';
        this.fieldValidators = [...FORM_FIELD_VALIDATORS];
        this.formSaved = new EventEmitter();
        this.formCompleted = new EventEmitter();
        this.formLoaded = new EventEmitter();
        this.formDataRefreshed = new EventEmitter();
        this.formContentClicked = new EventEmitter();
        this.subscriptions = [];
        this.onDestroy$ = new Subject();
        this.formService.formContentClicked
            .pipe(takeUntil(this.onDestroy$))
            .subscribe((content) => {
            if (content instanceof UploadWidgetContentLinkModel) {
                this.form.setNodeIdValueForViewersLinkedToUploadWidget(content);
                this.onFormDataRefreshed(this.form);
            }
            else {
                this.formContentClicked.emit(content);
            }
        });
        this.formService.updateFormValuesRequested
            .pipe(takeUntil(this.onDestroy$))
            .subscribe((valuesToSetIfNotPresent) => {
            this.form.addValuesNotPresent(valuesToSetIfNotPresent);
            this.onFormDataRefreshed(this.form);
        });
    }
    onKeyDown(event) {
        event.cancelBubble = true;
    }
    ngOnChanges(changes) {
        const appName = changes['appName'];
        if (appName && appName.currentValue) {
            if (this.taskId) {
                this.getFormByTaskId(appName.currentValue, this.taskId, this.appVersion);
            }
            else if (this.formId) {
                this.getFormById(appName.currentValue, this.formId, this.appVersion);
            }
            return;
        }
        const formId = changes['formId'];
        if (formId && formId.currentValue && this.appName) {
            this.getFormById(this.appName, formId.currentValue, this.appVersion);
            return;
        }
        const taskId = changes['taskId'];
        if (taskId && taskId.currentValue && this.appName) {
            this.getFormByTaskId(this.appName, taskId.currentValue, this.appVersion);
            return;
        }
        const data = changes['data'];
        if (data && data.currentValue) {
            this.refreshFormData();
            return;
        }
    }
    onRefreshClicked() {
        this.loadForm();
    }
    loadForm() {
        if (this.appName && this.taskId) {
            this.getFormByTaskId(this.appName, this.taskId, this.appVersion);
        }
        else if (this.appName && this.formId) {
            this.getFormById(this.appName, this.formId, this.appVersion);
        }
    }
    findProcessVariablesByTaskId(appName, taskId) {
        return this.formCloudService.getTask(appName, taskId).pipe(switchMap(task => {
            if (this.isAProcessTask(task)) {
                return this.formCloudService.getTaskVariables(appName, taskId);
            }
            else {
                return of([]);
            }
        }));
    }
    isAProcessTask(taskRepresentation) {
        return taskRepresentation.processDefinitionId && taskRepresentation.processDefinitionDeploymentId !== 'null';
    }
    getFormByTaskId(appName, taskId, version) {
        return new Promise(resolve => {
            forkJoin(this.formCloudService.getTaskForm(appName, taskId, version), this.formCloudService.getTaskVariables(appName, taskId))
                .pipe(takeUntil(this.onDestroy$))
                .subscribe((data) => {
                this.formCloudRepresentationJSON = data[0];
                this.formCloudRepresentationJSON.processVariables = data[1];
                this.data = data[1];
                const parsedForm = this.parseForm(this.formCloudRepresentationJSON);
                this.visibilityService.refreshVisibility(parsedForm, this.data);
                parsedForm.validateForm();
                this.form = parsedForm;
                this.form.nodeId = '-my-';
                this.onFormLoaded(this.form);
                resolve(this.form);
            }, (error) => {
                this.handleError(error);
                resolve(null);
            });
        });
    }
    getFormById(appName, formId, appVersion) {
        this.formCloudService
            .getForm(appName, formId, appVersion)
            .pipe(map((form) => {
            const flattenForm = Object.assign(Object.assign({}, form.formRepresentation), form.formRepresentation.formDefinition);
            delete flattenForm.formDefinition;
            return flattenForm;
        }), takeUntil(this.onDestroy$))
            .subscribe((form) => {
            this.formCloudRepresentationJSON = form;
            const parsedForm = this.parseForm(form);
            this.visibilityService.refreshVisibility(parsedForm);
            parsedForm.validateForm();
            this.form = parsedForm;
            this.form.nodeId = '-my-';
            this.onFormLoaded(this.form);
        }, (error) => {
            this.handleError(error);
        });
    }
    saveTaskForm() {
        if (this.form && this.appName && this.taskId) {
            this.formCloudService
                .saveTaskForm(this.appName, this.taskId, this.processInstanceId, `${this.form.id}`, this.form.values)
                .pipe(takeUntil(this.onDestroy$))
                .subscribe(() => {
                this.onTaskSaved(this.form);
            }, (error) => this.onTaskSavedError(error));
        }
    }
    completeTaskForm(outcome) {
        if (this.form && this.appName && this.taskId) {
            this.formCloudService
                .completeTaskForm(this.appName, this.taskId, this.processInstanceId, `${this.form.id}`, this.form.values, outcome, this.appVersion)
                .pipe(takeUntil(this.onDestroy$))
                .subscribe(() => {
                this.onTaskCompleted(this.form);
            }, (error) => this.onTaskCompletedError(error));
        }
    }
    parseForm(formCloudRepresentationJSON) {
        if (formCloudRepresentationJSON) {
            const formValues = {};
            (this.data || []).forEach(variable => {
                formValues[variable.name] = variable.value;
            });
            const form = new FormModel(formCloudRepresentationJSON, formValues, this.readOnly);
            if (!form) {
                form.outcomes = this.getFormDefinitionOutcomes(form);
            }
            if (this.fieldValidators && this.fieldValidators.length > 0) {
                form.fieldValidators = this.fieldValidators;
            }
            return form;
        }
        return null;
    }
    getFormDefinitionOutcomes(form) {
        return [
            new FormOutcomeModel(form, { id: '$save', name: FormOutcomeModel.SAVE_ACTION, isSystem: true })
        ];
    }
    checkVisibility(field) {
        if (field && field.form) {
            this.visibilityService.refreshVisibility(field.form);
        }
    }
    refreshFormData() {
        this.form = this.parseForm(this.formCloudRepresentationJSON);
        this.onFormLoaded(this.form);
        this.onFormDataRefreshed(this.form);
    }
    onFormLoaded(form) {
        this.formLoaded.emit(form);
    }
    onFormDataRefreshed(form) {
        this.formDataRefreshed.emit(form);
    }
    onTaskSaved(form) {
        this.formSaved.emit(form);
    }
    onTaskSavedError(error) {
        this.handleError(error);
    }
    onTaskCompleted(form) {
        this.formCompleted.emit(form);
    }
    onTaskCompletedError(error) {
        this.handleError(error);
    }
    onExecuteOutcome(outcome) {
        const args = new FormOutcomeEvent(outcome);
        if (args.defaultPrevented) {
            return false;
        }
        this.executeOutcome.emit(args);
        return !args.defaultPrevented;
    }
    storeFormAsMetadata() {
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
}
FormCloudComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-cloud-form',
                template: "<div *ngIf=\"!hasForm()\">\n    <ng-content select=\"[empty-form]\">\n    </ng-content>\n</div>\n\n<div *ngIf=\"hasForm()\" class=\"adf-form-container\">\n    <mat-card>\n        <mat-card-header *ngIf=\"showTitle || showRefreshButton || showValidationIcon\">\n            <mat-card-title>\n                <h4>\n                    <div *ngIf=\"showValidationIcon\" class=\"adf-form-validation-button\">\n                        <i id=\"adf-valid-form-icon\" class=\"material-icons\"\n                            *ngIf=\"form.isValid; else no_valid_form\">check_circle</i>\n                        <ng-template #no_valid_form>\n                            <i id=\"adf-invalid-form-icon\" class=\"material-icons adf-invalid-color\">error</i>\n                        </ng-template>\n                    </div>\n                    <div *ngIf=\"showRefreshButton\" class=\"adf-form-reload-button\">\n                        <button mat-icon-button (click)=\"onRefreshClicked()\">\n                            <mat-icon>refresh</mat-icon>\n                        </button>\n                    </div>\n                    <span *ngIf=\"isTitleEnabled()\" class=\"adf-form-title\" [matTooltip]=\"form.taskName\">\n                        {{form.taskName}}\n                        <ng-container *ngIf=\"!form.taskName\">\n                            {{'FORM.FORM_RENDERER.NAMELESS_TASK' | translate}}\n                        </ng-container>\n                    </span>\n\n                </h4>\n            </mat-card-title>\n        </mat-card-header>\n        <mat-card-content>\n            <adf-form-renderer [formDefinition]=\"form\">\n            </adf-form-renderer>\n        </mat-card-content>\n        <mat-card-actions *ngIf=\"form.hasOutcomes()\" class=\"adf-form-mat-card-actions\">\n            <ng-content select=\"adf-cloud-form-custom-outcomes\"></ng-content>\n            <ng-container *ngFor=\"let outcome of form.outcomes\">\n                <button *ngIf=\"outcome.isVisible\" [id]=\"'adf-form-'+ outcome.name  | formatSpace\" [color]=\"getColorForOutcome(outcome.name)\"\n                    mat-button [disabled]=\"!isOutcomeButtonEnabled(outcome)\"\n                    [class.adf-form-hide-button]=\"!isOutcomeButtonVisible(outcome, form.readOnly)\"\n                    (click)=\"onOutcomeClicked(outcome)\">\n                    {{outcome.name | translate | uppercase }}\n                </button>\n            </ng-container>\n        </mat-card-actions>\n    </mat-card>\n</div>\n"
            },] }
];
FormCloudComponent.ctorParameters = () => [
    { type: FormCloudService },
    { type: FormService },
    { type: WidgetVisibilityService }
];
FormCloudComponent.propDecorators = {
    appName: [{ type: Input }],
    appVersion: [{ type: Input }],
    formId: [{ type: Input }],
    processInstanceId: [{ type: Input }],
    form: [{ type: Input }],
    taskId: [{ type: Input }],
    data: [{ type: Input }],
    fieldValidators: [{ type: Input }],
    formSaved: [{ type: Output }],
    formCompleted: [{ type: Output }],
    formLoaded: [{ type: Output }],
    formDataRefreshed: [{ type: Output }],
    formContentClicked: [{ type: Output }],
    onKeyDown: [{ type: HostListener, args: ['keydown', ['$event'],] }]
};

class FormDefinitionSelectorCloudService extends BaseCloudService {
    constructor(apiService, appConfigService) {
        super(apiService, appConfigService);
    }
    getForms(appName) {
        const url = `${this.getBasePath(appName)}/form/v1/forms`;
        return this.get(url).pipe(map((data) => {
            return data.map((formData) => {
                return formData.formRepresentation;
            });
        }));
    }
    getStandAloneTaskForms(appName) {
        return from(this.getForms(appName)).pipe(map((data) => {
            return data.filter((formData) => formData.standalone || formData.standalone === undefined);
        }));
    }
}
FormDefinitionSelectorCloudService.ɵprov = ɵɵdefineInjectable({ factory: function FormDefinitionSelectorCloudService_Factory() { return new FormDefinitionSelectorCloudService(ɵɵinject(AlfrescoApiService), ɵɵinject(AppConfigService)); }, token: FormDefinitionSelectorCloudService, providedIn: "root" });
FormDefinitionSelectorCloudService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
FormDefinitionSelectorCloudService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: AppConfigService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FormDefinitionSelectorCloudComponent {
    constructor(formDefinitionCloudService) {
        this.formDefinitionCloudService = formDefinitionCloudService;
        this.appName = '';
        this.selectForm = new EventEmitter();
    }
    ngOnInit() {
        this.forms$ = this.formDefinitionCloudService.getStandAloneTaskForms(this.appName);
    }
    onSelect(event) {
        this.selectForm.emit(event.value);
    }
}
FormDefinitionSelectorCloudComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-cloud-form-definition-selector',
                template: "<mat-form-field class=\"adf-form-definition-selector\">\n    <mat-label>{{'ADF_CLOUD_TASK_LIST.START_TASK.FORM.LABEL.FORM'|translate}}</mat-label>\n    <mat-select class=\"adf-form-selector-dropdown\" (selectionChange)=\"onSelect($event)\">\n        <mat-option [value]=\"''\">{{'ADF_CLOUD_TASK_LIST.START_TASK.FORM.LABEL.NONE'|translate}}</mat-option>\n        <mat-option *ngFor=\"let form of forms$ | async\" [value]=\"form.id\">{{ form.name }}</mat-option>\n    </mat-select>\n</mat-form-field>\n",
                styles: [".adf-form-definition-selector{width:100%}"]
            },] }
];
FormDefinitionSelectorCloudComponent.ctorParameters = () => [
    { type: FormDefinitionSelectorCloudService }
];
FormDefinitionSelectorCloudComponent.propDecorators = {
    appName: [{ type: Input }],
    selectForm: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FormCustomOutcomesComponent {
}
FormCustomOutcomesComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-cloud-form-custom-outcomes',
                template: '<ng-content></ng-content>'
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ɵ0$3 = MOMENT_DATE_FORMATS;
class DateCloudWidgetComponent extends WidgetComponent {
    constructor(formService, dateAdapter, userPreferencesService) {
        super(formService);
        this.formService = formService;
        this.dateAdapter = dateAdapter;
        this.userPreferencesService = userPreferencesService;
        this.typeId = 'DateCloudWidgetComponent';
        this.DATE_FORMAT_CLOUD = 'YYYY-MM-DD';
        this.onDestroy$ = new Subject();
    }
    ngOnInit() {
        this.userPreferencesService
            .select(UserPreferenceValues.Locale)
            .pipe(takeUntil(this.onDestroy$))
            .subscribe(locale => this.dateAdapter.setLocale(locale));
        const momentDateAdapter = this.dateAdapter;
        momentDateAdapter.overrideDisplayFormat = this.field.dateDisplayFormat;
        if (this.field) {
            if (this.field.minValue) {
                this.minDate = moment(this.field.minValue, this.DATE_FORMAT_CLOUD);
            }
            if (this.field.maxValue) {
                this.maxDate = moment(this.field.maxValue, this.DATE_FORMAT_CLOUD);
            }
        }
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
    onDateChanged(newDateValue) {
        const date = moment(newDateValue, this.field.dateDisplayFormat, true);
        if (date.isValid()) {
            this.field.value = date.format(this.field.dateDisplayFormat);
        }
        else {
            this.field.value = newDateValue;
        }
        this.onFieldChanged(this.field);
    }
}
DateCloudWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'date-widget',
                providers: [
                    { provide: DateAdapter, useClass: MomentDateAdapter },
                    { provide: MAT_DATE_FORMATS, useValue: ɵ0$3 }
                ],
                template: "<div class=\"{{field.className}}\" id=\"data-widget\" [class.adf-invalid]=\"!field.isValid\">\n    <mat-form-field class=\"adf-date-widget\">\n        <label class=\"adf-label\" [attr.for]=\"field.id\">{{field.name | translate }} ({{field.dateDisplayFormat}})<span *ngIf=\"isRequired()\">*</span></label>\n        <input matInput\n               [id]=\"field.id\"\n               [value]=\"field.value\"\n               [required]=\"isRequired()\"\n               [disabled]=\"field.readOnly\"\n               (change)=\"onDateChanged($any($event).srcElement.value)\"\n               [placeholder]=\"field.placeholder\"\n               [matTooltip]=\"field.tooltip\"\n               matTooltipPosition=\"above\"\n               matTooltipShowDelay=\"1000\">\n        <mat-datepicker-toggle  matSuffix [for]=\"datePicker\" [disabled]=\"field.readOnly\" ></mat-datepicker-toggle>\n    </mat-form-field>\n    <error-widget [error]=\"field.validationSummary\"></error-widget>\n    <error-widget *ngIf=\"isInvalidFieldRequired()\" required=\"{{ 'FORM.FIELD.REQUIRED' | translate }}\"></error-widget>\n    <mat-datepicker #datePicker [touchUi]=\"true\" [startAt]=\"field.value | adfMomentDate: field.dateDisplayFormat\" [disabled]=\"field.readOnly\"></mat-datepicker>\n    <input\n        type=\"hidden\"\n        [matDatepicker]=\"datePicker\"\n        [value]=\"field.value | adfMomentDate: field.dateDisplayFormat\"\n        [min]=\"minDate\"\n        [max]=\"maxDate\"\n        [disabled]=\"field.readOnly\"\n        (dateInput)=\"onDateChanged($any($event).targetElement.value)\">\n</div>\n",
                host: {
                    '(click)': 'event($event)',
                    '(blur)': 'event($event)',
                    '(change)': 'event($event)',
                    '(focus)': 'event($event)',
                    '(focusin)': 'event($event)',
                    '(focusout)': 'event($event)',
                    '(input)': 'event($event)',
                    '(invalid)': 'event($event)',
                    '(select)': 'event($event)'
                },
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-date-widget .mat-form-field-suffix{top:26px}.adf-date-widget .mat-form-field-label-wrapper{top:20px}"]
            },] }
];
DateCloudWidgetComponent.ctorParameters = () => [
    { type: FormService },
    { type: DateAdapter },
    { type: UserPreferencesService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DropdownCloudWidgetComponent extends WidgetComponent {
    constructor(formService, formCloudService, logService) {
        super(formService);
        this.formService = formService;
        this.formCloudService = formCloudService;
        this.logService = logService;
        this.typeId = 'DropdownCloudWidgetComponent';
        this.onDestroy$ = new Subject();
    }
    ngOnInit() {
        if (this.hasRestUrl() && !this.isLinkedWidget()) {
            this.persistFieldOptionsFromRestApi();
        }
        if (this.isLinkedWidget()) {
            this.loadFieldOptionsForLinkedWidget();
            this.formService.formFieldValueChanged
                .pipe(filter((event) => this.isFormFieldEventOfTypeDropdown(event) && this.isParentFormFieldEvent(event)), takeUntil(this.onDestroy$))
                .subscribe((event) => {
                const valueOfParentWidget = event.field.value;
                this.parentValueChanged(valueOfParentWidget);
            });
        }
    }
    persistFieldOptionsFromRestApi() {
        if (this.isValidRestType()) {
            const bodyParam = this.buildBodyParam();
            this.formCloudService.getRestWidgetData(this.field.form.id, this.field.id, bodyParam)
                .pipe(takeUntil(this.onDestroy$))
                .subscribe((result) => {
                this.field.options = result;
                this.field.updateForm();
            }, (err) => this.handleError(err));
        }
    }
    buildBodyParam() {
        const bodyParam = Object.assign({});
        if (this.isLinkedWidget()) {
            const parentWidgetValue = this.getParentWidgetValue();
            const parentWidgetId = this.getLinkedWidgetId();
            bodyParam[parentWidgetId] = parentWidgetValue;
        }
        return bodyParam;
    }
    loadFieldOptionsForLinkedWidget() {
        const parentWidgetValue = this.getParentWidgetValue();
        this.parentValueChanged(parentWidgetValue);
    }
    getParentWidgetValue() {
        const parentWidgetId = this.getLinkedWidgetId();
        const parentWidget = this.getFormFieldById(parentWidgetId);
        return parentWidget === null || parentWidget === void 0 ? void 0 : parentWidget.value;
    }
    parentValueChanged(value) {
        if (this.isValidValue(value)) {
            this.isValidRestType() ? this.persistFieldOptionsFromRestApi() : this.persistFieldOptionsFromManualList(value);
        }
        else if (this.isDefaultValue(value)) {
            this.addDefaultOption();
        }
    }
    isValidValue(value) {
        return !!value && value !== DropdownCloudWidgetComponent.DEFAULT_OPTION.id;
    }
    isDefaultValue(value) {
        return value === DropdownCloudWidgetComponent.DEFAULT_OPTION.id;
    }
    getFormFieldById(fieldId) {
        return this.field.form.getFormFields().filter((field) => field.id === fieldId)[0];
    }
    persistFieldOptionsFromManualList(value) {
        if (this.hasRuleEntries()) {
            const rulesEntries = this.getRuleEntries();
            rulesEntries.forEach((ruleEntry) => {
                if (ruleEntry.key === value) {
                    this.field.options = ruleEntry.options;
                    this.field.updateForm();
                }
            });
        }
    }
    getRuleEntries() {
        return this.field.rule.entries;
    }
    hasRuleEntries() {
        return !!this.getRuleEntries().length;
    }
    addDefaultOption() {
        this.field.options = [DropdownCloudWidgetComponent.DEFAULT_OPTION];
    }
    selectionChangedForField(field) {
        const formFieldValueChangedEvent = new FormFieldEvent(field.form, field);
        this.formService.formFieldValueChanged.next(formFieldValueChangedEvent);
        this.onFieldChanged(field);
    }
    isParentFormFieldEvent(event) {
        return event.field.id === this.getLinkedWidgetId();
    }
    isFormFieldEventOfTypeDropdown(event) {
        return event.field.type === FormFieldTypes.DROPDOWN;
    }
    hasRestUrl() {
        var _a;
        return !!((_a = this.field) === null || _a === void 0 ? void 0 : _a.restUrl);
    }
    isLinkedWidget() {
        return !!this.getLinkedWidgetId();
    }
    getLinkedWidgetId() {
        var _a, _b;
        return (_b = (_a = this.field) === null || _a === void 0 ? void 0 : _a.rule) === null || _b === void 0 ? void 0 : _b.ruleOn;
    }
    compareDropdownValues(opt1, opt2) {
        if (!opt1 || !opt2) {
            return false;
        }
        if (typeof opt1 === 'string' && typeof opt2 === 'object') {
            return opt1 === opt2.id || opt1 === opt2.name;
        }
        if (typeof opt1 === 'object' && typeof opt2 === 'string') {
            return opt1.id === opt2 || opt1.name === opt2;
        }
        if (typeof opt1 === 'object' && typeof opt2 === 'object') {
            return opt1.id === opt2.id || opt1.name === opt2.name;
        }
        return opt1 === opt2;
    }
    getOptionValue(option, fieldValue) {
        if (this.field.hasMultipleValues) {
            return option;
        }
        let optionValue = '';
        if (option.id === DropdownCloudWidgetComponent.DEFAULT_OPTION.id || option.name !== fieldValue) {
            optionValue = option.id;
        }
        else {
            optionValue = option.name;
        }
        return optionValue;
    }
    isValidRestType() {
        return this.field.optionType === 'rest' && !!this.field.restUrl;
    }
    handleError(error) {
        this.logService.error(error);
    }
    isReadOnlyType() {
        return this.field.type === 'readonly';
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
}
DropdownCloudWidgetComponent.DEFAULT_OPTION = {
    id: 'empty',
    name: 'Choose one...'
};
DropdownCloudWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'dropdown-cloud-widget',
                template: "<div class=\"adf-dropdown-widget {{field.className}}\"\n     [class.adf-invalid]=\"!field.isValid\" [class.adf-readonly]=\"field.readOnly\">\n    <div class=\"adf-dropdown-widget-top-labels\">\n        <label class=\"adf-label\" [attr.for]=\"field.id\">{{field.name | translate }}<span\n            *ngIf=\"isRequired()\">*</span></label>\n        <label class=\"adf-label adf-dropdown-widget-linked\"\n               *ngIf=\"isLinkedWidget()\"\n               [attr.for]=\"field.id\">\n            {{ 'FORM.FIELD.DEPENDS_ON' | translate: { widgetId: getLinkedWidgetId() } }}\n        </label>\n    </div>\n    <mat-form-field>\n        <mat-select class=\"adf-select\"\n                    [id]=\"field.id\"\n                    [(ngModel)]=\"field.value\"\n                    [disabled]=\"field.readOnly\"\n                    [compareWith]=\"compareDropdownValues\"\n                    (ngModelChange)=\"selectionChangedForField(field)\"\n                    [matTooltip]=\"field.tooltip\"\n                    matTooltipPosition=\"above\"\n                    matTooltipShowDelay=\"1000\"\n                    [multiple]=\"field.hasMultipleValues\">\n            <mat-option *ngFor=\"let opt of field.options\"\n                        [value]=\"getOptionValue(opt, field.value)\"\n                        [id]=\"opt.id\">{{opt.name}}\n            </mat-option>\n            <mat-option id=\"readonlyOption\" *ngIf=\"isReadOnlyType()\" [value]=\"field.value\">{{field.value}}</mat-option>\n        </mat-select>\n    </mat-form-field>\n    <error-widget [error]=\"field.validationSummary\"></error-widget>\n    <error-widget class=\"adf-dropdown-required-message\" *ngIf=\"isInvalidFieldRequired()\"\n                  required=\"{{ 'FORM.FIELD.REQUIRED' | translate }}\"></error-widget>\n</div>\n",
                host: {
                    '(click)': 'event($event)',
                    '(blur)': 'event($event)',
                    '(change)': 'event($event)',
                    '(focus)': 'event($event)',
                    '(focusin)': 'event($event)',
                    '(focusout)': 'event($event)',
                    '(input)': 'event($event)',
                    '(invalid)': 'event($event)',
                    '(select)': 'event($event)'
                },
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-dropdown-widget{margin-top:13px;width:100%}.adf-dropdown-widget .adf-select{padding-top:0!important;width:100%}.adf-dropdown-widget .mat-select-value-text{font-size:14px}.adf-dropdown-widget-top-labels{display:flex;flex-direction:row;height:16px;justify-content:space-between}.adf-dropdown-widget-top-labels .adf-dropdown-widget-linked{display:contents}.adf-dropdown-widget-select{width:100%}.adf-dropdown-widget-dropdown-required-message .adf-error-text-container{margin-top:1px!important}"]
            },] }
];
DropdownCloudWidgetComponent.ctorParameters = () => [
    { type: FormService },
    { type: FormCloudService },
    { type: LogService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class GroupCloudWidgetComponent extends WidgetComponent {
    constructor(formService) {
        super(formService);
        this.onDestroy$ = new Subject();
        this.typeId = 'GroupCloudWidgetComponent';
    }
    ngOnInit() {
        if (this.field) {
            this.roles = this.field.roles;
            this.mode = this.field.optionType;
            this.title = this.field.placeholder;
            this.preSelectGroup = this.field.value ? this.field.value : [];
        }
        this.search = new FormControl({ value: '', disabled: this.field.readOnly }, []),
            this.search.statusChanges
                .pipe(filter((value) => {
                return value === 'INVALID';
            }), takeUntil(this.onDestroy$))
                .subscribe(() => {
                this.field.markAsInvalid();
                this.field.form.markAsInvalid();
            });
        this.search.statusChanges
            .pipe(filter((value) => {
            return value === 'VALID';
        }), takeUntil(this.onDestroy$))
            .subscribe(() => {
            this.field.validate();
            this.field.form.validateForm();
        });
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
    onChangedGroup(groups) {
        this.field.value = [...groups];
        this.onFieldChanged(this.field);
    }
    isMultipleMode() {
        return this.mode === 'multiple';
    }
}
GroupCloudWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'group-cloud-widget',
                template: "<div class=\"adf-dropdown-widget {{field.className}}\"\n     [class.adf-invalid]=\"!field.isValid\" [class.adf-readonly]=\"field.readOnly\">\n    <label class=\"adf-label\" [attr.for]=\"field.id\">{{field.name | translate }}<span\n        *ngIf=\"isRequired()\">*</span></label>\n        <adf-cloud-group [mode]=\"mode\"\n                         [title]=\"title\"\n                         [readOnly]=\"field.readOnly\"\n                         [roles]=\"roles\"\n                         [searchGroupsControl]=\"search\"\n                         (changedGroups)=\"onChangedGroup($event)\"\n                         [preSelectGroups]=\"preSelectGroup\"\n                         [matTooltip]=\"field.tooltip\"\n                         [matTooltipPosition]=\"'above'\"\n                         [matTooltipShowDelay]=\"1000\">\n        </adf-cloud-group>\n        <error-widget [error]=\"field.validationSummary\"></error-widget>\n        <error-widget class=\"adf-dropdown-required-message\" *ngIf=\"isInvalidFieldRequired()\"\n                  required=\"{{ 'FORM.FIELD.REQUIRED' | translate }}\"></error-widget>\n</div>\n\n",
                host: {
                    '(click)': 'event($event)',
                    '(blur)': 'event($event)',
                    '(change)': 'event($event)',
                    '(focus)': 'event($event)',
                    '(focusin)': 'event($event)',
                    '(focusout)': 'event($event)',
                    '(input)': 'event($event)',
                    '(invalid)': 'event($event)',
                    '(select)': 'event($event)'
                },
                encapsulation: ViewEncapsulation.None
            },] }
];
GroupCloudWidgetComponent.ctorParameters = () => [
    { type: FormService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PeopleCloudWidgetComponent extends WidgetComponent {
    constructor(formService) {
        super(formService);
        this.onDestroy$ = new Subject();
        this.typeId = 'PeopleCloudWidgetComponent';
    }
    ngOnInit() {
        if (this.field) {
            this.roles = this.field.roles;
            this.mode = this.field.optionType;
            this.title = this.field.placeholder;
            this.preSelectUsers = this.field.value ? this.field.value : [];
        }
        this.search = new FormControl({ value: '', disabled: this.field.readOnly }, []),
            this.search.statusChanges
                .pipe(filter((value) => {
                return value === 'INVALID';
            }), takeUntil(this.onDestroy$))
                .subscribe(() => {
                this.field.markAsInvalid();
                this.field.form.markAsInvalid();
            });
        this.search.statusChanges
            .pipe(filter((value) => {
            return value === 'VALID';
        }), takeUntil(this.onDestroy$))
            .subscribe(() => {
            this.field.validate();
            this.field.form.validateForm();
        });
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
    onChangedUser(users) {
        this.field.value = [...users];
        this.onFieldChanged(this.field);
    }
    isMultipleMode() {
        return this.mode === 'multiple';
    }
}
PeopleCloudWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'people-cloud-widget',
                template: "<div class=\"adf-dropdown-widget {{field.className}}\"\n     [class.adf-invalid]=\"!field.isValid\" [class.adf-readonly]=\"field.readOnly\">\n    <label class=\"adf-label\" [attr.for]=\"field.id\">{{field.name | translate }}<span *ngIf=\"isRequired()\">*</span></label>\n        <adf-cloud-people\n            [preSelectUsers]=\"preSelectUsers\"\n            [validate]=\"true\"\n            [appName]=\"appName\"\n            [title]=\"title\"\n            [readOnly]=\"field.readOnly\"\n            [searchUserCtrl]=\"search\"\n            (changedUsers)=\"onChangedUser($event)\"\n            [roles]=\"roles\"\n            [mode]=\"mode\"\n            [matTooltip]=\"field.tooltip\"\n            matTooltipPosition=\"above\"\n            matTooltipShowDelay=\"1000\">\n        </adf-cloud-people>\n    <error-widget [error]=\"field.validationSummary\"></error-widget>\n</div>\n\n",
                host: {
                    '(click)': 'event($event)',
                    '(blur)': 'event($event)',
                    '(change)': 'event($event)',
                    '(focus)': 'event($event)',
                    '(focusin)': 'event($event)',
                    '(focusout)': 'event($event)',
                    '(input)': 'event($event)',
                    '(invalid)': 'event($event)',
                    '(select)': 'event($event)'
                },
                encapsulation: ViewEncapsulation.None
            },] }
];
PeopleCloudWidgetComponent.ctorParameters = () => [
    { type: FormService }
];

class ContentCloudNodeSelectorService {
    constructor(apiService, notificationService, logService, dialog) {
        this.apiService = apiService;
        this.notificationService = notificationService;
        this.logService = logService;
        this.dialog = dialog;
        this.sourceNodeNotFound = false;
    }
    get nodesApi() {
        var _a;
        this._nodesApi = (_a = this._nodesApi) !== null && _a !== void 0 ? _a : new NodesApi(this.apiService.getInstance());
        return this._nodesApi;
    }
    openUploadFileDialog(currentFolderId, selectionMode, isAllFileSources, restrictRootToCurrentFolderId) {
        const select = new Subject();
        select.subscribe({ complete: this.close.bind(this) });
        const data = {
            title: 'Select a file',
            actionName: NodeAction.ATTACH,
            currentFolderId,
            restrictRootToCurrentFolderId,
            select,
            selectionMode,
            isSelectionValid: (entry) => entry.isFile,
            showFilesInResult: true,
            showDropdownSiteList: false,
            showLocalUploadButton: isAllFileSources
        };
        this.openContentNodeDialog(data, 'adf-content-node-selector-dialog', '66%');
        return select;
    }
    getNodeIdFromPath(destinationFolderPath) {
        return __awaiter(this, void 0, void 0, function* () {
            if (destinationFolderPath.alias && destinationFolderPath.path) {
                try {
                    return yield this.getNodeId(destinationFolderPath.alias, destinationFolderPath.path).toPromise();
                }
                catch (error) {
                    this.logService.error(error);
                }
            }
            return this.getNodeId(destinationFolderPath.alias).toPromise();
        });
    }
    getNodeIdFromFolderVariableValue(variableValue, defaultAlias) {
        return __awaiter(this, void 0, void 0, function* () {
            const isExistingNode = yield this.isExistingNode(variableValue);
            return isExistingNode ? variableValue : this.getNodeId(defaultAlias).toPromise();
        });
    }
    isExistingNode(nodeId) {
        return __awaiter(this, void 0, void 0, function* () {
            let isExistingNode = false;
            if (nodeId) {
                try {
                    isExistingNode = yield this.getNodeId(nodeId).pipe(mapTo(true)).toPromise();
                }
                catch (error) {
                    this.logService.error(error);
                }
            }
            return isExistingNode;
        });
    }
    getNodeId(nodeId, relativePath) {
        let opts;
        if (relativePath) {
            opts = { relativePath };
        }
        return from(this.nodesApi.getNode(nodeId, opts)).pipe(map((nodeEntry) => nodeEntry.entry.id), catchError((error) => {
            this.sourceNodeNotFound = true;
            return this.handleError(error);
        }));
    }
    openContentNodeDialog(data, currentPanelClass, chosenWidth) {
        const contentNodeDialog = this.dialog.open(ContentNodeSelectorComponent, { data, panelClass: currentPanelClass, width: chosenWidth });
        contentNodeDialog.afterOpened().subscribe(() => {
            if (this.sourceNodeNotFound) {
                this.notificationService.showWarning('ADF_CLOUD_TASK_FORM.ERROR.DESTINATION_FOLDER_PATH_ERROR');
            }
        });
        contentNodeDialog.afterClosed().subscribe(() => {
            this.sourceNodeNotFound = false;
        });
    }
    close() {
        this.dialog.closeAll();
    }
    handleError(error) {
        return throwError(error || 'Server error');
    }
}
ContentCloudNodeSelectorService.ɵprov = ɵɵdefineInjectable({ factory: function ContentCloudNodeSelectorService_Factory() { return new ContentCloudNodeSelectorService(ɵɵinject(AlfrescoApiService), ɵɵinject(NotificationService), ɵɵinject(LogService), ɵɵinject(MatDialog)); }, token: ContentCloudNodeSelectorService, providedIn: "root" });
ContentCloudNodeSelectorService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
ContentCloudNodeSelectorService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: NotificationService },
    { type: LogService },
    { type: MatDialog }
];

class ProcessCloudContentService {
    constructor(apiService, logService, contentService, downloadService) {
        this.apiService = apiService;
        this.logService = logService;
        this.contentService = contentService;
        this.downloadService = downloadService;
    }
    get uploadApi() {
        var _a;
        this._uploadApi = (_a = this._uploadApi) !== null && _a !== void 0 ? _a : new UploadApi(this.apiService.getInstance());
        return this._uploadApi;
    }
    get authenticationApi() {
        var _a;
        this._authenticationApi = (_a = this._authenticationApi) !== null && _a !== void 0 ? _a : new AuthenticationApi(this.apiService.getInstance());
        return this._authenticationApi;
    }
    createTemporaryRawRelatedContent(file, nodeId) {
        return from(this.uploadApi.uploadFile(file, '', nodeId, '', { overwrite: true })).pipe(map((res) => {
            return Object.assign(Object.assign({}, res.entry), { nodeId: res.entry.id });
        }), catchError(err => this.handleError(err)));
    }
    getRawContentNode(nodeId) {
        return this.contentService.getNodeContent(nodeId);
    }
    downloadNodeContent(blob, fileName) {
        this.contentService.downloadBlob(blob, fileName);
    }
    downloadFile(nodeId) {
        return __awaiter(this, void 0, void 0, function* () {
            const ticket = yield this.getAuthTicket();
            const url = this.contentService.getContentUrl(nodeId, true, ticket);
            this.downloadService.downloadUrl(url, nodeId);
        });
    }
    getAuthTicket() {
        return __awaiter(this, void 0, void 0, function* () {
            const ticket = yield this.authenticationApi.getTicket();
            if (ticket && ticket.entry) {
                return ticket.entry.id || '';
            }
            return '';
        });
    }
    handleError(error) {
        this.logService.error(error);
        return throwError(error || 'Server error');
    }
}
ProcessCloudContentService.ɵprov = ɵɵdefineInjectable({ factory: function ProcessCloudContentService_Factory() { return new ProcessCloudContentService(ɵɵinject(AlfrescoApiService), ɵɵinject(LogService), ɵɵinject(ContentService), ɵɵinject(DownloadService)); }, token: ProcessCloudContentService, providedIn: "root" });
ProcessCloudContentService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
ProcessCloudContentService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: LogService },
    { type: ContentService },
    { type: DownloadService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FormCloudRepresentation {
    constructor(obj) {
        this.id = obj.id || null;
        this.name = obj.name || null;
        this.description = obj.description || null;
        this.version = obj.version || null;
        this.tabs = obj.tabs || null;
        this.fields = obj.fields || null;
        this.outcomes = obj.outcomes || null;
        this.metadata = obj.metadata || null;
        this.variables = obj.variables || null;
        this.taskId = obj.taskId || null;
        this.taskName = obj.taskName || null;
        this.processDefinitionId = obj.processDefinitionId || null;
        this.processInstanceId = obj.processInstanceId || null;
        this.selectedOutcome = obj.selectedOutcome || null;
    }
}
var FileSourceTypes;
(function (FileSourceTypes) {
    FileSourceTypes["ALL_FILE_SOURCES_SERVICE_ID"] = "all-file-sources";
    FileSourceTypes["ALFRESCO_CONTENT_SOURCES_SERVICE_ID"] = "alfresco-content";
})(FileSourceTypes || (FileSourceTypes = {}));
var DestinationFolderPathType;
(function (DestinationFolderPathType) {
    DestinationFolderPathType["STATIC_TYPE"] = "value";
    DestinationFolderPathType["STRING_TYPE"] = "string";
    DestinationFolderPathType["FOLDER_TYPE"] = "folder";
})(DestinationFolderPathType || (DestinationFolderPathType = {}));

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class UploadCloudWidgetComponent extends WidgetComponent {
    constructor(formService, thumbnailService, processCloudContentService, notificationService, logService) {
        super(formService);
        this.thumbnailService = thumbnailService;
        this.processCloudContentService = processCloudContentService;
        this.notificationService = notificationService;
        this.logService = logService;
        this.multipleOption = '';
    }
    ngOnInit() {
        if (this.field &&
            this.field.value &&
            this.field.value.length > 0) {
            this.hasFile = true;
            this.fixIncompatibilityFromPreviousAndNewForm([]);
        }
        this.getMultipleFileParam();
        this.setDestinationFolderPathFromMappedVariable();
    }
    removeFile(file) {
        if (this.field) {
            this.removeElementFromList(file);
        }
    }
    onFileChanged(event) {
        const files = [];
        const filesSaved = [];
        for (const file of Array.from(event.target.files)) {
            if (!this.isUploaded(file)) {
                files.push(file);
            }
            else {
                this.notificationService.showWarning('FORM.FIELD.FILE_ALREADY_UPLOADED');
            }
        }
        if (files && files.length > 0) {
            from(files)
                .pipe(mergeMap((file) => this.uploadRawContent(file)))
                .subscribe((res) => {
                filesSaved.push(res);
            }, (error) => this.logService.error(`Error uploading file. See console output for more details. ${error}`), () => {
                this.fixIncompatibilityFromPreviousAndNewForm(filesSaved);
                this.hasFile = true;
            });
        }
    }
    isUploaded(file) {
        const current = this.field.value || [];
        return current.some(entry => entry.name === file.name);
    }
    fixIncompatibilityFromPreviousAndNewForm(filesSaved) {
        const value = [...this.field.value || []];
        value.push(...filesSaved || []);
        this.field.value = value;
        this.field.form.values[this.field.id] = value;
        this.hasFile = value.length > 0;
    }
    getIcon(mimeType) {
        return this.thumbnailService.getMimeTypeIcon(mimeType);
    }
    uploadRawContent(file) {
        return this.processCloudContentService.createTemporaryRawRelatedContent(file, this.field.form.nodeId);
    }
    getMultipleFileParam() {
        if (this.field &&
            this.field.params &&
            this.field.params.multiple) {
            this.multipleOption = this.field.params.multiple ? 'multiple' : '';
        }
    }
    get uploadedFiles() {
        const result = this.field.value || this.field.form.values[this.field.id];
        return result || [];
    }
    removeElementFromList(file) {
        const filteredValues = this.uploadedFiles.filter(value => value.id !== file.id);
        this.resetFormValues(filteredValues);
    }
    resetFormValues(values) {
        if (values && values.length > 0) {
            this.field.value = values;
            this.field.form.values[this.field.id] = values;
            this.hasFile = true;
        }
        else {
            this.field.value = [];
            this.field.form.values[this.field.id] = [];
            this.hasFile = false;
        }
    }
    fileClicked(file) {
        this.formService.formContentClicked.next(file);
    }
    isAlfrescoAndLocal() {
        var _a, _b, _c;
        return ((_c = (_b = (_a = this.field) === null || _a === void 0 ? void 0 : _a.params) === null || _b === void 0 ? void 0 : _b.fileSource) === null || _c === void 0 ? void 0 : _c.serviceId) === FileSourceTypes.ALL_FILE_SOURCES_SERVICE_ID;
    }
    isPathVariableType(type) {
        var _a, _b, _c, _d;
        return ((_d = (_c = (_b = (_a = this.field) === null || _a === void 0 ? void 0 : _a.params) === null || _b === void 0 ? void 0 : _b.fileSource) === null || _c === void 0 ? void 0 : _c.destinationFolderPath) === null || _d === void 0 ? void 0 : _d.type) === type;
    }
    setDestinationFolderPathFromMappedVariable() {
        if (this.isAlfrescoAndLocal()) {
            this.prepareUploadWidgetDestinationFolderPathFromStringVariable();
            this.prepareUploadWidgetDestinationFolderPathFromFolderVariable();
        }
    }
    prepareUploadWidgetDestinationFolderPathFromStringVariable() {
        if (this.isPathVariableType(DestinationFolderPathType.STRING_TYPE)) {
            this.setUploadWidgetDestinationFolderPath(this.getDestinationFolderPathValue());
        }
    }
    prepareUploadWidgetDestinationFolderPathFromFolderVariable() {
        if (this.isPathVariableType(DestinationFolderPathType.FOLDER_TYPE)) {
            const folder = this.getDestinationFolderPathValue();
            this.setUploadWidgetDestinationFolderPath((folder === null || folder === void 0 ? void 0 : folder.length) ? folder[0].id : undefined);
        }
    }
    setUploadWidgetDestinationFolderPath(path) {
        this.field.params.fileSource.destinationFolderPath['value'] = path ? path : undefined;
    }
    getDestinationFolderPathValue() {
        var _a, _b;
        return this.field.form.getProcessVariableValue((_b = (_a = this.field.params.fileSource) === null || _a === void 0 ? void 0 : _a.destinationFolderPath) === null || _b === void 0 ? void 0 : _b.name);
    }
}
UploadCloudWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'upload-cloud-widget',
                template: "<div class=\"adf-upload-widget {{field.className}}\" [class.adf-invalid]=\"!field.isValid\"\n    [class.adf-readonly]=\"field.readOnly\">\n    <label class=\"adf-label\" [attr.for]=\"field.id\">{{ field.name | translate }}<span\n            *ngIf=\"isRequired()\">*</span></label>\n    <div class=\"adf-cloud-upload-widget-container\">\n        <div>\n            <mat-list *ngIf=\"hasFile\">\n                <mat-list-item class=\"adf-upload-files-row\" *ngFor=\"let file of uploadedFiles\">\n                    <img mat-list-icon class=\"adf-upload-widget__icon\" [id]=\"'file-'+file.id+'-icon'\"\n                        [src]=\"getIcon(file.content.mimeType)\" [alt]=\"mimeTypeIcon\" (click)=\"fileClicked(file)\"\n                        (keyup.enter)=\"fileClicked(file)\" role=\"button\" tabindex=\"0\" />\n                    <span matLine id=\"{{'file-'+file.id}}\" (click)=\"fileClicked(file)\" (keyup.enter)=\"fileClicked(file)\"\n                        role=\"button\" tabindex=\"0\" class=\"adf-file\">{{file.name}}</span>\n                    <button *ngIf=\"!field.readOnly\" mat-icon-button [id]=\"'file-'+file.id+'-remove'\"\n                        (click)=\"removeFile(file);\" (keyup.enter)=\"removeFile(file);\">\n                        <mat-icon class=\"mat-24\">highlight_off</mat-icon>\n                    </button>\n                </mat-list-item>\n            </mat-list>\n        </div>\n\n        <div *ngIf=\"(!hasFile || multipleOption) && !field.readOnly\">\n            <button mat-raised-button color=\"primary\" (click)=\"uploadFiles.click()\" [matTooltip]=\"field.tooltip\"\n                matTooltipPosition=\"above\" matTooltipShowDelay=\"1000\">\n                {{ 'FORM.FIELD.UPLOAD' | translate }}<mat-icon>file_upload</mat-icon>\n                <input #uploadFiles [multiple]=\"multipleOption\" type=\"file\" [id]=\"field.form.nodeId\"\n                    (change)=\"onFileChanged($event)\" />\n            </button>\n        </div>\n\n        <div *ngIf=\"!hasFile && field.readOnly\">\n            {{ 'FORM.FIELD.NO_FILE_ATTACHED' | translate }}\n        </div>\n\n    </div>\n    <error-widget [error]=\"field.validationSummary\"></error-widget>\n    <error-widget *ngIf=\"isInvalidFieldRequired()\" required=\"{{ 'FORM.FIELD.REQUIRED' | translate }}\"></error-widget>\n</div>\n",
                host: {
                    '(click)': 'event($event)',
                    '(blur)': 'event($event)',
                    '(change)': 'event($event)',
                    '(focus)': 'event($event)',
                    '(focusin)': 'event($event)',
                    '(focusout)': 'event($event)',
                    '(input)': 'event($event)',
                    '(invalid)': 'event($event)',
                    '(select)': 'event($event)'
                },
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-cloud-upload-widget-container{margin-bottom:15px}.adf-cloud-upload-widget-container input{display:none}.adf-cloud-upload-widget{border-top:.84375em solid transparent;padding:.4375em 0;width:100%;word-break:break-all}.adf-cloud-upload-widget__icon{cursor:pointer;float:left;padding:6px}.adf-cloud-upload-widget__reset{margin-top:-2px}.adf-cloud-upload-files-row .mat-line{margin-bottom:0}"]
            },] }
];
UploadCloudWidgetComponent.ctorParameters = () => [
    { type: FormService },
    { type: ThumbnailService },
    { type: ProcessCloudContentService },
    { type: NotificationService },
    { type: LogService }
];
UploadCloudWidgetComponent.propDecorators = {
    fileInput: [{ type: ViewChild, args: ['uploadFiles',] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AttachFileCloudWidgetComponent extends UploadCloudWidgetComponent {
    constructor(formService, logger, thumbnails, processCloudContentService, notificationService, contentNodeSelectorService, appConfigService, apiService, contentNodeSelectorPanelService) {
        super(formService, thumbnails, processCloudContentService, notificationService, logger);
        this.contentNodeSelectorService = contentNodeSelectorService;
        this.appConfigService = appConfigService;
        this.apiService = apiService;
        this.contentNodeSelectorPanelService = contentNodeSelectorPanelService;
        this.typeId = 'AttachFileCloudWidgetComponent';
        this.rootNodeId = AttachFileCloudWidgetComponent.ALIAS_USER_FOLDER;
        this.displayedColumns = ['icon', 'fileName', 'action'];
    }
    get nodesApi() {
        var _a;
        this._nodesApi = (_a = this._nodesApi) !== null && _a !== void 0 ? _a : new NodesApi(this.apiService.getInstance());
        return this._nodesApi;
    }
    ngOnInit() {
        var _a, _b;
        super.ngOnInit();
        if (this.hasFile && this.field.value.length === 1) {
            const files = this.field.value || this.field.form.values[this.field.id];
            this.contentModelFormFileHandler(files[0]);
        }
        this.field.params.displayableCMProperties = (_a = this.field.params.displayableCMProperties) !== null && _a !== void 0 ? _a : [];
        this.displayedColumns.splice(2, 0, ...(_b = this.field.params.displayableCMProperties) === null || _b === void 0 ? void 0 : _b.map(property => property === null || property === void 0 ? void 0 : property.name));
    }
    isPathStaticType() {
        var _a, _b, _c;
        return ((_c = (_b = (_a = this.field.params) === null || _a === void 0 ? void 0 : _a.fileSource) === null || _b === void 0 ? void 0 : _b.destinationFolderPath) === null || _c === void 0 ? void 0 : _c.type) === DestinationFolderPathType.STATIC_TYPE;
    }
    isUploadButtonVisible() {
        return (!this.hasFile || this.multipleOption) && !this.field.readOnly;
    }
    onRemoveAttachFile(file) {
        var _a;
        this.removeFile(file);
        if (file['id'] === ((_a = this.selectedNode) === null || _a === void 0 ? void 0 : _a.id)) {
            this.selectedNode = null;
            this.contentModelFormFileHandler();
        }
    }
    fetchAppNameFromAppConfig() {
        var _a;
        return (_a = this.appConfigService.get('alfresco-deployed-apps')[0]) === null || _a === void 0 ? void 0 : _a.name;
    }
    replaceAppNameAliasWithValue(path) {
        if (path === null || path === void 0 ? void 0 : path.match(AttachFileCloudWidgetComponent.APP_NAME)) {
            const appName = this.fetchAppNameFromAppConfig();
            return path.replace(AttachFileCloudWidgetComponent.APP_NAME, appName);
        }
        return path;
    }
    openSelectDialog() {
        return __awaiter(this, void 0, void 0, function* () {
            const selectedMode = this.field.params.multiple ? 'multiple' : 'single';
            const nodeId = yield this.getDestinationFolderNodeId();
            this.rootNodeId = nodeId ? nodeId : AttachFileCloudWidgetComponent.ALIAS_USER_FOLDER;
            this.contentNodeSelectorPanelService.customModels = this.field.params.customModels;
            this.contentNodeSelectorService
                .openUploadFileDialog(this.rootNodeId, selectedMode, this.isAlfrescoAndLocal(), true)
                .subscribe((selections) => {
                selections.forEach(node => (node['isExternal'] = true));
                const selectionWithoutDuplication = this.removeExistingSelection(selections);
                this.fixIncompatibilityFromPreviousAndNewForm(selectionWithoutDuplication);
                if (this.field.value.length === 1) {
                    this.contentModelFormFileHandler(selections && selections.length > 0 ? selections[0] : null);
                }
            });
        });
    }
    getDestinationFolderNodeId() {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            let rootNodeId;
            switch ((_d = (_c = (_b = (_a = this.field) === null || _a === void 0 ? void 0 : _a.params) === null || _b === void 0 ? void 0 : _b.fileSource) === null || _c === void 0 ? void 0 : _c.destinationFolderPath) === null || _d === void 0 ? void 0 : _d.type) {
                case DestinationFolderPathType.STATIC_TYPE:
                    rootNodeId = yield this.getNodeIdFromPath(this.field.params.fileSource.destinationFolderPath);
                    break;
                case DestinationFolderPathType.STRING_TYPE:
                    rootNodeId = yield this.getNodeIdFromPath(this.field.params.fileSource.destinationFolderPath);
                    break;
                case DestinationFolderPathType.FOLDER_TYPE:
                    rootNodeId = yield this.getNodeIdFromFolderVariableValue(this.field.params.fileSource.destinationFolderPath);
                    break;
                default:
                    rootNodeId = yield this.getNodeIdFromPath({ type: '', value: AttachFileCloudWidgetComponent.ALIAS_USER_FOLDER });
                    break;
            }
            return rootNodeId;
        });
    }
    getNodeIdFromPath(destinationFolderPath) {
        return __awaiter(this, void 0, void 0, function* () {
            let nodeId;
            const destinationPath = this.getAliasAndRelativePathFromDestinationFolderPath(destinationFolderPath.value);
            destinationPath.path = this.replaceAppNameAliasWithValue(destinationPath.path);
            try {
                nodeId = yield this.contentNodeSelectorService.getNodeIdFromPath(destinationPath);
            }
            catch (error) {
                this.logService.error(error);
            }
            return nodeId;
        });
    }
    getNodeIdFromFolderVariableValue(destinationFolderPath) {
        return __awaiter(this, void 0, void 0, function* () {
            let nodeId;
            try {
                nodeId = yield this.contentNodeSelectorService.getNodeIdFromFolderVariableValue(destinationFolderPath.value, AttachFileCloudWidgetComponent.ALIAS_USER_FOLDER);
            }
            catch (error) {
                this.logService.error(error);
            }
            return nodeId;
        });
    }
    getAliasAndRelativePathFromDestinationFolderPath(destinationFolderPath) {
        let alias;
        let path;
        if (destinationFolderPath) {
            const startOfRelativePathIndex = destinationFolderPath.indexOf('/');
            if (startOfRelativePathIndex >= 0) {
                alias = destinationFolderPath.substring(0, startOfRelativePathIndex);
                path = destinationFolderPath.substring(startOfRelativePathIndex, destinationFolderPath.length);
            }
            else {
                alias = destinationFolderPath;
            }
        }
        return this.isValidAlias(alias) ? { alias, path } : { alias: AttachFileCloudWidgetComponent.ALIAS_USER_FOLDER, path: undefined };
    }
    removeExistingSelection(selections) {
        const existingNode = [...this.field.value || []];
        return selections.filter(opt => !existingNode.some((node) => node.id === opt.id));
    }
    downloadContent(file) {
        this.processCloudContentService.downloadFile(file.id);
    }
    onAttachFileClicked(nodeSelector) {
        nodeSelector.nodeId = nodeSelector.id;
        this.fileClicked(new ContentLinkModel(nodeSelector));
    }
    getWidgetIcon() {
        return this.isAlfrescoAndLocal() ? 'file_upload' : 'attach_file';
    }
    onRowClicked(file) {
        var _a;
        if (((_a = this.selectedNode) === null || _a === void 0 ? void 0 : _a.id) === (file === null || file === void 0 ? void 0 : file.id)) {
            this.selectedNode = null;
        }
        else {
            this.selectedNode = file;
        }
        this.contentModelFormFileHandler(this.selectedNode);
    }
    contentModelFormFileHandler(file) {
        if ((file === null || file === void 0 ? void 0 : file.id) && this.isRetrieveMetadataOptionEnabled()) {
            const values = {};
            this.nodesApi.getNode(file.id).then(acsNode => {
                var _a;
                const metadata = (_a = acsNode === null || acsNode === void 0 ? void 0 : acsNode.entry) === null || _a === void 0 ? void 0 : _a.properties;
                if (metadata) {
                    const keys = Object.keys(metadata);
                    keys.forEach(key => {
                        const sanitizedKey = key.replace(':', '_');
                        values[sanitizedKey] = metadata[key];
                    });
                    this.formService.updateFormValuesRequested.next(values);
                }
            });
        }
        this.fileClicked(new UploadWidgetContentLinkModel(file, this.field.id));
    }
    isRetrieveMetadataOptionEnabled() {
        var _a, _b;
        return ((_b = (_a = this.field) === null || _a === void 0 ? void 0 : _a.params) === null || _b === void 0 ? void 0 : _b.menuOptions) && this.field.params.menuOptions[AttachFileCloudWidgetComponent.RETRIEVE_METADATA_OPTION];
    }
    isValidAlias(alias) {
        return alias && AttachFileCloudWidgetComponent.VALID_ALIAS.includes(alias);
    }
    ngOnDestroy() {
        this.contentNodeSelectorPanelService.customModels = [];
    }
}
AttachFileCloudWidgetComponent.ALIAS_ROOT_FOLDER = '-root-';
AttachFileCloudWidgetComponent.ALIAS_USER_FOLDER = '-my-';
AttachFileCloudWidgetComponent.APP_NAME = '-appname-';
AttachFileCloudWidgetComponent.VALID_ALIAS = [
    AttachFileCloudWidgetComponent.ALIAS_ROOT_FOLDER,
    AttachFileCloudWidgetComponent.ALIAS_USER_FOLDER, '-shared-'
];
AttachFileCloudWidgetComponent.RETRIEVE_METADATA_OPTION = 'retrieveMetadata';
AttachFileCloudWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-cloud-attach-file-cloud-widget',
                template: "<div class=\"adf-attach-file-widget-container\">\n    <div class=\"adf-attach-widget {{field.className}}\" [class.adf-invalid]=\"!field.isValid\"\n        [class.adf-readonly]=\"field.readOnly\">\n        <label class=\"adf-label\" [attr.for]=\"field.id\">{{field.name}}\n            <span *ngIf=\"isRequired()\">*</span>\n        </label>\n        <div class=\"adf-attach-widget-container\">\n            <div class=\"adf-attach-widget__menu-upload\" *ngIf=\"isUploadButtonVisible()\">\n                <button (click)=\"openSelectDialog()\" mat-raised-button color=\"primary\" [id]=\"field.id\"\n                    [matTooltip]=\"field.tooltip\" matTooltipPosition=\"above\" matTooltipShowDelay=\"1000\">\n                    {{ 'FORM.FIELD.ATTACH' | translate }}\n                    <mat-icon>{{getWidgetIcon()}}</mat-icon>\n                </button>\n            </div>\n        </div>\n    </div>\n\n    <div id=\"adf-attach-widget-readonly-list\" class=\"adf-attach-widget-readonly-table\">\n        <adf-cloud-file-properties-table\n            [uploadedFiles]=\"uploadedFiles\"\n            [hasFile]=\"hasFile\"\n            [selectedNode]=\"selectedNode\"\n            [field]=\"field\"\n            [displayedColumns]=\"displayedColumns\"\n            [mimeTypeIcon]=\"mimeTypeIcon\"\n            (rowClick)=\"onRowClicked($event)\"\n            (attachFileClick)=\"onAttachFileClicked($event)\"\n            (downloadFile)=\"downloadContent($event)\"\n            (contentModelFileHandler)=\"contentModelFormFileHandler($event)\"\n            (removeAttachFile)=\"onRemoveAttachFile($event)\"\n        ></adf-cloud-file-properties-table>\n        <div *ngIf=\"!hasFile && field.readOnly\" id=\"{{'adf-attach-empty-list-'+field.id}}\">\n            {{ 'FORM.FIELD.NO_FILE_ATTACHED' | translate }}\n        </div>\n\n    </div>\n\n    <error-widget [error]=\"field.validationSummary\"></error-widget>\n    <error-widget *ngIf=\"isInvalidFieldRequired()\" required=\"{{ 'FORM.FIELD.REQUIRED' | translate }}\"></error-widget>\n</div>\n",
                host: {
                    '(click)': 'event($event)',
                    '(blur)': 'event($event)',
                    '(change)': 'event($event)',
                    '(focus)': 'event($event)',
                    '(focusin)': 'event($event)',
                    '(focusout)': 'event($event)',
                    '(input)': 'event($event)',
                    '(invalid)': 'event($event)',
                    '(select)': 'event($event)'
                },
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-attach-widget-container{align-items:center;display:flex}.adf-attach-widget-container input{cursor:pointer;height:100%;opacity:0;position:absolute;right:0;top:0;width:300px;z-index:4}.adf-attach-widget__menu-upload{align-items:center;display:flex;margin-right:8px}.adf-attach-widget__menu-upload .mat-raised-button{font-size:12px;line-height:28px}.adf-attach-widget__menu-upload button span{font-size:12px}.adf-attach-widget__menu-upload button span mat-icon{height:12px;line-height:12px;width:12px}.adf-attach-widget__menu-upload button span .material-icons{font-size:18px}.adf-attach-widget__input-type{height:.1px;opacity:0;overflow:hidden;position:absolute;width:.1px;z-index:-1}.adf-attach-widget__image-logo{padding-left:5px}.adf-attach-widget-repo-button{padding-left:10px}.adf-attach-widget-repo-button .mat-button-wrapper{display:inline}.adf-attach-widget-repo-button .mat-mini-fab.mat-accent{background-color:inherit}.adf-attach-widget{background:var(--theme-colors-mat-grey);border-bottom:none;display:flex;justify-content:space-between;min-height:27px;padding:.4375em;word-break:break-all}.adf-attach-widget .adf-label{font-size:var(--theme-caption-font-size);line-height:var(--theme-headline-line-height);margin-left:8px;text-align:left;white-space:nowrap;width:32px}.adf-attach-widget__icon{cursor:pointer;float:left;padding:6px}.adf-attach-widget__reset{margin-top:-2px}.adf-attach-files-row div.mat-list-item-content{cursor:pointer}.adf-attach-files-row .mat-line{margin-bottom:0}.adf-attach-selected-file-row div.mat-list-item-content .adf-datatable-selected{color:var(--theme-primary-color);padding-right:6px}.adf-attach-file-widget-container{margin:15px}"]
            },] }
];
AttachFileCloudWidgetComponent.ctorParameters = () => [
    { type: FormService },
    { type: LogService },
    { type: ThumbnailService },
    { type: ProcessCloudContentService },
    { type: NotificationService },
    { type: ContentCloudNodeSelectorService },
    { type: AppConfigService },
    { type: AlfrescoApiService },
    { type: ContentNodeSelectorPanelService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PropertiesViewerWidgetComponent extends WidgetComponent {
    constructor(formService) {
        super(formService);
        this.nodeContentLoaded = new EventEmitter();
    }
    onNodeContentLoaded(node) {
        this.nodeContentLoaded.emit(node);
    }
}
PropertiesViewerWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-properties-viewer-widget',
                template: "<div class=\"adf-file-viewer-widget {{field.className}}\" [class.adf-invalid]=\"!field.isValid\"\n    [class.adf-readonly]=\"field.readOnly\">\n    <label class=\"adf-label\" [attr.for]=\"field.id\">{{field.name | translate }}<span\n            *ngIf=\"isRequired()\">*</span></label>\n    <ng-template #properties [ngTemplateOutlet]=\"properties\" let-properties=\"properties\" [ngTemplateOutletContext]=\"{ properties: field.params?.propertiesViewerOptions }\">\n        <adf-properties-viewer-wrapper *ngIf=\"field.value\" [nodeId]=\"field.value\"\n            [displayDefaultProperties]=\"properties?.displayDefaultProperties !== undefined ?  properties?.displayDefaultProperties : true\"\n            [expanded]=\"properties?.expanded !== undefined ? properties?.expanded : true\"\n            [preset]=\"properties?.preset\"\n            [displayEmpty]=\"properties?.displayEmpty !== undefined ? properties?.displayEmpty : false\"\n            [editable]=\"properties?.editable !== undefined ? properties?.editable : false\"\n            [multi]=\"properties?.multi !== undefined ? properties?.multi : false\"\n            [displayAspect]=\"properties?.displayAspect !== undefined ? properties?.displayAspect : null\"\n            [copyToClipboardAction]=\"properties?.copyToClipboardAction !== undefined ? properties?.copyToClipboardAction : true\"\n            [useChipsForMultiValueProperty]=\"properties?.useChipsForMultiValueProperty !== undefined ? properties?.useChipsForMultiValueProperty : true\"\n            (nodeContentLoaded)=\"onNodeContentLoaded($event)\">\n        </adf-properties-viewer-wrapper>\n    </ng-template>\n    <error-widget [error]=\"field.validationSummary\"></error-widget>\n</div>\n",
                host: {
                    '(click)': 'event($event)',
                    '(blur)': 'event($event)',
                    '(change)': 'event($event)',
                    '(focus)': 'event($event)',
                    '(focusin)': 'event($event)',
                    '(focusout)': 'event($event)',
                    '(input)': 'event($event)',
                    '(invalid)': 'event($event)',
                    '(select)': 'event($event)'
                },
                encapsulation: ViewEncapsulation.None,
                styles: ["adf-properties-viewer-widget{height:100%;width:100%}adf-properties-viewer-widget adf-properties-viewer-wrapper{border:1px solid var(--theme-border-color);border-radius:6px;display:block;height:100%;width:100%}adf-properties-viewer-widget adf-properties-viewer-wrapper .adf-properties-viewer-wrapper-loading{height:100%;width:100%}adf-properties-viewer-widget adf-properties-viewer-wrapper .adf-properties-viewer-wrapper-loading mat-progress-spinner{display:block;margin:auto}"]
            },] }
];
PropertiesViewerWidgetComponent.ctorParameters = () => [
    { type: FormService }
];
PropertiesViewerWidgetComponent.propDecorators = {
    nodeContentLoaded: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PropertiesViewerWrapperComponent {
    constructor(nodesApiService) {
        this.nodesApiService = nodesApiService;
        this.loading = true;
        this.displayAspect = null;
        this.nodeContentLoaded = new EventEmitter();
    }
    ngOnChanges(changes) {
        if (changes && changes['nodeId'] && changes['nodeId'].currentValue && !changes['nodeId'].isFirstChange()) {
            this.getNode(changes['nodeId'].currentValue);
        }
    }
    ngOnInit() {
        if (this.nodeId) {
            this.getNode(this.nodeId);
        }
    }
    getNode(nodeId) {
        this.loading = true;
        this.nodesApiService.getNode(nodeId).subscribe(retrievedNode => {
            this.node = retrievedNode;
            this.loading = false;
            this.nodeContentLoaded.emit(retrievedNode);
        });
    }
}
PropertiesViewerWrapperComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-properties-viewer-wrapper',
                template: "<adf-content-metadata [displayDefaultProperties]=\"displayDefaultProperties\" [expanded]=\"expanded\" [node]=\"node\"\n    [preset]=\"preset\" [displayEmpty]=\"displayEmpty\" [editable]=\"editable\" [multi]=\"multi\"\n    [displayAspect]=\"displayAspect\" [copyToClipboardAction]=\"copyToClipboardAction\"\n    [useChipsForMultiValueProperty]=\"useChipsForMultiValueProperty\" *ngIf=\"!loading; else loadingTemplate\">\n</adf-content-metadata>\n<ng-template #loadingTemplate>\n    <div class=\"adf-properties-viewer-wrapper-loading\">\n        <mat-progress-spinner></mat-progress-spinner>\n    </div>\n</ng-template>\n",
                encapsulation: ViewEncapsulation.None
            },] }
];
PropertiesViewerWrapperComponent.ctorParameters = () => [
    { type: NodesApiService }
];
PropertiesViewerWrapperComponent.propDecorators = {
    nodeId: [{ type: Input }],
    editable: [{ type: Input }],
    displayEmpty: [{ type: Input }],
    expanded: [{ type: Input }],
    multi: [{ type: Input }],
    preset: [{ type: Input }],
    displayDefaultProperties: [{ type: Input }],
    displayAspect: [{ type: Input }],
    copyToClipboardAction: [{ type: Input }],
    useChipsForMultiValueProperty: [{ type: Input }],
    nodeContentLoaded: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RadioButtonsCloudWidgetComponent extends WidgetComponent {
    constructor(formService, formCloudService, logService) {
        super(formService);
        this.formService = formService;
        this.formCloudService = formCloudService;
        this.logService = logService;
        this.typeId = 'RadioButtonsCloudWidgetComponent';
        this.onDestroy$ = new Subject();
    }
    ngOnInit() {
        if (this.field && this.field.restUrl) {
            this.getValuesFromRestApi();
        }
    }
    getValuesFromRestApi() {
        this.formCloudService.getRestWidgetData(this.field.form.id, this.field.id)
            .pipe(takeUntil(this.onDestroy$))
            .subscribe((result) => {
            this.field.options = result;
            this.field.updateForm();
        }, (err) => this.handleError(err));
    }
    onOptionClick(optionSelected) {
        this.field.value = optionSelected;
        this.fieldChanged.emit(this.field);
    }
    handleError(error) {
        this.logService.error(error);
    }
    isChecked(option) {
        var _a, _b;
        if (this.field.value && typeof this.field.value === 'object') {
            let id = 'id';
            let name = 'name';
            if (this.field.restUrl) {
                id = (_a = this.field.restIdProperty) !== null && _a !== void 0 ? _a : 'id';
                name = (_b = this.field.restLabelProperty) !== null && _b !== void 0 ? _b : 'name';
            }
            return this.field.value[id] === option.id || this.field.value[name] === option.name;
        }
        return this.field.value === option.id;
    }
}
RadioButtonsCloudWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'radio-buttons-cloud-widget',
                template: "<div class=\"adf-radio-buttons-widget-cloud {{field.className}}\"\n     [class.adf-invalid]=\"!field.isValid\" [class.adf-readonly]=\"field.readOnly\" [id]=\"field.id\">\n    <div class=\"adf-radio-button-container\">\n        <label class=\"adf-label\" [attr.for]=\"field.id\">{{field.name | translate }}<span *ngIf=\"isRequired()\">*</span></label>\n        <mat-radio-group class=\"adf-radio-group\" [(ngModel)]=\"field.value\" [disabled]=\"field.readOnly\">\n            <mat-radio-button\n                [matTooltip]=\"field.tooltip\"\n                matTooltipPosition=\"above\"\n                matTooltipShowDelay=\"1000\"\n                [id]=\"field.id + '-' + opt.id\"\n                [name]=\"field.id\"\n                [value]=\"opt.id\"\n                [checked]=\"isChecked(opt)\"\n                (change)=\"onOptionClick(opt.id)\"\n                color=\"primary\"\n                class=\"adf-radio-button\" *ngFor=\"let opt of field.options\" >\n                {{opt.name}}\n            </mat-radio-button>\n        </mat-radio-group>\n    </div>\n    <error-widget [error]=\"field.validationSummary\" ></error-widget>\n    <error-widget *ngIf=\"isInvalidFieldRequired()\" required=\"{{ 'FORM.FIELD.REQUIRED' | translate }}\"></error-widget>\n</div>\n",
                host: {
                    '(click)': 'event($event)',
                    '(blur)': 'event($event)',
                    '(change)': 'event($event)',
                    '(focus)': 'event($event)',
                    '(focusin)': 'event($event)',
                    '(focusout)': 'event($event)',
                    '(input)': 'event($event)',
                    '(invalid)': 'event($event)',
                    '(select)': 'event($event)'
                },
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-radio-button-container{display:flex;flex-direction:column;margin-bottom:15px}.adf-radio-group{display:inline-flex;flex-direction:column;margin-left:5px;margin-top:15px}.adf-radio-button{margin:5px}"]
            },] }
];
RadioButtonsCloudWidgetComponent.ctorParameters = () => [
    { type: FormService },
    { type: FormCloudService },
    { type: LogService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FilePropertiesTableCloudComponent {
    constructor(localizedDatePipe, thumbnailService) {
        this.localizedDatePipe = localizedDatePipe;
        this.thumbnailService = thumbnailService;
        this.rowClick = new EventEmitter();
        this.attachFileClick = new EventEmitter();
        this.downloadFile = new EventEmitter();
        this.contentModelFileHandler = new EventEmitter();
        this.removeAttachFile = new EventEmitter();
    }
    onRowClicked(file) {
        this.rowClick.emit(file);
    }
    onAttachFileClicked(nodeSelector) {
        this.attachFileClick.emit(nodeSelector);
    }
    downloadContent(file) {
        this.downloadFile.emit(file);
    }
    contentModelFormFileHandler(file) {
        this.contentModelFileHandler.emit(file);
    }
    onRemoveAttachFile(file) {
        this.removeAttachFile.emit(file);
    }
    getIcon(mimeType) {
        return this.thumbnailService.getMimeTypeIcon(mimeType);
    }
    getColumnValue(file, displayableCMProperty) {
        var _a;
        if (!file.properties[displayableCMProperty.prefixedName]) {
            const fieldProperty = (_a = this.field.params.displayableCMProperties) === null || _a === void 0 ? void 0 : _a.find(property => property.name === displayableCMProperty.name);
            return fieldProperty.defaultValue ? this.checkDateTypeAndTransform(displayableCMProperty.dataType, fieldProperty.defaultValue) : '--';
        }
        return file.properties[displayableCMProperty.prefixedName] ?
            this.checkDateTypeAndTransform(displayableCMProperty.dataType, file.properties[displayableCMProperty.prefixedName]) :
            '--';
    }
    checkDateTypeAndTransform(dataType, value) {
        if (dataType === 'd:date') {
            return this.localizedDatePipe.transform(value);
        }
        else if (dataType === 'd:datetime') {
            return this.localizedDatePipe.transform(value, 'medium');
        }
        return value;
    }
    displayMenuOption(option) {
        var _a, _b;
        return ((_b = (_a = this.field) === null || _a === void 0 ? void 0 : _a.params) === null || _b === void 0 ? void 0 : _b.menuOptions) ? this.field.params.menuOptions[option] : option !== FilePropertiesTableCloudComponent.RETRIEVE_METADATA_OPTION;
    }
}
FilePropertiesTableCloudComponent.RETRIEVE_METADATA_OPTION = 'retrieveMetadata';
FilePropertiesTableCloudComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-cloud-file-properties-table',
                template: "<div class=\"adf-file-properties-table\">\n    <table mat-table [dataSource]=\"uploadedFiles\" class=\"mat-elevation-z0\" *ngIf=\"hasFile\">\n        <ng-container matColumnDef=\"icon\">\n            <th mat-header-cell *matHeaderCellDef></th>\n            <td mat-cell *matCellDef=\"let element\">\n                <mat-icon mat-list-icon class=\"adf-datatable-selected\"\n                    *ngIf=\"selectedNode && element.id === selectedNode.id\" (click)=\"onRowClicked(element)\">\n                    check_circle\n                </mat-icon>\n                <img mat-list-icon class=\"adf-attach-widget__icon\"\n                    *ngIf=\"!selectedNode || element.id !== selectedNode.id\" [id]=\"'file-'+element?.id+'-icon'\"\n                    (click)=\"onRowClicked(element)\"\n                    [src]=\"element.content ? getIcon(element.content.mimeType) : getIcon(element['mimeType'])\"\n                    [alt]=\"mimeTypeIcon\" role=\"button\" tabindex=\"0\" />\n            </td>\n        </ng-container>\n    \n        <ng-container matColumnDef=\"fileName\">\n            <th mat-header-cell *matHeaderCellDef>{{ 'FORM.FIELD.FILE_NAME' | translate }}</th>\n            <td mat-cell *matCellDef=\"let element\">\n                <span matLine id=\"{{'file-'+element?.id}}\" role=\"button\" tabindex=\"0\" class=\"adf-file\"\n                    (click)=\"onRowClicked(element)\">{{element.name}}</span>\n            </td>\n        </ng-container>\n    \n        <ng-container *ngFor=\"let columnName of field?.params?.displayableCMProperties\" [matColumnDef]=\"columnName.name\">\n            <th mat-header-cell *matHeaderCellDef>{{ columnName.title ? columnName.title : columnName.name | titlecase\n                }}</th>\n            <td mat-cell *matCellDef=\"let row\">\n                <span matLine id=\"{{'fileProperty-'+row?.id+'-'+columnName?.name}}\" role=\"button\" tabindex=\"0\"\n                    (click)=\"onRowClicked(row)\">{{ getColumnValue(row, columnName) }}</span>\n            </td>\n        </ng-container>\n    \n        <ng-container matColumnDef=\"action\">\n            <th mat-header-cell *matHeaderCellDef></th>\n            <td mat-cell *matCellDef=\"let element\">\n                <button id=\"{{'file-'+element?.id+'-option-menu'}}\" mat-icon-button [matMenuTriggerFor]=\"fileActionMenu\"\n                    *ngIf=\"!!element.content?.mimeType\">\n                    <mat-icon>more_vert</mat-icon>\n                </button>\n                <mat-menu #fileActionMenu=\"matMenu\" xPosition=\"before\">\n                    <button *ngIf=\"displayMenuOption('show') && !!element.content?.mimeType\"\n                        id=\"{{'file-'+element?.id+'-show-file'}}\" mat-menu-item (click)=\"onAttachFileClicked(element)\">\n                        <mat-icon>visibility</mat-icon>\n                        <span>{{ 'FORM.FIELD.VIEW_FILE' | translate }}</span>\n                    </button>\n                    <button *ngIf=\"displayMenuOption('download') && !!element.content?.mimeType\"\n                        id=\"{{'file-'+element?.id+'-download-file'}}\" mat-menu-item (click)=\"downloadContent(element)\">\n                        <mat-icon>file_download</mat-icon>\n                        <span>{{ 'FORM.FIELD.DOWNLOAD_FILE' | translate }}</span>\n                    </button>\n                    <button *ngIf=\"displayMenuOption('retrieveMetadata') && !!element.content?.mimeType\"\n                        id=\"{{'file-'+element?.id+'-retrieve-file-metadata'}}\" mat-menu-item\n                        (click)=\"contentModelFormFileHandler(element)\">\n                        <mat-icon class=\"mat-24\">low_priority</mat-icon>\n                        <span>{{ 'ADF_CLOUD_FORM_COMPONENT.RETRIEVE_METADATA' | translate }}</span>\n                    </button>\n                    <button *ngIf=\"!field.readOnly && displayMenuOption('remove')\"\n                        id=\"{{'file-'+element?.id+'-remove-file'}}\" mat-menu-item [id]=\"'file-'+element?.id+'-remove'\"\n                        (click)=\"onRemoveAttachFile(element);\" (keyup.enter)=\"onRemoveAttachFile(element);\">\n                        <mat-icon class=\"mat-24\">highlight_off</mat-icon>\n                        <span>{{ 'FORM.FIELD.REMOVE_FILE' | translate }}</span>\n                    </button>\n                </mat-menu>\n            </td>\n        </ng-container>\n        <tr mat-header-row *matHeaderRowDef=\"displayedColumns\"></tr>\n        <tr mat-row *matRowDef=\"let row; columns: displayedColumns\"></tr>\n    \n    </table>\n</div>\n",
                styles: [".adf-file-properties-table table{border:1px solid var(--theme-border-color);box-shadow:none;width:100%}.adf-file-properties-table table .adf-datatable-selected{padding:6px}.adf-file-properties-table table tr.mat-header-row{height:32px}.adf-file-properties-table table th{font-weight:700;padding-right:0!important}.adf-file-properties-table table td{max-width:50px;overflow:hidden;padding-right:0!important;text-overflow:ellipsis;white-space:nowrap}.adf-file-properties-table table td.mat-cell:first-of-type,.adf-file-properties-table table td.mat-cell:last-of-type,.adf-file-properties-table table td.mat-footer-cell:first-of-type,.adf-file-properties-table table td.mat-footer-cell:last-of-type{width:18%!important}"]
            },] }
];
FilePropertiesTableCloudComponent.ctorParameters = () => [
    { type: LocalizedDatePipe },
    { type: ThumbnailService }
];
FilePropertiesTableCloudComponent.propDecorators = {
    uploadedFiles: [{ type: Input }],
    hasFile: [{ type: Input }],
    selectedNode: [{ type: Input }],
    field: [{ type: Input }],
    displayedColumns: [{ type: Input }],
    mimeTypeIcon: [{ type: Input }],
    rowClick: [{ type: Output }],
    attachFileClick: [{ type: Output }],
    downloadFile: [{ type: Output }],
    contentModelFileHandler: [{ type: Output }],
    removeAttachFile: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FormCloudModule {
}
FormCloudModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FlexLayoutModule,
                    MaterialModule,
                    FormsModule,
                    ReactiveFormsModule,
                    CoreModule,
                    ContentNodeSelectorModule,
                    PeopleCloudModule,
                    GroupCloudModule,
                    ContentMetadataModule
                ],
                declarations: [
                    FormCloudComponent,
                    UploadCloudWidgetComponent,
                    FormDefinitionSelectorCloudComponent,
                    FormCustomOutcomesComponent,
                    DropdownCloudWidgetComponent,
                    RadioButtonsCloudWidgetComponent,
                    AttachFileCloudWidgetComponent,
                    DateCloudWidgetComponent,
                    PeopleCloudWidgetComponent,
                    GroupCloudWidgetComponent,
                    PropertiesViewerWrapperComponent,
                    PropertiesViewerWidgetComponent,
                    FilePropertiesTableCloudComponent
                ],
                exports: [
                    FormCloudComponent,
                    UploadCloudWidgetComponent,
                    FormDefinitionSelectorCloudComponent,
                    FormCustomOutcomesComponent,
                    DropdownCloudWidgetComponent,
                    RadioButtonsCloudWidgetComponent,
                    AttachFileCloudWidgetComponent,
                    DateCloudWidgetComponent,
                    PeopleCloudWidgetComponent,
                    GroupCloudWidgetComponent,
                    PropertiesViewerWidgetComponent
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class StartTaskCloudModule {
}
StartTaskCloudModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FlexLayoutModule,
                    MaterialModule,
                    FormsModule,
                    ReactiveFormsModule,
                    GroupCloudModule,
                    CoreModule,
                    FormCloudModule,
                    PeopleCloudModule
                ],
                declarations: [StartTaskCloudComponent],
                exports: [
                    StartTaskCloudComponent
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TaskHeaderCloudComponent {
    constructor(taskCloudService, translationService, appConfig, cardViewUpdateService) {
        this.taskCloudService = taskCloudService;
        this.translationService = translationService;
        this.appConfig = appConfig;
        this.cardViewUpdateService = cardViewUpdateService;
        this.appName = '';
        this.showTitle = true;
        this.claim = new EventEmitter();
        this.unclaim = new EventEmitter();
        this.error = new EventEmitter();
        this.taskDetails = {};
        this.candidateUsers = [];
        this.candidateGroups = [];
        this.inEdit = false;
        this.displayDateClearAction = false;
        this.isLoading = true;
        this.onDestroy$ = new Subject();
        this.dateFormat = this.appConfig.get('dateValues.defaultDateFormat');
        this.dateLocale = this.appConfig.get('dateValues.defaultDateLocale');
        this.dateTimeFormat = this.appConfig.get('dateValue.defaultDateTimeFormat');
    }
    ngOnInit() {
        this.taskCloudService.dataChangesDetected$
            .pipe(takeUntil(this.onDestroy$))
            .subscribe(() => {
            this.loadTaskDetailsById(this.appName, this.taskId);
        });
        this.cardViewUpdateService.itemUpdated$
            .pipe(takeUntil(this.onDestroy$))
            .subscribe(this.updateTaskDetails.bind(this));
    }
    ngOnChanges() {
        this.taskDetails = {};
        if ((this.appName || this.appName === '') && this.taskId) {
            this.loadTaskDetailsById(this.appName, this.taskId);
        }
        else {
            this.error.emit('App Name and Task Id are mandatory');
        }
    }
    loadTaskDetailsById(appName, taskId) {
        this.isLoading = true;
        this.taskCloudService.getTaskById(appName, taskId).pipe(concatMap((task) => forkJoin(of(task), this.taskCloudService.getCandidateUsers(this.appName, this.taskId), this.taskCloudService.getCandidateGroups(this.appName, this.taskId))), finalize(() => (this.isLoading = false))).subscribe(([taskDetails, candidateUsers, candidateGroups]) => {
            this.taskDetails = taskDetails;
            this.candidateGroups = candidateGroups.map((user) => ({ icon: 'group', value: user }));
            this.candidateUsers = candidateUsers.map((group) => ({ icon: 'person', value: group }));
            if (this.taskDetails.parentTaskId) {
                this.loadParentName(`${this.taskDetails.parentTaskId}`);
            }
            else {
                this.refreshData();
            }
        }, (err) => {
            this.error.emit(err);
        });
    }
    initDefaultProperties() {
        return [
            new CardViewTextItemModel({
                label: 'ADF_CLOUD_TASK_HEADER.PROPERTIES.ASSIGNEE',
                value: this.taskDetails.assignee,
                key: 'assignee',
                clickable: this.isAssigneePropertyClickable(),
                default: this.translationService.instant('ADF_CLOUD_TASK_HEADER.PROPERTIES.ASSIGNEE_DEFAULT'),
                icon: 'create'
            }),
            new CardViewTextItemModel({
                label: 'ADF_CLOUD_TASK_HEADER.PROPERTIES.STATUS',
                value: this.taskDetails.status,
                key: 'status'
            }),
            new CardViewSelectItemModel({
                label: 'ADF_CLOUD_TASK_HEADER.PROPERTIES.PRIORITY',
                value: this.taskDetails.priority.toString(),
                key: 'priority',
                editable: true,
                displayNoneOption: false,
                options$: of(this.taskCloudService.priorities)
            }),
            new CardViewDatetimeItemModel({
                label: 'ADF_CLOUD_TASK_HEADER.PROPERTIES.DUE_DATE',
                value: this.taskDetails.dueDate,
                key: 'dueDate',
                default: this.translationService.instant('ADF_CLOUD_TASK_HEADER.PROPERTIES.DUE_DATE_DEFAULT'),
                editable: true,
                format: this.dateTimeFormat,
                locale: this.dateLocale
            }),
            new CardViewTextItemModel({
                label: 'ADF_CLOUD_TASK_HEADER.PROPERTIES.CATEGORY',
                value: this.taskDetails.category,
                key: 'category',
                default: this.translationService.instant('ADF_CLOUD_TASK_HEADER.PROPERTIES.CATEGORY_DEFAULT')
            }),
            new CardViewDateItemModel({
                label: 'ADF_CLOUD_TASK_HEADER.PROPERTIES.CREATED',
                value: this.taskDetails.createdDate,
                key: 'created',
                format: this.dateFormat,
                locale: this.dateLocale
            }),
            new CardViewTextItemModel({
                label: 'ADF_CLOUD_TASK_HEADER.PROPERTIES.PARENT_NAME',
                value: this.parentTaskName,
                default: this.translationService.instant('ADF_CLOUD_TASK_HEADER.PROPERTIES.PARENT_NAME_DEFAULT'),
                key: 'parentName',
                clickable: true
            }),
            new CardViewTextItemModel({
                label: 'ADF_CLOUD_TASK_HEADER.PROPERTIES.PARENT_TASK_ID',
                value: this.taskDetails.parentTaskId,
                key: 'parentTaskId',
                clickable: true
            }),
            new CardViewDateItemModel({
                label: 'ADF_CLOUD_TASK_HEADER.PROPERTIES.END_DATE',
                value: this.taskDetails.completedDate,
                key: 'endDate',
                format: this.dateFormat,
                locale: this.dateLocale
            }),
            new CardViewTextItemModel({
                label: 'ADF_CLOUD_TASK_HEADER.PROPERTIES.ID',
                value: this.taskDetails.id,
                key: 'id'
            }),
            new CardViewTextItemModel({
                label: 'ADF_CLOUD_TASK_HEADER.PROPERTIES.DESCRIPTION',
                value: this.taskDetails.description,
                key: 'description',
                default: this.translationService.instant('ADF_CLOUD_TASK_HEADER.PROPERTIES.DESCRIPTION_DEFAULT'),
                multiline: true,
                editable: true
            }),
            new CardViewArrayItemModel({
                label: 'ADF_CLOUD_TASK_HEADER.PROPERTIES.CANDIDATE_USERS',
                value: of(this.candidateUsers),
                key: 'candidateUsers',
                icon: 'edit',
                clickable: false,
                default: this.translationService.instant('ADF_CLOUD_TASK_HEADER.PROPERTIES.CANDIDATE_USERS_DEFAULT'),
                noOfItemsToDisplay: 2
            }),
            new CardViewArrayItemModel({
                label: 'ADF_CLOUD_TASK_HEADER.PROPERTIES.CANDIDATE_GROUPS',
                value: of(this.candidateGroups),
                key: 'candidateGroups',
                icon: 'edit',
                clickable: false,
                default: this.translationService.instant('ADF_CLOUD_TASK_HEADER.PROPERTIES.CANDIDATE_GROUPS_DEFAULT'),
                noOfItemsToDisplay: 2
            })
        ];
    }
    refreshData() {
        if (this.taskDetails) {
            const defaultProperties = this.initDefaultProperties();
            const filteredProperties = this.appConfig.get('adf-cloud-task-header.presets.properties');
            this.properties = defaultProperties.filter((cardItem) => this.isValidSelection(filteredProperties, cardItem));
        }
    }
    updateTaskDetails(updateNotification) {
        this.taskCloudService.updateTask(this.appName, this.taskId, updateNotification.changed)
            .pipe(catchError(() => {
            this.cardViewUpdateService.updateElement(updateNotification.target);
            return of(null);
        }))
            .subscribe((taskDetails) => {
            if (taskDetails) {
                this.taskDetails = taskDetails;
            }
        });
    }
    loadParentName(taskId) {
        this.taskCloudService.getTaskById(this.appName, taskId)
            .subscribe((taskDetails) => {
            this.parentTaskName = taskDetails.name;
            this.refreshData();
        });
    }
    isCompleted() {
        return this.taskDetails && this.taskDetails.status === 'COMPLETED';
    }
    hasAssignee() {
        return !!this.taskDetails.assignee ? true : false;
    }
    isTaskValid() {
        return (this.appName || this.appName === '') && !!this.taskId;
    }
    isTaskAssigned() {
        return this.taskDetails.assignee !== undefined;
    }
    isTaskEditable() {
        return this.taskCloudService.isTaskEditable(this.taskDetails);
    }
    isAssigneePropertyClickable() {
        return this.taskCloudService.isAssigneePropertyClickable(this.taskDetails, this.candidateUsers, []);
    }
    isValidSelection(filteredProperties, cardItem) {
        return filteredProperties ? filteredProperties.indexOf(cardItem.key) >= 0 : true;
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
}
TaskHeaderCloudComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-cloud-task-header',
                template: "<h3 *ngIf=\"showTitle\" class=\"adf-task-title\">{{ taskDetails?.name }}</h3>\n\n<div class=\"adf-task-header-container\">\n    <mat-card *ngIf=\"isTaskValid()\" class=\"adf-card-container\">\n        <mat-card-content>\n            <adf-card-view\n                *ngIf=\"!isLoading; else loadingTemplate\"\n                [displayNoneOption]=\"false\"\n                [properties]=\"properties\"\n                [editable]=\"isTaskEditable()\"\n                [displayClearAction]=\"displayDateClearAction\">\n            </adf-card-view>\n        </mat-card-content>\n    </mat-card>\n</div>\n\n<ng-template #loadingTemplate>\n    <div class=\"adf-task-header-loading\">\n        <mat-spinner></mat-spinner>\n    </div>\n</ng-template>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-controls{display:flex;justify-content:space-between}.adf-edit-controls{display:flex;justify-content:flex-end;margin-left:auto}.adf-save-edit-mode,.adf-switch-to-edit-mode{color:var(--theme-primary-color)}.adf-cancel-edit-mode,.adf-claim-controls{color:#838383}@media screen and (max-width:959px){adf-card-view .adf-property-value{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}}.adf-task-header-loading{display:flex;justify-content:center}"]
            },] }
];
TaskHeaderCloudComponent.ctorParameters = () => [
    { type: TaskCloudService },
    { type: TranslationService },
    { type: AppConfigService },
    { type: CardViewUpdateService }
];
TaskHeaderCloudComponent.propDecorators = {
    appName: [{ type: Input }],
    taskId: [{ type: Input }],
    showTitle: [{ type: Input }],
    claim: [{ type: Output }],
    unclaim: [{ type: Output }],
    error: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TaskHeaderCloudModule {
}
TaskHeaderCloudModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    CoreModule.forChild()
                ],
                declarations: [
                    TaskHeaderCloudComponent
                ],
                exports: [
                    TaskHeaderCloudComponent
                ]
            },] }
];

class CompleteTaskDirective {
    constructor(taskListService) {
        this.taskListService = taskListService;
        this.appName = '';
        this.success = new EventEmitter();
        this.error = new EventEmitter();
        this.invalidParams = [];
    }
    ngOnInit() {
        this.validateInputs();
    }
    validateInputs() {
        if (!this.isTaskValid()) {
            this.invalidParams.push('taskId');
        }
        if (!this.isAppValid()) {
            this.invalidParams.push('appName');
        }
        if (this.invalidParams.length) {
            throw new Error(`Attribute ${this.invalidParams.join(', ')} is required`);
        }
    }
    isTaskValid() {
        return this.taskId && this.taskId.length > 0;
    }
    isAppValid() {
        return !!this.appName || this.appName === '';
    }
    onClick() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const result = yield this.taskListService.completeTask(this.appName, this.taskId).toPromise();
                if (result) {
                    this.success.emit(result);
                }
            }
            catch (error) {
                this.error.emit(error);
            }
        });
    }
}
CompleteTaskDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-cloud-complete-task]'
            },] }
];
CompleteTaskDirective.ctorParameters = () => [
    { type: TaskCloudService }
];
CompleteTaskDirective.propDecorators = {
    taskId: [{ type: Input }],
    appName: [{ type: Input }],
    success: [{ type: Output }],
    error: [{ type: Output }],
    onClick: [{ type: HostListener, args: ['click',] }]
};

class ClaimTaskCloudDirective {
    constructor(taskListService, identityUserService) {
        this.taskListService = taskListService;
        this.identityUserService = identityUserService;
        this.appName = '';
        this.success = new EventEmitter();
        this.error = new EventEmitter();
        this.invalidParams = [];
    }
    ngOnInit() {
        this.validateInputs();
    }
    validateInputs() {
        if (!this.isTaskValid()) {
            this.invalidParams.push('taskId');
        }
        if (!this.isAppValid()) {
            this.invalidParams.push('appName');
        }
        if (this.invalidParams.length) {
            throw new Error(`Attribute ${this.invalidParams.join(', ')} is required`);
        }
    }
    isTaskValid() {
        return this.taskId && this.taskId.length > 0;
    }
    isAppValid() {
        return !!this.appName || this.appName === '';
    }
    onClick() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.claimTask();
            }
            catch (error) {
                this.error.emit(error);
            }
        });
    }
    claimTask() {
        return __awaiter(this, void 0, void 0, function* () {
            const currentUser = this.identityUserService.getCurrentUserInfo().username;
            try {
                const result = yield this.taskListService.claimTask(this.appName, this.taskId, currentUser).toPromise();
                if (result) {
                    this.success.emit(result);
                }
            }
            catch (error) {
                this.error.emit(error);
            }
        });
    }
}
ClaimTaskCloudDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-cloud-claim-task]'
            },] }
];
ClaimTaskCloudDirective.ctorParameters = () => [
    { type: TaskCloudService },
    { type: IdentityUserService }
];
ClaimTaskCloudDirective.propDecorators = {
    taskId: [{ type: Input }],
    appName: [{ type: Input }],
    success: [{ type: Output }],
    error: [{ type: Output }],
    onClick: [{ type: HostListener, args: ['click',] }]
};

class UnClaimTaskCloudDirective {
    constructor(taskListService) {
        this.taskListService = taskListService;
        this.appName = '';
        this.success = new EventEmitter();
        this.error = new EventEmitter();
        this.invalidParams = [];
    }
    ngOnInit() {
        this.validateInputs();
    }
    validateInputs() {
        if (!this.isTaskValid()) {
            this.invalidParams.push('taskId');
        }
        if (!this.isAppValid()) {
            this.invalidParams.push('appName');
        }
        if (this.invalidParams.length) {
            throw new Error(`Attribute ${this.invalidParams.join(', ')} is required`);
        }
    }
    isTaskValid() {
        return this.taskId && this.taskId.length > 0;
    }
    isAppValid() {
        return !!this.appName || this.appName === '';
    }
    onClick() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.taskListService.unclaimTask(this.appName, this.taskId).toPromise();
                this.success.emit(this.taskId);
            }
            catch (error) {
                this.error.emit(error);
            }
        });
    }
}
UnClaimTaskCloudDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-cloud-unclaim-task]'
            },] }
];
UnClaimTaskCloudDirective.ctorParameters = () => [
    { type: TaskCloudService }
];
UnClaimTaskCloudDirective.propDecorators = {
    taskId: [{ type: Input }],
    appName: [{ type: Input }],
    success: [{ type: Output }],
    error: [{ type: Output }],
    onClick: [{ type: HostListener, args: ['click',] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TaskDirectiveModule {
}
TaskDirectiveModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    CompleteTaskDirective,
                    ClaimTaskCloudDirective,
                    UnClaimTaskCloudDirective
                ],
                exports: [
                    CompleteTaskDirective,
                    ClaimTaskCloudDirective,
                    UnClaimTaskCloudDirective
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TaskFormCloudComponent {
    constructor(taskCloudService, formRenderingService) {
        this.taskCloudService = taskCloudService;
        this.formRenderingService = formRenderingService;
        this.appName = '';
        this.showTitle = true;
        this.showRefreshButton = false;
        this.showValidationIcon = true;
        this.showCancelButton = true;
        this.showCompleteButton = true;
        this.readOnly = false;
        this.formSaved = new EventEmitter();
        this.formCompleted = new EventEmitter();
        this.taskCompleted = new EventEmitter();
        this.taskClaimed = new EventEmitter();
        this.taskUnclaimed = new EventEmitter();
        this.cancelClick = new EventEmitter();
        this.error = new EventEmitter();
        this.formContentClicked = new EventEmitter();
        this.candidateUsers = [];
        this.candidateGroups = [];
        this.loading = false;
        this.formRenderingService.setComponentTypeResolver('upload', () => AttachFileCloudWidgetComponent, true);
        this.formRenderingService.setComponentTypeResolver('dropdown', () => DropdownCloudWidgetComponent, true);
        this.formRenderingService.setComponentTypeResolver('date', () => DateCloudWidgetComponent, true);
    }
    ngOnInit() {
        if (this.appName === '' && this.taskId) {
            this.loadTask();
        }
    }
    ngOnChanges(changes) {
        const appName = changes['appName'];
        if (appName && (appName.currentValue !== appName.previousValue) && this.taskId) {
            this.loadTask();
            return;
        }
        const taskId = changes['taskId'];
        if (taskId && taskId.currentValue && this.appName) {
            this.loadTask();
            return;
        }
    }
    loadTask() {
        this.loading = true;
        this.taskCloudService
            .getTaskById(this.appName, this.taskId)
            .subscribe(details => {
            this.taskDetails = details;
            this.loading = false;
        });
        this.taskCloudService
            .getCandidateUsers(this.appName, this.taskId)
            .subscribe(users => this.candidateUsers = users || []);
        this.taskCloudService
            .getCandidateGroups(this.appName, this.taskId)
            .subscribe(groups => this.candidateGroups = groups || []);
    }
    hasForm() {
        return this.taskDetails && !!this.taskDetails.formKey;
    }
    canCompleteTask() {
        return this.showCompleteButton && !this.readOnly && this.taskCloudService.canCompleteTask(this.taskDetails);
    }
    canClaimTask() {
        return !this.readOnly && this.taskCloudService.canClaimTask(this.taskDetails);
    }
    hasCandidateUsers() {
        return this.candidateUsers.length !== 0;
    }
    hasCandidateGroups() {
        return this.candidateGroups.length !== 0;
    }
    hasCandidateUsersOrGroups() {
        var _a;
        let hasCandidateUsersOrGroups = false;
        if (((_a = this.taskDetails) === null || _a === void 0 ? void 0 : _a.status) === 'ASSIGNED') {
            hasCandidateUsersOrGroups = this.hasCandidateUsers() || this.hasCandidateGroups();
        }
        return hasCandidateUsersOrGroups;
    }
    canUnclaimTask() {
        return !this.readOnly && this.taskCloudService.canUnclaimTask(this.taskDetails);
    }
    isReadOnly() {
        return this.readOnly || !this.taskCloudService.canCompleteTask(this.taskDetails);
    }
    onCompleteTask() {
        this.loadTask();
        this.taskCompleted.emit(this.taskId);
    }
    onClaimTask() {
        this.loadTask();
        this.taskClaimed.emit(this.taskId);
    }
    onUnclaimTask() {
        this.loadTask();
        this.taskUnclaimed.emit(this.taskId);
    }
    onCancelClick() {
        this.cancelClick.emit(this.taskId);
    }
    onFormSaved(form) {
        this.formSaved.emit(form);
    }
    onFormCompleted(form) {
        this.formCompleted.emit(form);
        this.taskCompleted.emit(this.taskId);
    }
    onError(data) {
        this.error.emit(data);
    }
    onFormContentClicked(content) {
        this.formContentClicked.emit(content);
    }
}
TaskFormCloudComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-cloud-task-form',
                template: "<div *ngIf=\"!loading; else loadingTemplate\">\n    <adf-cloud-form *ngIf=\"hasForm(); else withoutForm\"\n                    [appName]=\"appName\"\n                    [appVersion]=\"taskDetails.appVersion\"\n                    [taskId]=\"taskId\"\n                    [showTitle]=\"showTitle\"\n                    [processInstanceId]=\"taskDetails.processInstanceId\"\n                    [readOnly]=\"isReadOnly()\"\n                    [showRefreshButton]=\"showRefreshButton\"\n                    [showValidationIcon]=\"showValidationIcon\"\n                    [showCompleteButton]=\"canCompleteTask()\"\n                    [showSaveButton]=\"canCompleteTask()\"\n                    (formSaved)=\"onFormSaved($event)\"\n                    (formCompleted)=\"onFormCompleted($event)\"\n                    (formError)=\"onError($event)\"\n                    (error)=\"onError($event)\"\n                    (formContentClicked)=\"onFormContentClicked($event)\">\n        <adf-cloud-form-custom-outcomes>\n            <ng-template [ngTemplateOutlet]=\"taskFormCloudButtons\">\n            </ng-template>\n        </adf-cloud-form-custom-outcomes>\n    </adf-cloud-form>\n\n    <ng-template #withoutForm>\n        <mat-card class=\"adf-task-form-container\">\n            <mat-card-header *ngIf=\"showTitle\">\n                <mat-card-title>\n                    <h4>\n                        <span class=\"adf-form-title\">\n                            {{ taskDetails?.name || 'FORM.FORM_RENDERER.NAMELESS_TASK' | translate }}\n                        </span>\n                    </h4>\n                </mat-card-title>\n            </mat-card-header>\n            <mat-card-content>\n                <adf-empty-content\n                    [icon]=\"'description'\"\n                    [title]=\"'ADF_CLOUD_TASK_FORM.EMPTY_FORM.TITLE'\"\n                    [subtitle]=\"'ADF_CLOUD_TASK_FORM.EMPTY_FORM.SUBTITLE'\">\n                </adf-empty-content>\n            </mat-card-content>\n            <mat-card-actions class=\"adf-task-form-actions\">\n                <ng-template [ngTemplateOutlet]=\"taskFormCloudButtons\">\n                </ng-template>\n                <button mat-button *ngIf=\"canCompleteTask()\" adf-cloud-complete-task [appName]=\"appName\"\n                        [taskId]=\"taskId\" (success)=\"onCompleteTask()\" (error)=\"onError($event)\" color=\"primary\" id=\"adf-form-complete\">\n                    {{'ADF_CLOUD_TASK_FORM.EMPTY_FORM.BUTTONS.COMPLETE' | translate}}\n                </button>\n            </mat-card-actions>\n        </mat-card>\n    </ng-template>\n    <ng-template #taskFormCloudButtons>\n        <button mat-button *ngIf=\"showCancelButton\" id=\"adf-cloud-cancel-task\" (click)=\"onCancelClick()\">\n            {{'ADF_CLOUD_TASK_FORM.EMPTY_FORM.BUTTONS.CANCEL' | translate}}\n        </button>\n        <button mat-button *ngIf=\"canClaimTask()\" adf-cloud-claim-task [appName]=\"appName\" [taskId]=\"taskId\"\n                (success)=\"onClaimTask()\" (error)=\"onError($event)\">\n            {{'ADF_CLOUD_TASK_FORM.EMPTY_FORM.BUTTONS.CLAIM' | translate}}\n        </button>\n        <button mat-button *ngIf=\"hasCandidateUsersOrGroups()\" adf-cloud-unclaim-task [appName]=\"appName\" [taskId]=\"taskId\"\n                (success)=\"onUnclaimTask()\" (error)=\"onError($event)\">\n            {{'ADF_CLOUD_TASK_FORM.EMPTY_FORM.BUTTONS.UNCLAIM' | translate}}\n        </button>\n    </ng-template>\n</div>\n\n<ng-template #loadingTemplate>\n    <div fxLayout=\"row\" fxLayoutAlign=\"center stretch\">\n        <mat-spinner></mat-spinner>\n    </div>\n</ng-template>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-task-form-container{overflow:hidden}.adf-task-form-actions{float:right;padding-bottom:25px!important;padding-right:25px!important}.adf-task-form-actions .mat-button{border-radius:5px;height:36px}.adf-task-form-actions .mat-button-wrapper{font-size:var(--theme-body-2-font-size);font-weight:700;height:20px;opacity:.54;width:58px}"]
            },] }
];
TaskFormCloudComponent.ctorParameters = () => [
    { type: TaskCloudService },
    { type: FormRenderingService }
];
TaskFormCloudComponent.propDecorators = {
    appName: [{ type: Input }],
    taskId: [{ type: Input }],
    showTitle: [{ type: Input }],
    showRefreshButton: [{ type: Input }],
    showValidationIcon: [{ type: Input }],
    showCancelButton: [{ type: Input }],
    showCompleteButton: [{ type: Input }],
    readOnly: [{ type: Input }],
    formSaved: [{ type: Output }],
    formCompleted: [{ type: Output }],
    taskCompleted: [{ type: Output }],
    taskClaimed: [{ type: Output }],
    taskUnclaimed: [{ type: Output }],
    cancelClick: [{ type: Output }],
    error: [{ type: Output }],
    formContentClicked: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TaskFormModule {
}
TaskFormModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CoreModule,
                    CommonModule,
                    MaterialModule,
                    FormCloudModule,
                    TaskDirectiveModule,
                    FlexLayoutModule
                ],
                declarations: [
                    TaskFormCloudComponent
                ],
                exports: [
                    TaskFormCloudComponent
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TaskCloudModule {
}
TaskCloudModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    TaskListCloudModule,
                    TaskFiltersCloudModule,
                    StartTaskCloudModule,
                    TaskHeaderCloudModule,
                    TaskDirectiveModule,
                    TaskFormModule
                ],
                exports: [
                    TaskListCloudModule,
                    TaskFiltersCloudModule,
                    StartTaskCloudModule,
                    TaskHeaderCloudModule,
                    TaskDirectiveModule,
                    TaskFormModule
                ]
            },] }
];

class ProcessFilterCloudModel {
    constructor(obj) {
        this.dateRangeFilterService = new DateRangeFilterService();
        if (obj) {
            this.id = obj.id || Math.random().toString(36).substring(2, 9);
            this.name = obj.name || null;
            this.key = obj.key || null;
            this.icon = obj.icon || null;
            this.index = obj.index || null;
            this.appName = obj.appName || obj.appName === '' ? obj.appName : null;
            this.appVersion = obj.appVersion || null;
            if (obj.appVersionMultiple && Array.isArray(obj.appVersionMultiple)) {
                this.appVersion = obj.appVersionMultiple;
            }
            this.processInstanceId = obj.processInstanceId || null;
            this.processName = obj.processName || null;
            this.initiator = obj.initiator || null;
            this.status = obj.status || null;
            this.sort = obj.sort || null;
            this.order = obj.order || null;
            this.processDefinitionId = obj.processDefinitionId || null;
            this.processDefinitionName = obj.processDefinitionName || null;
            this.processDefinitionKey = obj.processDefinitionKey || null;
            this.lastModified = obj.lastModified || null;
            this.lastModifiedTo = obj.lastModifiedTo || null;
            this.lastModifiedFrom = obj.lastModifiedFrom || null;
            this.startedDate = obj.startedDate || null;
            this.startFrom = obj._startFrom || null;
            this.startTo = obj._startTo || null;
            this.completedDateType = obj.completedDateType || null;
            this.startedDateType = obj.startedDateType || null;
            this.suspendedDateType = obj.suspendedDateType || null;
            this.completedFrom = obj._completedFrom || null;
            this.completedTo = obj._completedTo || null;
            this.completedDate = obj.completedDate || null;
            this._suspendedFrom = obj._suspendedFrom || null;
            this._suspendedTo = obj._suspendedTo || null;
        }
    }
    set completedFrom(completedFrom) {
        this._completedFrom = completedFrom;
    }
    set completedTo(completedTo) {
        this._completedTo = completedTo;
    }
    get completedFrom() {
        if (this.isDateRangeType(this.completedDateType)) {
            return this._completedFrom;
        }
        return this.getStartDate(this.completedDateType);
    }
    get completedTo() {
        if (this.isDateRangeType(this.completedDateType)) {
            return this._completedTo;
        }
        return this.getEndDate(this.completedDateType);
    }
    set startFrom(startFrom) {
        this._startFrom = startFrom;
    }
    set startTo(startTo) {
        this._startTo = startTo;
    }
    get startFrom() {
        if (this.isDateRangeType(this.startedDateType)) {
            return this._startFrom;
        }
        return this.getStartDate(this.startedDateType);
    }
    get startTo() {
        if (this.isDateRangeType(this.startedDateType)) {
            return this._startTo;
        }
        return this.getEndDate(this.startedDateType);
    }
    set suspendedFrom(suspendedFrom) {
        this._suspendedFrom = suspendedFrom;
    }
    set suspendedTo(suspendedTo) {
        this._suspendedTo = suspendedTo;
    }
    get suspendedFrom() {
        if (this.isDateRangeType(this.suspendedDateType)) {
            return this._suspendedFrom;
        }
        return this.getStartDate(this.suspendedDateType);
    }
    get suspendedTo() {
        if (this.isDateRangeType(this.suspendedDateType)) {
            return this._suspendedTo;
        }
        return this.getEndDate(this.suspendedDateType);
    }
    getStartDate(key) {
        return this.dateRangeFilterService.getDateRange(key).startDate;
    }
    getEndDate(key) {
        return this.dateRangeFilterService.getDateRange(key).endDate;
    }
    isDateRangeType(type) {
        return !!this.dateRangeFilterService.isDateRangeType(type);
    }
}

class ProcessFilterCloudService {
    constructor(preferenceService, identityUserService) {
        this.preferenceService = preferenceService;
        this.identityUserService = identityUserService;
        this.filtersSubject = new BehaviorSubject([]);
        this.filters$ = this.filtersSubject.asObservable();
    }
    readQueryParams(obj) {
        const model = Object.assign({}, obj);
        if (obj.hasOwnProperty('appVersion') && obj['appVersion']) {
            if (typeof obj['appVersion'] === 'string') {
                model.appVersion = obj['appVersion'].split(',').map(str => parseInt(str, 10));
            }
        }
        if (obj.hasOwnProperty('lastModifiedFrom')) {
            model.lastModifiedFrom = new Date(parseInt(obj['lastModifiedFrom'], 10));
        }
        if (obj.hasOwnProperty('lastModifiedTo')) {
            model.lastModifiedTo = new Date(parseInt(obj['lastModifiedTo'], 10));
        }
        return model;
    }
    writeQueryParams(value, filterProperties, appName, id) {
        value = value || {};
        const result = {
            appName: appName || value['appName'],
            id: id || value['id']
        };
        for (const prop of filterProperties) {
            if (prop === 'appVersionMultiple') {
                const versions = value['appVersion'];
                if (Array.isArray(versions) && versions.length > 0) {
                    result['appVersion'] = versions.join(',');
                }
            }
            else if (prop === 'lastModified') {
                if (value['lastModifiedFrom']) {
                    result['lastModifiedFrom'] = value['lastModifiedFrom'].valueOf();
                }
                if (value['lastModifiedTo']) {
                    result['lastModifiedTo'] = value['lastModifiedTo'].valueOf();
                }
            }
            else if (value.hasOwnProperty(prop)) {
                result[prop] = value[prop];
            }
        }
        return result;
    }
    createDefaultFilters(appName) {
        const key = this.prepareKey(appName);
        this.preferenceService.getPreferences(appName, key).pipe(switchMap((response) => {
            const preferences = (response && response.list && response.list.entries) ? response.list.entries : [];
            if (!this.hasPreferences(preferences)) {
                return this.createProcessFilters(appName, key, this.defaultProcessFilters(appName));
            }
            else if (!this.hasProcessFilters(preferences, key)) {
                return this.createProcessFilters(appName, key, this.defaultProcessFilters(appName));
            }
            else {
                return of(this.findFiltersByKeyInPreferences(preferences, key));
            }
        }), catchError((err) => this.handleProcessError(err))).subscribe((filters) => {
            this.addFiltersToStream(filters);
        });
    }
    getProcessFilters(appName) {
        this.createDefaultFilters(appName);
        return this.filters$;
    }
    getFilterById(appName, id) {
        const key = this.prepareKey(appName);
        return this.getProcessFiltersByKey(appName, key).pipe(switchMap((filters) => {
            if (filters && filters.length === 0) {
                return this.createProcessFilters(appName, key, this.defaultProcessFilters(appName));
            }
            else {
                return of(filters);
            }
        }), map((filters) => {
            return filters.filter((filter) => {
                return filter.id === id;
            })[0];
        }), catchError((err) => this.handleProcessError(err)));
    }
    addFilter(newFilter) {
        const { appName, name } = newFilter;
        const key = this.prepareKey(appName);
        return this.getProcessFiltersByKey(appName, key).pipe(switchMap((filters) => {
            if (filters && filters.length === 0) {
                return this.createProcessFilters(appName, key, [newFilter]);
            }
            else {
                const index = filters.findIndex(filter => filter.name === name);
                if (index >= 0) {
                    filters.splice(index, 1);
                }
                filters.push(newFilter);
                return this.preferenceService.updatePreference(appName, key, filters);
            }
        }), map((filters) => {
            this.addFiltersToStream(filters);
            return filters;
        }), catchError((err) => this.handleProcessError(err)));
    }
    updateFilter(updatedFilter) {
        const key = this.prepareKey(updatedFilter.appName);
        return this.getProcessFiltersByKey(updatedFilter.appName, key).pipe(switchMap((filters) => {
            if (filters && filters.length === 0) {
                return this.createProcessFilters(updatedFilter.appName, key, [updatedFilter]);
            }
            else {
                const itemIndex = filters.findIndex((filter) => filter.id === updatedFilter.id);
                filters[itemIndex] = updatedFilter;
                return this.updateProcessFilters(updatedFilter.appName, key, filters);
            }
        }), map((updatedFilters) => {
            this.addFiltersToStream(updatedFilters);
            return updatedFilters;
        }), catchError((err) => this.handleProcessError(err)));
    }
    deleteFilter(deletedFilter) {
        const key = this.prepareKey(deletedFilter.appName);
        return this.getProcessFiltersByKey(deletedFilter.appName, key).pipe(switchMap(filters => {
            if (filters && filters.length > 0) {
                filters = filters.filter(filter => filter.id !== deletedFilter.id);
                return this.updateProcessFilters(deletedFilter.appName, key, filters);
            }
            else {
                return of([]);
            }
        }), map((filters) => {
            this.addFiltersToStream(filters);
            return filters;
        }), catchError((err) => this.handleProcessError(err)));
    }
    isDefaultFilter(filterName) {
        const defaultFilters = this.defaultProcessFilters();
        return defaultFilters.findIndex((filter) => filterName === filter.name) !== -1;
    }
    hasPreferences(preferences) {
        return preferences && preferences.length > 0;
    }
    hasProcessFilters(preferences, key) {
        const filters = preferences.find((filter) => { return filter.entry.key === key; });
        return (filters && filters.entry) ? JSON.parse(filters.entry.value).length > 0 : false;
    }
    createProcessFilters(appName, key, filters) {
        return this.preferenceService.createPreference(appName, key, filters);
    }
    getProcessFiltersByKey(appName, key) {
        return this.preferenceService.getPreferenceByKey(appName, key);
    }
    updateProcessFilters(appName, key, filters) {
        return this.preferenceService.updatePreference(appName, key, filters);
    }
    prepareKey(appName) {
        const user = this.identityUserService.getCurrentUserInfo();
        return `process-filters-${appName}-${user.username}`;
    }
    findFiltersByKeyInPreferences(preferences, key) {
        const result = preferences.find((filter) => { return filter.entry.key === key; });
        return result && result.entry ? JSON.parse(result.entry.value) : [];
    }
    addFiltersToStream(filters) {
        this.filtersSubject.next(filters);
    }
    handleProcessError(error) {
        return throwError(error || 'Server error');
    }
    defaultProcessFilters(appName) {
        return [
            new ProcessFilterCloudModel({
                name: 'ADF_CLOUD_PROCESS_FILTERS.RUNNING_PROCESSES',
                icon: 'inbox',
                key: 'running-processes',
                appName,
                sort: 'startDate',
                status: 'RUNNING',
                order: 'DESC'
            }),
            new ProcessFilterCloudModel({
                name: 'ADF_CLOUD_PROCESS_FILTERS.COMPLETED_PROCESSES',
                icon: 'done',
                key: 'completed-processes',
                appName,
                sort: 'startDate',
                status: 'COMPLETED',
                order: 'DESC'
            }),
            new ProcessFilterCloudModel({
                name: 'ADF_CLOUD_PROCESS_FILTERS.ALL_PROCESSES',
                key: 'all-processes',
                icon: 'adjust',
                appName,
                sort: 'startDate',
                status: '',
                order: 'DESC'
            })
        ];
    }
}
ProcessFilterCloudService.ɵprov = ɵɵdefineInjectable({ factory: function ProcessFilterCloudService_Factory() { return new ProcessFilterCloudService(ɵɵinject(PROCESS_FILTERS_SERVICE_TOKEN), ɵɵinject(IdentityUserService)); }, token: ProcessFilterCloudService, providedIn: "root" });
ProcessFilterCloudService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
ProcessFilterCloudService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [PROCESS_FILTERS_SERVICE_TOKEN,] }] },
    { type: IdentityUserService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessFiltersCloudComponent {
    constructor(processFilterCloudService, translationService) {
        this.processFilterCloudService = processFilterCloudService;
        this.translationService = translationService;
        this.appName = '';
        this.showIcons = false;
        this.filterSelected = new EventEmitter();
        this.filterClicked = new EventEmitter();
        this.success = new EventEmitter();
        this.error = new EventEmitter();
        this.filters = [];
        this.onDestroy$ = new Subject();
    }
    ngOnInit() {
        if (this.appName === '') {
            this.getFilters(this.appName);
        }
    }
    ngOnChanges(changes) {
        const appName = changes['appName'];
        const filter = changes['filterParam'];
        if (appName && appName.currentValue) {
            this.getFilters(appName.currentValue);
        }
        else if (filter && filter.currentValue !== filter.previousValue) {
            this.selectFilterAndEmit(filter.currentValue);
        }
    }
    getFilters(appName) {
        this.filters$ = this.processFilterCloudService.getProcessFilters(appName);
        this.filters$.pipe(takeUntil(this.onDestroy$)).subscribe((res) => {
            this.resetFilter();
            this.filters = res || [];
            this.selectFilterAndEmit(this.filterParam);
            this.success.emit(res);
        }, (err) => {
            this.error.emit(err);
        });
    }
    selectFilter(paramFilter) {
        if (paramFilter) {
            this.currentFilter = this.filters.find((filter, index) => {
                return paramFilter.id === filter.id ||
                    (paramFilter.name && this.checkFilterNamesEquality(paramFilter.name, filter.name)) ||
                    (paramFilter.key && (paramFilter.key === filter.key)) ||
                    paramFilter.index === index;
            });
        }
    }
    checkFilterNamesEquality(name1, name2) {
        const translatedName1 = this.translationService.instant(name1);
        const translatedName2 = this.translationService.instant(name2);
        return translatedName1.toLocaleLowerCase() === translatedName2.toLocaleLowerCase();
    }
    selectFilterAndEmit(newParamFilter) {
        if (newParamFilter) {
            this.selectFilter(newParamFilter);
            this.filterSelected.emit(this.currentFilter);
        }
        else {
            this.currentFilter = undefined;
        }
    }
    selectFilterById(id) {
        this.selectFilterAndEmit({ id: id });
    }
    onFilterClick(filter) {
        if (filter) {
            this.selectFilter(filter);
            this.filterClicked.emit(this.currentFilter);
        }
        else {
            this.currentFilter = undefined;
        }
    }
    selectDefaultProcessFilter() {
        if (!this.isFilterListEmpty()) {
            this.currentFilter = this.filters[0];
        }
    }
    getCurrentFilter() {
        return this.currentFilter;
    }
    isFilterListEmpty() {
        return this.filters === undefined || (this.filters && this.filters.length === 0);
    }
    resetFilter() {
        this.filters = [];
        this.currentFilter = undefined;
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
    isActiveFilter(filter) {
        return this.currentFilter.name === filter.name;
    }
}
ProcessFiltersCloudComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-cloud-process-filters',
                template: "\n<ng-container *ngIf=\"filters$ | async as filterList; else loading\">\n    <div *ngFor=\"let filter of filterList\" class=\"adf-filters__entry\" [class.adf-active]=\"currentFilter === filter\">\n        <button (click)=\"onFilterClick(filter)\"\n          [attr.aria-label]=\"filter.name | translate\"\n          [id]=\"filter.id\"\n          [attr.data-automation-id]=\"filter.key + '_filter'\"\n          mat-button\n          class=\"adf-filter-action-button adf-full-width\" fxLayout=\"row\" fxLayoutAlign=\"space-between center\">\n          <adf-icon data-automation-id=\"adf-filter-icon\" *ngIf=\"showIcons\" [value]=\"filter.icon\"></adf-icon>\n          <span data-automation-id=\"adf-filter-label\" class=\"adf-filter-action-button__label\">{{ filter.name | translate }}</span>\n        </button>\n    </div>\n</ng-container>\n<ng-template #loading>\n    <ng-container>\n        <div class=\"adf-app-list-spinner\">\n            <mat-spinner></mat-spinner>\n        </div>\n    </ng-container>\n</ng-template>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-filters__entry{cursor:pointer;font-size:14px!important;font-weight:700;height:24px;opacity:1;padding:12px 0!important;width:100%}.adf-filters__entry .adf-full-width{display:flex;width:100%}.adf-filters__entry .adf-filter-action-button .adf-filter-action-button__label{margin:0 8px!important;padding-left:20px}.adf-filters__entry.adf-active,.adf-filters__entry:hover{color:var(--theme-primary-color);opacity:1}"]
            },] }
];
ProcessFiltersCloudComponent.ctorParameters = () => [
    { type: ProcessFilterCloudService },
    { type: TranslationService }
];
ProcessFiltersCloudComponent.propDecorators = {
    appName: [{ type: Input }],
    filterParam: [{ type: Input }],
    showIcons: [{ type: Input }],
    filterSelected: [{ type: Output }],
    filterClicked: [{ type: Output }],
    success: [{ type: Output }],
    error: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessFilterDialogCloudComponent {
    constructor(fb, dialogRef, data) {
        this.fb = fb;
        this.dialogRef = dialogRef;
        this.data = data;
        this.defaultIcon = 'inbox';
    }
    ngOnInit() {
        this.filterForm = this.fb.group({
            name: [this.data.name, Validators.required]
        });
    }
    onSaveClick() {
        this.dialogRef.close({
            action: ProcessFilterDialogCloudComponent.ACTION_SAVE,
            icon: this.defaultIcon,
            name: this.nameController.value
        });
    }
    onCancelClick() {
        this.dialogRef.close();
    }
    get nameController() {
        return this.filterForm.get('name');
    }
    isValid() {
        return this.filterForm.valid;
    }
}
ProcessFilterDialogCloudComponent.ACTION_SAVE = 'SAVE';
ProcessFilterDialogCloudComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-cloud-process-filter-dialog-cloud',
                template: "<div class=\"adf-process-filter-dialog\">\n    <span mat-dialog-title id=\"adf-process-filter-dialog-title\">\n         {{ 'ADF_CLOUD_EDIT_PROCESS_FILTER.DIALOG.TITLE' | translate}}\n    </span>\n    <mat-card>\n        <mat-card-content>\n        <form [formGroup]=\"filterForm\">\n            <mat-form-field fxFlex [floatLabel]=\"'auto'\">\n                <input matInput placeholder=\"{{ 'ADF_CLOUD_EDIT_PROCESS_FILTER.FILTER_NAME' | translate }}\" formControlName=\"name\" id=\"adf-filter-name-id\">\n            </mat-form-field>\n        </form>\n        </mat-card-content>\n        <mat-card-actions fxLayout=\"row\" fxLayoutAlign=\"end end\">\n            <button mat-button (click)=\"onSaveClick()\" id=\"adf-save-button-id\" [disabled]=\"!isValid()\">\n                {{ 'ADF_CLOUD_EDIT_PROCESS_FILTER.DIALOG.SAVE' | translate}}\n            </button>\n            <button mat-button (click)=\"onCancelClick()\" id=\"adf-cancel-button-id\">\n               {{ 'ADF_CLOUD_EDIT_PROCESS_FILTER.DIALOG.CANCEL' | translate}}\n            </button>\n        </mat-card-actions>\n    </mat-card>\n</div>\n",
                styles: [".adf-process-filter-dialog .mat-card,.adf-process-filter-dialog .mat-card-content{box-shadow:none;padding:0}"]
            },] }
];
ProcessFilterDialogCloudComponent.ctorParameters = () => [
    { type: FormBuilder },
    { type: MatDialogRef },
    { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] }] }
];

class ProcessCloudService extends BaseCloudService {
    constructor(apiService, appConfigService, logService) {
        super(apiService, appConfigService);
        this.logService = logService;
        this.dataChangesDetected = new Subject();
    }
    getProcessInstanceById(appName, processInstanceId) {
        if (appName && processInstanceId) {
            const url = `${this.getBasePath(appName)}/query/v1/process-instances/${processInstanceId}`;
            return this.get(url).pipe(map((res) => {
                this.dataChangesDetected.next(res.entry);
                return res.entry;
            }));
        }
        else {
            this.logService.error('AppName and ProcessInstanceId are mandatory for querying a process');
            return throwError('AppName/ProcessInstanceId not configured');
        }
    }
    getProcessDefinitions(appName) {
        if (appName || appName === '') {
            const url = `${this.getBasePath(appName)}/rb/v1/process-definitions`;
            return this.get(url).pipe(map((res) => {
                return res.list.entries.map((processDefs) => new ProcessDefinitionCloud(processDefs.entry));
            }));
        }
        else {
            this.logService.error('AppName is mandatory for querying task');
            return throwError('AppName not configured');
        }
    }
    getApplicationVersions(appName) {
        if (appName) {
            const url = `${this.getBasePath(appName)}/query/v1/applications`;
            return this.get(url).pipe(map((appEntities) => {
                return appEntities.list.entries;
            }), catchError((err) => this.handleError(err)));
        }
        else {
            this.logService.error('AppName is mandatory for querying the versions of an application');
            return throwError('AppName not configured');
        }
    }
    cancelProcess(appName, processInstanceId) {
        if (appName && processInstanceId) {
            const queryUrl = `${this.getBasePath(appName)}/rb/v1/process-instances/${processInstanceId}`;
            return this.delete(queryUrl).pipe(map((res) => {
                this.dataChangesDetected.next(res.entry);
                return res.entry;
            }));
        }
        else {
            this.logService.error('App name and Process id are mandatory for deleting a process');
            return throwError('App name and process id not configured');
        }
    }
    handleError(error) {
        this.logService.error(error);
        return throwError(error || 'Server error');
    }
}
ProcessCloudService.ɵprov = ɵɵdefineInjectable({ factory: function ProcessCloudService_Factory() { return new ProcessCloudService(ɵɵinject(AlfrescoApiService), ɵɵinject(AppConfigService), ɵɵinject(LogService)); }, token: ProcessCloudService, providedIn: "root" });
ProcessCloudService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
ProcessCloudService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: AppConfigService },
    { type: LogService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class EditProcessFilterCloudComponent {
    constructor(formBuilder, dialog, dateAdapter, userPreferencesService, translateService, processFilterCloudService, appsProcessCloudService, processCloudService) {
        this.formBuilder = formBuilder;
        this.dialog = dialog;
        this.dateAdapter = dateAdapter;
        this.userPreferencesService = userPreferencesService;
        this.translateService = translateService;
        this.processFilterCloudService = processFilterCloudService;
        this.appsProcessCloudService = appsProcessCloudService;
        this.processCloudService = processCloudService;
        this.DATE_FORMAT = 'DD/MM/YYYY';
        this.appName = '';
        this.role = '';
        this.filterProperties = EditProcessFilterCloudComponent.DEFAULT_PROCESS_FILTER_PROPERTIES;
        this.sortProperties = EditProcessFilterCloudComponent.DEFAULT_SORT_PROPERTIES;
        this.actions = EditProcessFilterCloudComponent.DEFAULT_ACTIONS;
        this.showFilterActions = true;
        this.showTitle = true;
        this.showProcessFilterName = true;
        this.filterChange = new EventEmitter();
        this.action = new EventEmitter();
        this.filterHasBeenChanged = false;
        this.status = [
            { value: '', label: 'ADF_CLOUD_PROCESS_FILTERS.STATUS.ALL' },
            { value: 'RUNNING', label: 'ADF_CLOUD_PROCESS_FILTERS.STATUS.RUNNING' },
            { value: 'SUSPENDED', label: 'ADF_CLOUD_PROCESS_FILTERS.STATUS.SUSPENDED' },
            { value: 'CANCELLED', label: 'ADF_CLOUD_PROCESS_FILTERS.STATUS.CANCELLED' },
            { value: 'COMPLETED', label: 'ADF_CLOUD_PROCESS_FILTERS.STATUS.COMPLETED' }
        ];
        this.directions = [
            { value: 'ASC', label: 'ADF_CLOUD_PROCESS_FILTERS.DIRECTION.ASCENDING' },
            { value: 'DESC', label: 'ADF_CLOUD_PROCESS_FILTERS.DIRECTION.DESCENDING' }
        ];
        this.actionDisabledForDefault = [
            EditProcessFilterCloudComponent.ACTION_SAVE,
            EditProcessFilterCloudComponent.ACTION_DELETE
        ];
        this.applicationNames = [];
        this.allProcessDefinitionNamesOption = {
            label: 'ADF_CLOUD_PROCESS_FILTERS.STATUS.ALL',
            value: ''
        };
        this.processDefinitionNames = [];
        this.processFilterProperties = [];
        this.processFilterActions = [];
        this.toggleFilterActions = false;
        this.appVersionOptions = [];
        this.initiatorOptions = [];
        this.onDestroy$ = new Subject();
        this.isLoading = false;
    }
    get processFilter() {
        return this._filter;
    }
    set processFilter(value) {
        const isChanged = this.isFilterChanged(this._filter, value);
        this._filter = value;
        if (value === null || value === void 0 ? void 0 : value.appName) {
            this.appName = value.appName;
        }
        if (value === null || value === void 0 ? void 0 : value.id) {
            this.id = value.id;
        }
        this.processFilterProperties = this.createAndFilterProperties();
        this.processFilterActions = this.createAndFilterActions();
        this.buildForm(this.processFilterProperties);
        if (isChanged) {
            this.filterChange.emit(value);
        }
    }
    ngOnInit() {
        this.userPreferencesService
            .select(UserPreferenceValues.Locale)
            .pipe(takeUntil(this.onDestroy$))
            .subscribe(locale => this.dateAdapter.setLocale(locale));
    }
    ngOnChanges(changes) {
        const id = changes['id'];
        if (id && id.currentValue !== id.previousValue) {
            this.retrieveProcessFilterAndBuildForm();
        }
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
    buildForm(processFilterProperties) {
        this.editProcessFilterForm = this.formBuilder.group(this.getFormControlsConfig(processFilterProperties));
        this.onFilterChange();
    }
    getFormControlsConfig(processFilterProperties) {
        const properties = processFilterProperties.map((property) => {
            if (!!property.attributes) {
                return this.getAttributesControlConfig(property);
            }
            else {
                return { [property.key]: property.value };
            }
        });
        return properties.reduce(((result, current) => Object.assign(result, current)), {});
    }
    getAttributesControlConfig(property) {
        return Object.values(property.attributes).reduce((result, key) => {
            result[key] = property.value[key];
            return result;
        }, {});
    }
    retrieveProcessFilterAndBuildForm() {
        this.isLoading = true;
        this.processFilterCloudService
            .getFilterById(this.appName, this.id)
            .pipe(finalize(() => this.isLoading = false))
            .subscribe(response => {
            this.filterHasBeenChanged = false;
            this.processFilter = new ProcessFilterCloudModel(Object.assign({}, response || {}, this.processFilter || {}));
        });
    }
    onFilterChange() {
        if (this.filterChangeSub) {
            this.filterChangeSub.unsubscribe();
            this.filterChangeSub = null;
        }
        this.filterChangeSub = this.editProcessFilterForm.valueChanges
            .pipe(debounceTime(500), filter(() => this.isFormValid()), takeUntil(this.onDestroy$))
            .subscribe((formValues) => {
            this.setLastModifiedToFilter(formValues);
            const newValue = new ProcessFilterCloudModel(Object.assign({}, this.processFilter, formValues));
            const changed = !this.compareFilters(newValue, this.processFilter);
            this.filterHasBeenChanged = changed;
            if (changed) {
                this._filter = newValue;
                this.filterChange.emit(newValue);
            }
        });
    }
    createAndFilterProperties() {
        this.checkMandatoryFilterProperties();
        if (this.filterProperties.includes('appName')) {
            this.getRunningApplications();
        }
        if (this.filterProperties.includes('processDefinitionName')) {
            this.getProcessDefinitions();
        }
        if (this.filterProperties.includes('appVersionMultiple')) {
            this.getAppVersionOptions();
        }
        if (this.filterProperties.includes('initiator')) {
            this.initiatorOptions = !!this.processFilter.initiator
                ? this.processFilter.initiator.split(',').map(username => Object.assign({}, { username: username }))
                : [];
        }
        const defaultProperties = this.createProcessFilterProperties(this.processFilter);
        let filteredProperties = defaultProperties.filter((filterProperty) => this.isValidProperty(this.filterProperties, filterProperty.key));
        if (!this.filterProperties.includes('sort')) {
            filteredProperties = filteredProperties.filter(property => property.key !== 'order');
        }
        if (this.filterProperties.includes('lastModified')) {
            filteredProperties = [
                ...filteredProperties,
                ...this.createLastModifiedProperty(this.processFilter)
            ];
        }
        return filteredProperties;
    }
    checkMandatoryFilterProperties() {
        if (this.filterProperties === undefined || this.filterProperties.length === 0) {
            this.filterProperties = EditProcessFilterCloudComponent.DEFAULT_PROCESS_FILTER_PROPERTIES;
        }
    }
    isValidProperty(filterProperties, key) {
        return filterProperties ? filterProperties.indexOf(key) >= 0 : true;
    }
    get createSortProperties() {
        this.checkMandatorySortProperties();
        const defaultSortProperties = this.createProcessSortProperties();
        return defaultSortProperties.filter((sortProperty) => this.isValidProperty(this.sortProperties, sortProperty.key));
    }
    getAppVersionOptions() {
        this.appVersionOptions = [];
        this.processCloudService.getApplicationVersions(this.appName).subscribe((appVersions) => {
            appVersions.forEach(appVersion => {
                this.appVersionOptions.push({ label: appVersion.entry.version, value: appVersion.entry.version });
            });
        });
    }
    checkMandatorySortProperties() {
        if (this.sortProperties === undefined || this.sortProperties.length === 0) {
            this.sortProperties = EditProcessFilterCloudComponent.DEFAULT_SORT_PROPERTIES;
        }
    }
    createAndFilterActions() {
        this.checkMandatoryActions();
        const actions = this.createFilterActions();
        return actions.filter((action) => this.isValidAction(this.actions, action));
    }
    checkMandatoryActions() {
        if (this.actions === undefined || this.actions.length === 0) {
            this.actions = EditProcessFilterCloudComponent.DEFAULT_ACTIONS;
        }
    }
    isValidAction(actions, action) {
        return actions ? actions.indexOf(action.actionType) >= 0 : true;
    }
    isFormValid() {
        return this.editProcessFilterForm.valid;
    }
    getPropertyController(property) {
        return this.editProcessFilterForm.get(property.key);
    }
    onDateChanged(newDateValue, dateProperty) {
        if (newDateValue) {
            const controller = this.getPropertyController(dateProperty);
            if (newDateValue.isValid()) {
                controller.setValue(newDateValue);
                controller.setErrors(null);
            }
            else {
                controller.setErrors({ invalid: true });
            }
        }
    }
    onDateTypeChange(dateType, property) {
        this.editProcessFilterForm.get(property.attributes.dateType).setValue(dateType);
    }
    onDateRangeFilterChanged(dateRange, property) {
        var _a, _b;
        this.editProcessFilterForm.get((_a = property.attributes) === null || _a === void 0 ? void 0 : _a.from).setValue(dateRange.startDate ? dateRange.startDate : null);
        this.editProcessFilterForm.get((_b = property.attributes) === null || _b === void 0 ? void 0 : _b.to).setValue(dateRange.endDate ? dateRange.endDate : null);
        this.editProcessFilterForm.get(property.attributes.dateType).setValue(DateCloudFilterType.RANGE);
    }
    onChangedUser(users, processProperty) {
        this.getPropertyController(processProperty).setValue(users.map(user => user.username).join(','));
    }
    hasError(property) {
        const controller = this.getPropertyController(property);
        return controller.errors && controller.errors.invalid;
    }
    compareFilters(editedQuery, currentQuery) {
        return JSON.stringify(editedQuery).toLowerCase() === JSON.stringify(currentQuery).toLowerCase();
    }
    getRunningApplications() {
        this.applicationNames = [];
        this.appsProcessCloudService
            .getDeployedApplicationsByStatus('RUNNING', this.role)
            .subscribe((applications) => {
            if (applications && applications.length > 0) {
                applications.map((application) => {
                    this.applicationNames.push({ label: application.name, value: application.name });
                });
            }
        });
    }
    getProcessDefinitions() {
        this.processDefinitionNames = [];
        this.processCloudService.getProcessDefinitions(this.appName).subscribe((processDefinitions) => {
            if (processDefinitions && processDefinitions.length > 0) {
                this.processDefinitionNames.push(this.allProcessDefinitionNamesOption);
                processDefinitions.map((processDefinition) => {
                    this.processDefinitionNames.push({ label: processDefinition.name, value: processDefinition.name });
                });
            }
        });
    }
    executeFilterActions(action) {
        if (action.actionType === EditProcessFilterCloudComponent.ACTION_SAVE) {
            this.save(action);
        }
        else if (action.actionType === EditProcessFilterCloudComponent.ACTION_SAVE_AS) {
            this.saveAs(action);
        }
        else if (action.actionType === EditProcessFilterCloudComponent.ACTION_DELETE) {
            this.delete(action);
        }
    }
    save(saveAction) {
        this.processFilterCloudService
            .updateFilter(this.processFilter)
            .subscribe(() => {
            saveAction.filter = this.processFilter;
            this.filterHasBeenChanged = false;
            this.action.emit(saveAction);
        });
    }
    delete(deleteAction) {
        this.processFilterCloudService
            .deleteFilter(this.processFilter)
            .pipe(filter((filters) => {
            deleteAction.filter = this.processFilter;
            this.action.emit(deleteAction);
            return filters.length === 0;
        }), switchMap(() => this.restoreDefaultProcessFilters()))
            .subscribe(() => { });
    }
    saveAs(saveAsAction) {
        const dialogRef = this.dialog.open(ProcessFilterDialogCloudComponent, {
            data: {
                name: this.translateService.instant(this.processFilter.name)
            },
            height: 'auto',
            minWidth: '30%'
        });
        dialogRef.afterClosed().subscribe((result) => {
            if (result && result.action === ProcessFilterDialogCloudComponent.ACTION_SAVE) {
                const filterId = Math.random().toString(36).substr(2, 9);
                const filterKey = this.getSanitizeFilterName(result.name);
                const newFilter = {
                    name: result.name,
                    icon: result.icon,
                    id: filterId,
                    key: 'custom-' + filterKey
                };
                const resultFilter = Object.assign({}, this.processFilter, newFilter);
                this.processFilterCloudService
                    .addFilter(resultFilter)
                    .subscribe(() => {
                    saveAsAction.filter = resultFilter;
                    this.filterHasBeenChanged = false;
                    this.action.emit(saveAsAction);
                });
            }
        });
    }
    getSanitizeFilterName(filterName) {
        const nameWithHyphen = this.replaceSpaceWithHyphen(filterName.trim());
        return nameWithHyphen.toLowerCase();
    }
    replaceSpaceWithHyphen(name) {
        const regExt = new RegExp(' ', 'g');
        return name.replace(regExt, '-');
    }
    restoreDefaultProcessFilters() {
        return this.processFilterCloudService.getProcessFilters(this.appName);
    }
    onExpand() {
        this.toggleFilterActions = true;
    }
    onClose() {
        this.toggleFilterActions = false;
    }
    isDisabledAction(action) {
        return (this.processFilterCloudService.isDefaultFilter(this.processFilter.name) &&
            this.actionDisabledForDefault.includes(action.actionType)) ? true : this.hasFilterChanged(action);
    }
    hasFilterChanged(action) {
        return action.actionType === EditProcessFilterCloudComponent.ACTION_SAVE ||
            action.actionType === EditProcessFilterCloudComponent.ACTION_SAVE_AS ?
            !this.filterHasBeenChanged : false;
    }
    setLastModifiedToFilter(formValues) {
        if (formValues.lastModifiedTo && Date.parse(formValues.lastModifiedTo.toString())) {
            const lastModifiedToFilterValue = moment(formValues.lastModifiedTo);
            lastModifiedToFilterValue.set({
                hour: 23,
                minute: 59,
                second: 59
            });
            formValues.lastModifiedTo = lastModifiedToFilterValue.toDate();
        }
    }
    createFilterActions() {
        return [
            {
                actionType: EditProcessFilterCloudComponent.ACTION_SAVE,
                icon: 'adf:save',
                tooltip: 'ADF_CLOUD_EDIT_PROCESS_FILTER.TOOL_TIP.SAVE'
            },
            {
                actionType: EditProcessFilterCloudComponent.ACTION_SAVE_AS,
                icon: 'adf:save-as',
                tooltip: 'ADF_CLOUD_EDIT_PROCESS_FILTER.TOOL_TIP.SAVE_AS'
            },
            {
                actionType: EditProcessFilterCloudComponent.ACTION_DELETE,
                icon: 'delete',
                tooltip: 'ADF_CLOUD_EDIT_PROCESS_FILTER.TOOL_TIP.DELETE'
            }
        ];
    }
    createLastModifiedProperty(filterModel) {
        let lastModifiedFrom;
        let lastModifiedTo;
        if (filterModel.lastModifiedFrom) {
            lastModifiedFrom = moment(filterModel.lastModifiedFrom);
        }
        if (filterModel.lastModifiedTo) {
            lastModifiedTo = moment(filterModel.lastModifiedTo);
        }
        return [
            {
                label: 'ADF_CLOUD_EDIT_PROCESS_FILTER.LABEL.LAST_MODIFIED_DATE_FORM',
                type: 'date',
                key: 'lastModifiedFrom',
                value: lastModifiedFrom
            },
            {
                label: 'ADF_CLOUD_EDIT_PROCESS_FILTER.LABEL.LAST_MODIFIED_TO',
                type: 'date',
                key: 'lastModifiedTo',
                value: lastModifiedTo
            }
        ];
    }
    createProcessSortProperties() {
        return [
            {
                label: 'ADF_CLOUD_EDIT_PROCESS_FILTER.LABEL.ID',
                key: 'id',
                value: 'id'
            },
            {
                label: 'ADF_CLOUD_EDIT_PROCESS_FILTER.LABEL.PROCESS_NAME',
                key: 'name',
                value: 'name'
            },
            {
                label: 'ADF_CLOUD_EDIT_PROCESS_FILTER.LABEL.START_DATE',
                key: 'startDate',
                value: 'startDate'
            },
            {
                label: 'ADF_CLOUD_EDIT_PROCESS_FILTER.LABEL.STATUS',
                key: 'status',
                value: 'status'
            },
            {
                label: 'ADF_CLOUD_EDIT_PROCESS_FILTER.LABEL.STARTED_BY',
                key: 'initiator',
                value: 'initiator'
            },
            {
                label: 'ADF_CLOUD_EDIT_PROCESS_FILTER.LABEL.APP_NAME',
                key: 'appName',
                value: 'appName'
            },
            {
                label: 'ADF_CLOUD_EDIT_PROCESS_FILTER.LABEL.APP_VERSION',
                key: 'appVersion',
                value: 'appVersion'
            },
            {
                label: 'ADF_CLOUD_EDIT_PROCESS_FILTER.LABEL.PROCESS_INS_ID',
                key: 'processInstanceId',
                value: 'processInstanceId'
            },
            {
                label: 'ADF_CLOUD_EDIT_PROCESS_FILTER.LABEL.PROCESS_DEF_ID',
                key: 'processDefinitionId',
                value: 'processDefinitionId'
            },
            {
                label: 'ADF_CLOUD_EDIT_PROCESS_FILTER.LABEL.PROCESS_DEF_NAME',
                key: 'processDefinitionName',
                value: 'processDefinitionName'
            },
            {
                label: 'ADF_CLOUD_EDIT_PROCESS_FILTER.LABEL.PROCESS_DEF_KEY',
                key: 'processDefinitionKey',
                value: 'processDefinitionKey'
            },
            {
                label: 'ADF_CLOUD_EDIT_PROCESS_FILTER.LABEL.LAST_MODIFIED',
                key: 'lastModified',
                value: 'lastModified'
            },
            {
                label: 'ADF_CLOUD_EDIT_PROCESS_FILTER.LABEL.BUSINESS_KEY',
                key: 'businessKey',
                value: 'businessKey'
            }
        ];
    }
    isFilterChanged(oldValue, newValue) {
        const oldJson = JSON.stringify(this.processFilterCloudService.writeQueryParams(oldValue || {}, this.filterProperties));
        const newJson = JSON.stringify(this.processFilterCloudService.writeQueryParams(newValue || {}, this.filterProperties));
        return oldJson !== newJson;
    }
    createProcessFilterProperties(filterModel) {
        const appVersionMultiple = [];
        if (filterModel.appVersion) {
            appVersionMultiple.push(Array.isArray(filterModel.appVersion)
                ? filterModel.appVersion.map(entry => entry.toString())
                : `${filterModel.appVersion}`);
        }
        return [
            {
                label: 'ADF_CLOUD_EDIT_PROCESS_FILTER.LABEL.APP_NAME',
                type: 'select',
                key: 'appName',
                value: filterModel.appName || '',
                options: this.applicationNames
            },
            {
                label: 'ADF_CLOUD_EDIT_PROCESS_FILTER.LABEL.APP_VERSION',
                type: 'number',
                key: 'appVersion',
                value: filterModel.appVersion
            },
            {
                label: 'ADF_CLOUD_EDIT_PROCESS_FILTER.LABEL.APP_VERSION',
                type: 'multi-select',
                key: 'appVersionMultiple',
                value: appVersionMultiple,
                options: this.appVersionOptions
            },
            {
                label: 'ADF_CLOUD_EDIT_PROCESS_FILTER.LABEL.PROCESS_INS_ID',
                type: 'text',
                key: 'processInstanceId',
                value: filterModel.processInstanceId || ''
            },
            {
                label: 'ADF_CLOUD_EDIT_PROCESS_FILTER.LABEL.PROCESS_NAME',
                type: 'text',
                key: 'processName',
                value: filterModel.processName || ''
            },
            {
                label: 'ADF_CLOUD_EDIT_PROCESS_FILTER.LABEL.PROCESS_DEF_NAME',
                type: 'select',
                key: 'processDefinitionName',
                value: filterModel.processDefinitionName || '',
                options: this.processDefinitionNames
            },
            {
                label: 'ADF_CLOUD_EDIT_PROCESS_FILTER.LABEL.STATUS',
                type: 'select',
                key: 'status',
                value: filterModel.status || this.status[0].value,
                options: this.status
            },
            {
                label: 'ADF_CLOUD_EDIT_PROCESS_FILTER.LABEL.PROCESS_DEF_ID',
                type: 'text',
                key: 'processDefinitionId',
                value: filterModel.processDefinitionId || ''
            },
            {
                label: 'ADF_CLOUD_EDIT_PROCESS_FILTER.LABEL.PROCESS_DEF_KEY',
                type: 'text',
                key: 'processDefinitionKey',
                value: filterModel.processDefinitionKey || ''
            },
            {
                label: 'ADF_CLOUD_EDIT_PROCESS_FILTER.LABEL.SORT',
                type: 'select',
                key: 'sort',
                value: filterModel.sort || this.createSortProperties[0].value,
                options: this.createSortProperties
            },
            {
                label: 'ADF_CLOUD_EDIT_PROCESS_FILTER.LABEL.DIRECTION',
                type: 'select',
                key: 'order',
                value: filterModel.order || this.directions[0].value,
                options: this.directions
            },
            {
                label: 'ADF_CLOUD_EDIT_PROCESS_FILTER.LABEL.COMPLETED_DATE',
                type: 'date',
                key: 'completedDate',
                value: filterModel.completedDate || false
            },
            {
                label: 'ADF_CLOUD_EDIT_PROCESS_FILTER.LABEL.STARTED_BY',
                type: 'people',
                key: 'initiator',
                value: filterModel.initiator,
                selectionMode: 'multiple'
            },
            {
                label: 'ADF_CLOUD_EDIT_PROCESS_FILTER.LABEL.COMPLETED_DATE',
                type: 'date-range',
                key: 'completedDateRange',
                attributes: { dateType: 'completedDateType', from: '_completedFrom', to: '_completedTo' },
                value: {
                    completedDateType: filterModel.completedDateType || null,
                    _completedFrom: filterModel.completedFrom || null,
                    _completedTo: filterModel.completedTo || null
                }
            },
            {
                label: 'ADF_CLOUD_EDIT_PROCESS_FILTER.LABEL.STARTED_DATE',
                type: 'date-range',
                key: 'startedDateRange',
                attributes: { dateType: 'startedDateType', from: '_startFrom', to: '_startTo' },
                value: {
                    startedDateType: filterModel.startedDateType || null,
                    _startFrom: filterModel.startFrom || null,
                    _startTo: filterModel.startTo || null
                }
            },
            {
                label: 'ADF_CLOUD_EDIT_PROCESS_FILTER.LABEL.SUSPENDED_DATE',
                type: 'date-range',
                key: 'suspendedDateRange',
                attributes: { dateType: 'suspendedDateType', from: '_suspendedFrom', to: '_suspendedTo' },
                value: {
                    suspendedDateType: filterModel.suspendedDateType || null,
                    _suspendedFrom: filterModel.suspendedFrom || null,
                    _suspendedTo: filterModel.suspendedTo || null
                }
            }
        ];
    }
}
EditProcessFilterCloudComponent.ACTION_SAVE = 'save';
EditProcessFilterCloudComponent.ACTION_SAVE_AS = 'saveAs';
EditProcessFilterCloudComponent.ACTION_DELETE = 'delete';
EditProcessFilterCloudComponent.DEFAULT_PROCESS_FILTER_PROPERTIES = ['status', 'sort', 'order', 'lastModified'];
EditProcessFilterCloudComponent.DEFAULT_SORT_PROPERTIES = ['id', 'name', 'status', 'startDate'];
EditProcessFilterCloudComponent.DEFAULT_ACTIONS = ['save', 'saveAs', 'delete'];
EditProcessFilterCloudComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-cloud-edit-process-filter',
                template: "<mat-accordion [hideToggle]=\"isLoading\">\n    <mat-expansion-panel (afterExpand)=\"onExpand()\" (closed)=\"onClose()\">\n        <mat-expansion-panel-header *ngIf=\"processFilter\" id=\"adf-edit-process-filter-expansion-header\">\n            <ng-container *ngIf=\"!isLoading; else loadingTemplate\">\n                <mat-panel-title *ngIf=\"showProcessFilterName\" fxLayoutAlign=\"space-between center\" id=\"adf-edit-process-filter-title-id\">{{processFilter.name | translate}}</mat-panel-title>\n                <mat-panel-description fxLayoutAlign=\"space-between center\" id=\"adf-edit-process-filter-sub-title-id\">\n                    <span *ngIf=\"showTitle\"> {{ 'ADF_CLOUD_EDIT_PROCESS_FILTER.TITLE' | translate}}</span>\n                    <div *ngIf=\"showFilterActions\" class=\"adf-cloud-edit-process-filter-actions\">\n                        <ng-container *ngIf=\"toggleFilterActions\">\n                            <button *ngFor=\"let filterAction of processFilterActions\" mat-icon-button matTooltip=\"{{ filterAction.tooltip | translate}}\" [attr.data-automation-id]=\"'adf-filter-action-' + filterAction.actionType\" [disabled]=\"isDisabledAction(filterAction)\" (click)=\"executeFilterActions(filterAction)\">\n                                <adf-icon [value]=\"filterAction.icon\"></adf-icon>\n                            </button>\n                        </ng-container>\n                    </div>\n                </mat-panel-description>\n            </ng-container>\n            <ng-template #loadingTemplate>\n                <div class=\"adf-cloud-edit-process-filter-loading-margin\">\n                    <mat-spinner [diameter]=\"30\"></mat-spinner>\n                </div>\n            </ng-template>\n        </mat-expansion-panel-header>\n        <ng-container *ngIf=\"!isLoading\">\n            <form [formGroup]=\"editProcessFilterForm\" *ngIf=\"editProcessFilterForm\">\n                <div fxLayout=\"row wrap\" fxLayout.xs=\"column\" fxLayoutGap=\"10px\" fxLayoutAlign=\"start center\">\n                    <ng-container *ngFor=\"let processFilterProperty of processFilterProperties\">\n                        <mat-form-field [floatLabel]=\"'auto'\" fxFlex=\"23%\" *ngIf=\"processFilterProperty.type === 'select'\" [attr.data-automation-id]=\"processFilterProperty.key\">\n                            <mat-select\n                                placeholder=\"{{processFilterProperty.label | translate}}\"\n                                [formControlName]=\"processFilterProperty.key\"\n                                [attr.data-automation-id]=\"'adf-cloud-edit-process-property-' + processFilterProperty.key\">\n                                <mat-option\n                                    *ngFor=\"let propertyOption of processFilterProperty.options\"\n                                    [value]=\"propertyOption.value\"\n                                    [attr.data-automation-id]=\"'adf-cloud-edit-process-property-options-' + processFilterProperty.key\"\n                                >{{ propertyOption.label | translate }}</mat-option>\n                            </mat-select>\n                        </mat-form-field>\n                        <mat-form-field [floatLabel]=\"'auto'\" fxFlex=\"23%\" *ngIf=\"processFilterProperty.type === 'multi-select'\" [attr.data-automation-id]=\"processFilterProperty.key\">\n                            <mat-select\n                                placeholder=\"{{processFilterProperty.label | translate}}\"\n                                [formControlName]=\"processFilterProperty.key\"\n                                [attr.data-automation-id]=\"'adf-cloud-edit-process-property-' + processFilterProperty.key\"\n                                [multiple]=\"true\">\n                                <mat-option *ngFor=\"let propertyOption of processFilterProperty.options\" [value]=\"propertyOption.value\" [attr.data-automation-id]=\"'adf-cloud-edit-process-property-options-' + processFilterProperty.key\">\n                                    {{ propertyOption.label | translate }}\n                                </mat-option>\n                            </mat-select>\n                        </mat-form-field>\n                        <mat-form-field [floatLabel]=\"'auto'\" fxFlex=\"23%\" *ngIf=\"processFilterProperty.type === 'text'\" [attr.data-automation-id]=\"processFilterProperty.key\">\n                            <input matInput\n                                [formControlName]=\"processFilterProperty.key\"\n                                type=\"text\"\n                                placeholder=\"{{processFilterProperty.label | translate}}\"\n                                [attr.data-automation-id]=\"'adf-cloud-edit-process-property-' + processFilterProperty.key\"/>\n                        </mat-form-field>\n                        <mat-form-field [floatLabel]=\"'auto'\" fxFlex=\"23%\" *ngIf=\"processFilterProperty.type === 'number'\" [attr.data-automation-id]=\"processFilterProperty.key\">\n                            <input matInput\n                                [formControlName]=\"processFilterProperty.key\"\n                                type=\"number\" min=\"0\"\n                                placeholder=\"{{processFilterProperty.label | translate}}\"\n                                [attr.data-automation-id]=\"'adf-cloud-edit-process-property-' + processFilterProperty.key\"/>\n                        </mat-form-field>\n                        <mat-form-field [floatLabel]=\"'auto'\" fxFlex=\"23%\" *ngIf=\"processFilterProperty.type === 'date'\" [attr.data-automation-id]=\"processFilterProperty.key\">\n                            <mat-label>{{processFilterProperty.label | translate}}</mat-label>\n                            <input\n                                matInput\n                                [formControlName]=\"processFilterProperty.key\"\n                                (keyup)=\"onDateChanged($any($event).srcElement.value, processFilterProperty)\"\n                                (dateChange)=\"onDateChanged($event.value, processFilterProperty)\"\n                                [matDatepicker]=\"dateController\"\n                                placeholder=\"{{processFilterProperty.label | translate}}\"\n                                [attr.data-automation-id]=\"'adf-cloud-edit-process-property-' + processFilterProperty.key\">\n                        <mat-datepicker-toggle matSuffix [for]=\"dateController\" [attr.data-automation-id]=\"'adf-cloud-edit-process-property-date-toggle-' + processFilterProperty.key\"></mat-datepicker-toggle>\n                        <mat-datepicker #dateController [attr.data-automation-id]=\"'adf-cloud-edit-process-property-date-picker-' + processFilterProperty.key\"></mat-datepicker>\n                        <div class=\"adf-edit-process-filter-date-error-container\">\n                            <div *ngIf=\"hasError(processFilterProperty)\">\n                                <div class=\"adf-error-text\">{{'ADF_CLOUD_EDIT_PROCESS_FILTER.ERROR.DATE' | translate}}</div>\n                                <mat-icon class=\"adf-error-icon\">warning</mat-icon>\n                            </div>\n                        </div>\n                        </mat-form-field>\n\n                        <adf-cloud-date-range-filter *ngIf=\"processFilterProperty.type === 'date-range'\"\n                            [processFilterProperty]=\"processFilterProperty\"\n                            [options]=\"processFilterProperty.dateFilterOptions\"\n                            (dateTypeChange)=\"onDateTypeChange($event, processFilterProperty)\"\n                            (dateChanged)=\"onDateRangeFilterChanged($event, processFilterProperty)\"></adf-cloud-date-range-filter>\n\n                        <div fxFlex=\"23%\" *ngIf=\"processFilterProperty.type === 'people'\">\n                            <adf-cloud-people\n                                [preSelectUsers]=\"initiatorOptions\"\n                                [title]=\"processFilterProperty.label\"\n                                [validate]=\"true\"\n                                [appName]=\"appName\"\n                                [mode]=\"processFilterProperty.selectionMode\"\n                                (changedUsers)=\"onChangedUser($event, processFilterProperty)\"></adf-cloud-people>\n                        </div>\n                    </ng-container>\n                </div>\n            </form>\n        </ng-container>\n    </mat-expansion-panel>\n</mat-accordion>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-edit-process-filter-date-error-container{height:20px;margin-top:12px;position:absolute;width:100%}.adf-edit-process-filter-date-error-container>div{display:flex;flex-flow:row;justify-content:flex-start}.adf-edit-process-filter-date-error-container .adf-error-text{color:var(--theme-warn-color);font-size:11px;height:16px;line-height:1.33;padding-right:8px;width:auto}.adf-edit-process-filter-date-error-container .adf-error-icon{color:var(--theme-warn-color);font-size:16px}.adf-cloud-edit-process-filter-loading-margin{margin-left:calc(50% - 50px);margin-right:calc(50% - 50px)}"]
            },] }
];
EditProcessFilterCloudComponent.ctorParameters = () => [
    { type: FormBuilder },
    { type: MatDialog },
    { type: DateAdapter },
    { type: UserPreferencesService },
    { type: TranslationService },
    { type: ProcessFilterCloudService },
    { type: AppsProcessCloudService },
    { type: ProcessCloudService }
];
EditProcessFilterCloudComponent.propDecorators = {
    appName: [{ type: Input }],
    role: [{ type: Input }],
    id: [{ type: Input }],
    filterProperties: [{ type: Input }],
    sortProperties: [{ type: Input }],
    actions: [{ type: Input }],
    showFilterActions: [{ type: Input }],
    showTitle: [{ type: Input }],
    showProcessFilterName: [{ type: Input }],
    filterChange: [{ type: Output }],
    action: [{ type: Output }],
    processFilter: [{ type: Input }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ɵ0$4 = MOMENT_DATE_FORMATS;
class ProcessFiltersCloudModule {
}
ProcessFiltersCloudModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    FormsModule,
                    ReactiveFormsModule,
                    HttpClientModule,
                    CommonModule,
                    FlexLayoutModule,
                    MaterialModule,
                    AppListCloudModule,
                    CoreModule,
                    ProcessCommonModule,
                    PeopleCloudModule
                ],
                declarations: [ProcessFiltersCloudComponent, EditProcessFilterCloudComponent, ProcessFilterDialogCloudComponent],
                exports: [ProcessFiltersCloudComponent, EditProcessFilterCloudComponent, ProcessFilterDialogCloudComponent],
                providers: [
                    { provide: DateAdapter, useClass: MomentDateAdapter },
                    { provide: MAT_DATE_FORMATS, useValue: ɵ0$4 }
                ]
            },] }
];

class ProcessListCloudService extends BaseCloudService {
    constructor(apiService, appConfigService, logService) {
        super(apiService, appConfigService);
        this.logService = logService;
    }
    getProcessByRequest(requestNode, queryUrl) {
        if (requestNode.appName || requestNode.appName === '') {
            queryUrl = queryUrl || `${this.getBasePath(requestNode.appName)}/query/v1/process-instances`;
            const queryParams = this.buildQueryParams(requestNode);
            const sortingParams = this.buildSortingParam(requestNode.sorting);
            if (sortingParams) {
                queryParams['sort'] = sortingParams;
            }
            return this.get(queryUrl, queryParams).pipe(map((response) => {
                const entries = response.list && response.list.entries;
                if (entries) {
                    response.list.entries = entries.map((entryData) => {
                        return entryData.entry;
                    });
                }
                return response;
            }));
        }
        else {
            this.logService.error('Appname is mandatory for querying task');
            return throwError('Appname not configured');
        }
    }
    isPropertyValueValid(requestNode, property) {
        return requestNode[property] !== '' && requestNode[property] !== null && requestNode[property] !== undefined;
    }
    buildQueryParams(requestNode) {
        const queryParam = {};
        for (const property in requestNode) {
            if (requestNode.hasOwnProperty(property) &&
                !this.isExcludedField(property) &&
                this.isPropertyValueValid(requestNode, property)) {
                queryParam[property] = requestNode[property];
            }
        }
        if (!queryParam['status']) {
            queryParam['status'] = this.buildFilterForAllStatus();
        }
        return queryParam;
    }
    buildFilterForAllStatus() {
        return ['RUNNING', 'SUSPENDED', 'CANCELLED', 'COMPLETED'];
    }
    isExcludedField(property) {
        return property === 'appName' || property === 'sorting';
    }
    buildSortingParam(models) {
        let finalSorting = '';
        if (models) {
            for (const sort of models) {
                if (!finalSorting) {
                    finalSorting = `${sort.orderBy},${sort.direction}`;
                }
                else {
                    finalSorting = `${finalSorting}&${sort.orderBy},${sort.direction}`;
                }
            }
        }
        return encodeURI(finalSorting);
    }
}
ProcessListCloudService.ɵprov = ɵɵdefineInjectable({ factory: function ProcessListCloudService_Factory() { return new ProcessListCloudService(ɵɵinject(AlfrescoApiService), ɵɵinject(AppConfigService), ɵɵinject(LogService)); }, token: ProcessListCloudService, providedIn: "root" });
ProcessListCloudService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
ProcessListCloudService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: AppConfigService },
    { type: LogService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let processCloudPresetsDefaultModel = {
    'default': [
        {
            'key': 'name',
            'type': 'text',
            'title': 'ADF_CLOUD_PROCESS_LIST.PROPERTIES.NAME',
            'sortable': true
        },
        {
            'key': 'startDate',
            'type': 'date',
            'title': 'ADF_CLOUD_PROCESS_LIST.PROPERTIES.START_DATE',
            'cssClass': 'hidden',
            'sortable': true,
            'format': 'timeAgo'
        }
    ]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessQueryCloudRequestModel {
    constructor(obj) {
        if (obj) {
            this.appName = obj.appName;
            this.appVersion = obj.appVersion;
            this.initiator = obj.initiator;
            this.id = obj.id;
            this.name = obj.name;
            this.processDefinitionId = obj.processDefinitionId;
            this.processDefinitionName = obj.processDefinitionName;
            this.processDefinitionKey = obj.processDefinitionKey;
            this.status = obj.status;
            this.startDate = obj.startDate;
            this.businessKey = obj.businessKey;
            this.lastModified = obj.lastModified;
            this.lastModifiedTo = obj.lastModifiedTo;
            this.lastModifiedFrom = obj.lastModifiedFrom;
            this.startFrom = obj.startFrom;
            this.startTo = obj.startTo;
            this.completedFrom = obj.completedFrom;
            this.completedTo = obj.completedTo;
            this.suspendedFrom = obj.suspendedFrom;
            this.suspendedTo = obj.suspendedTo;
            this.completedDate = obj.completedDate;
            this.maxItems = obj.maxItems;
            this.skipCount = obj.skipCount;
            this.sorting = obj.sorting;
        }
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessListCloudSortingModel {
    constructor(obj) {
        if (obj) {
            this.orderBy = obj.orderBy;
            this.direction = obj.direction;
        }
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessListCloudComponent extends DataTableSchema {
    constructor(processListCloudService, appConfigService, userPreferences) {
        super(appConfigService, ProcessListCloudComponent.PRESET_KEY, processCloudPresetsDefaultModel);
        this.processListCloudService = processListCloudService;
        this.userPreferences = userPreferences;
        this.appName = '';
        this.initiator = '';
        this.id = '';
        this.name = '';
        this.processDefinitionId = '';
        this.processDefinitionName = '';
        this.processDefinitionKey = '';
        this.status = '';
        this.businessKey = '';
        this.startFrom = '';
        this.startTo = '';
        this.completedFrom = '';
        this.completedTo = '';
        this.completedDate = '';
        this.suspendedFrom = '';
        this.suspendedTo = '';
        this.selectionMode = 'single';
        this.multiselect = false;
        this.showActions = false;
        this.actionsPosition = 'right';
        this.stickyHeader = false;
        this.showContextMenu = false;
        this.rowClick = new EventEmitter();
        this.rowsSelected = new EventEmitter();
        this.showRowContextMenu = new EventEmitter();
        this.showRowActionsMenu = new EventEmitter();
        this.executeRowAction = new EventEmitter();
        this.error = new EventEmitter();
        this.success = new EventEmitter();
        this.skipCount = 0;
        this.isLoading = true;
        this.rows = [];
        this.defaultSorting = { key: 'startDate', direction: 'desc' };
        this.size = userPreferences.paginationSize;
        this.userPreferences.select(UserPreferenceValues.PaginationSize).subscribe((pageSize) => {
            this.size = pageSize;
        });
        this.pagination = new BehaviorSubject({
            maxItems: this.size,
            skipCount: 0,
            totalItems: 0
        });
    }
    ngAfterContentInit() {
        this.createDatatableSchema();
    }
    ngOnChanges(changes) {
        if (this.isPropertyChanged(changes, 'sorting')) {
            this.formatSorting(changes['sorting'].currentValue);
        }
        if (this.isAnyPropertyChanged(changes)) {
            this.reload();
        }
    }
    getCurrentId() {
        return this.currentInstanceId;
    }
    reload() {
        this.requestNode = this.createRequestNode();
        if (this.requestNode.appName || this.requestNode.appName === '') {
            this.load(this.requestNode);
        }
        else {
            this.rows = [];
        }
    }
    load(requestNode) {
        this.isLoading = true;
        this.processListCloudService.getProcessByRequest(requestNode).subscribe((processes) => {
            this.rows = processes.list.entries;
            this.success.emit(processes);
            this.isLoading = false;
            this.pagination.next(processes.list.pagination);
        }, (error) => {
            this.error.emit(error);
            this.isLoading = false;
        });
    }
    isAnyPropertyChanged(changes) {
        for (const property in changes) {
            if (this.isPropertyChanged(changes, property)) {
                return true;
            }
        }
        return false;
    }
    isPropertyChanged(changes, property) {
        return changes.hasOwnProperty(property);
    }
    isListEmpty() {
        return !this.rows || this.rows.length === 0;
    }
    resetPagination() {
        this.skipCount = 0;
        this.size = this.userPreferences.paginationSize;
        this.pagination.next({
            skipCount: 0,
            maxItems: this.size
        });
    }
    updatePagination(pagination) {
        this.size = pagination.maxItems;
        this.skipCount = pagination.skipCount;
        this.pagination.next(pagination);
        this.reload();
    }
    onSortingChanged(event) {
        this.setSorting(event.detail);
        this.formatSorting(this.sorting);
        this.reload();
    }
    onRowClick(item) {
        this.currentInstanceId = item.value.getValue('id');
        this.rowClick.emit(this.currentInstanceId);
    }
    onRowSelect(event) {
        this.selectedInstances = [...event.detail.selection];
        this.rowsSelected.emit(this.selectedInstances);
    }
    onRowUnselect(event) {
        this.selectedInstances = [...event.detail.selection];
        this.rowsSelected.emit(this.selectedInstances);
    }
    onRowKeyUp(event) {
        if (event.detail.keyboardEvent.key === 'Enter') {
            event.preventDefault();
            this.currentInstanceId = event.detail.row.getValue('id');
            this.rowClick.emit(this.currentInstanceId);
        }
    }
    onShowRowActionsMenu(event) {
        this.showRowActionsMenu.emit(event);
    }
    onShowRowContextMenu(event) {
        this.showRowContextMenu.emit(event);
    }
    onExecuteRowAction(row) {
        this.executeRowAction.emit(row);
    }
    createRequestNode() {
        const requestNode = {
            appName: this.appName,
            appVersion: this.getAppVersions(),
            maxItems: this.size,
            skipCount: this.skipCount,
            initiator: this.initiator,
            id: this.id,
            name: this.name,
            processDefinitionId: this.processDefinitionId,
            processDefinitionName: this.processDefinitionName,
            processDefinitionKey: this.processDefinitionKey,
            status: this.status,
            businessKey: this.businessKey,
            lastModifiedFrom: this.lastModifiedFrom,
            lastModifiedTo: this.lastModifiedTo,
            startFrom: this.startFrom,
            startTo: this.startTo,
            completedFrom: this.completedFrom,
            completedTo: this.completedTo,
            suspendedFrom: this.suspendedFrom,
            suspendedTo: this.suspendedTo,
            completedDate: this.completedDate,
            sorting: this.sorting
        };
        return new ProcessQueryCloudRequestModel(requestNode);
    }
    getAppVersions() {
        return this.appVersion instanceof Array ? this.appVersion.join(',') : (this.appVersion ? String(this.appVersion) : '');
    }
    setSorting(sortDetail) {
        const sorting = sortDetail ? {
            orderBy: sortDetail.key,
            direction: sortDetail.direction.toUpperCase()
        } : Object.assign({}, this.defaultSorting);
        this.sorting = [new ProcessListCloudSortingModel(sorting)];
    }
    formatSorting(sorting) {
        this.formattedSorting = this.isValidSorting(sorting) ? [
            sorting[0].orderBy,
            sorting[0].direction.toLocaleLowerCase()
        ] : null;
    }
    isValidSorting(sorting) {
        return sorting.length && sorting[0].orderBy && sorting[0].direction;
    }
}
ProcessListCloudComponent.PRESET_KEY = 'adf-cloud-process-list.presets';
ProcessListCloudComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-cloud-process-list',
                template: "<adf-datatable #dataTable\n        [rows]=\"rows\"\n        [columns]=\"columns\"\n        [stickyHeader]=\"stickyHeader\"\n        [loading]=\"isLoading\"\n        [sorting]=\"formattedSorting\"\n        [selectionMode]=\"selectionMode\"\n        [multiselect]=\"multiselect\"\n        [actions]=\"showActions\"\n        [actionsPosition]=\"actionsPosition\"\n        [contextMenu]=\"showContextMenu\"\n        (showRowActionsMenu)=\"onShowRowActionsMenu($event)\"\n        (showRowContextMenu)=\"onShowRowContextMenu($event)\"\n        (executeRowAction)=\"onExecuteRowAction($event)\"\n        (rowClick)=\"onRowClick($any($event))\"\n        (row-select)=\"onRowSelect($any($event))\"\n        (row-unselect)=\"onRowUnselect($any($event))\"\n        (row-keyup)=\"onRowKeyUp($any($event))\"\n        (sorting-changed)=\"onSortingChanged($any($event))\">\n        <adf-loading-content-template>\n            <ng-template>\n                <mat-progress-spinner\n                    *ngIf=\"!customLoadingContent\"\n                    class=\"adf-cloud-process-list-loading-margin\"\n                    [color]=\"'primary'\"\n                    [mode]=\"'indeterminate'\">\n                </mat-progress-spinner>\n                <ng-content select=\"adf-custom-loading-content-template\"></ng-content>\n            </ng-template>\n        </adf-loading-content-template>\n        <adf-no-content-template>\n            <ng-template>\n                <adf-empty-content *ngIf=\"!emptyCustomContent\"\n                    icon=\"assessment\"\n                    [title]=\"'ADF_CLOUD_PROCESS_LIST.MESSAGES.TITLE' | translate\"\n                    [subtitle]=\"'ADF_CLOUD_PROCESS_LIST.MESSAGES.SUBTITLE'| translate\">\n                </adf-empty-content>\n                <ng-content select=\"adf-custom-empty-content-template\"></ng-content>\n            </ng-template>\n        </adf-no-content-template>\n</adf-datatable>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-cloud-process-list-loading-margin{margin-left:calc(50% - 50px);margin-right:calc(50% - 50px)}.adf-no-content-message{font-size:16px;font-weight:700;opacity:.54;text-align:center}"]
            },] }
];
ProcessListCloudComponent.ctorParameters = () => [
    { type: ProcessListCloudService },
    { type: AppConfigService },
    { type: UserPreferencesService }
];
ProcessListCloudComponent.propDecorators = {
    dataTable: [{ type: ViewChild, args: [DataTableComponent,] }],
    emptyCustomContent: [{ type: ContentChild, args: [CustomEmptyContentTemplateDirective,] }],
    customLoadingContent: [{ type: ContentChild, args: [CustomLoadingContentTemplateDirective,] }],
    appName: [{ type: Input }],
    appVersion: [{ type: Input }],
    initiator: [{ type: Input }],
    id: [{ type: Input }],
    name: [{ type: Input }],
    processDefinitionId: [{ type: Input }],
    processDefinitionName: [{ type: Input }],
    processDefinitionKey: [{ type: Input }],
    status: [{ type: Input }],
    businessKey: [{ type: Input }],
    lastModifiedFrom: [{ type: Input }],
    lastModifiedTo: [{ type: Input }],
    startFrom: [{ type: Input }],
    startTo: [{ type: Input }],
    completedFrom: [{ type: Input }],
    completedTo: [{ type: Input }],
    completedDate: [{ type: Input }],
    suspendedFrom: [{ type: Input }],
    suspendedTo: [{ type: Input }],
    selectionMode: [{ type: Input }],
    multiselect: [{ type: Input }],
    sorting: [{ type: Input }],
    showActions: [{ type: Input }],
    actionsPosition: [{ type: Input }],
    stickyHeader: [{ type: Input }],
    showContextMenu: [{ type: Input }],
    rowClick: [{ type: Output }],
    rowsSelected: [{ type: Output }],
    showRowContextMenu: [{ type: Output }],
    showRowActionsMenu: [{ type: Output }],
    executeRowAction: [{ type: Output }],
    error: [{ type: Output }],
    success: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessListCloudModule {
}
ProcessListCloudModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    CoreModule
                ],
                declarations: [ProcessListCloudComponent],
                exports: [ProcessListCloudComponent]
            },] }
];

class StartProcessCloudService extends BaseCloudService {
    constructor(apiService, logService, appConfigService) {
        super(apiService, appConfigService);
        this.logService = logService;
    }
    getProcessDefinitions(appName) {
        if (appName || appName === '') {
            const url = `${this.getBasePath(appName)}/rb/v1/process-definitions`;
            return this.get(url).pipe(map((res) => {
                return res.list.entries.map((processDefs) => new ProcessDefinitionCloud(processDefs.entry));
            }));
        }
        else {
            this.logService.error('AppName is mandatory for querying task');
            return throwError('AppName not configured');
        }
    }
    createProcess(appName, payload) {
        const url = `${this.getBasePath(appName)}/rb/v1/process-instances/create`;
        payload.payloadType = 'CreateProcessInstancePayload';
        return this.post(url, payload).pipe(map((result) => result.entry));
    }
    startCreatedProcess(appName, createdProcessInstanceId, payload) {
        const url = `${this.getBasePath(appName)}/rb/v1/process-instances/${createdProcessInstanceId}/start`;
        return this.post(url, payload).pipe(map((result) => result.entry));
    }
    startProcess(appName, payload) {
        const url = `${this.getBasePath(appName)}/rb/v1/process-instances`;
        payload.payloadType = 'StartProcessPayload';
        return this.post(url, payload);
    }
    updateProcess(appName, processInstanceId, payload) {
        const url = `${this.getBasePath(appName)}/rb/v1/process-instances/${processInstanceId}`;
        payload.payloadType = 'UpdateProcessPayload';
        return this.put(url, payload).pipe(map((processInstance) => processInstance.entry));
    }
    deleteProcess(appName, processInstanceId) {
        const url = `${this.getBasePath(appName)}/rb/v1/process-instances/${processInstanceId}`;
        return this.delete(url);
    }
}
StartProcessCloudService.ɵprov = ɵɵdefineInjectable({ factory: function StartProcessCloudService_Factory() { return new StartProcessCloudService(ɵɵinject(AlfrescoApiService), ɵɵinject(LogService), ɵɵinject(AppConfigService)); }, token: StartProcessCloudService, providedIn: "root" });
StartProcessCloudService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
StartProcessCloudService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: LogService },
    { type: AppConfigService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessPayloadCloud {
    constructor(obj) {
        this.payloadType = 'StartProcessPayload';
        this.processDefinitionKey = obj && obj.processDefinitionKey ? obj.processDefinitionKey : null;
        this.name = obj && obj.name ? obj.name : null;
        this.businessKey = obj && obj.businessKey ? obj.businessKey : null;
        this.variables = obj && obj.variables ? obj.variables : {};
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessNameCloudPipe {
    constructor(localizedDatePipe) {
        this.localizedDatePipe = localizedDatePipe;
    }
    transform(processNameFormat, processInstance) {
        let processName = processNameFormat;
        if (processName.match(ProcessNameCloudPipe.DATE_TIME_IDENTIFIER_REG_EXP)) {
            const presentDateTime = moment.now();
            processName = processName.replace(ProcessNameCloudPipe.DATE_TIME_IDENTIFIER_REG_EXP, this.localizedDatePipe.transform(presentDateTime, 'medium'));
        }
        if (processName.match(ProcessNameCloudPipe.PROCESS_DEFINITION_IDENTIFIER_REG_EXP)) {
            const selectedProcessDefinitionName = processInstance ? processInstance.processDefinitionName : '';
            processName = processName.replace(ProcessNameCloudPipe.PROCESS_DEFINITION_IDENTIFIER_REG_EXP, selectedProcessDefinitionName);
        }
        return processName;
    }
}
ProcessNameCloudPipe.DATE_TIME_IDENTIFIER_REG_EXP = new RegExp('%{datetime}', 'i');
ProcessNameCloudPipe.PROCESS_DEFINITION_IDENTIFIER_REG_EXP = new RegExp('%{processdefinition}', 'i');
ProcessNameCloudPipe.decorators = [
    { type: Pipe, args: [{ name: 'processNameCloud' },] }
];
ProcessNameCloudPipe.ctorParameters = () => [
    { type: LocalizedDatePipe }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class StartProcessCloudComponent {
    constructor(startProcessCloudService, formBuilder, processNameCloudPipe) {
        this.startProcessCloudService = startProcessCloudService;
        this.formBuilder = formBuilder;
        this.processNameCloudPipe = processNameCloudPipe;
        this.appName = '';
        this.maxNameLength = StartProcessCloudComponent.MAX_NAME_LENGTH;
        this.name = '';
        this.showSelectProcessDropdown = true;
        this.success = new EventEmitter();
        this.cancel = new EventEmitter();
        this.error = new EventEmitter();
        this.formContentClicked = new EventEmitter();
        this.processDefinitionSelection = new EventEmitter();
        this.processDefinitionList = [];
        this.errorMessageId = '';
        this.processPayloadCloud = new ProcessPayloadCloud();
        this.filteredProcesses = [];
        this.isLoading = false;
        this.isFormCloudLoaded = false;
        this.disableStartButton = true;
        this.onDestroy$ = new Subject();
        this.processDefinitionLoaded = false;
    }
    ngOnInit() {
        this.processForm = this.formBuilder.group({
            processInstanceName: new FormControl('', [Validators.required, Validators.maxLength(this.getMaxNameLength()), Validators.pattern('^[^\\s]+(\\s+[^\\s]+)*$')]),
            processDefinition: new FormControl(this.processDefinitionName, [Validators.required, this.processDefinitionNameValidator()])
        });
        this.processDefinition.valueChanges
            .pipe(debounceTime(StartProcessCloudComponent.PROCESS_DEFINITION_DEBOUNCE))
            .pipe(takeUntil(this.onDestroy$))
            .subscribe((processDefinitionName) => {
            this.selectProcessDefinitionByProcesDefinitionName(processDefinitionName);
        });
        this.processForm.valueChanges
            .pipe(debounceTime(StartProcessCloudComponent.PROCESS_FORM_DEBOUNCE), tap(() => this.disableStartButton = true), distinctUntilChanged(), filter(() => this.isProcessSelectionValid()), switchMap(() => this.generateProcessInstance())).pipe(takeUntil(this.onDestroy$))
            .subscribe((res) => {
            this.currentCreatedProcess = res;
            this.disableStartButton = false;
        });
        if (this.processDefinitionName) {
            this.processDefinition.setValue(this.processDefinitionName);
            this.processDefinition.markAsDirty();
            this.processDefinition.markAsTouched();
        }
    }
    ngOnChanges(changes) {
        if (changes['appName'] && changes['appName'].currentValue !== changes['appName'].previousValue) {
            this.appName = changes['appName'].currentValue;
            if (this.appName || this.appName === '') {
                this.loadProcessDefinitions();
            }
        }
    }
    onKeyDown(event) {
        event.cancelBubble = true;
    }
    hasForm() {
        return this.processDefinitionCurrent && !!this.processDefinitionCurrent.formKey;
    }
    onFormLoaded(form) {
        this.isFormCloudLoaded = true;
        this.formCloud = form;
    }
    isProcessSelectionValid() {
        return this.processForm.valid && this.isProcessPayloadValid();
    }
    getMaxNameLength() {
        return this.maxNameLength > StartProcessCloudComponent.MAX_NAME_LENGTH ?
            StartProcessCloudComponent.MAX_NAME_LENGTH : this.maxNameLength;
    }
    generateProcessInstance() {
        const createPayload = new ProcessPayloadCloud({
            name: this.processInstanceName.value,
            processDefinitionKey: this.processPayloadCloud.processDefinitionKey
        });
        if (this.currentCreatedProcess && this.processPayloadCloud.processDefinitionKey === this.currentCreatedProcess.processDefinitionKey) {
            return this.startProcessCloudService.updateProcess(this.appName, this.currentCreatedProcess.id, createPayload);
        }
        else {
            return this.startProcessCloudService.createProcess(this.appName, createPayload);
        }
    }
    selectProcessDefinitionByProcesDefinitionName(processDefinitionName) {
        this.filteredProcesses = this.getProcessDefinitionListByNameOrKey(processDefinitionName);
        if (this.isProcessFormValid() &&
            this.filteredProcesses && this.filteredProcesses.length === 1) {
            this.setProcessDefinitionOnForm(this.filteredProcesses[0].name);
        }
    }
    setProcessDefinitionOnForm(selectedProcessDefinitionName) {
        this.processDefinitionCurrent = this.filteredProcesses.find((process) => process.name === selectedProcessDefinitionName || process.key === selectedProcessDefinitionName);
        this.isFormCloudLoaded = false;
        this.processPayloadCloud.processDefinitionKey = this.processDefinitionCurrent.key;
    }
    getProcessDefinitionListByNameOrKey(processDefinitionName) {
        return this.processDefinitionList.filter((processDefinitionCloud) => {
            return !processDefinitionName || this.getProcessDefinition(processDefinitionCloud, processDefinitionName);
        });
    }
    getProcessIfExists(processDefinition) {
        let matchedProcess = this.processDefinitionList.find((option) => this.getProcessDefinition(option, processDefinition));
        if (!matchedProcess) {
            matchedProcess = new ProcessDefinitionCloud();
        }
        return matchedProcess;
    }
    getProcessDefinitionByName(processDefinitionName) {
        const matchedProcess = processDefinitionName ? this.getProcessIfExists(processDefinitionName) : this.processDefinitionList[0];
        return matchedProcess;
    }
    selectDefaultProcessDefinition() {
        const selectedProcess = this.getProcessDefinitionByName(this.processDefinitionName);
        if (selectedProcess) {
            this.processDefinition.setValue(selectedProcess.name);
            this.processDefinitionSelectionChanged(selectedProcess);
        }
    }
    loadProcessDefinitions() {
        this.resetErrorMessage();
        this.startProcessCloudService.getProcessDefinitions(this.appName)
            .pipe(tap(() => this.processDefinitionLoaded = true), takeUntil(this.onDestroy$))
            .subscribe((processDefinitionRepresentations) => {
            this.processDefinitionList = processDefinitionRepresentations;
            if (processDefinitionRepresentations.length === 1) {
                this.selectDefaultProcessDefinition();
            }
            else if (this.processDefinitionName) {
                this.processDefinition.setValue(this.processDefinitionName);
            }
        }, () => {
            this.errorMessageId = 'ADF_CLOUD_PROCESS_LIST.ADF_CLOUD_START_PROCESS.ERROR.LOAD_PROCESS_DEFS';
        });
    }
    isValidName(name) {
        return !!name;
    }
    isProcessFormValid() {
        if (this.hasForm() && this.isFormCloudLoaded) {
            return this.formCloud.isValid || this.isLoading;
        }
        else {
            return this.processForm.valid || this.isLoading;
        }
    }
    isProcessPayloadValid() {
        return !!this.processPayloadCloud.processDefinitionKey;
    }
    getProcessDefinition(processDefinitionCloud, processDefinitionName) {
        return (this.isValidName(processDefinitionCloud.name) && processDefinitionCloud.name.toLowerCase().includes(processDefinitionName.toLowerCase())) ||
            (processDefinitionCloud.key && processDefinitionCloud.key.toLowerCase().includes(processDefinitionName.toLowerCase()));
    }
    isProcessDefinitionsEmpty() {
        return this.processDefinitionList.length === 0;
    }
    buildProcessCloudPayload() {
        this.processPayloadCloud.name = this.processInstanceName.value;
        if (this.variables) {
            this.processPayloadCloud.variables = this.variables;
        }
        if (this.hasForm()) {
            this.processPayloadCloud.variables = Object.assign(this.processPayloadCloud.variables, this.formCloud.values);
        }
    }
    startProcess() {
        this.isLoading = true;
        this.buildProcessCloudPayload();
        this.startProcessCloudService.startCreatedProcess(this.appName, this.currentCreatedProcess.id, this.processPayloadCloud)
            .subscribe((res) => {
            this.success.emit(res);
            this.isLoading = false;
        }, (err) => {
            this.errorMessageId = 'ADF_CLOUD_PROCESS_LIST.ADF_CLOUD_START_PROCESS.ERROR.START';
            this.error.emit(err);
            this.isLoading = false;
        });
    }
    cancelStartProcess() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.currentCreatedProcess) {
                yield this.startProcessCloudService.deleteProcess(this.appName, this.currentCreatedProcess.id);
            }
            this.currentCreatedProcess = null;
            this.cancel.emit();
        });
    }
    resetErrorMessage() {
        this.errorMessageId = '';
    }
    resetProcessDefinitionList() {
        this.processDefinition.setValue('');
        this.filteredProcesses = this.processDefinitionList;
    }
    displayProcessNameOnDropdown(process) {
        if (process) {
            let processName = process;
            if (typeof process !== 'string') {
                processName = process.name;
            }
            return processName;
        }
    }
    displayDropdown(event) {
        event.stopPropagation();
        if (!this.inputAutocomplete.panelOpen) {
            this.resetProcessDefinitionList();
            this.inputAutocomplete.openPanel();
        }
        else {
            this.inputAutocomplete.closePanel();
        }
    }
    processDefinitionNameValidator() {
        return (control) => {
            const processDefinitionFieldValue = control.value;
            let processDefinitionNameError = false;
            if (processDefinitionFieldValue) {
                const processDefinition = this.getProcessIfExists(processDefinitionFieldValue);
                if (!processDefinition.key) {
                    processDefinitionNameError = true;
                }
            }
            return processDefinitionNameError ? { 'invalid name': true } : null;
        };
    }
    getProcessDefinitionValue(process) {
        return !!process.name ? process.name : process.key;
    }
    get processInstanceName() {
        return this.processForm.get('processInstanceName');
    }
    get processDefinition() {
        return this.processForm.get('processDefinition');
    }
    onFormContentClicked(content) {
        this.formContentClicked.emit(content);
    }
    processDefinitionSelectionChanged(processDefinition) {
        if (processDefinition) {
            const processInstanceDetails = { processDefinitionName: processDefinition.name };
            const defaultProcessName = this.processNameCloudPipe.transform(this.name, processInstanceDetails);
            this.processInstanceName.setValue(defaultProcessName);
            this.processInstanceName.markAsDirty();
            this.processInstanceName.markAsTouched();
            this.processDefinitionSelection.emit(processDefinition);
        }
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
}
StartProcessCloudComponent.MAX_NAME_LENGTH = 255;
StartProcessCloudComponent.PROCESS_DEFINITION_DEBOUNCE = 300;
StartProcessCloudComponent.PROCESS_FORM_DEBOUNCE = 400;
StartProcessCloudComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-cloud-start-process',
                template: "<mat-card class=\"adf-start-process\">\n\n    <mat-card-title class=\"adf-title\">{{'ADF_CLOUD_PROCESS_LIST.ADF_CLOUD_START_PROCESS.FORM.TITLE' | translate}}\n    </mat-card-title>\n\n    <mat-card-content>\n        <mat-card-subtitle id=\"error-message\" *ngIf=\"errorMessageId\">\n            {{ errorMessageId | translate }}\n        </mat-card-subtitle>\n\n        <div *ngIf=\"!isProcessDefinitionsEmpty(); else emptyProcessDefinitionsList\">\n            <form [formGroup]=\"processForm\">\n                <mat-form-field class=\"adf-process-input-container\"  [floatLabel]=\"'always'\">\n                    <mat-label>{{ 'ADF_CLOUD_PROCESS_LIST.ADF_CLOUD_START_PROCESS.FORM.LABEL.TYPE' | translate }}</mat-label>\n                    <input\n                        #inputAutocomplete\n                        matInput\n                        formControlName=\"processDefinition\"\n                        [matAutocomplete]=\"auto\"\n                        id=\"processDefinitionName\">\n                    <div class=\"adf-process-input-autocomplete\">\n                        <mat-autocomplete #auto=\"matAutocomplete\" id=\"processDefinitionOptions\" [displayWith]=\"displayProcessNameOnDropdown\" (optionSelected)=\"setProcessDefinitionOnForm($event.option.value)\" >\n                            <mat-option *ngFor=\"let processDef of filteredProcesses\" [value]=\"getProcessDefinitionValue(processDef)\"\n                                        (click)=\"processDefinitionSelectionChanged(processDef)\">\n                                {{ getProcessDefinitionValue(processDef) }}\n                            </mat-option>\n                        </mat-autocomplete>\n                        <button id=\"adf-select-process-dropdown\" *ngIf=\"showSelectProcessDropdown\" mat-icon-button (click)=\"displayDropdown($event)\">\n                            <mat-icon>arrow_drop_down</mat-icon>\n                        </button>\n                    </div>\n                    <mat-error *ngIf=\"processDefinition.hasError('required')\" class=\"adf-error-pb\">\n                            {{ 'ADF_CLOUD_PROCESS_LIST.ADF_CLOUD_START_PROCESS.ERROR.PROCESS_DEFINITION_REQUIRED' | translate }}\n                        </mat-error>\n                </mat-form-field>\n\n                <mat-form-field class=\"adf-process-input-container\"  [floatLabel]=\"'always'\">\n                    <mat-label>{{ 'ADF_CLOUD_PROCESS_LIST.ADF_CLOUD_START_PROCESS.FORM.LABEL.NAME' | translate }}</mat-label>\n                    <input\n                        matInput\n                        formControlName=\"processInstanceName\"\n                        id=\"processName\">\n                    <mat-error id=\"adf-start-process-required-error\" *ngIf=\"processInstanceName.hasError('required')\">\n                        {{ 'ADF_CLOUD_PROCESS_LIST.ADF_CLOUD_START_PROCESS.ERROR.PROCESS_NAME_REQUIRED' | translate }}\n                    </mat-error>\n                    <mat-error id=\"adf-start-process-maxlength-error\" *ngIf=\"processInstanceName.hasError('maxlength')\">\n                        {{ 'ADF_CLOUD_PROCESS_LIST.ADF_CLOUD_START_PROCESS.ERROR.MAXIMUM_LENGTH' | translate : { characters : maxNameLength } }}\n                    </mat-error>\n                    <mat-error *ngIf=\"processInstanceName.hasError('pattern')\">\n                        {{ 'ADF_CLOUD_PROCESS_LIST.ADF_CLOUD_START_PROCESS.ERROR.SPACE_VALIDATOR' | translate }}\n                    </mat-error>\n                </mat-form-field>\n            </form>\n\n            <ng-container *ngIf=\"hasForm() else taskFormCloudButtons\">\n                <adf-cloud-form\n                    [appName]=\"appName\"\n                    [appVersion]=\"processDefinitionCurrent.appVersion\"\n                    [data]=\"values\"\n                    [formId]=\"processDefinitionCurrent.formKey\"\n                    [showSaveButton]=\"false\"\n                    [showCompleteButton]=\"false\"\n                    [showRefreshButton]=\"false\"\n                    [showValidationIcon]=\"false\"\n                    [showTitle]=\"false\"\n                    (formContentClicked)=\"onFormContentClicked($event)\"\n                    (formLoaded)=\"onFormLoaded($event)\">\n                    <adf-cloud-form-custom-outcomes>\n                        <ng-template [ngTemplateOutlet]=\"taskFormCloudButtons\">\n                        </ng-template>\n                    </adf-cloud-form-custom-outcomes>\n                </adf-cloud-form>\n            </ng-container>\n        </div>\n\n    </mat-card-content>\n\n    <ng-template #taskFormCloudButtons>\n        <div fxLayout=\"row\" fxLayoutAlign=\"end end\">\n            <button mat-button (click)=\"cancelStartProcess()\" id=\"cancel_process\">\n                {{ 'ADF_CLOUD_PROCESS_LIST.ADF_CLOUD_START_PROCESS.FORM.ACTION.CANCEL' | translate | uppercase}}\n            </button>\n            <button color=\"primary\" mat-button [disabled]=\"disableStartButton || !isProcessFormValid()\" (click)=\"startProcess()\"\n                data-automation-id=\"btn-start\" id=\"button-start\" class=\"btn-start\">\n                {{'ADF_CLOUD_PROCESS_LIST.ADF_CLOUD_START_PROCESS.FORM.ACTION.START' | translate | uppercase}}\n            </button>\n        </div>\n    </ng-template>\n\n    <ng-template #emptyProcessDefinitionsList>\n        <mat-card-content *ngIf=\"processDefinitionLoaded\">\n            <mat-card-subtitle class=\"error-message\" id=\"no-process-message\">\n                {{ 'ADF_CLOUD_PROCESS_LIST.ADF_CLOUD_START_PROCESS.NO_PROCESS_DEFINITIONS' | translate | uppercase}}\n            </mat-card-subtitle>\n        </mat-card-content>\n    </ng-template>\n</mat-card>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-start-process mat-form-field{width:100%}.adf-start-process .mat-form-field-label{color:var(--theme-colors-mat-grey-dark)}.adf-start-process mat-card-actions{text-align:right}.adf-start-process mat-card-actions .mat-button{text-transform:uppercase!important}.adf-title{padding-bottom:1.25em}.adf-process-input-container mat-form-field{width:100%}.adf-process-input-autocomplete{display:flex}.adf-process-input-autocomplete button{position:absolute;right:-14px;top:0}.adf-start-form-container .mat-card{box-shadow:none!important;padding:0!important}.adf-start-form-actions{text-align:right!important}"]
            },] }
];
StartProcessCloudComponent.ctorParameters = () => [
    { type: StartProcessCloudService },
    { type: FormBuilder },
    { type: ProcessNameCloudPipe }
];
StartProcessCloudComponent.propDecorators = {
    inputAutocomplete: [{ type: ViewChild, args: [MatAutocompleteTrigger,] }],
    appName: [{ type: Input }],
    maxNameLength: [{ type: Input }],
    name: [{ type: Input }],
    processDefinitionName: [{ type: Input }],
    variables: [{ type: Input }],
    values: [{ type: Input }],
    showSelectProcessDropdown: [{ type: Input }],
    success: [{ type: Output }],
    cancel: [{ type: Output }],
    error: [{ type: Output }],
    formContentClicked: [{ type: Output }],
    processDefinitionSelection: [{ type: Output }],
    onKeyDown: [{ type: HostListener, args: ['keydown', ['$event'],] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class StartProcessCloudModule {
}
StartProcessCloudModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    FormsModule,
                    CommonModule,
                    FormCloudModule,
                    MaterialModule,
                    FlexLayoutModule,
                    ReactiveFormsModule,
                    CoreModule
                ],
                declarations: [
                    StartProcessCloudComponent
                ],
                exports: [
                    StartProcessCloudComponent
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessHeaderCloudComponent {
    constructor(processCloudService, translationService, appConfig) {
        this.processCloudService = processCloudService;
        this.translationService = translationService;
        this.appConfig = appConfig;
        this.appName = '';
        this.loaded = new EventEmitter();
        this.onDestroy$ = new Subject();
    }
    ngOnInit() {
        this.dateFormat = this.appConfig.get('dateValues.defaultDateFormat');
        this.dateLocale = this.appConfig.get('dateValues.defaultDateLocale');
        this.processCloudService.dataChangesDetected
            .pipe(takeUntil(this.onDestroy$))
            .subscribe((processDetails) => this.onLoaded(processDetails));
    }
    ngOnChanges() {
        if ((this.appName || this.appName === '') && this.processInstanceId) {
            this.loadProcessInstanceDetails(this.appName, this.processInstanceId);
        }
    }
    loadProcessInstanceDetails(appName, processInstanceId) {
        this.processCloudService
            .getProcessInstanceById(appName, processInstanceId)
            .subscribe((result) => this.onLoaded(result));
    }
    onLoaded(processInstanceDetails) {
        this.processInstanceDetails = processInstanceDetails;
        this.refreshData();
        this.loaded.emit(processInstanceDetails);
    }
    refreshData() {
        if (this.processInstanceDetails) {
            const defaultProperties = this.initDefaultProperties();
            const filteredProperties = this.appConfig.get('adf-cloud-process-header.presets.properties');
            this.properties = defaultProperties.filter((cardItem) => this.isValidSelection(filteredProperties, cardItem));
        }
    }
    initDefaultProperties() {
        return [
            new CardViewTextItemModel({
                label: 'ADF_CLOUD_PROCESS_HEADER.PROPERTIES.ID',
                value: this.processInstanceDetails.id,
                key: 'id'
            }),
            new CardViewTextItemModel({
                label: 'ADF_CLOUD_PROCESS_HEADER.PROPERTIES.NAME',
                value: this.processInstanceDetails.name,
                key: 'name',
                default: this.translationService.instant('ADF_CLOUD_PROCESS_HEADER.PROPERTIES.NAME_DEFAULT')
            }),
            new CardViewTextItemModel({
                label: 'ADF_CLOUD_PROCESS_HEADER.PROPERTIES.STATUS',
                value: this.processInstanceDetails.status,
                key: 'status'
            }),
            new CardViewTextItemModel({
                label: 'ADF_CLOUD_PROCESS_HEADER.PROPERTIES.INITIATOR',
                value: this.processInstanceDetails.initiator,
                key: 'initiator'
            }),
            new CardViewDateItemModel({
                label: 'ADF_CLOUD_PROCESS_HEADER.PROPERTIES.START_DATE',
                value: this.processInstanceDetails.startDate,
                key: 'startDate',
                format: this.dateFormat,
                locale: this.dateLocale
            }),
            new CardViewDateItemModel({
                label: 'ADF_CLOUD_PROCESS_HEADER.PROPERTIES.LAST_MODIFIED',
                value: this.processInstanceDetails.lastModified,
                key: 'lastModified',
                format: this.dateFormat,
                locale: this.dateLocale
            }),
            new CardViewTextItemModel({
                label: 'ADF_CLOUD_PROCESS_HEADER.PROPERTIES.PARENT_ID',
                value: this.processInstanceDetails.parentId,
                key: 'parentId',
                default: this.translationService.instant('ADF_CLOUD_PROCESS_HEADER.PROPERTIES.NONE')
            }),
            new CardViewTextItemModel({
                label: 'ADF_CLOUD_PROCESS_HEADER.PROPERTIES.BUSINESS_KEY',
                value: this.processInstanceDetails.businessKey,
                key: 'businessKey',
                default: this.translationService.instant('ADF_CLOUD_PROCESS_HEADER.PROPERTIES.NONE')
            })
        ];
    }
    isValidSelection(filteredProperties, cardItem) {
        return filteredProperties ? filteredProperties.indexOf(cardItem.key) >= 0 : true;
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
}
ProcessHeaderCloudComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-cloud-process-header',
                template: "<mat-card *ngIf=\"processInstanceDetails\">\n  <mat-card-content>\n    <adf-card-view [properties]=\"properties\"></adf-card-view>\n  </mat-card-content>\n</mat-card>",
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-cloud-process-header' }
            },] }
];
ProcessHeaderCloudComponent.ctorParameters = () => [
    { type: ProcessCloudService },
    { type: TranslationService },
    { type: AppConfigService }
];
ProcessHeaderCloudComponent.propDecorators = {
    appName: [{ type: Input }],
    processInstanceId: [{ type: Input }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessHeaderCloudModule {
}
ProcessHeaderCloudModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    CoreModule
                ],
                declarations: [ProcessHeaderCloudComponent],
                exports: [ProcessHeaderCloudComponent]
            },] }
];

class CancelProcessDirective {
    constructor(elementRef, processCloudService, identityUserService) {
        this.elementRef = elementRef;
        this.processCloudService = processCloudService;
        this.identityUserService = identityUserService;
        this.success = new EventEmitter();
        this.error = new EventEmitter();
        this.canCancelProcess = false;
        this.onDestroy$ = new Subject();
    }
    ngOnInit() {
        this.processCloudService.dataChangesDetected
            .pipe(takeUntil(this.onDestroy$))
            .subscribe((processDetails) => {
            this.processInstanceDetails = processDetails;
            this.canCancelProcess = this.checkCanCancelProcess();
            this.setElementVisibility();
        });
    }
    onClick() {
        this.cancelProcess();
    }
    setElementVisibility() {
        this.elementRef.nativeElement.disabled = !this.canCancelProcess;
    }
    checkCanCancelProcess() {
        const currentUser = this.identityUserService.getCurrentUserInfo().username;
        return this.processInstanceDetails.initiator === currentUser && this.processInstanceDetails.status === 'RUNNING';
    }
    cancelProcess() {
        if (this.canCancelProcess) {
            this.processCloudService.cancelProcess(this.processInstanceDetails.appName, this.processInstanceDetails.id)
                .subscribe((response) => this.success.emit(response), (error) => this.error.emit(error));
        }
        else {
            this.error.emit('Permission denied, only process initiator can cancel the process');
        }
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
}
CancelProcessDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-cloud-cancel-process]'
            },] }
];
CancelProcessDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: ProcessCloudService },
    { type: IdentityUserService }
];
CancelProcessDirective.propDecorators = {
    success: [{ type: Output }],
    error: [{ type: Output }],
    onClick: [{ type: HostListener, args: ['click',] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessDirectiveModule {
}
ProcessDirectiveModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    CancelProcessDirective
                ],
                exports: [
                    CancelProcessDirective
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessCloudModule {
}
ProcessCloudModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CoreModule,
                    ProcessFiltersCloudModule,
                    ProcessListCloudModule,
                    StartProcessCloudModule,
                    ProcessHeaderCloudModule,
                    ProcessDirectiveModule
                ],
                exports: [
                    ProcessFiltersCloudModule,
                    ProcessListCloudModule,
                    StartProcessCloudModule,
                    ProcessHeaderCloudModule,
                    ProcessDirectiveModule
                ],
                providers: [ProcessNameCloudPipe]
            },] }
];

class UserPreferenceCloudService extends BaseCloudService {
    constructor(apiService, appConfigService, logService) {
        super(apiService, appConfigService);
        this.logService = logService;
    }
    getPreferences(appName) {
        if (appName) {
            const url = `${this.getBasePath(appName)}/preference/v1/preferences`;
            return this.get(url);
        }
        else {
            this.logService.error('Appname is mandatory for querying preferences');
            return throwError('Appname not configured');
        }
    }
    getPreferenceByKey(appName, key) {
        if (appName) {
            const url = `${this.getBasePath(appName)}/preference/v1/preferences/${key}`;
            return this.get(url);
        }
        else {
            this.logService.error('Appname and key are mandatory for querying preference');
            return throwError('Appname not configured');
        }
    }
    createPreference(appName, key, newPreference) {
        if (appName) {
            const url = `${this.getBasePath(appName)}/preference/v1/preferences/${key}`;
            const payload = JSON.stringify(newPreference);
            return this.put(url, payload);
        }
        else {
            this.logService.error('Appname  and key are  mandatory for creating preference');
            return throwError('Appname not configured');
        }
    }
    updatePreference(appName, key, updatedPreference) {
        return this.createPreference(appName, key, updatedPreference);
    }
    deletePreference(appName, key) {
        if (appName) {
            const url = `${this.getBasePath(appName)}/preference/v1/preferences/${key}`;
            return this.delete(url);
        }
        else {
            this.logService.error('Appname and key are mandatory to delete preference');
            return throwError('Appname not configured');
        }
    }
}
UserPreferenceCloudService.ɵprov = ɵɵdefineInjectable({ factory: function UserPreferenceCloudService_Factory() { return new UserPreferenceCloudService(ɵɵinject(AlfrescoApiService), ɵɵinject(AppConfigService), ɵɵinject(LogService)); }, token: UserPreferenceCloudService, providedIn: "root" });
UserPreferenceCloudService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
UserPreferenceCloudService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: AppConfigService },
    { type: LogService }
];

class LocalPreferenceCloudService {
    constructor(storage) {
        this.storage = storage;
    }
    getPreferences(_, key) {
        if (key || key === '') {
            return of(this.prepareLocalPreferenceResponse(key));
        }
        return of({
            'list': {
                'entries': []
            }
        });
    }
    getPreferenceByKey(_, key) {
        return of(JSON.parse(this.storage.getItem(key)) || []);
    }
    createPreference(_, key, newPreference) {
        const storedFilters = JSON.parse(this.storage.getItem(key) || '[]');
        storedFilters.push(...newPreference);
        this.storage.setItem(key, JSON.stringify(storedFilters));
        return of(storedFilters);
    }
    updatePreference(_, key, updatedPreference) {
        if (key) {
            this.storage.setItem(key, JSON.stringify(updatedPreference));
        }
        return of(updatedPreference);
    }
    deletePreference(key, preferences) {
        if (key) {
            this.storage.setItem(key, JSON.stringify(preferences));
        }
        return of(preferences);
    }
    prepareLocalPreferenceResponse(key) {
        return {
            'list': {
                'entries': [
                    {
                        'entry': {
                            'key': key,
                            'value': this.storage.getItem(key) || '[]'
                        }
                    }
                ]
            }
        };
    }
}
LocalPreferenceCloudService.ɵprov = ɵɵdefineInjectable({ factory: function LocalPreferenceCloudService_Factory() { return new LocalPreferenceCloudService(ɵɵinject(StorageService)); }, token: LocalPreferenceCloudService, providedIn: "root" });
LocalPreferenceCloudService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
LocalPreferenceCloudService.ctorParameters = () => [
    { type: StorageService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var PeopleModeOptions;
(function (PeopleModeOptions) {
    PeopleModeOptions["single"] = "single";
    PeopleModeOptions["multiple"] = "multiple";
})(PeopleModeOptions || (PeopleModeOptions = {}));
var FormFieldType;
(function (FormFieldType) {
    FormFieldType["text"] = "text";
    FormFieldType["multiline"] = "multi-line-text";
    FormFieldType["number"] = "integer";
    FormFieldType["checkbox"] = "boolean";
    FormFieldType["date"] = "date";
    FormFieldType["datetime"] = "datetime";
    FormFieldType["dropdown"] = "dropdown";
    FormFieldType["typeahead"] = "typeahead";
    FormFieldType["amount"] = "amount";
    FormFieldType["radio"] = "radio-buttons";
    FormFieldType["people"] = "people";
    FormFieldType["groupOfPeople"] = "functional-group";
    FormFieldType["dynamicTable"] = "dynamicTable";
    FormFieldType["hyperlink"] = "hyperlink";
    FormFieldType["header"] = "group";
    FormFieldType["uploadFile"] = "upload";
    FormFieldType["uploadFolder"] = "uploadFolder";
    FormFieldType["displayValue"] = "readonly";
    FormFieldType["displayText"] = "readonly-text";
    FormFieldType["fileViewer"] = "file-viewer";
})(FormFieldType || (FormFieldType = {}));

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class CloudFormRenderingService extends FormRenderingService {
    constructor() {
        super();
        this.register({
            'upload': () => AttachFileCloudWidgetComponent,
            'dropdown': () => DropdownCloudWidgetComponent,
            'date': () => DateCloudWidgetComponent,
            'people': () => PeopleCloudWidgetComponent,
            'functional-group': () => GroupCloudWidgetComponent,
            'properties-viewer': () => PropertiesViewerWidgetComponent,
            'radio-buttons': () => RadioButtonsCloudWidgetComponent
        }, true);
    }
}
CloudFormRenderingService.ɵprov = ɵɵdefineInjectable({ factory: function CloudFormRenderingService_Factory() { return new CloudFormRenderingService(); }, token: CloudFormRenderingService, providedIn: "root" });
CloudFormRenderingService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
CloudFormRenderingService.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessServicesCloudPipeModule {
}
ProcessServicesCloudPipeModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    ProcessNameCloudPipe
                ],
                exports: [
                    ProcessNameCloudPipe
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ɵ0$5 = {
    name: 'adf-process-services-cloud',
    source: 'assets/adf-process-services-cloud'
};
class ProcessServicesCloudModule {
    static forRoot(preferenceServiceInstance) {
        return {
            ngModule: ProcessServicesCloudModule,
            providers: [
                {
                    provide: TRANSLATION_PROVIDER,
                    multi: true,
                    useValue: {
                        name: 'adf-process-services-cloud',
                        source: 'assets/adf-process-services-cloud'
                    }
                },
                { provide: PROCESS_FILTERS_SERVICE_TOKEN, useExisting: preferenceServiceInstance !== null && preferenceServiceInstance !== void 0 ? preferenceServiceInstance : LocalPreferenceCloudService },
                { provide: TASK_FILTERS_SERVICE_TOKEN, useExisting: preferenceServiceInstance !== null && preferenceServiceInstance !== void 0 ? preferenceServiceInstance : LocalPreferenceCloudService },
                FormRenderingService,
                { provide: FormRenderingService, useClass: CloudFormRenderingService }
            ]
        };
    }
    static forChild() {
        return {
            ngModule: ProcessServicesCloudModule
        };
    }
}
ProcessServicesCloudModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CoreModule,
                    AppListCloudModule,
                    ProcessCloudModule,
                    TaskCloudModule,
                    GroupCloudModule,
                    PeopleCloudModule,
                    FormCloudModule,
                    TaskFormModule,
                    ProcessServicesCloudPipeModule
                ],
                providers: [
                    {
                        provide: TRANSLATION_PROVIDER,
                        multi: true,
                        useValue: ɵ0$5
                    }
                ],
                exports: [
                    AppListCloudModule,
                    ProcessCloudModule,
                    TaskCloudModule,
                    GroupCloudModule,
                    FormCloudModule,
                    TaskFormModule,
                    PeopleCloudModule,
                    ProcessServicesCloudPipeModule
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class StartTaskCloudService extends BaseCloudService {
    constructor(apiService, appConfigService) {
        super(apiService, appConfigService);
    }
    createNewTask(taskDetails) {
        const url = `${this.getBasePath(taskDetails.appName)}/rb/v1/tasks`;
        const payload = JSON.stringify(new StartTaskCloudRequestModel(taskDetails));
        return this.post(url, payload)
            .pipe(map(response => response.entry));
    }
}
StartTaskCloudService.ɵprov = ɵɵdefineInjectable({ factory: function StartTaskCloudService_Factory() { return new StartTaskCloudService(ɵɵinject(AlfrescoApiService), ɵɵinject(AppConfigService)); }, token: StartTaskCloudService, providedIn: "root" });
StartTaskCloudService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
StartTaskCloudService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: AppConfigService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ApplicationVersionModel {
}
class ApplicationVersionResponseModel {
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { AppDetailsCloudComponent, AppListCloudComponent, AppListCloudModule, ApplicationVersionModel, ApplicationVersionResponseModel, AppsProcessCloudService, AssignmentType, AttachFileCloudWidgetComponent, CancelProcessDirective, ClaimTaskCloudDirective, ClaimTaskEnum, CloudFormRenderingService, CompleteTaskDirective, ContentCloudNodeSelectorService, DEFAULT_APP_INSTANCE_ICON, DEFAULT_APP_INSTANCE_THEME, DEFAULT_TASK_PRIORITIES, DateCloudFilterType, DateCloudWidgetComponent, DropdownCloudWidgetComponent, EditProcessFilterCloudComponent, EditServiceTaskFilterCloudComponent, EditTaskFilterCloudComponent, FormCloudComponent, FormCloudModule, FormCloudService, FormCustomOutcomesComponent, FormDefinitionSelectorCloudComponent, FormDefinitionSelectorCloudService, FormFieldType, GroupCloudComponent, GroupCloudModule, GroupCloudWidgetComponent, InitialGroupNamePipe, LocalPreferenceCloudService, NotificationCloudService, PROCESS_FILTERS_SERVICE_TOKEN, PeopleCloudComponent, PeopleCloudModule, PeopleCloudWidgetComponent, PeopleModeOptions, ProcessCloudContentService, ProcessCloudModule, ProcessCloudService, ProcessDefinitionCloud, ProcessDirectiveModule, ProcessFilterCloudModel, ProcessFilterCloudService, ProcessFilterDialogCloudComponent, ProcessFiltersCloudComponent, ProcessFiltersCloudModule, ProcessHeaderCloudComponent, ProcessHeaderCloudModule, ProcessListCloudComponent, ProcessListCloudModule, ProcessListCloudService, ProcessListCloudSortingModel, ProcessNameCloudPipe, ProcessPayloadCloud, ProcessQueryCloudRequestModel, ProcessServicesCloudModule, ProcessServicesCloudPipeModule, PropertiesViewerWidgetComponent, ServiceTaskFilterCloudService, ServiceTaskFiltersCloudComponent, ServiceTaskListCloudComponent, ServiceTaskListCloudService, StartProcessCloudComponent, StartProcessCloudModule, StartProcessCloudService, StartTaskCloudComponent, StartTaskCloudModule, StartTaskCloudService, TASK_ASSIGNED_STATE, TASK_CREATED_STATE, TASK_FILTERS_SERVICE_TOKEN, TaskCloudModule, TaskCloudService, TaskDirectiveModule, TaskFilterCloudModel, TaskFilterCloudService, TaskFiltersCloudComponent, TaskFiltersCloudModule, TaskFormCloudComponent, TaskFormModule, TaskHeaderCloudComponent, TaskHeaderCloudModule, TaskListCloudComponent, TaskListCloudModule, TaskListCloudService, TaskListCloudSortingModel, TaskQueryCloudRequestModel, TaskVariableCloud, UnClaimTaskCloudDirective, UploadCloudWidgetComponent, UserPreferenceCloudService, processCloudPresetsDefaultModel, serviceTaskPresetsCloudDefaultModel, taskPresetsCloudDefaultModel, ɵ0$5 as ɵ0, MaterialModule as ɵa, ProcessCommonModule as ɵb, DateRangeFilterComponent as ɵc, DateRangeFilterService as ɵd, BaseCloudService as ɵe, RadioButtonsCloudWidgetComponent as ɵf, PropertiesViewerWrapperComponent as ɵg, FilePropertiesTableCloudComponent as ɵh, BaseTaskListCloudComponent as ɵi, BaseTaskFiltersCloudComponent as ɵj, BaseEditTaskFilterCloudComponent as ɵk, TaskFilterDialogCloudComponent as ɵl, TaskAssignmentFilterCloudComponent as ɵm };
//# sourceMappingURL=adf-process-services-cloud.js.map
