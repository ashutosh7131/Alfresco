/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { ContentApi, RenditionEntry, RenditionsApi, VersionsApi } from '@alfresco/js-api';
import { AlfrescoApiService } from '../../services/alfresco-api.service';
import { LogService } from '../../services/log.service';
import { Subject } from 'rxjs';
import { Track } from '../models/viewer.model';
import { TranslationService } from '../../services/translation.service';
export declare class ViewUtilService {
    private apiService;
    private logService;
    private translateService;
    static TARGET: string;
    static ContentGroup: {
        IMAGE: string;
        MEDIA: string;
        PDF: string;
        TEXT: string;
    };
    static SUBTITLES_RENDITION_NAME: string;
    maxRetries: number;
    private mimeTypes;
    TRY_TIMEOUT: number;
    viewerTypeChange: Subject<string>;
    urlFileContentChange: Subject<string>;
    _renditionsApi: RenditionsApi;
    get renditionsApi(): RenditionsApi;
    _contentApi: ContentApi;
    get contentApi(): ContentApi;
    _versionsApi: VersionsApi;
    get versionsApi(): VersionsApi;
    constructor(apiService: AlfrescoApiService, logService: LogService, translateService: TranslationService);
    printFile(url: string, type: string): void;
    printFileGeneric(objectId: string, mimeType: string): void;
    getRenditionUrl(nodeId: string, type: string, renditionExists: boolean): string;
    private waitRendition;
    getViewerTypeByMimeType(mimeType: string): string;
    wait(ms: number): Promise<any>;
    getRendition(nodeId: string, renditionId: string): Promise<RenditionEntry>;
    displayNodeRendition(nodeId: string, versionId?: string): Promise<void>;
    private resolveNodeRendition;
    private waitNodeRendition;
    private handleNodeRendition;
    generateMediaTracks(nodeId: string): Promise<Track[]>;
    private isRenditionAvailable;
}
