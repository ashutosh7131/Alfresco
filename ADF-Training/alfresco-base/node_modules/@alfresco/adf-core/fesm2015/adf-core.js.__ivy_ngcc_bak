import { Component, ViewEncapsulation, Input, Injectable, ɵɵdefineInjectable, ɵɵinject, NgModule, InjectionToken, Inject, Optional, ViewChildren, HostListener, ElementRef, INJECTOR, Injector, Directive, Pipe, Renderer2, EventEmitter, Output, ChangeDetectorRef, Host, NgZone, TemplateRef, ViewContainerRef, SecurityContext, ChangeDetectionStrategy, HostBinding, ContentChild, ContentChildren, IterableDiffers, ComponentFactoryResolver, ViewChild, forwardRef, Compiler, RendererFactory2, APP_INITIALIZER } from '@angular/core';
import { DateAdapter, MatNativeDateModule, MatOptionModule, MatRippleModule, MAT_DATE_FORMATS } from '@angular/material/core';
import { isMoment } from 'moment';
import moment from 'moment-es6';
import { Subject, ReplaySubject, from, forkJoin, throwError, Observable, BehaviorSubject, of, fromEvent, combineLatest, merge, empty, interval } from 'rxjs';
import { __awaiter } from 'tslib';
import { AlfrescoApiConfig, AlfrescoApi, PeopleApi, UserProfileApi, DiscoveryApi, AboutApi, SystemPropertiesApi, ContentApi, TrashcanApi, NodesApi, FavoritesApi, DownloadsApi, SitesApi, RenditionsApi, VersionsApi, UploadApi, Pagination, SharedlinksApi, FormSaveRepresentation, CustomModelApi, TaskFormsApi, TasksApi, ModelsApi, FormModelsApi, ProcessDefinitionsApi, ProcessInstanceVariablesApi, ProcessInstancesApi, ActivitiGroupsApi, UsersApi, TaskActionsApi, ActivitiContentApi, IntegrationAlfrescoOnPremiseApi, ActivitiCommentsApi, CommentsApi, RuntimeAppDefinitionsApi, QueriesApi, SearchApi, AlfrescoApiCompatibility, PersonPaging, Person } from '@alfresco/js-api';
import { HttpClient, HttpHeaders, HttpClientModule } from '@angular/common/http';
import { map, distinctUntilChanged, take, catchError, tap, filter, switchMap, takeUntil, retry, mergeMap, share, buffer, debounceTime, skipWhile, delay, combineAll, defaultIfEmpty, concatMap, takeWhile } from 'rxjs/operators';
import { mergeObjects, ExtensionService, AppExtensionService, ExtensionsModule } from '@alfresco/adf-extensions';
import { CommonModule, DatePipe, DecimalPipe, DOCUMENT } from '@angular/common';
import { TranslateModule, TranslateService, TranslateStore, TranslateLoader } from '@ngx-translate/core';
import { MatDatetimepickerModule, MatNativeDatetimeModule, DatetimeAdapter, MAT_DATETIME_FORMATS } from '@mat-datetimepicker/core';
import { MatAutocompleteModule } from '@angular/material/autocomplete';
import { MatButtonModule } from '@angular/material/button';
import { MatCardModule } from '@angular/material/card';
import { MatCheckboxModule } from '@angular/material/checkbox';
import { MatChipsModule } from '@angular/material/chips';
import { MatDatepickerModule } from '@angular/material/datepicker';
import { MatDialogModule, MatDialogRef, MAT_DIALOG_DATA, MatDialog } from '@angular/material/dialog';
import { MatExpansionModule } from '@angular/material/expansion';
import { MatGridListModule } from '@angular/material/grid-list';
import { MatIconModule, MatIconRegistry } from '@angular/material/icon';
import { MatInputModule } from '@angular/material/input';
import { MatListModule } from '@angular/material/list';
import { MatMenuModule, MatMenuItem, MatMenuTrigger } from '@angular/material/menu';
import { MatProgressBarModule } from '@angular/material/progress-bar';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatRadioModule } from '@angular/material/radio';
import { MatSelectModule, MatSelect } from '@angular/material/select';
import { MatSidenavModule, MatSidenav } from '@angular/material/sidenav';
import { MatSlideToggleModule } from '@angular/material/slide-toggle';
import { MatSnackBarModule, MatSnackBar } from '@angular/material/snack-bar';
import { MatTableModule, MatTableDataSource } from '@angular/material/table';
import { MatTabsModule } from '@angular/material/tabs';
import { MatToolbarModule } from '@angular/material/toolbar';
import { MatTooltipModule } from '@angular/material/tooltip';
import { MatBadgeModule } from '@angular/material/badge';
import { Router, RouterModule, ActivatedRoute } from '@angular/router';
import { OverlayConfig, Overlay, OverlayPositionBuilder, OverlayModule } from '@angular/cdk/overlay';
import { ComponentPortal, PortalInjector } from '@angular/cdk/portal';
import { state, style, transition, sequence, query, animate, group, trigger } from '@angular/animations';
import { UP_ARROW, DOWN_ARROW, ESCAPE, ENTER, TAB } from '@angular/cdk/keycodes';
import { FocusKeyManager, A11yModule } from '@angular/cdk/a11y';
import { DomSanitizer, Title } from '@angular/platform-browser';
import { Minimatch } from 'minimatch';
import Cropper from 'cropperjs';
import { FormControl, Validators, FormsModule, ReactiveFormsModule, FormBuilder, NG_VALUE_ACCESSOR } from '@angular/forms';
import { FlexLayoutModule } from '@angular/flex-layout';
import { MAT_MOMENT_DATETIME_FORMATS, MomentDatetimeAdapter } from '@mat-datetimepicker/moment';
import { MediaMatcher } from '@angular/cdk/layout';
import { TestBed } from '@angular/core/testing';
import { NoopAnimationsModule } from '@angular/platform-browser/animations';
import { RouterTestingModule } from '@angular/router/testing';
import { Directionality } from '@angular/cdk/bidi';

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AboutGithubLinkComponent {
    constructor() {
        this.url = 'https://github.com/Alfresco/alfresco-ng2-components/commits/';
        this.version = '';
        this.application = '';
    }
}
AboutGithubLinkComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-about-github-link',
                template: "<div class=\"adf-github-link-container\">\n    <div>\n        <h3 data-automation-id=\"adf-github-source-code-title\">{{ 'ABOUT.SOURCE_CODE.TITLE' | translate }}</h3>\n        <mat-card>\n            <h3 data-automation-id=\"adf-github-app-title\">{{application}}</h3>\n            <p *ngIf=\"version\" data-automation-id=\"adf-github-version\">{{ 'ABOUT.VERSION' | translate }}: {{ version }}</p>\n\n            <div *ngIf=\"url\">\n                <small>{{ 'ABOUT.SOURCE_CODE.DESCRIPTION' | translate }}</small>\n                <div data-automation-id=\"adf-github-url\">\n                    <a [href]=\"url\" target=\"_blank\">{{url}}</a>\n                </div>\n            </div>\n        </mat-card>\n    </div>\n</div>\n",
                encapsulation: ViewEncapsulation.None
            },] }
];
AboutGithubLinkComponent.ctorParameters = () => [];
AboutGithubLinkComponent.propDecorators = {
    url: [{ type: Input }],
    version: [{ type: Input }],
    application: [{ type: Input }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ObjectUtils {
    static getValue(target, key) {
        if (!target) {
            return undefined;
        }
        const keys = key.split('.');
        key = '';
        do {
            key += keys.shift();
            const value = target[key];
            if (value !== undefined && (typeof value === 'object' || !keys.length)) {
                target = value;
                key = '';
            }
            else if (!keys.length) {
                target = undefined;
            }
            else {
                key += '.';
            }
        } while (keys.length);
        return target;
    }
    static merge(...objects) {
        const result = {};
        objects.forEach((source) => {
            Object.keys(source).forEach((prop) => {
                if (prop in result && Array.isArray(result[prop])) {
                    result[prop] = result[prop].concat(source[prop]);
                }
                else if (prop in result && typeof result[prop] === 'object') {
                    result[prop] = ObjectUtils.merge(result[prop], source[prop]);
                }
                else {
                    result[prop] = source[prop];
                }
            });
        });
        return result;
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FileUtils {
    static flatten(folder) {
        const reader = folder.createReader();
        const files = [];
        return new Promise((resolve) => {
            const iterations = [];
            (function traverse() {
                reader.readEntries((entries) => {
                    if (!entries.length) {
                        Promise.all(iterations).then(() => resolve(files));
                    }
                    else {
                        iterations.push(Promise.all(entries.map((entry) => {
                            if (entry.isFile) {
                                return new Promise((resolveFile) => {
                                    entry.file(function (file) {
                                        files.push({
                                            entry: entry,
                                            file: file,
                                            relativeFolder: entry.fullPath.replace(/\/[^\/]*$/, '')
                                        });
                                        resolveFile();
                                    });
                                });
                            }
                            else {
                                return FileUtils.flatten(entry).then((result) => {
                                    files.push(...result);
                                });
                            }
                        })));
                        traverse();
                    }
                });
            })();
        });
    }
    static toFileArray(fileList) {
        const result = [];
        if (fileList && fileList.length > 0) {
            for (let i = 0; i < fileList.length; i++) {
                result.push(fileList[i]);
            }
        }
        return result;
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const MOMENT_DATE_FORMATS = {
    parse: {
        dateInput: 'DD/MM/YYYY'
    },
    display: {
        dateInput: 'DD/MM/YYYY',
        monthYearLabel: 'MMMM Y',
        dateA11yLabel: 'LL',
        monthYearA11yLabel: 'MMMM Y'
    }
};
const dateNames = [];
for (let date = 1; date <= 31; date++) {
    dateNames.push(String(date));
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class MomentDateAdapter extends DateAdapter {
    constructor() {
        super(...arguments);
        this.localeData = moment.localeData();
    }
    getYear(date) {
        return date.year();
    }
    getMonth(date) {
        return date.month();
    }
    getDate(date) {
        return date.date();
    }
    getDayOfWeek(date) {
        return date.day();
    }
    getMonthNames(style) {
        switch (style) {
            case 'long':
                return this.localeData.months();
            case 'short':
                return this.localeData.monthsShort();
            case 'narrow':
                return this.localeData.monthsShort().map((month) => month[0]);
            default:
                return [];
        }
    }
    getDateNames() {
        const dateNames = [];
        for (let date = 1; date <= 31; date++) {
            dateNames.push(String(date));
        }
        return dateNames;
    }
    getDayOfWeekNames(style) {
        switch (style) {
            case 'long':
                return this.localeData.weekdays();
            case 'short':
                return this.localeData.weekdaysShort();
            case 'narrow':
                return this.localeData.weekdaysShort();
            default:
                return [];
        }
    }
    getYearName(date) {
        return String(date.year());
    }
    getFirstDayOfWeek() {
        return this.localeData.firstDayOfWeek();
    }
    getNumDaysInMonth(date) {
        return date.daysInMonth();
    }
    clone(date) {
        const locale = this.locale || 'en';
        return date.clone().locale(locale);
    }
    createDate(year, month, date) {
        return moment([year, month, date]);
    }
    today() {
        const locale = this.locale || 'en';
        return moment().locale(locale);
    }
    parse(value, parseFormat) {
        const locale = this.locale || 'en';
        if (value && typeof value === 'string') {
            let m = moment(value, parseFormat, locale, true);
            if (!m.isValid()) {
                m = moment(value, this.overrideDisplayFormat, locale, true);
            }
            if (m.isValid()) {
                if (m.year() === 2001 && value.indexOf('2001') === -1) {
                    const currentYear = new Date().getFullYear();
                    m.set('year', currentYear);
                    if (m.isAfter(moment())) {
                        m.set('year', currentYear - 1);
                    }
                }
            }
            return m;
        }
        return value ? moment(value).locale(locale) : null;
    }
    format(date, displayFormat) {
        date = this.clone(date);
        displayFormat = this.overrideDisplayFormat ? this.overrideDisplayFormat : displayFormat;
        if (date && date.format) {
            return date.format(displayFormat);
        }
        else {
            return '';
        }
    }
    addCalendarYears(date, years) {
        return date.clone().add(years, 'y');
    }
    addCalendarMonths(date, months) {
        return date.clone().add(months, 'M');
    }
    addCalendarDays(date, days) {
        return date.clone().add(days, 'd');
    }
    getISODateString(date) {
        return date.toISOString();
    }
    setLocale(locale) {
        super.setLocale(locale);
        this.localeData = moment.localeData(locale);
    }
    compareDate(first, second) {
        return first.diff(second, 'seconds', true);
    }
    sameDate(first, second) {
        if (first == null) {
            return second == null;
        }
        else if (isMoment(first)) {
            return first.isSame(second);
        }
        else {
            const isSame = super.sameDate(first, second);
            return isSame;
        }
    }
    clampDate(date, min, max) {
        if (min && date.isBefore(min)) {
            return min;
        }
        else if (max && date.isAfter(max)) {
            return max;
        }
        else {
            return date;
        }
    }
    isDateInstance(date) {
        let isValidDateInstance = false;
        if (date) {
            isValidDateInstance = date._isAMomentObject;
        }
        return isValidDateInstance;
    }
    isValid(date) {
        return date.isValid();
    }
    toIso8601(date) {
        return this.clone(date).format();
    }
    fromIso8601(iso8601String) {
        const locale = this.locale || 'en';
        const d = moment(iso8601String, moment.ISO_8601).locale(locale);
        return this.isValid(d) ? d : null;
    }
    invalid() {
        return moment.invalid();
    }
}
MomentDateAdapter.decorators = [
    { type: Injectable }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ObjectDataRow {
    constructor(obj, isSelected = false) {
        this.obj = obj;
        this.isSelected = isSelected;
        if (!obj) {
            throw new Error('Object source not found');
        }
    }
    getValue(key) {
        return ObjectUtils.getValue(this.obj, key);
    }
    hasValue(key) {
        return this.getValue(key) !== undefined;
    }
    imageErrorResolver() {
        return '';
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ObjectDataColumn {
    constructor(input) {
        this.key = input.key;
        this.type = input.type || 'text';
        this.format = input.format;
        this.sortable = input.sortable;
        this.title = input.title;
        this.srTitle = input.srTitle;
        this.cssClass = input.cssClass;
        this.template = input.template;
        this.copyContent = input.copyContent;
        this.focus = input.focus;
        this.sortingKey = input.sortingKey;
        this.header = input.header;
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DataSorting {
    constructor(key, direction) {
        this.key = key;
        this.direction = direction;
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ObjectDataTableAdapter {
    constructor(data = [], schema = []) {
        this._rows = [];
        this._columns = [];
        if (data && data.length > 0) {
            this._rows = data.map((item) => {
                return new ObjectDataRow(item);
            });
        }
        if (schema && schema.length > 0) {
            this._columns = schema.map((item) => {
                return new ObjectDataColumn(item);
            });
            const sortable = this._columns.filter((column) => column.sortable);
            if (sortable.length > 0) {
                this.sort(sortable[0].key, 'asc');
            }
        }
        this.rowsChanged = new Subject();
    }
    static generateSchema(data) {
        const schema = [];
        if (data && data.length) {
            const rowToExaminate = data[0];
            if (typeof rowToExaminate === 'object') {
                for (const key in rowToExaminate) {
                    if (rowToExaminate.hasOwnProperty(key)) {
                        schema.push({
                            type: 'text',
                            key: key,
                            title: key,
                            sortable: false
                        });
                    }
                }
            }
        }
        return schema;
    }
    getRows() {
        return this._rows;
    }
    setRows(rows) {
        this._rows = rows || [];
        this.sort();
        this.rowsChanged.next(this._rows);
    }
    getColumns() {
        return this._columns;
    }
    setColumns(columns) {
        this._columns = columns || [];
    }
    getValue(row, col, resolver) {
        if (!row) {
            throw new Error('Row not found');
        }
        if (!col) {
            throw new Error('Column not found');
        }
        if (resolver) {
            return resolver(row, col);
        }
        const value = row.getValue(col.key);
        if (col.type === 'icon') {
            const icon = row.getValue(col.key);
            return icon;
        }
        return value;
    }
    getSorting() {
        return this._sorting;
    }
    setSorting(sorting) {
        this._sorting = sorting;
        if (sorting && sorting.key) {
            this._rows.sort((a, b) => {
                let left = a.getValue(sorting.key);
                if (left) {
                    left = (left instanceof Date) ? left.valueOf().toString() : left.toString();
                }
                else {
                    left = '';
                }
                let right = b.getValue(sorting.key);
                if (right) {
                    right = (right instanceof Date) ? right.valueOf().toString() : right.toString();
                }
                else {
                    right = '';
                }
                return sorting.direction === 'asc'
                    ? left.localeCompare(right)
                    : right.localeCompare(left);
            });
        }
    }
    sort(key, direction) {
        const sorting = this._sorting || new DataSorting();
        if (key) {
            sorting.key = key;
            sorting.direction = direction || 'asc';
        }
        this.setSorting(sorting);
    }
}

var AppConfigValues;
(function (AppConfigValues) {
    AppConfigValues["APP_CONFIG_LANGUAGES_KEY"] = "languages";
    AppConfigValues["PROVIDERS"] = "providers";
    AppConfigValues["OAUTHCONFIG"] = "oauth2";
    AppConfigValues["ECMHOST"] = "ecmHost";
    AppConfigValues["BASESHAREURL"] = "baseShareUrl";
    AppConfigValues["BPMHOST"] = "bpmHost";
    AppConfigValues["IDENTITY_HOST"] = "identityHost";
    AppConfigValues["AUTHTYPE"] = "authType";
    AppConfigValues["CONTEXTROOTECM"] = "contextRootEcm";
    AppConfigValues["CONTEXTROOTBPM"] = "contextRootBpm";
    AppConfigValues["ALFRESCO_REPOSITORY_NAME"] = "alfrescoRepositoryName";
    AppConfigValues["LOG_LEVEL"] = "logLevel";
    AppConfigValues["LOGIN_ROUTE"] = "loginRoute";
    AppConfigValues["DISABLECSRF"] = "disableCSRF";
    AppConfigValues["AUTH_WITH_CREDENTIALS"] = "auth.withCredentials";
    AppConfigValues["APPLICATION"] = "application";
    AppConfigValues["STORAGE_PREFIX"] = "application.storagePrefix";
    AppConfigValues["NOTIFY_DURATION"] = "notificationDefaultDuration";
})(AppConfigValues || (AppConfigValues = {}));
var Status;
(function (Status) {
    Status["INIT"] = "init";
    Status["LOADING"] = "loading";
    Status["LOADED"] = "loaded";
})(Status || (Status = {}));
class AppConfigService {
    constructor(http, extensionService) {
        this.http = http;
        this.extensionService = extensionService;
        this.config = {
            application: {
                name: 'Alfresco ADF Application'
            },
            ecmHost: 'http://{hostname}{:port}/ecm',
            bpmHost: 'http://{hostname}{:port}/bpm',
            logLevel: 'silent'
        };
        this.status = Status.INIT;
        this.onLoadSubject = new Subject();
        this.onLoad = this.onLoadSubject.asObservable();
        extensionService.setup$.subscribe((config) => {
            this.onExtensionsLoaded(config);
        });
    }
    select(property) {
        return this.onLoadSubject
            .pipe(map((config) => config[property]), distinctUntilChanged());
    }
    get(key, defaultValue) {
        let result = ObjectUtils.getValue(this.config, key);
        if (typeof result === 'string') {
            const keywords = new Map();
            keywords.set('hostname', this.getLocationHostname());
            keywords.set(':port', this.getLocationPort(':'));
            keywords.set('port', this.getLocationPort());
            keywords.set('protocol', this.getLocationProtocol());
            result = this.formatString(result, keywords);
        }
        if (typeof result === 'object') {
            result = JSON.parse(JSON.stringify(result).replace('{hostname}', this.getLocationHostname()));
            result = JSON.parse(JSON.stringify(result).replace('{:port}', this.getLocationPort(':')));
            result = JSON.parse(JSON.stringify(result).replace('{protocol}', this.getLocationProtocol()));
        }
        if (result === undefined) {
            return defaultValue;
        }
        return result;
    }
    getLocationProtocol() {
        return location.protocol;
    }
    getLocationHostname() {
        return location.hostname;
    }
    getLocationPort(prefix = '') {
        return location.port ? prefix + location.port : '';
    }
    onLoaded() {
        this.onLoadSubject.next(this.config);
    }
    onDataLoaded(data) {
        this.config = Object.assign({}, this.config, data || {});
        this.onLoadSubject.next(this.config);
        this.extensionService.setup$
            .pipe(take(1))
            .subscribe((config) => this.onExtensionsLoaded(config));
    }
    onExtensionsLoaded(config) {
        if (config) {
            const customConfig = config.appConfig;
            if (customConfig) {
                this.config = mergeObjects(this.config, customConfig);
            }
        }
    }
    load() {
        return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {
            const configUrl = `app.config.json?v=${Date.now()}`;
            if (this.status === Status.INIT) {
                this.status = Status.LOADING;
                this.http.get(configUrl).subscribe((data) => {
                    this.status = Status.LOADED;
                    this.onDataLoaded(data);
                    resolve(this.config);
                }, () => {
                    resolve(this.config);
                });
            }
            else if (this.status === Status.LOADED) {
                resolve(this.config);
            }
            else if (this.status === Status.LOADING) {
                this.onLoad.subscribe(() => {
                    resolve(this.config);
                });
            }
        }));
    }
    formatString(str, keywords) {
        let result = str;
        keywords.forEach((value, key) => {
            const expr = new RegExp('{' + key + '}', 'gm');
            result = result.replace(expr, value);
        });
        return result;
    }
}
AppConfigService.ɵprov = ɵɵdefineInjectable({ factory: function AppConfigService_Factory() { return new AppConfigService(ɵɵinject(HttpClient), ɵɵinject(ExtensionService)); }, token: AppConfigService, providedIn: "root" });
AppConfigService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
AppConfigService.ctorParameters = () => [
    { type: HttpClient },
    { type: ExtensionService }
];

class StorageService {
    constructor() {
        this.memoryStore = {};
        this.useLocalStorage = false;
        this._prefix = '';
        this.useLocalStorage = this.storageAvailable('localStorage');
    }
    get prefix() {
        return this._prefix;
    }
    set prefix(prefix) {
        this._prefix = prefix ? prefix + '_' : '';
    }
    getItem(key) {
        if (this.useLocalStorage) {
            return localStorage.getItem(this.prefix + key);
        }
        else {
            return this.memoryStore.hasOwnProperty(this.prefix + key) ? this.memoryStore[this.prefix + key] : null;
        }
    }
    setItem(key, data) {
        if (this.useLocalStorage) {
            localStorage.setItem(this.prefix + key, data);
        }
        else {
            this.memoryStore[this.prefix + key] = data.toString();
        }
    }
    clear() {
        if (this.useLocalStorage) {
            localStorage.clear();
        }
        else {
            this.memoryStore = {};
        }
    }
    removeItem(key) {
        if (this.useLocalStorage) {
            localStorage.removeItem(this.prefix + key);
        }
        else {
            delete this.memoryStore[this.prefix + key];
        }
    }
    hasItem(key) {
        if (this.useLocalStorage) {
            return localStorage.getItem(this.prefix + key) ? true : false;
        }
        else {
            return this.memoryStore.hasOwnProperty(key);
        }
    }
    storageAvailable(type) {
        try {
            const storage = window[type];
            const key = '__storage_test__';
            storage.setItem(key, key);
            storage.removeItem(key, key);
            return true;
        }
        catch (e) {
            return false;
        }
    }
}
StorageService.ɵprov = ɵɵdefineInjectable({ factory: function StorageService_Factory() { return new StorageService(); }, token: StorageService, providedIn: "root" });
StorageService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
StorageService.ctorParameters = () => [];

class AlfrescoApiService {
    constructor(appConfig, storageService) {
        this.appConfig = appConfig;
        this.storageService = storageService;
        this.nodeUpdated = new Subject();
        this.alfrescoApiInitialized = new ReplaySubject(1);
        this.excludedErrorUrl = ['api/enterprise/system/properties'];
    }
    getInstance() {
        return this.alfrescoApi;
    }
    load() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.appConfig.load().then(() => {
                this.storageService.prefix = this.appConfig.get(AppConfigValues.STORAGE_PREFIX, '');
                this.initAlfrescoApi();
                this.alfrescoApiInitialized.next(true);
            });
        });
    }
    reset() {
        this.initAlfrescoApi();
    }
    initAlfrescoApi() {
        const oauth = Object.assign({}, this.appConfig.get(AppConfigValues.OAUTHCONFIG, null));
        if (oauth) {
            oauth.redirectUri = window.location.origin + window.location.pathname;
            oauth.redirectUriLogout = window.location.origin + window.location.pathname;
        }
        const config = new AlfrescoApiConfig({
            provider: this.appConfig.get(AppConfigValues.PROVIDERS),
            hostEcm: this.appConfig.get(AppConfigValues.ECMHOST),
            hostBpm: this.appConfig.get(AppConfigValues.BPMHOST),
            authType: this.appConfig.get(AppConfigValues.AUTHTYPE, 'BASIC'),
            contextRootBpm: this.appConfig.get(AppConfigValues.CONTEXTROOTBPM),
            contextRoot: this.appConfig.get(AppConfigValues.CONTEXTROOTECM),
            disableCsrf: this.appConfig.get(AppConfigValues.DISABLECSRF),
            withCredentials: this.appConfig.get(AppConfigValues.AUTH_WITH_CREDENTIALS, false),
            domainPrefix: this.appConfig.get(AppConfigValues.STORAGE_PREFIX),
            oauth2: oauth
        });
        if (this.alfrescoApi && this.isDifferentConfig(this.lastConfig, config)) {
            this.lastConfig = config;
            this.alfrescoApi.setConfig(config);
        }
        else {
            this.lastConfig = config;
            this.alfrescoApi = new AlfrescoApi(config);
        }
    }
    isDifferentConfig(lastConfig, newConfig) {
        return JSON.stringify(lastConfig) !== JSON.stringify(newConfig);
    }
    isExcludedErrorListener(currentFullPath) {
        const formattedPath = currentFullPath.replace(this.lastConfig.hostBpm + '/' + this.lastConfig.contextRootBpm, '');
        return this.excludedErrorUrl.includes(formattedPath);
    }
}
AlfrescoApiService.ɵprov = ɵɵdefineInjectable({ factory: function AlfrescoApiService_Factory() { return new AlfrescoApiService(ɵɵinject(AppConfigService), ɵɵinject(StorageService)); }, token: AlfrescoApiService, providedIn: "root" });
AlfrescoApiService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
AlfrescoApiService.ctorParameters = () => [
    { type: AppConfigService },
    { type: StorageService }
];

class CookieService {
    constructor() {
        this.cookieEnabled = false;
        if (navigator.cookieEnabled === false) {
            this.cookieEnabled = false;
        }
        this.setItem('test-cookie', 'test');
        this.cookieEnabled = document.cookie.indexOf('test-cookie') >= 0;
        this.deleteCookie('test-cookie');
    }
    isEnabled() {
        return this.cookieEnabled;
    }
    getItem(key) {
        const regexp = new RegExp('(?:' + key + '|;\s*' + key + ')=(.*?)(?:;|$)', 'g');
        const result = regexp.exec(document.cookie);
        return (result === null) ? null : result[1];
    }
    setItem(key, data, expiration = null, path = null) {
        document.cookie = `${key}=${data}` +
            (expiration ? ';expires=' + expiration.toUTCString() : '') +
            (path ? `;path=${path}` : ';path=/');
    }
    deleteCookie(key, path = null) {
        document.cookie = key + '=; expires=Thu, 01 Jan 1970 00:00:01 GMT;' +
            (path ? `;path=${path}` : ';path=/');
    }
    clear() {
    }
}
CookieService.ɵprov = ɵɵdefineInjectable({ factory: function CookieService_Factory() { return new CookieService(); }, token: CookieService, providedIn: "root" });
CookieService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
CookieService.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class LogLevelsEnum extends Number {
}
LogLevelsEnum.TRACE = 5;
LogLevelsEnum.DEBUG = 4;
LogLevelsEnum.INFO = 3;
LogLevelsEnum.WARN = 2;
LogLevelsEnum.ERROR = 1;
LogLevelsEnum.SILENT = 0;
let logLevels = [
    { level: LogLevelsEnum.TRACE, name: 'TRACE' },
    { level: LogLevelsEnum.DEBUG, name: 'DEBUG' },
    { level: LogLevelsEnum.INFO, name: 'INFO' },
    { level: LogLevelsEnum.WARN, name: 'WARN' },
    { level: LogLevelsEnum.ERROR, name: 'ERROR' },
    { level: LogLevelsEnum.SILENT, name: 'SILENT' }
];

class LogService {
    constructor(appConfig) {
        this.appConfig = appConfig;
        this.onMessage = new Subject();
    }
    get currentLogLevel() {
        const configLevel = this.appConfig.get(AppConfigValues.LOG_LEVEL);
        if (configLevel) {
            return this.getLogLevel(configLevel);
        }
        return LogLevelsEnum.TRACE;
    }
    error(message, ...optionalParams) {
        if (this.currentLogLevel >= LogLevelsEnum.ERROR) {
            this.messageBus(message, 'ERROR');
            console.error(message, ...optionalParams);
        }
    }
    debug(message, ...optionalParams) {
        if (this.currentLogLevel >= LogLevelsEnum.DEBUG) {
            this.messageBus(message, 'DEBUG');
            console.debug(message, ...optionalParams);
        }
    }
    info(message, ...optionalParams) {
        if (this.currentLogLevel >= LogLevelsEnum.INFO) {
            this.messageBus(message, 'INFO');
            console.info(message, ...optionalParams);
        }
    }
    log(message, ...optionalParams) {
        if (this.currentLogLevel >= LogLevelsEnum.TRACE) {
            this.messageBus(message, 'LOG');
            console.log(message, ...optionalParams);
        }
    }
    trace(message, ...optionalParams) {
        if (this.currentLogLevel >= LogLevelsEnum.TRACE) {
            this.messageBus(message, 'TRACE');
            console.trace(message, ...optionalParams);
        }
    }
    warn(message, ...optionalParams) {
        if (this.currentLogLevel >= LogLevelsEnum.WARN) {
            this.messageBus(message, 'WARN');
            console.warn(message, ...optionalParams);
        }
    }
    assert(test, message, ...optionalParams) {
        if (this.currentLogLevel !== LogLevelsEnum.SILENT) {
            this.messageBus(message, 'ASSERT');
            console.assert(test, message, ...optionalParams);
        }
    }
    group(groupTitle, ...optionalParams) {
        if (this.currentLogLevel !== LogLevelsEnum.SILENT) {
            console.group(groupTitle, ...optionalParams);
        }
    }
    groupEnd() {
        if (this.currentLogLevel !== LogLevelsEnum.SILENT) {
            console.groupEnd();
        }
    }
    getLogLevel(level) {
        const referencedLevel = logLevels.find((currentLevel) => {
            return currentLevel.name.toLocaleLowerCase() === level.toLocaleLowerCase();
        });
        return referencedLevel ? referencedLevel.level : 5;
    }
    messageBus(text, logLevel) {
        this.onMessage.next({ text: text, type: logLevel });
    }
}
LogService.ɵprov = ɵɵdefineInjectable({ factory: function LogService_Factory() { return new LogService(ɵɵinject(AppConfigService)); }, token: LogService, providedIn: "root" });
LogService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
LogService.ctorParameters = () => [
    { type: AppConfigService }
];

class JwtHelperService {
    constructor(storageService) {
        this.storageService = storageService;
    }
    decodeToken(token) {
        const parts = token.split('.');
        if (parts.length !== 3) {
            throw new Error('JWT must have 3 parts');
        }
        const decoded = this.urlBase64Decode(parts[1]);
        if (!decoded) {
            throw new Error('Cannot decode the token');
        }
        return JSON.parse(decoded);
    }
    urlBase64Decode(token) {
        let output = token.replace(/-/g, '+').replace(/_/g, '/');
        switch (output.length % 4) {
            case 0: {
                break;
            }
            case 2: {
                output += '==';
                break;
            }
            case 3: {
                output += '=';
                break;
            }
            default: {
                throw new Error('Illegal base64url string!');
            }
        }
        return decodeURIComponent(escape(window.atob(output)));
    }
    getValueFromLocalAccessToken(key) {
        return this.getValueFromToken(this.getAccessToken(), key);
    }
    getAccessToken() {
        return this.storageService.getItem(JwtHelperService.USER_ACCESS_TOKEN);
    }
    getValueFromToken(accessToken, key) {
        let value;
        if (accessToken) {
            const tokenPayload = this.decodeToken(accessToken);
            value = tokenPayload[key];
        }
        return value;
    }
    getRealmRoles() {
        const access = this.getValueFromLocalAccessToken(JwtHelperService.REALM_ACCESS);
        return access ? access['roles'] : [];
    }
    getClientRoles(clientName) {
        const clientRole = this.getValueFromLocalAccessToken(JwtHelperService.RESOURCE_ACCESS)[clientName];
        return clientRole ? clientRole['roles'] : [];
    }
    hasRealmRole(role) {
        let hasRole = false;
        if (this.getAccessToken()) {
            const realmRoles = this.getRealmRoles();
            hasRole = realmRoles.some((currentRole) => {
                return currentRole === role;
            });
        }
        return hasRole;
    }
    hasRealmRoles(rolesToCheck) {
        return rolesToCheck.some((currentRole) => {
            return this.hasRealmRole(currentRole);
        });
    }
    hasRealmRolesForClientRole(clientName, rolesToCheck) {
        return rolesToCheck.some((currentRole) => {
            return this.hasClientRole(clientName, currentRole);
        });
    }
    hasClientRole(clientName, role) {
        let hasRole = false;
        if (this.getAccessToken()) {
            const clientRoles = this.getClientRoles(clientName);
            hasRole = clientRoles.some((currentRole) => {
                return currentRole === role;
            });
        }
        return hasRole;
    }
}
JwtHelperService.USER_NAME = 'name';
JwtHelperService.FAMILY_NAME = 'family_name';
JwtHelperService.GIVEN_NAME = 'given_name';
JwtHelperService.USER_EMAIL = 'email';
JwtHelperService.USER_ACCESS_TOKEN = 'access_token';
JwtHelperService.REALM_ACCESS = 'realm_access';
JwtHelperService.RESOURCE_ACCESS = 'resource_access';
JwtHelperService.USER_PREFERRED_USERNAME = 'preferred_username';
JwtHelperService.ɵprov = ɵɵdefineInjectable({ factory: function JwtHelperService_Factory() { return new JwtHelperService(ɵɵinject(StorageService)); }, token: JwtHelperService, providedIn: "root" });
JwtHelperService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
JwtHelperService.ctorParameters = () => [
    { type: StorageService }
];

const REMEMBER_ME_COOKIE_KEY = 'ALFRESCO_REMEMBER_ME';
const REMEMBER_ME_UNTIL = 1000 * 60 * 60 * 24 * 30;
class AuthenticationService {
    constructor(appConfig, storageService, alfrescoApi, cookie, logService) {
        this.appConfig = appConfig;
        this.storageService = storageService;
        this.alfrescoApi = alfrescoApi;
        this.cookie = cookie;
        this.logService = logService;
        this.redirectUrl = null;
        this.bearerExcludedUrls = ['auth/realms', 'resources/', 'assets/'];
        this.onLogin = new ReplaySubject(1);
        this.onLogout = new ReplaySubject(1);
        this.alfrescoApi.alfrescoApiInitialized.subscribe(() => {
            this.alfrescoApi.getInstance().reply('logged-in', () => {
                this.onLogin.next();
            });
            if (this.isKerberosEnabled()) {
                this.loadUserDetails();
            }
        });
    }
    get peopleApi() {
        var _a;
        this._peopleApi = (_a = this._peopleApi) !== null && _a !== void 0 ? _a : new PeopleApi(this.alfrescoApi.getInstance());
        return this._peopleApi;
    }
    get profileApi() {
        var _a;
        this._profileApi = (_a = this._profileApi) !== null && _a !== void 0 ? _a : new UserProfileApi(this.alfrescoApi.getInstance());
        return this._profileApi;
    }
    loadUserDetails() {
        const ecmUser$ = from(this.peopleApi.getPerson('-me-'));
        const bpmUser$ = this.getBpmLoggedUser();
        if (this.isALLProvider()) {
            forkJoin([ecmUser$, bpmUser$]).subscribe(() => this.onLogin.next());
        }
        else if (this.isECMProvider()) {
            ecmUser$.subscribe(() => this.onLogin.next());
        }
        else {
            bpmUser$.subscribe(() => this.onLogin.next());
        }
    }
    isLoggedIn() {
        if (!this.isOauth() && this.cookie.isEnabled() && !this.isRememberMeSet()) {
            return false;
        }
        return this.alfrescoApi.getInstance().isLoggedIn();
    }
    isLoggedInWith(provider) {
        if (provider === 'BPM') {
            return this.isBpmLoggedIn();
        }
        else if (provider === 'ECM') {
            return this.isEcmLoggedIn();
        }
        else {
            return this.isLoggedIn();
        }
    }
    isKerberosEnabled() {
        return this.appConfig.get(AppConfigValues.AUTH_WITH_CREDENTIALS, false);
    }
    isOauth() {
        return this.alfrescoApi.getInstance().isOauthConfiguration();
    }
    isPublicUrl() {
        return this.alfrescoApi.getInstance().isPublicUrl();
    }
    isECMProvider() {
        return this.alfrescoApi.getInstance().isEcmConfiguration();
    }
    isBPMProvider() {
        return this.alfrescoApi.getInstance().isBpmConfiguration();
    }
    isALLProvider() {
        return this.alfrescoApi.getInstance().isEcmBpmConfiguration();
    }
    login(username, password, rememberMe = false) {
        return from(this.alfrescoApi.getInstance().login(username, password))
            .pipe(map((response) => {
            this.saveRememberMeCookie(rememberMe);
            this.onLogin.next(response);
            return {
                type: this.appConfig.get(AppConfigValues.PROVIDERS),
                ticket: response
            };
        }), catchError((err) => this.handleError(err)));
    }
    ssoImplicitLogin() {
        this.alfrescoApi.getInstance().implicitLogin();
    }
    saveRememberMeCookie(rememberMe) {
        let expiration = null;
        if (rememberMe) {
            expiration = new Date();
            const time = expiration.getTime();
            const expireTime = time + REMEMBER_ME_UNTIL;
            expiration.setTime(expireTime);
        }
        this.cookie.setItem(REMEMBER_ME_COOKIE_KEY, '1', expiration, null);
    }
    isRememberMeSet() {
        return (this.cookie.getItem(REMEMBER_ME_COOKIE_KEY) !== null);
    }
    logout() {
        return from(this.callApiLogout())
            .pipe(tap((response) => {
            this.onLogout.next(response);
            return response;
        }), catchError((err) => this.handleError(err)));
    }
    callApiLogout() {
        if (this.alfrescoApi.getInstance()) {
            return this.alfrescoApi.getInstance().logout();
        }
        return Promise.resolve();
    }
    getTicketEcm() {
        return this.alfrescoApi.getInstance().getTicketEcm();
    }
    getTicketBpm() {
        return this.alfrescoApi.getInstance().getTicketBpm();
    }
    getTicketEcmBase64() {
        const ticket = this.alfrescoApi.getInstance().getTicketEcm();
        if (ticket) {
            return 'Basic ' + btoa(ticket);
        }
        return null;
    }
    isEcmLoggedIn() {
        if (this.isECMProvider() || this.isALLProvider()) {
            if (!this.isOauth() && this.cookie.isEnabled() && !this.isRememberMeSet()) {
                return false;
            }
            return this.alfrescoApi.getInstance().isEcmLoggedIn();
        }
        return false;
    }
    isBpmLoggedIn() {
        if (this.isBPMProvider() || this.isALLProvider()) {
            if (!this.isOauth() && this.cookie.isEnabled() && !this.isRememberMeSet()) {
                return false;
            }
            return this.alfrescoApi.getInstance().isBpmLoggedIn();
        }
        return false;
    }
    getEcmUsername() {
        return this.alfrescoApi.getInstance().getEcmUsername();
    }
    getBpmUsername() {
        return this.alfrescoApi.getInstance().getBpmUsername();
    }
    setRedirect(url) {
        this.redirectUrl = url;
    }
    getRedirect() {
        const provider = this.appConfig.get(AppConfigValues.PROVIDERS);
        return this.hasValidRedirection(provider) ? this.redirectUrl.url : null;
    }
    getBpmLoggedUser() {
        return from(this.profileApi.getProfile());
    }
    hasValidRedirection(provider) {
        return this.redirectUrl && (this.redirectUrl.provider === provider || this.hasSelectedProviderAll(provider));
    }
    hasSelectedProviderAll(provider) {
        return this.redirectUrl && (this.redirectUrl.provider === 'ALL' || provider === 'ALL');
    }
    handleError(error) {
        this.logService.error('Error when logging in', error);
        return throwError(error || 'Server error');
    }
    getBearerExcludedUrls() {
        return this.bearerExcludedUrls;
    }
    getToken() {
        return this.storageService.getItem(JwtHelperService.USER_ACCESS_TOKEN);
    }
    addTokenToHeader(headersArg) {
        return new Observable((observer) => {
            let headers = headersArg;
            if (!headers) {
                headers = new HttpHeaders();
            }
            try {
                const token = this.getToken();
                headers = headers.set('Authorization', 'bearer ' + token);
                observer.next(headers);
                observer.complete();
            }
            catch (error) {
                observer.error(error);
            }
        });
    }
}
AuthenticationService.ɵprov = ɵɵdefineInjectable({ factory: function AuthenticationService_Factory() { return new AuthenticationService(ɵɵinject(AppConfigService), ɵɵinject(StorageService), ɵɵinject(AlfrescoApiService), ɵɵinject(CookieService), ɵɵinject(LogService)); }, token: AuthenticationService, providedIn: "root" });
AuthenticationService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
AuthenticationService.ctorParameters = () => [
    { type: AppConfigService },
    { type: StorageService },
    { type: AlfrescoApiService },
    { type: CookieService },
    { type: LogService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class BpmProductVersionModel {
    constructor(obj) {
        if (obj) {
            this.edition = obj.edition || null;
            this.majorVersion = obj.majorVersion || null;
            this.revisionVersion = obj.revisionVersion || null;
            this.minorVersion = obj.minorVersion || null;
            this.type = obj.type || null;
        }
    }
}
class VersionModel {
    constructor(obj) {
        if (obj) {
            this.major = obj.major || null;
            this.minor = obj.minor || null;
            this.patch = obj.patch || null;
            this.hotfix = obj.hotfix || null;
            this.schema = obj.schema || null;
            this.label = obj.label || null;
            this.display = obj.display || null;
        }
    }
}
class LicenseModel {
    constructor(obj) {
        if (obj) {
            this.issuedAt = obj.issuedAt || null;
            this.expiresAt = obj.expiresAt || null;
            this.remainingDays = obj.remainingDays || null;
            this.holder = obj.holder || null;
            this.mode = obj.mode || null;
            this.isClusterEnabled = !!obj.isClusterEnabled;
            this.isCryptodocEnabled = !!obj.isCryptodocEnabled;
        }
    }
}
class VersionStatusModel {
    constructor(obj) {
        if (obj) {
            this.isReadOnly = !!obj.isReadOnly;
            this.isAuditEnabled = !!obj.isAuditEnabled;
            this.isQuickShareEnabled = !!obj.isQuickShareEnabled;
            this.isThumbnailGenerationEnabled = !!obj.isThumbnailGenerationEnabled;
        }
    }
}
class VersionModuleModel {
    constructor(obj) {
        if (obj) {
            this.id = obj.id || null;
            this.title = obj.title || null;
            this.description = obj.description || null;
            this.version = obj.version || null;
            this.installDate = obj.installDate || null;
            this.installState = obj.installState || null;
            this.versionMin = obj.versionMin || null;
            this.versionMax = obj.versionMax || null;
        }
    }
}
class EcmProductVersionModel {
    constructor(obj) {
        this.modules = [];
        if (obj && obj.entry && obj.entry.repository) {
            this.edition = obj.entry.repository.edition || null;
            this.version = new VersionModel(obj.entry.repository.version);
            this.license = new LicenseModel(obj.entry.repository.license);
            this.status = new VersionStatusModel(obj.entry.repository.status);
            if (obj.entry.repository.modules) {
                obj.entry.repository.modules.forEach((module) => {
                    this.modules.push(new VersionModuleModel(module));
                });
            }
        }
    }
}

class DiscoveryApiService {
    constructor(apiService, authenticationService) {
        this.apiService = apiService;
        this.authenticationService = authenticationService;
        this.ecmProductInfo$ = new Subject();
        this.authenticationService.onLogin
            .pipe(filter(() => { var _a; return (_a = this.apiService.getInstance()) === null || _a === void 0 ? void 0 : _a.isEcmLoggedIn(); }), take(1), switchMap(() => this.getEcmProductInfo()))
            .subscribe((info) => this.ecmProductInfo$.next(info));
    }
    getEcmProductInfo() {
        const discoveryApi = new DiscoveryApi(this.apiService.getInstance());
        return from(discoveryApi.getRepositoryInformation())
            .pipe(map((res) => new EcmProductVersionModel(res)), catchError((err) => throwError(err)));
    }
    getBpmProductInfo() {
        const aboutApi = new AboutApi(this.apiService.getInstance());
        return from(aboutApi.getAppVersion())
            .pipe(map((res) => new BpmProductVersionModel(res)), catchError((err) => throwError(err)));
    }
    getBPMSystemProperties() {
        const systemPropertiesApi = new SystemPropertiesApi(this.apiService.getInstance());
        return from(systemPropertiesApi.getProperties())
            .pipe(map((res) => {
            if ('string' === typeof (res)) {
                throw new Error('Not valid response');
            }
            return res;
        }), catchError((err) => throwError(err.error)));
    }
}
DiscoveryApiService.ɵprov = ɵɵdefineInjectable({ factory: function DiscoveryApiService_Factory() { return new DiscoveryApiService(ɵɵinject(AlfrescoApiService), ɵɵinject(AuthenticationService)); }, token: DiscoveryApiService, providedIn: "root" });
DiscoveryApiService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
DiscoveryApiService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: AuthenticationService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AboutProductVersionComponent {
    constructor(authService, discovery) {
        this.authService = authService;
        this.discovery = discovery;
        this.ecmVersion = null;
        this.bpmVersion = null;
    }
    ngOnInit() {
        if (this.authService.isEcmLoggedIn()) {
            this.setECMInfo();
        }
        if (this.authService.isBpmLoggedIn()) {
            this.setBPMInfo();
        }
    }
    setECMInfo() {
        this.discovery.getEcmProductInfo().subscribe((ecmVers) => {
            this.ecmVersion = ecmVers;
            this.modules = new ObjectDataTableAdapter(this.ecmVersion.modules, [
                { type: 'text', key: 'id', title: 'ABOUT.TABLE_HEADERS.MODULES.ID', sortable: true },
                { type: 'text', key: 'title', title: 'ABOUT.TABLE_HEADERS.MODULES.TITLE', sortable: true },
                { type: 'text', key: 'version', title: 'ABOUT.TABLE_HEADERS.MODULES.DESCRIPTION', sortable: true },
                {
                    type: 'text',
                    key: 'installDate',
                    title: 'ABOUT.TABLE_HEADERS.MODULES.INSTALL_DATE',
                    sortable: true
                },
                {
                    type: 'text',
                    key: 'installState',
                    title: 'ABOUT.TABLE_HEADERS.MODULES.INSTALL_STATE',
                    sortable: true
                },
                {
                    type: 'text',
                    key: 'versionMin',
                    title: 'ABOUT.TABLE_HEADERS.MODULES.VERSION_MIN',
                    sortable: true
                },
                {
                    type: 'text',
                    key: 'versionMax',
                    title: 'ABOUT.TABLE_HEADERS.MODULES.VERSION_MAX',
                    sortable: true
                }
            ]);
            this.status = new ObjectDataTableAdapter([this.ecmVersion.status], [
                { type: 'text', key: 'isReadOnly', title: 'ABOUT.TABLE_HEADERS.STATUS.READ_ONLY', sortable: true },
                {
                    type: 'text',
                    key: 'isAuditEnabled',
                    title: 'ABOUT.TABLE_HEADERS.STATUS.AUDIT_ENABLED',
                    sortable: true
                },
                {
                    type: 'text',
                    key: 'isQuickShareEnabled',
                    title: 'ABOUT.TABLE_HEADERS.STATUS.QUICK_SHARE_ENABLED',
                    sortable: true
                },
                {
                    type: 'text',
                    key: 'isThumbnailGenerationEnabled',
                    title: 'ABOUT.TABLE_HEADERS.STATUS.THUMBNAIL_ENABLED',
                    sortable: true
                }
            ]);
            this.license = new ObjectDataTableAdapter([this.ecmVersion.license], [
                { type: 'text', key: 'issuedAt', title: 'ABOUT.TABLE_HEADERS.LICENSE.ISSUES_AT', sortable: true },
                { type: 'text', key: 'expiresAt', title: 'ABOUT.TABLE_HEADERS.LICENSE.EXPIRES_AT', sortable: true },
                {
                    type: 'text',
                    key: 'remainingDays',
                    title: 'ABOUT.TABLE_HEADERS.LICENSE.REMAINING_DAYS',
                    sortable: true
                },
                { type: 'text', key: 'holder', title: 'ABOUT.TABLE_HEADERS.LICENSE.HOLDER', sortable: true },
                { type: 'text', key: 'mode', title: 'ABOUT.TABLE_HEADERS.LICENSE.MODE', sortable: true },
                {
                    type: 'text',
                    key: 'isClusterEnabled',
                    title: 'ABOUT.TABLE_HEADERS.LICENSE.CLUSTER_ENABLED',
                    sortable: true
                },
                {
                    type: 'text',
                    key: 'isCryptodocEnabled',
                    title: 'ABOUT.TABLE_HEADERS.LICENSE.CRYPTODOC_ENABLED',
                    sortable: true
                }
            ]);
        });
    }
    setBPMInfo() {
        this.discovery.getBpmProductInfo().subscribe((bpmVersion) => {
            this.bpmVersion = bpmVersion;
        });
    }
}
AboutProductVersionComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-about-product-version',
                template: "<div class=\"adf-about-product-version-container\" *ngIf=\"bpmVersion || ecmVersion\">\n    <h3 data-automation-id=\"adf-about-product-version-title\">{{ 'ABOUT.VERSIONS.TITLE' | translate }}</h3>\n        <mat-card>\n            <div *ngIf=\"bpmVersion\" data-automation-id=\"adf-about-bpm-service\">\n                <h3>{{ 'ABOUT.VERSIONS.PROCESS_SERVICE' | translate }}</h3>\n                <p data-automation-id=\"adf-about-bpm-edition\">\n                    {{ 'ABOUT.VERSIONS.LABELS.EDITION' | translate }}: {{ bpmVersion.edition }}\n                </p>\n                <p data-automation-id=\"adf-about-bpm-version\">\n                    {{ 'ABOUT.VERSIONS.LABELS.VERSION' | translate }}: {{ bpmVersion.majorVersion }}.{{\n                    bpmVersion.minorVersion }}.{{ bpmVersion.revisionVersion }}\n                </p>\n            </div>\n            <div *ngIf=\"ecmVersion\" data-automation-id=\"adf-about-ecm-service\">\n                <h3>{{ 'ABOUT.VERSIONS.CONTENT_SERVICE' | translate }}</h3>\n                <p data-automation-id=\"adf-about-ecm-edition\">\n                    {{ 'ABOUT.VERSIONS.LABELS.EDITION' | translate }}: {{ ecmVersion.edition }}\n                </p>\n                <p data-automation-id=\"adf-about-ecm-version\">\n                    {{ 'ABOUT.VERSIONS.LABELS.VERSION' | translate }}: {{ ecmVersion.version.display }}\n                </p>\n            </div>\n        </mat-card>\n    <div *ngIf=\"ecmVersion\" data-automation-id=\"adf-about-ecm\">\n        <h3 data-automation-id=\"adf-about-ecm-license-title\">{{ 'ABOUT.VERSIONS.LABELS.LICENSE' | translate }}</h3>\n        <adf-datatable [data]=\"license\"></adf-datatable>\n        <h3 data-automation-id=\"adf-about-ecm-status-title\"> {{ 'ABOUT.VERSIONS.LABELS.STATUS' | translate }}</h3>\n        <adf-datatable [data]=\"status\"></adf-datatable>\n        <h3 data-automation-id=\"adf-about-ecm-modules-title\">{{ 'ABOUT.VERSIONS.LABELS.MODULES' | translate }}</h3>\n        <adf-datatable [data]=\"modules\"></adf-datatable>\n    </div>\n</div>\n\n\n\n",
                encapsulation: ViewEncapsulation.None
            },] }
];
AboutProductVersionComponent.ctorParameters = () => [
    { type: AuthenticationService },
    { type: DiscoveryApiService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AboutApplicationModulesComponent {
    constructor(appExtensions) {
        this.appExtensions = appExtensions;
        this.extensionColumns = ['$id', '$name', '$version', '$vendor', '$license', '$runtime', '$description'];
        this.showExtensions = true;
        this.regexp = '^(@alfresco)';
        this.onDestroy$ = new Subject();
    }
    ngOnInit() {
        const alfrescoPackages = Object.keys(this.dependencies).filter((val) => {
            return new RegExp(this.regexp).test(val);
        });
        const alfrescoPackagesTableRepresentation = [];
        alfrescoPackages.forEach((val) => {
            alfrescoPackagesTableRepresentation.push({
                name: val,
                version: (this.dependencies[val])
            });
        });
        this.dependencyEntries = new ObjectDataTableAdapter(alfrescoPackagesTableRepresentation, [
            { type: 'text', key: 'name', title: 'Name', sortable: true },
            { type: 'text', key: 'version', title: 'Version', sortable: true }
        ]);
        this.appExtensions.references$
            .pipe(takeUntil(this.onDestroy$))
            .subscribe((extensions) => this.extensions = extensions);
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
}
AboutApplicationModulesComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-about-application-modules',
                template: "<div class=\"adf-about-modules-container\">\n    <h3 data-automation-id=\"adf-about-modules-title\">{{ 'ABOUT.PACKAGES.TITLE' | translate }}</h3>\n    <small>{{ 'ABOUT.PACKAGES.DESCRIPTION' | translate }}</small>\n    <adf-datatable [data]=\"dependencyEntries\"></adf-datatable>\n\n    <div class=\"adf-extension-details-container\" *ngIf=\"showExtensions && extensions.length\">\n        <h3>{{ 'ABOUT.EXTENSIONS.TITLE' | translate }}</h3>\n        <mat-table [dataSource]=\"extensions\">\n            <!-- $id Column -->\n            <ng-container matColumnDef=\"$id\">\n                <mat-header-cell\n                    *matHeaderCellDef>{{ 'ABOUT.EXTENSIONS.TABLE_HEADERS.ID' | translate }}</mat-header-cell>\n                <mat-cell *matCellDef=\"let element\">{{element.$id}}</mat-cell>\n            </ng-container>\n\n            <!-- $name Column -->\n            <ng-container matColumnDef=\"$name\">\n                <mat-header-cell\n                    *matHeaderCellDef>{{ 'ABOUT.EXTENSIONS.TABLE_HEADERS.NAME' | translate }}</mat-header-cell>\n                <mat-cell *matCellDef=\"let element\">{{element.$name}}</mat-cell>\n            </ng-container>\n\n            <!-- $version Column -->\n            <ng-container matColumnDef=\"$version\">\n                <mat-header-cell\n                    *matHeaderCellDef>{{ 'ABOUT.EXTENSIONS.TABLE_HEADERS.VERSION' | translate }}</mat-header-cell>\n                <mat-cell *matCellDef=\"let element\">{{element.$version}}</mat-cell>\n            </ng-container>\n\n            <!-- $vendor Column -->\n            <ng-container matColumnDef=\"$vendor\">\n                <mat-header-cell\n                    *matHeaderCellDef>{{ 'ABOUT.EXTENSIONS.TABLE_HEADERS.VENDOR' | translate }}</mat-header-cell>\n                <mat-cell *matCellDef=\"let element\">{{element.$vendor}}</mat-cell>\n            </ng-container>\n\n            <!-- $license Column -->\n            <ng-container matColumnDef=\"$license\">\n                <mat-header-cell\n                    *matHeaderCellDef>{{ 'ABOUT.EXTENSIONS.TABLE_HEADERS.LICENSE' | translate }}</mat-header-cell>\n                <mat-cell *matCellDef=\"let element\">{{element.$license}}</mat-cell>\n            </ng-container>\n\n            <!-- $runtime Column -->\n            <ng-container matColumnDef=\"$runtime\">\n                <mat-header-cell\n                    *matHeaderCellDef>{{ 'ABOUT.EXTENSIONS.TABLE_HEADERS.RUNTIME' | translate }}</mat-header-cell>\n                <mat-cell *matCellDef=\"let element\">{{element.$runtime}}</mat-cell>\n            </ng-container>\n\n            <!-- $description Column -->\n            <ng-container matColumnDef=\"$description\">\n                <mat-header-cell\n                    *matHeaderCellDef>{{ 'ABOUT.EXTENSIONS.TABLE_HEADERS.DESCRIPTION' | translate }}</mat-header-cell>\n                <mat-cell *matCellDef=\"let element\">{{element.$description}}</mat-cell>\n            </ng-container>\n\n            <mat-header-row *matHeaderRowDef=\"extensionColumns\"></mat-header-row>\n            <mat-row *matRowDef=\"let row; columns: extensionColumns;\"></mat-row>\n        </mat-table>\n    </div>\n</div>\n",
                encapsulation: ViewEncapsulation.None
            },] }
];
AboutApplicationModulesComponent.ctorParameters = () => [
    { type: AppExtensionService }
];
AboutApplicationModulesComponent.propDecorators = {
    showExtensions: [{ type: Input }],
    regexp: [{ type: Input }],
    dependencies: [{ type: Input }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AboutServerSettingsComponent {
    constructor(appConfig) {
        this.appConfig = appConfig;
        this.ecmHost = '';
        this.bpmHost = '';
    }
    ngOnInit() {
        this.ecmHost = this.appConfig.get(AppConfigValues.ECMHOST);
        this.bpmHost = this.appConfig.get(AppConfigValues.BPMHOST);
    }
}
AboutServerSettingsComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-about-server-settings',
                template: "<div class=\"adf-github-link-container\">\n    <h3 data-automation-id=\"adf-about-setting-title\">{{ 'ABOUT.SERVER_SETTINGS.TITLE' | translate }}</h3>\n    <small>{{ 'ABOUT.SERVER_SETTINGS.DESCRIPTION' | translate }}</small>\n    <mat-card>\n        <p data-automation-id=\"adf-process-service-host\">\n            {{ 'ABOUT.SERVER_SETTINGS.PROCESS_SERVICE_HOST' | translate: {value: bpmHost} }}\n        </p>\n        <p data-automation-id=\"adf-content-service-host\">\n            {{ 'ABOUT.SERVER_SETTINGS.CONTENT_SERVICE_HOST' | translate: {value: ecmHost} }}\n        </p>\n    </mat-card>\n</div>\n",
                encapsulation: ViewEncapsulation.None
            },] }
];
AboutServerSettingsComponent.ctorParameters = () => [
    { type: AppConfigService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class MaterialModule {
}
MaterialModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    MatAutocompleteModule, MatButtonModule, MatCardModule, MatCheckboxModule,
                    MatChipsModule, MatDatepickerModule, MatDialogModule, MatGridListModule, MatIconModule,
                    MatInputModule, MatListModule, MatNativeDateModule, MatOptionModule, MatProgressSpinnerModule, MatRadioModule,
                    MatRippleModule, MatSelectModule, MatSlideToggleModule, MatTableModule, MatTabsModule,
                    MatMenuModule, MatProgressBarModule, MatSidenavModule, MatSnackBarModule, MatToolbarModule,
                    MatTooltipModule, MatDatetimepickerModule, MatNativeDatetimeModule, MatExpansionModule, MatBadgeModule
                ],
                exports: [
                    MatAutocompleteModule, MatButtonModule, MatCardModule, MatCheckboxModule,
                    MatChipsModule, MatDatepickerModule, MatDialogModule, MatGridListModule, MatIconModule,
                    MatInputModule, MatListModule, MatNativeDateModule, MatOptionModule, MatProgressSpinnerModule, MatRadioModule,
                    MatRippleModule, MatSelectModule, MatSlideToggleModule, MatTableModule, MatTabsModule,
                    MatMenuModule, MatProgressBarModule, MatSidenavModule, MatSnackBarModule, MatToolbarModule,
                    MatTooltipModule, MatDatetimepickerModule, MatNativeDatetimeModule, MatExpansionModule, MatBadgeModule
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ContextMenuOverlayRef {
    constructor(overlayRef) {
        this.overlayRef = overlayRef;
    }
    close() {
        this.overlayRef.dispose();
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const CONTEXT_MENU_DATA = new InjectionToken('CONTEXT_MENU_DATA');

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const contextMenuAnimation = [
    state('void', style({
        opacity: 0,
        transform: 'scale(0.01, 0.01)'
    })),
    transition('void => *', sequence([
        query('.mat-menu-content', style({ opacity: 0 })),
        animate('100ms linear', style({ opacity: 1, transform: 'scale(1, 0.5)' })),
        group([
            query('.mat-menu-content', animate('400ms cubic-bezier(0.55, 0, 0.55, 0.2)', style({ opacity: 1 }))),
            animate('300ms cubic-bezier(0.25, 0.8, 0.25, 1)', style({ transform: 'scale(1, 1)' }))
        ])
    ])),
    transition('* => void', animate('150ms 50ms linear', style({ opacity: 0 })))
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ContextMenuListComponent {
    constructor(contextMenuOverlayRef, data) {
        this.contextMenuOverlayRef = contextMenuOverlayRef;
        this.data = data;
        this.links = this.data;
    }
    handleKeydownEscape(event) {
        if (event) {
            this.contextMenuOverlayRef.close();
        }
    }
    handleKeydownEvent(event) {
        if (event) {
            const keyCode = event.keyCode;
            if (keyCode === UP_ARROW || keyCode === DOWN_ARROW) {
                this.keyManager.onKeydown(event);
            }
        }
    }
    onMenuItemClick(event, menuItem) {
        if (menuItem && menuItem.model && menuItem.model.disabled) {
            event.preventDefault();
            event.stopImmediatePropagation();
            return;
        }
        menuItem.subject.next(menuItem);
        this.contextMenuOverlayRef.close();
    }
    ngAfterViewInit() {
        this.keyManager = new FocusKeyManager(this.items);
        this.keyManager.setFirstItemActive();
    }
}
ContextMenuListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-context-menu',
                template: `
        <div mat-menu class="mat-menu-panel" @panelAnimation>
            <div id="adf-context-menu-content" class="mat-menu-content">
                <ng-container *ngFor="let link of links">
                    <button *ngIf="link.model?.visible"
                            [attr.data-automation-id]="'context-'+((link.title || link.model?.title) | translate)"
                            mat-menu-item
                            [disabled]="link.model?.disabled"
                            (click)="onMenuItemClick($event, link)">
                        <mat-icon *ngIf="link.model?.icon">{{ link.model.icon }}</mat-icon>
                        <span>{{ (link.title || link.model?.title) | translate }}</span>
                    </button>
                </ng-container>
            </div>
        </div>
    `,
                host: {
                    role: 'menu',
                    class: 'adf-context-menu'
                },
                encapsulation: ViewEncapsulation.None,
                animations: [
                    trigger('panelAnimation', contextMenuAnimation)
                ]
            },] }
];
ContextMenuListComponent.ctorParameters = () => [
    { type: ContextMenuOverlayRef, decorators: [{ type: Inject, args: [ContextMenuOverlayRef,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [CONTEXT_MENU_DATA,] }] }
];
ContextMenuListComponent.propDecorators = {
    items: [{ type: ViewChildren, args: [MatMenuItem,] }],
    handleKeydownEscape: [{ type: HostListener, args: ['document:keydown.Escape', ['$event'],] }],
    handleKeydownEvent: [{ type: HostListener, args: ['document:keydown', ['$event'],] }]
};

const DEFAULT_CONFIG = {
    panelClass: 'cdk-overlay-pane',
    backdropClass: 'cdk-overlay-transparent-backdrop',
    hasBackdrop: true
};
class ContextMenuOverlayService {
    constructor(injector, overlay) {
        this.injector = injector;
        this.overlay = overlay;
    }
    open(config) {
        const overlayConfig = Object.assign(Object.assign({}, DEFAULT_CONFIG), config);
        const overlay = this.createOverlay(overlayConfig);
        const overlayRef = new ContextMenuOverlayRef(overlay);
        this.attachDialogContainer(overlay, config, overlayRef);
        overlay.backdropClick().subscribe(() => overlayRef.close());
        if (overlayConfig.hasBackdrop) {
            overlay._backdropElement
                .addEventListener('contextmenu', (event) => {
                event.preventDefault();
                overlay._backdropClick.next(null);
            }, true);
        }
        return overlayRef;
    }
    createOverlay(config) {
        const overlayConfig = this.getOverlayConfig(config);
        return this.overlay.create(overlayConfig);
    }
    attachDialogContainer(overlay, config, contextMenuOverlayRef) {
        const injector = this.createInjector(config, contextMenuOverlayRef);
        const containerPortal = new ComponentPortal(ContextMenuListComponent, null, injector);
        const containerRef = overlay.attach(containerPortal);
        return containerRef.instance;
    }
    createInjector(config, contextMenuOverlayRef) {
        const injectionTokens = new WeakMap();
        injectionTokens.set(ContextMenuOverlayRef, contextMenuOverlayRef);
        injectionTokens.set(CONTEXT_MENU_DATA, config.data);
        return new PortalInjector(this.injector, injectionTokens);
    }
    getOverlayConfig(config) {
        const { clientY, clientX } = config.source;
        const fakeElement = {
            getBoundingClientRect: () => ({
                bottom: clientY,
                height: 0,
                left: clientX,
                right: clientX,
                top: clientY,
                width: 0
            })
        };
        const positionStrategy = this.overlay.position()
            .connectedTo(new ElementRef(fakeElement), { originX: 'start', originY: 'bottom' }, { overlayX: 'start', overlayY: 'top' })
            .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'start', overlayY: 'bottom' })
            .withFallbackPosition({ originX: 'end', originY: 'top' }, { overlayX: 'start', overlayY: 'top' })
            .withFallbackPosition({ originX: 'start', originY: 'top' }, { overlayX: 'end', overlayY: 'top' })
            .withFallbackPosition({ originX: 'end', originY: 'center' }, { overlayX: 'start', overlayY: 'center' })
            .withFallbackPosition({ originX: 'start', originY: 'center' }, { overlayX: 'end', overlayY: 'center' });
        const overlayConfig = new OverlayConfig({
            hasBackdrop: config.hasBackdrop,
            backdropClass: config.backdropClass,
            panelClass: config.panelClass,
            scrollStrategy: this.overlay.scrollStrategies.close(),
            positionStrategy
        });
        return overlayConfig;
    }
}
ContextMenuOverlayService.ɵprov = ɵɵdefineInjectable({ factory: function ContextMenuOverlayService_Factory() { return new ContextMenuOverlayService(ɵɵinject(INJECTOR), ɵɵinject(Overlay)); }, token: ContextMenuOverlayService, providedIn: "root" });
ContextMenuOverlayService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
ContextMenuOverlayService.ctorParameters = () => [
    { type: Injector },
    { type: Overlay }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ContextMenuDirective {
    constructor(contextMenuService) {
        this.contextMenuService = contextMenuService;
        this.enabled = false;
    }
    onShowContextMenu(event) {
        if (this.enabled) {
            if (event) {
                event.preventDefault();
            }
            if (this.links && this.links.length > 0) {
                this.contextMenuService.open({
                    source: event,
                    data: this.links
                });
            }
        }
    }
}
ContextMenuDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-context-menu]'
            },] }
];
ContextMenuDirective.ctorParameters = () => [
    { type: ContextMenuOverlayService }
];
ContextMenuDirective.propDecorators = {
    links: [{ type: Input, args: ['adf-context-menu',] }],
    enabled: [{ type: Input, args: ['adf-context-menu-enabled',] }],
    onShowContextMenu: [{ type: HostListener, args: ['contextmenu', ['$event'],] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ContextMenuModule {
}
ContextMenuModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    TranslateModule
                ],
                declarations: [
                    ContextMenuDirective,
                    ContextMenuListComponent
                ],
                exports: [
                    ContextMenuDirective
                ]
            },] }
];

var UserPreferenceValues;
(function (UserPreferenceValues) {
    UserPreferenceValues["PaginationSize"] = "paginationSize";
    UserPreferenceValues["Locale"] = "locale";
    UserPreferenceValues["SupportedPageSizes"] = "supportedPageSizes";
    UserPreferenceValues["ExpandedSideNavStatus"] = "expandedSidenav";
})(UserPreferenceValues || (UserPreferenceValues = {}));
class UserPreferencesService {
    constructor(translate, appConfig, storage, alfrescoApiService) {
        this.translate = translate;
        this.appConfig = appConfig;
        this.storage = storage;
        this.alfrescoApiService = alfrescoApiService;
        this.defaults = {
            paginationSize: 25,
            supportedPageSizes: [5, 10, 15, 20],
            locale: 'en',
            expandedSidenav: true
        };
        this.userPreferenceStatus = this.defaults;
        this.alfrescoApiService.alfrescoApiInitialized.pipe(filter(status => status)).subscribe(this.initUserPreferenceStatus.bind(this));
        this.onChangeSubject = new BehaviorSubject(this.userPreferenceStatus);
        this.onChange = this.onChangeSubject.asObservable();
    }
    initUserPreferenceStatus() {
        this.initUserLanguage();
        this.set(UserPreferenceValues.PaginationSize, this.paginationSize);
        this.set(UserPreferenceValues.SupportedPageSizes, JSON.stringify(this.supportedPageSizes));
    }
    initUserLanguage() {
        if (this.locale || this.appConfig.get(UserPreferenceValues.Locale)) {
            const locale = this.locale || this.getDefaultLocale();
            this.set(UserPreferenceValues.Locale, locale);
            this.set('textOrientation', this.getLanguageByKey(locale).direction || 'ltr');
        }
        else {
            const locale = this.locale || this.getDefaultLocale();
            this.setWithoutStore(UserPreferenceValues.Locale, locale);
            this.setWithoutStore('textOrientation', this.getLanguageByKey(locale).direction || 'ltr');
        }
    }
    select(property) {
        return this.onChange
            .pipe(map((userPreferenceStatus) => userPreferenceStatus[property]), distinctUntilChanged());
    }
    get(property, defaultValue) {
        const key = this.getPropertyKey(property);
        const value = this.storage.getItem(key);
        if (value === undefined || value === null) {
            return defaultValue;
        }
        return value;
    }
    set(property, value) {
        if (!property) {
            return;
        }
        this.storage.setItem(this.getPropertyKey(property), value);
        this.userPreferenceStatus[property] = value;
        this.onChangeSubject.next(this.userPreferenceStatus);
    }
    setWithoutStore(property, value) {
        if (!property) {
            return;
        }
        this.userPreferenceStatus[property] = value;
        this.onChangeSubject.next(this.userPreferenceStatus);
    }
    hasItem(property) {
        if (!property) {
            return false;
        }
        return this.storage.hasItem(this.getPropertyKey(property));
    }
    getStoragePrefix() {
        return this.storage.getItem('USER_PROFILE') || 'GUEST';
    }
    setStoragePrefix(value) {
        this.storage.setItem('USER_PROFILE', value || 'GUEST');
        this.initUserPreferenceStatus();
    }
    getPropertyKey(property) {
        return `${this.getStoragePrefix()}__${property}`;
    }
    get supportedPageSizes() {
        const supportedPageSizes = this.get(UserPreferenceValues.SupportedPageSizes);
        if (supportedPageSizes) {
            return JSON.parse(supportedPageSizes);
        }
        else {
            return this.appConfig.get('pagination.supportedPageSizes', this.defaults.supportedPageSizes);
        }
    }
    set supportedPageSizes(value) {
        this.set(UserPreferenceValues.SupportedPageSizes, JSON.stringify(value));
    }
    set paginationSize(value) {
        this.set(UserPreferenceValues.PaginationSize, value);
    }
    get paginationSize() {
        const paginationSize = this.get(UserPreferenceValues.PaginationSize);
        if (paginationSize) {
            return Number(paginationSize);
        }
        else {
            return Number(this.appConfig.get('pagination.size', this.defaults.paginationSize));
        }
    }
    get locale() {
        return this.get(UserPreferenceValues.Locale);
    }
    set locale(value) {
        this.set(UserPreferenceValues.Locale, value);
    }
    getDefaultLocale() {
        return this.appConfig.get(UserPreferenceValues.Locale) || this.translate.getBrowserCultureLang() || 'en';
    }
    getLanguageByKey(key) {
        return (this.appConfig
            .get(AppConfigValues.APP_CONFIG_LANGUAGES_KEY, [{ key: 'en' }])
            .find((language) => key.includes(language.key)) || { key: 'en' });
    }
}
UserPreferencesService.ɵprov = ɵɵdefineInjectable({ factory: function UserPreferencesService_Factory() { return new UserPreferencesService(ɵɵinject(TranslateService), ɵɵinject(AppConfigService), ɵɵinject(StorageService), ɵɵinject(AlfrescoApiService)); }, token: UserPreferencesService, providedIn: "root" });
UserPreferencesService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
UserPreferencesService.ctorParameters = () => [
    { type: TranslateService },
    { type: AppConfigService },
    { type: StorageService },
    { type: AlfrescoApiService }
];

const TRANSLATION_PROVIDER = new InjectionToken('Injection token for translation providers.');
class TranslationService {
    constructor(translate, userPreferencesService, providers) {
        this.translate = translate;
        this.customLoader = this.translate.currentLoader;
        this.defaultLang = 'en';
        translate.setDefaultLang(this.defaultLang);
        this.customLoader.setDefaultLang(this.defaultLang);
        if (providers && providers.length > 0) {
            for (const provider of providers) {
                this.addTranslationFolder(provider.name, provider.source);
            }
        }
        userPreferencesService.select(UserPreferenceValues.Locale).subscribe((locale) => {
            if (locale) {
                this.userLang = locale;
                this.use(this.userLang);
            }
        });
    }
    addTranslationFolder(name = '', path = '') {
        if (!this.customLoader.providerRegistered(name)) {
            this.customLoader.registerProvider(name, path);
            if (this.userLang) {
                this.loadTranslation(this.userLang, this.defaultLang);
            }
            else {
                this.loadTranslation(this.defaultLang);
            }
        }
    }
    loadTranslation(lang, fallback) {
        this.translate.getTranslation(lang).subscribe(() => {
            this.translate.use(lang);
            this.onTranslationChanged(lang);
        }, () => {
            if (fallback && fallback !== lang) {
                this.loadTranslation(fallback);
            }
        });
    }
    onTranslationChanged(lang) {
        this.translate.onTranslationChange.next({
            lang: lang,
            translations: this.customLoader.getFullTranslationJSON(lang)
        });
    }
    use(lang) {
        this.customLoader.init(lang);
        return this.translate.use(lang);
    }
    get(key, interpolateParams) {
        return this.translate.get(key, interpolateParams);
    }
    instant(key, interpolateParams) {
        return key ? this.translate.instant(key, interpolateParams) : '';
    }
}
TranslationService.ɵprov = ɵɵdefineInjectable({ factory: function TranslationService_Factory() { return new TranslationService(ɵɵinject(TranslateService), ɵɵinject(UserPreferencesService), ɵɵinject(TRANSLATION_PROVIDER, 8)); }, token: TranslationService, providedIn: "root" });
TranslationService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
TranslationService.ctorParameters = () => [
    { type: TranslateService },
    { type: UserPreferencesService },
    { type: Array, decorators: [{ type: Optional }, { type: Inject, args: [TRANSLATION_PROVIDER,] }] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FileSizePipe {
    constructor(translation) {
        this.translation = translation;
    }
    transform(paramByte, decimals = 2) {
        if (paramByte == null) {
            return '';
        }
        const bytes = parseInt(paramByte, 10);
        if (isNaN(bytes)) {
            return '';
        }
        if (bytes === 0) {
            return '0 ' + this.translation.instant('CORE.FILE_SIZE.BYTES');
        }
        const k = 1024, dm = decimals || 2, sizes = ['BYTES', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'], i = Math.floor(Math.log(bytes) / Math.log(k));
        const i18nSize = this.translation.instant(`CORE.FILE_SIZE.${sizes[i]}`);
        return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + i18nSize;
    }
}
FileSizePipe.decorators = [
    { type: Pipe, args: [{
                name: 'adfFileSize',
                pure: false
            },] }
];
FileSizePipe.ctorParameters = () => [
    { type: TranslationService }
];

class ThumbnailService {
    constructor(apiService, matIconRegistry, sanitizer) {
        this.apiService = apiService;
        this.DEFAULT_ICON = './assets/images/ft_ic_miscellaneous.svg';
        this.mimeTypeIcons = {
            'image/png': './assets/images/ft_ic_raster_image.svg',
            'image/jpeg': './assets/images/ft_ic_raster_image.svg',
            'image/gif': './assets/images/ft_ic_raster_image.svg',
            'image/bmp': './assets/images/ft_ic_raster_image.svg',
            'image/cgm': './assets/images/ft_ic_raster_image.svg',
            'image/ief': './assets/images/ft_ic_raster_image.svg',
            'image/jp2': './assets/images/ft_ic_raster_image.svg',
            'image/tiff': './assets/images/ft_ic_raster_image.svg',
            'image/vnd.adobe.photoshop': './assets/images/ft_ic_raster_image.svg',
            'image/vnd.adobe.premiere': './assets/images/ft_ic_raster_image.svg',
            'image/x-cmu-raster': './assets/images/ft_ic_raster_image.svg',
            'image/x-dwt': './assets/images/ft_ic_raster_image.svg',
            'image/x-portable-anymap': './assets/images/ft_ic_raster_image.svg',
            'image/x-portable-bitmap': './assets/images/ft_ic_raster_image.svg',
            'image/x-portable-graymap': './assets/images/ft_ic_raster_image.svg',
            'image/x-portable-pixmap': './assets/images/ft_ic_raster_image.svg',
            'image/x-raw-adobe': './assets/images/ft_ic_raster_image.svg',
            'image/x-raw-canon': './assets/images/ft_ic_raster_image.svg',
            'image/x-raw-fuji': './assets/images/ft_ic_raster_image.svg',
            'image/x-raw-hasselblad': './assets/images/ft_ic_raster_image.svg',
            'image/x-raw-kodak': './assets/images/ft_ic_raster_image.svg',
            'image/x-raw-leica': './assets/images/ft_ic_raster_image.svg',
            'image/x-raw-minolta': './assets/images/ft_ic_raster_image.svg',
            'image/x-raw-nikon': './assets/images/ft_ic_raster_image.svg',
            'image/x-raw-olympus': './assets/images/ft_ic_raster_image.svg',
            'image/x-raw-panasonic': './assets/images/ft_ic_raster_image.svg',
            'image/x-raw-pentax': './assets/images/ft_ic_raster_image.svg',
            'image/x-raw-red': './assets/images/ft_ic_raster_image.svg',
            'image/x-raw-sigma': './assets/images/ft_ic_raster_image.svg',
            'image/x-raw-sony': './assets/images/ft_ic_raster_image.svg',
            'image/x-xbitmap': './assets/images/ft_ic_raster_image.svg',
            'image/x-xpixmap': './assets/images/ft_ic_raster_image.svg',
            'image/x-xwindowdump': './assets/images/ft_ic_raster_image.svg',
            'image/svg+xml': './assets/images/ft_ic_vector_image.svg',
            'application/eps': './assets/images/ft_ic_raster_image.svg',
            'application/illustrator': './assets/images/ft_ic_raster_image.svg',
            'application/pdf': './assets/images/ft_ic_pdf.svg',
            'application/vnd.ms-excel': './assets/images/ft_ic_ms_excel.svg',
            'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet': './assets/images/ft_ic_ms_excel.svg',
            'application/vnd.openxmlformats-officedocument.spreadsheetml.template': './assets/images/ft_ic_ms_excel.svg',
            'application/vnd.ms-excel.addin.macroenabled.12': './assets/images/ft_ic_ms_excel.svg',
            'application/vnd.ms-excel.sheet.binary.macroenabled.12': './assets/images/ft_ic_ms_excel.svg',
            'application/vnd.ms-excel.sheet.macroenabled.12': './assets/images/ft_ic_ms_excel.svg',
            'application/vnd.ms-excel.template.macroenabled.12': './assets/images/ft_ic_ms_excel.svg',
            'application/vnd.sun.xml.calc': './assets/images/ft_ic_ms_excel.svg',
            'application/vnd.sun.xml.calc.template': './assets/images/ft_ic_ms_excel.svg',
            'application/vnd.ms-outlook': './assets/images/ft_ic_document.svg',
            'application/msword': './assets/images/ft_ic_ms_word.svg',
            'application/vnd.openxmlformats-officedocument.wordprocessingml.document': './assets/images/ft_ic_ms_word.svg',
            'application/vnd.openxmlformats-officedocument.wordprocessingml.template': './assets/images/ft_ic_ms_word.svg',
            'application/vnd.ms-word.document.macroenabled.12': './assets/images/ft_ic_ms_word.svg',
            'application/vnd.ms-word.template.macroenabled.12': './assets/images/ft_ic_ms_word.svg',
            'application/vnd.sun.xml.writer': './assets/images/ft_ic_ms_word.svg',
            'application/vnd.sun.xml.writer.template': './assets/images/ft_ic_ms_word.svg',
            'application/rtf': './assets/images/ft_ic_ms_word.svg',
            'text/rtf': './assets/images/ft_ic_ms_word.svg',
            'application/vnd.ms-powerpoint': './assets/images/ft_ic_ms_powerpoint.svg',
            'application/vnd.openxmlformats-officedocument.presentationml.presentation': './assets/images/ft_ic_ms_powerpoint.svg',
            'application/vnd.openxmlformats-officedocument.presentationml.template': './assets/images/ft_ic_ms_powerpoint.svg',
            'application/vnd.openxmlformats-officedocument.presentationml.slideshow': './assets/images/ft_ic_ms_powerpoint.svg',
            'application/vnd.oasis.opendocument.presentation': './assets/images/ft_ic_ms_powerpoint.svg',
            'application/vnd.oasis.opendocument.presentation-template': './assets/images/ft_ic_ms_powerpoint.svg',
            'application/vnd.openxmlformats-officedocument.presentationml.slide': './assets/images/ft_ic_ms_powerpoint.svg',
            'application/vnd.sun.xml.impress': './assets/images/ft_ic_ms_powerpoint.svg',
            'application/vnd.sun.xml.impress.template': './assets/images/ft_ic_ms_powerpoint.svg',
            'application/vnd.oasis.opendocument.spreadsheet': './assets/images/ft_ic_ms_excel.svg',
            'application/vnd.oasis.opendocument.spreadsheet-template': './assets/images/ft_ic_ms_excel.svg',
            'application/vnd.ms-powerpoint.addin.macroenabled.12': './assets/images/ft_ic_ms_powerpoint.svg',
            'application/vnd.ms-powerpoint.presentation.macroenabled.12': './assets/images/ft_ic_ms_powerpoint.svg',
            'application/vnd.ms-powerpoint.slide.macroenabled.12': './assets/images/ft_ic_ms_powerpoint.svg',
            'application/vnd.ms-powerpoint.slideshow.macroenabled.12': './assets/images/ft_ic_ms_powerpoint.svg',
            'application/vnd.ms-powerpoint.template.macroenabled.12': './assets/images/ft_ic_ms_powerpoint.svg',
            'video/mp4': './assets/images/ft_ic_video.svg',
            'video/3gpp': './assets/images/ft_ic_video.svg',
            'video/3gpp2': './assets/images/ft_ic_video.svg',
            'video/mp2t': './assets/images/ft_ic_video.svg',
            'video/mpeg': './assets/images/ft_ic_video.svg',
            'video/mpeg2': './assets/images/ft_ic_video.svg',
            'video/ogg': './assets/images/ft_ic_video.svg',
            'video/quicktime': './assets/images/ft_ic_video.svg',
            'video/webm': './assets/images/ft_ic_video.svg',
            'video/x-flv': './assets/images/ft_ic_video.svg',
            'video/x-m4v': './assets/images/ft_ic_video.svg',
            'video/x-ms-asf': './assets/images/ft_ic_video.svg',
            'video/x-ms-wmv': './assets/images/ft_ic_video.svg',
            'video/x-msvideo': './assets/images/ft_ic_video.svg',
            'video/x-rad-screenplay': './assets/images/ft_ic_video.svg',
            'video/x-sgi-movie': './assets/images/ft_ic_video.svg',
            'video/x-matroska': './assets/images/ft_ic_video.svg',
            'audio/mpeg': './assets/images/ft_ic_audio.svg',
            'audio/ogg': './assets/images/ft_ic_audio.svg',
            'audio/wav': './assets/images/ft_ic_audio.svg',
            'audio/basic': './assets/images/ft_ic_audio.svg',
            'audio/mp3': './assets/images/ft_ic_audio.svg',
            'audio/mp4': './assets/images/ft_ic_audio.svg',
            'audio/vnd.adobe.soundbooth': './assets/images/ft_ic_audio.svg',
            'audio/vorbis': './assets/images/ft_ic_audio.svg',
            'audio/x-aiff': './assets/images/ft_ic_audio.svg',
            'audio/x-flac': './assets/images/ft_ic_audio.svg',
            'audio/x-ms-wma': './assets/images/ft_ic_audio.svg',
            'audio/x-wav': './assets/images/ft_ic_audio.svg',
            'x-world/x-vrml': './assets/images/ft_ic_video.svg',
            'text/plain': './assets/images/ft_ic_document.svg',
            'application/vnd.oasis.opendocument.text': './assets/images/ft_ic_document.svg',
            'application/vnd.oasis.opendocument.text-template': './assets/images/ft_ic_document.svg',
            'application/x-javascript': './assets/images/ft_ic_document.svg',
            'application/json': './assets/images/ft_ic_document.svg',
            'text/csv': './assets/images/ft_ic_document.svg',
            'text/xml': './assets/images/ft_ic_document.svg',
            'text/html': './assets/images/ft_ic_website.svg',
            'application/x-compressed': './assets/images/ft_ic_archive.svg',
            'application/x-zip-compressed': './assets/images/ft_ic_archive.svg',
            'application/zip': './assets/images/ft_ic_archive.svg',
            'application/x-tar': './assets/images/ft_ic_archive.svg',
            'application/vnd.apple.keynote': './assets/images/ft_ic_presentation.svg',
            'application/vnd.apple.pages': './assets/images/ft_ic_document.svg',
            'application/vnd.apple.numbers': './assets/images/ft_ic_spreadsheet.svg',
            'application/vnd.visio': './assets/images/ft_ic_document.svg',
            'application/wordperfect': './assets/images/ft_ic_document.svg',
            'application/x-cpio': './assets/images/ft_ic_document.svg',
            'folder': './assets/images/ft_ic_folder.svg',
            'smartFolder': './assets/images/ft_ic_smart_folder.svg',
            'ruleFolder': './assets/images/ft_ic_folder_rule.svg',
            'linkFolder': './assets/images/ft_ic_folder_shortcut_link.svg',
            'disable/folder': './assets/images/ft_ic_folder_disable.svg',
            'selected': './assets/images/ft_ic_selected.svg',
            'dynamic-feed': './assets/images/dynamic_feed-24px.svg',
            'ic-process': './assets/images/ic-process.svg',
            'filter': './assets/images/ft_ic_filter.svg',
            'save-as': './assets/images/save-as.svg',
            'save': './assets/images/save.svg',
            'task': './assets/images/task.svg'
        };
        Object.keys(this.mimeTypeIcons).forEach((key) => {
            const url = sanitizer.bypassSecurityTrustResourceUrl(this.mimeTypeIcons[key]);
            matIconRegistry.addSvgIcon(key, url);
            matIconRegistry.addSvgIconInNamespace('adf', key, url);
        });
    }
    get contentApi() {
        var _a;
        this._contentApi = (_a = this._contentApi) !== null && _a !== void 0 ? _a : new ContentApi(this.apiService.getInstance());
        return this._contentApi;
    }
    getDocumentThumbnailUrl(node, attachment, ticket) {
        let resultUrl;
        if (node) {
            let nodeId;
            if (typeof node === 'string') {
                nodeId = node;
            }
            else if (node.entry) {
                nodeId = node.entry.id;
            }
            resultUrl = this.contentApi.getDocumentThumbnailUrl(nodeId, attachment, ticket);
        }
        return resultUrl || this.DEFAULT_ICON;
    }
    getMimeTypeIcon(mimeType) {
        const icon = this.mimeTypeIcons[mimeType];
        return (icon || this.DEFAULT_ICON);
    }
    getDefaultMimeTypeIcon() {
        return this.DEFAULT_ICON;
    }
}
ThumbnailService.ɵprov = ɵɵdefineInjectable({ factory: function ThumbnailService_Factory() { return new ThumbnailService(ɵɵinject(AlfrescoApiService), ɵɵinject(MatIconRegistry), ɵɵinject(DomSanitizer)); }, token: ThumbnailService, providedIn: "root" });
ThumbnailService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
ThumbnailService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: MatIconRegistry },
    { type: DomSanitizer }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class MimeTypeIconPipe {
    constructor(thumbnailService) {
        this.thumbnailService = thumbnailService;
    }
    transform(text) {
        return this.thumbnailService.getMimeTypeIcon(text);
    }
}
MimeTypeIconPipe.decorators = [
    { type: Pipe, args: [{
                name: 'adfMimeTypeIcon'
            },] }
];
MimeTypeIconPipe.ctorParameters = () => [
    { type: ThumbnailService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class NodeNameTooltipPipe {
    transform(node) {
        if (node) {
            return this.getNodeTooltip(node);
        }
        return null;
    }
    containsLine(lines, line) {
        return lines.some((item) => {
            return item.toLowerCase() === line.toLowerCase();
        });
    }
    removeDuplicateLines(lines) {
        const reducer = (acc, line) => {
            if (!this.containsLine(acc, line)) {
                acc.push(line);
            }
            return acc;
        };
        return lines.reduce(reducer, []);
    }
    getNodeTooltip(node) {
        if (!node || !node.entry) {
            return null;
        }
        const { entry: { properties, name } } = node;
        const lines = [name];
        if (properties) {
            const { 'cm:title': title, 'cm:description': description } = properties;
            if (title && description) {
                lines[0] = title;
                lines[1] = description;
            }
            if (title) {
                lines[1] = title;
            }
            if (description) {
                lines[1] = description;
            }
        }
        return this.removeDuplicateLines(lines).join(`\n`);
    }
}
NodeNameTooltipPipe.decorators = [
    { type: Pipe, args: [{
                name: 'adfNodeNameTooltip'
            },] }
];

class HighlightTransformService {
    highlight(text, search, wrapperClass = 'adf-highlight') {
        let isMatching = false, result = text;
        if (search && text) {
            let pattern = search.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
            pattern = pattern.split(' ').filter((t) => {
                return t.length > 0;
            }).join('|');
            const regex = new RegExp(pattern, 'gi');
            result = text.replace(/<[^>]+>/g, '').replace(regex, (match) => {
                isMatching = true;
                return `<span class="${wrapperClass}">${match}</span>`;
            });
            return { text: result, changed: isMatching };
        }
        else {
            return { text: result, changed: isMatching };
        }
    }
}
HighlightTransformService.ɵprov = ɵɵdefineInjectable({ factory: function HighlightTransformService_Factory() { return new HighlightTransformService(); }, token: HighlightTransformService, providedIn: "root" });
HighlightTransformService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class HighlightPipe {
    constructor(highlightTransformService) {
        this.highlightTransformService = highlightTransformService;
    }
    transform(text, search) {
        const highlightTransformResult = this.highlightTransformService.highlight(text, search);
        return highlightTransformResult.text;
    }
}
HighlightPipe.decorators = [
    { type: Pipe, args: [{
                name: 'highlight'
            },] }
];
HighlightPipe.ctorParameters = () => [
    { type: HighlightTransformService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TimeAgoPipe {
    constructor(userPreferenceService, appConfig) {
        this.userPreferenceService = userPreferenceService;
        this.appConfig = appConfig;
        this.onDestroy$ = new Subject();
        this.userPreferenceService
            .select(UserPreferenceValues.Locale)
            .pipe(takeUntil(this.onDestroy$))
            .subscribe(locale => {
            this.defaultLocale = locale || TimeAgoPipe.DEFAULT_LOCALE;
        });
        this.defaultDateTimeFormat = this.appConfig.get('dateValues.defaultDateTimeFormat', TimeAgoPipe.DEFAULT_DATE_TIME_FORMAT);
    }
    transform(value, locale) {
        if (value !== null && value !== undefined) {
            const actualLocale = locale || this.defaultLocale;
            const then = moment(value);
            const diff = moment().locale(actualLocale).diff(then, 'days');
            if (diff > 7) {
                const datePipe = new DatePipe(actualLocale);
                return datePipe.transform(value, this.defaultDateTimeFormat);
            }
            else {
                return then.locale(actualLocale).fromNow();
            }
        }
        return '';
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
}
TimeAgoPipe.DEFAULT_LOCALE = 'en-US';
TimeAgoPipe.DEFAULT_DATE_TIME_FORMAT = 'dd/MM/yyyy HH:mm';
TimeAgoPipe.decorators = [
    { type: Pipe, args: [{
                name: 'adfTimeAgo'
            },] }
];
TimeAgoPipe.ctorParameters = () => [
    { type: UserPreferencesService },
    { type: AppConfigService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class InitialUsernamePipe {
    constructor(sanitized) {
        this.sanitized = sanitized;
    }
    transform(user, className = '', delimiter = '') {
        let safeHtml = '';
        if (user) {
            const initialResult = this.getInitialUserName(user.firstName || user.displayName, user.lastName, delimiter);
            safeHtml = this.sanitized.bypassSecurityTrustHtml(`<div id="user-initials-image" class="${className}">${initialResult}</div>`);
        }
        return safeHtml;
    }
    getInitialUserName(firstName, lastName, delimiter) {
        firstName = (firstName ? firstName[0] : '');
        lastName = (lastName ? lastName[0] : '');
        return firstName + delimiter + lastName;
    }
}
InitialUsernamePipe.decorators = [
    { type: Pipe, args: [{
                name: 'usernameInitials'
            },] }
];
InitialUsernamePipe.ctorParameters = () => [
    { type: DomSanitizer }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FullNamePipe {
    transform(user) {
        let fullName = '';
        if (user) {
            if (user.firstName && user.firstName !== 'null') {
                fullName += user.firstName;
            }
            if (user.lastName && user.lastName !== 'null') {
                fullName += fullName.length > 0 ? ' ' : '';
                fullName += user.lastName;
            }
            if (!fullName) {
                fullName += user.username ? user.username : user.email ? user.email : '';
            }
        }
        return fullName;
    }
}
FullNamePipe.decorators = [
    { type: Pipe, args: [{ name: 'fullName' },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FormatSpacePipe {
    transform(inputValue, replaceChar = '_', lowerCase = true) {
        let transformedString = '';
        if (inputValue) {
            transformedString = lowerCase ? inputValue.trim().split(' ').join(replaceChar).toLocaleLowerCase() :
                inputValue.trim().split(' ').join(replaceChar);
        }
        return transformedString;
    }
}
FormatSpacePipe.decorators = [
    { type: Pipe, args: [{
                name: 'formatSpace'
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FileTypePipe {
    transform(value) {
        if (value == null) {
            return '';
        }
        else {
            const fileInfo = value.substring(value.lastIndexOf('/') + 1).replace(/\.[a-z]+/, '');
            return fileInfo.split('_').pop();
        }
    }
}
FileTypePipe.decorators = [
    { type: Pipe, args: [{
                name: 'fileType',
                pure: true
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class MultiValuePipe {
    transform(values, valueSeparator = MultiValuePipe.DEFAULT_SEPARATOR) {
        if (values && values instanceof Array) {
            return values.join(valueSeparator);
        }
        return values;
    }
}
MultiValuePipe.DEFAULT_SEPARATOR = ', ';
MultiValuePipe.decorators = [
    { type: Pipe, args: [{ name: 'multiValue' },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class LocalizedDatePipe {
    constructor(userPreferenceService, appConfig) {
        this.userPreferenceService = userPreferenceService;
        this.appConfig = appConfig;
        this.defaultLocale = LocalizedDatePipe.DEFAULT_LOCALE;
        this.defaultFormat = LocalizedDatePipe.DEFAULT_DATE_FORMAT;
        this.onDestroy$ = new Subject();
        if (this.userPreferenceService) {
            this.userPreferenceService
                .select(UserPreferenceValues.Locale)
                .pipe(takeUntil(this.onDestroy$))
                .subscribe(locale => {
                if (locale) {
                    this.defaultLocale = locale;
                }
            });
        }
        if (this.appConfig) {
            this.defaultFormat = this.appConfig.get('dateValues.defaultDateFormat', LocalizedDatePipe.DEFAULT_DATE_FORMAT);
        }
    }
    transform(value, format, locale) {
        const actualFormat = format || this.defaultFormat;
        const actualLocale = locale || this.defaultLocale;
        const datePipe = new DatePipe(actualLocale);
        return datePipe.transform(value, actualFormat);
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
}
LocalizedDatePipe.DEFAULT_LOCALE = 'en-US';
LocalizedDatePipe.DEFAULT_DATE_FORMAT = 'mediumDate';
LocalizedDatePipe.decorators = [
    { type: Pipe, args: [{
                name: 'adfLocalizedDate',
                pure: false
            },] }
];
LocalizedDatePipe.ctorParameters = () => [
    { type: UserPreferencesService },
    { type: AppConfigService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DecimalNumberPipe {
    constructor(userPreferenceService, appConfig) {
        this.userPreferenceService = userPreferenceService;
        this.appConfig = appConfig;
        this.defaultLocale = DecimalNumberPipe.DEFAULT_LOCALE;
        this.defaultMinIntegerDigits = DecimalNumberPipe.DEFAULT_MIN_INTEGER_DIGITS;
        this.defaultMinFractionDigits = DecimalNumberPipe.DEFAULT_MIN_FRACTION_DIGITS;
        this.defaultMaxFractionDigits = DecimalNumberPipe.DEFAULT_MAX_FRACTION_DIGITS;
        this.onDestroy$ = new Subject();
        if (this.userPreferenceService) {
            this.userPreferenceService.select(UserPreferenceValues.Locale)
                .pipe(takeUntil(this.onDestroy$))
                .subscribe((locale) => {
                if (locale) {
                    this.defaultLocale = locale;
                }
            });
        }
        if (this.appConfig) {
            this.defaultMinIntegerDigits = this.appConfig.get('decimalValues.minIntegerDigits', DecimalNumberPipe.DEFAULT_MIN_INTEGER_DIGITS);
            this.defaultMinFractionDigits = this.appConfig.get('decimalValues.minFractionDigits', DecimalNumberPipe.DEFAULT_MIN_FRACTION_DIGITS);
            this.defaultMaxFractionDigits = this.appConfig.get('decimalValues.maxFractionDigits', DecimalNumberPipe.DEFAULT_MAX_FRACTION_DIGITS);
        }
    }
    transform(value, digitsInfo, locale) {
        const actualMinIntegerDigits = digitsInfo && digitsInfo.minIntegerDigits ? digitsInfo.minIntegerDigits : this.defaultMinIntegerDigits;
        const actualMinFractionDigits = digitsInfo && digitsInfo.minFractionDigits ? digitsInfo.minFractionDigits : this.defaultMinFractionDigits;
        const actualMaxFractionDigits = digitsInfo && digitsInfo.maxFractionDigits ? digitsInfo.maxFractionDigits : this.defaultMaxFractionDigits;
        const actualDigitsInfo = `${actualMinIntegerDigits}.${actualMinFractionDigits}-${actualMaxFractionDigits}`;
        const actualLocale = locale || this.defaultLocale;
        const decimalPipe = new DecimalPipe(actualLocale);
        return decimalPipe.transform(value, actualDigitsInfo);
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
}
DecimalNumberPipe.DEFAULT_LOCALE = 'en-US';
DecimalNumberPipe.DEFAULT_MIN_INTEGER_DIGITS = 1;
DecimalNumberPipe.DEFAULT_MIN_FRACTION_DIGITS = 0;
DecimalNumberPipe.DEFAULT_MAX_FRACTION_DIGITS = 2;
DecimalNumberPipe.decorators = [
    { type: Pipe, args: [{
                name: 'adfDecimalNumber',
                pure: false
            },] }
];
DecimalNumberPipe.ctorParameters = () => [
    { type: UserPreferencesService },
    { type: AppConfigService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class LocalizedRolePipe {
    constructor(translationService) {
        this.translationService = translationService;
    }
    transform(value) {
        if (value) {
            const key = `ADF.ROLES.${value.toUpperCase()}`;
            const translation = this.translationService.instant(key);
            if (translation) {
                return translation;
            }
        }
        return value;
    }
}
LocalizedRolePipe.decorators = [
    { type: Pipe, args: [{
                name: 'adfLocalizedRole'
            },] }
];
LocalizedRolePipe.ctorParameters = () => [
    { type: TranslationService }
];

class MomentDatePipe {
    transform(value, dateFormat) {
        return moment(value, dateFormat);
    }
}
MomentDatePipe.decorators = [
    { type: Pipe, args: [{ name: 'adfMomentDate' },] }
];

class MomentDateTimePipe {
    transform(value, dateFormat) {
        return moment(value, dateFormat)
            .add(moment(value, dateFormat).utcOffset(), 'minutes');
    }
}
MomentDateTimePipe.decorators = [
    { type: Pipe, args: [{ name: 'adfMomentDateTime' },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PipeModule {
}
PipeModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    TranslateModule
                ],
                declarations: [
                    FileSizePipe,
                    HighlightPipe,
                    TimeAgoPipe,
                    MimeTypeIconPipe,
                    InitialUsernamePipe,
                    FullNamePipe,
                    NodeNameTooltipPipe,
                    FormatSpacePipe,
                    FileTypePipe,
                    MultiValuePipe,
                    LocalizedDatePipe,
                    DecimalNumberPipe,
                    LocalizedRolePipe,
                    MomentDatePipe,
                    MomentDateTimePipe
                ],
                providers: [
                    FileSizePipe,
                    HighlightPipe,
                    TimeAgoPipe,
                    MimeTypeIconPipe,
                    InitialUsernamePipe,
                    NodeNameTooltipPipe,
                    FormatSpacePipe,
                    FileTypePipe,
                    MultiValuePipe,
                    LocalizedDatePipe,
                    DecimalNumberPipe,
                    LocalizedRolePipe,
                    MomentDatePipe,
                    MomentDateTimePipe
                ],
                exports: [
                    FileSizePipe,
                    HighlightPipe,
                    TimeAgoPipe,
                    MimeTypeIconPipe,
                    InitialUsernamePipe,
                    FullNamePipe,
                    NodeNameTooltipPipe,
                    FormatSpacePipe,
                    FileTypePipe,
                    MultiValuePipe,
                    LocalizedDatePipe,
                    DecimalNumberPipe,
                    LocalizedRolePipe,
                    MomentDatePipe,
                    MomentDateTimePipe
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class HighlightDirective {
    constructor(el, renderer, highlightTransformService) {
        this.el = el;
        this.renderer = renderer;
        this.highlightTransformService = highlightTransformService;
        this.selector = '';
        this.search = '';
        this.classToApply = 'adf-highlight';
    }
    ngAfterViewChecked() {
        this.highlight();
    }
    highlight(search = this.search, selector = this.selector, classToApply = this.classToApply) {
        if (search && selector) {
            const elements = this.el.nativeElement.querySelectorAll(selector);
            elements.forEach((element) => {
                const highlightTransformResult = this.highlightTransformService.highlight(element.innerHTML, search, classToApply);
                if (highlightTransformResult.changed) {
                    this.renderer.setProperty(element, 'innerHTML', highlightTransformResult.text);
                }
            });
        }
    }
}
HighlightDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-highlight]'
            },] }
];
HighlightDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: HighlightTransformService }
];
HighlightDirective.propDecorators = {
    selector: [{ type: Input, args: ['adf-highlight-selector',] }],
    search: [{ type: Input, args: ['adf-highlight',] }],
    classToApply: [{ type: Input, args: ['adf-highlight-class',] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class LogoutDirective {
    constructor(elementRef, renderer, router, appConfig, auth) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.router = router;
        this.appConfig = appConfig;
        this.auth = auth;
        this.enableRedirect = true;
    }
    ngOnInit() {
        if (this.elementRef.nativeElement) {
            this.renderer.listen(this.elementRef.nativeElement, 'click', (evt) => {
                evt.preventDefault();
                this.logout();
            });
        }
    }
    getRedirectUri() {
        if (this.redirectUri === undefined) {
            return this.appConfig.get('loginRoute', '/login');
        }
        return this.redirectUri;
    }
    logout() {
        this.auth.logout().subscribe(() => this.redirectToUri(), () => this.redirectToUri());
    }
    redirectToUri() {
        if (this.enableRedirect && !this.auth.isOauth()) {
            const redirectRoute = this.getRedirectUri();
            this.router.navigate([redirectRoute]);
        }
    }
}
LogoutDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-logout]'
            },] }
];
LogoutDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: Router },
    { type: AppConfigService },
    { type: AuthenticationService }
];
LogoutDirective.propDecorators = {
    redirectUri: [{ type: Input }],
    enableRedirect: [{ type: Input }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class NodeDeleteDirective {
    constructor(alfrescoApiService, translation, elementRef) {
        this.alfrescoApiService = alfrescoApiService;
        this.translation = translation;
        this.elementRef = elementRef;
        this.permanent = false;
        this.delete = new EventEmitter();
    }
    get trashcanApi() {
        var _a;
        this._trashcanApi = (_a = this._trashcanApi) !== null && _a !== void 0 ? _a : new TrashcanApi(this.alfrescoApiService.getInstance());
        return this._trashcanApi;
    }
    get nodesApi() {
        var _a;
        this._nodesApi = (_a = this._nodesApi) !== null && _a !== void 0 ? _a : new NodesApi(this.alfrescoApiService.getInstance());
        return this._nodesApi;
    }
    onClick() {
        this.process(this.selection);
    }
    ngOnChanges() {
        if (!this.selection || (this.selection && this.selection.length === 0)) {
            this.setDisableAttribute(true);
        }
        else {
            if (!this.elementRef.nativeElement.hasAttribute('adf-check-allowable-operation')) {
                this.setDisableAttribute(false);
            }
        }
    }
    setDisableAttribute(disable) {
        this.elementRef.nativeElement.disabled = disable;
    }
    process(selection) {
        if (selection && selection.length) {
            const batch = this.getDeleteNodesBatch(selection);
            forkJoin(...batch)
                .subscribe((data) => {
                const processedItems = this.processStatus(data);
                const message = this.getMessage(processedItems);
                if (message) {
                    this.delete.emit(message);
                }
            });
        }
    }
    getDeleteNodesBatch(selection) {
        return selection.map((node) => this.deleteNode(node));
    }
    deleteNode(node) {
        const id = node.entry.nodeId || node.entry.id;
        let promise;
        if (node.entry.hasOwnProperty('archivedAt') && node.entry['archivedAt']) {
            promise = this.trashcanApi.deleteDeletedNode(id);
        }
        else {
            promise = this.nodesApi.deleteNode(id, { permanent: this.permanent });
        }
        return from(promise).pipe(retry(3), map(() => ({
            entry: node.entry,
            status: 1
        })), catchError(() => of({
            entry: node.entry,
            status: 0
        })));
    }
    processStatus(data) {
        const deleteStatus = {
            success: [],
            failed: [],
            get someFailed() {
                return !!(this.failed.length);
            },
            get someSucceeded() {
                return !!(this.success.length);
            },
            get oneFailed() {
                return this.failed.length === 1;
            },
            get oneSucceeded() {
                return this.success.length === 1;
            },
            get allSucceeded() {
                return this.someSucceeded && !this.someFailed;
            },
            get allFailed() {
                return this.someFailed && !this.someSucceeded;
            }
        };
        return data.reduce((acc, next) => {
            if (next.status === 1) {
                acc.success.push(next);
            }
            else {
                acc.failed.push(next);
            }
            return acc;
        }, deleteStatus);
    }
    getMessage(status) {
        if (status.allFailed && !status.oneFailed) {
            return this.translation.instant('CORE.DELETE_NODE.ERROR_PLURAL', { number: status.failed.length });
        }
        if (status.allSucceeded && !status.oneSucceeded) {
            return this.translation.instant('CORE.DELETE_NODE.PLURAL', { number: status.success.length });
        }
        if (status.someFailed && status.someSucceeded && !status.oneSucceeded) {
            return this.translation.instant('CORE.DELETE_NODE.PARTIAL_PLURAL', {
                success: status.success.length,
                failed: status.failed.length
            });
        }
        if (status.someFailed && status.oneSucceeded) {
            return this.translation.instant('CORE.DELETE_NODE.PARTIAL_SINGULAR', {
                success: status.success.length,
                failed: status.failed.length
            });
        }
        if (status.oneFailed && !status.someSucceeded) {
            return this.translation.instant('CORE.DELETE_NODE.ERROR_SINGULAR', { name: status.failed[0].entry.name });
        }
        if (status.oneSucceeded && !status.someFailed) {
            return this.translation.instant('CORE.DELETE_NODE.SINGULAR', { name: status.success[0].entry.name });
        }
        return null;
    }
}
NodeDeleteDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-delete]'
            },] }
];
NodeDeleteDirective.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: TranslationService },
    { type: ElementRef }
];
NodeDeleteDirective.propDecorators = {
    selection: [{ type: Input, args: ['adf-delete',] }],
    permanent: [{ type: Input }],
    delete: [{ type: Output }],
    onClick: [{ type: HostListener, args: ['click',] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class NodeFavoriteDirective {
    constructor(alfrescoApiService) {
        this.alfrescoApiService = alfrescoApiService;
        this.favorites = [];
        this.selection = [];
        this.toggle = new EventEmitter();
        this.error = new EventEmitter();
    }
    get favoritesApi() {
        var _a;
        this._favoritesApi = (_a = this._favoritesApi) !== null && _a !== void 0 ? _a : new FavoritesApi(this.alfrescoApiService.getInstance());
        return this._favoritesApi;
    }
    onClick() {
        this.toggleFavorite();
    }
    ngOnChanges(changes) {
        if (!changes.selection.currentValue.length) {
            this.favorites = [];
            return;
        }
        this.markFavoritesNodes(changes.selection.currentValue);
    }
    toggleFavorite() {
        if (!this.favorites.length) {
            return;
        }
        const every = this.favorites.every((selected) => selected.entry.isFavorite);
        if (every) {
            const batch = this.favorites.map((selected) => {
                const id = selected.entry.nodeId || selected.entry.id;
                return from(this.favoritesApi.deleteFavorite('-me-', id));
            });
            forkJoin(batch).subscribe(() => {
                this.favorites.map((selected) => selected.entry.isFavorite = false);
                this.toggle.emit();
            }, (error) => this.error.emit(error));
        }
        if (!every) {
            const notFavorite = this.favorites.filter((node) => !node.entry.isFavorite);
            const body = notFavorite.map((node) => this.createFavoriteBody(node));
            from(this.favoritesApi.createFavorite('-me-', body))
                .subscribe(() => {
                notFavorite.map((selected) => selected.entry.isFavorite = true);
                this.toggle.emit();
            }, (error) => this.error.emit(error));
        }
    }
    markFavoritesNodes(selection) {
        if (selection.length <= this.favorites.length) {
            const newFavorites = this.reduce(this.favorites, selection);
            this.favorites = newFavorites;
        }
        const result = this.diff(selection, this.favorites);
        const batch = this.getProcessBatch(result);
        forkJoin(batch).subscribe((data) => {
            this.favorites.push(...data);
        });
    }
    hasFavorites() {
        if (this.favorites && !this.favorites.length) {
            return false;
        }
        return this.favorites.every((selected) => selected.entry.isFavorite);
    }
    getProcessBatch(selection) {
        return selection.map((selected) => this.getFavorite(selected));
    }
    getFavorite(selected) {
        const node = selected.entry;
        if (node && node.hasOwnProperty('isFavorite')) {
            return of(selected);
        }
        const { name, isFile, isFolder } = node;
        const id = node.nodeId || node.id;
        const promise = this.favoritesApi.getFavorite('-me-', id);
        return from(promise).pipe(map(() => ({
            entry: {
                id,
                isFolder,
                isFile,
                name,
                isFavorite: true
            }
        })), catchError(() => {
            return of({
                entry: {
                    id,
                    isFolder,
                    isFile,
                    name,
                    isFavorite: false
                }
            });
        }));
    }
    createFavoriteBody(node) {
        const type = this.getNodeType(node);
        const id = node.entry.nodeId || node.entry.id;
        return {
            target: {
                [type]: {
                    guid: id
                }
            }
        };
    }
    getNodeType(node) {
        if (!node.entry.isFile && !node.entry.isFolder) {
            return 'file';
        }
        return node.entry.isFile ? 'file' : 'folder';
    }
    diff(list, patch) {
        const ids = patch.map((item) => item.entry.id);
        return list.filter((item) => ids.includes(item.entry.id) ? null : item);
    }
    reduce(patch, comparator) {
        const ids = comparator.map((item) => item.entry.id);
        return patch.filter((item) => ids.includes(item.entry.id) ? item : null);
    }
}
NodeFavoriteDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-node-favorite]',
                exportAs: 'adfFavorite'
            },] }
];
NodeFavoriteDirective.ctorParameters = () => [
    { type: AlfrescoApiService }
];
NodeFavoriteDirective.propDecorators = {
    selection: [{ type: Input, args: ['adf-node-favorite',] }],
    toggle: [{ type: Output }],
    error: [{ type: Output }],
    onClick: [{ type: HostListener, args: ['click',] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PermissionsEnum extends String {
}
PermissionsEnum.CONTRIBUTOR = 'Contributor';
PermissionsEnum.CONSUMER = 'Consumer';
PermissionsEnum.COLLABORATOR = 'Collaborator';
PermissionsEnum.MANAGER = 'Manager';
PermissionsEnum.EDITOR = 'Editor';
PermissionsEnum.COORDINATOR = 'Coordinator';
PermissionsEnum.NOT_CONTRIBUTOR = '!Contributor';
PermissionsEnum.NOT_CONSUMER = '!Consumer';
PermissionsEnum.NOT_COLLABORATOR = '!Collaborator';
PermissionsEnum.NOT_MANAGER = '!Manager';
PermissionsEnum.NOT_EDITOR = '!Editor';
PermissionsEnum.NOT_COORDINATOR = '!Coordinator';

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AllowableOperationsEnum extends String {
}
AllowableOperationsEnum.DELETE = 'delete';
AllowableOperationsEnum.UPDATE = 'update';
AllowableOperationsEnum.CREATE = 'create';
AllowableOperationsEnum.COPY = 'copy';
AllowableOperationsEnum.LOCK = 'lock';
AllowableOperationsEnum.UPDATEPERMISSIONS = 'updatePermissions';
AllowableOperationsEnum.NOT_DELETE = '!delete';
AllowableOperationsEnum.NOT_UPDATE = '!update';
AllowableOperationsEnum.NOT_CREATE = '!create';
AllowableOperationsEnum.NOT_UPDATEPERMISSIONS = '!updatePermissions';

class DownloadService {
    constructor() {
        this.saveData = (function () {
            const a = document.createElement('a');
            document.body.appendChild(a);
            a.style.display = 'none';
            return function (fileData, format, fileName) {
                let blob = null;
                if (format === 'blob' || format === 'data') {
                    blob = new Blob([fileData], { type: 'octet/stream' });
                }
                if (format === 'object' || format === 'json') {
                    const json = JSON.stringify(fileData);
                    blob = new Blob([json], { type: 'octet/stream' });
                }
                if (blob) {
                    if (typeof window.navigator !== 'undefined' &&
                        window.navigator.msSaveOrOpenBlob) {
                        navigator.msSaveOrOpenBlob(blob, fileName);
                    }
                    else {
                        const url = window.URL.createObjectURL(blob);
                        a.href = url;
                        a.download = fileName;
                        a.click();
                        window.URL.revokeObjectURL(url);
                    }
                }
            };
        })();
    }
    downloadBlob(blob, fileName) {
        this.saveData(blob, 'blob', fileName);
    }
    downloadData(data, fileName) {
        this.saveData(data, 'data', fileName);
    }
    downloadJSON(json, fileName) {
        this.saveData(json, 'json', fileName);
    }
    downloadUrl(url, fileName) {
        if (url && fileName) {
            const link = document.createElement('a');
            link.style.display = 'none';
            link.download = fileName;
            link.href = url;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
    }
}
DownloadService.ɵprov = ɵɵdefineInjectable({ factory: function DownloadService_Factory() { return new DownloadService(); }, token: DownloadService, providedIn: "root" });
DownloadService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
DownloadService.ctorParameters = () => [];

class ContentService {
    constructor(authService, apiService, logService, sanitizer, downloadService, thumbnailService) {
        this.authService = authService;
        this.apiService = apiService;
        this.logService = logService;
        this.sanitizer = sanitizer;
        this.downloadService = downloadService;
        this.thumbnailService = thumbnailService;
        this.folderCreated = new Subject();
        this.folderCreate = new Subject();
        this.folderEdit = new Subject();
    }
    get contentApi() {
        var _a;
        this._contentApi = (_a = this._contentApi) !== null && _a !== void 0 ? _a : new ContentApi(this.apiService.getInstance());
        return this._contentApi;
    }
    get nodesApi() {
        var _a;
        this._nodesApi = (_a = this._nodesApi) !== null && _a !== void 0 ? _a : new NodesApi(this.apiService.getInstance());
        return this._nodesApi;
    }
    downloadBlob(blob, fileName) {
        this.downloadService.downloadBlob(blob, fileName);
    }
    createTrustedUrl(blob) {
        const url = window.URL.createObjectURL(blob);
        return this.sanitizer.bypassSecurityTrustUrl(url);
    }
    getDocumentThumbnailUrl(node, attachment, ticket) {
        return this.thumbnailService.getDocumentThumbnailUrl(node, attachment, ticket);
    }
    getContentUrl(node, attachment, ticket) {
        if (node) {
            let nodeId;
            if (typeof node === 'string') {
                nodeId = node;
            }
            else if (node.entry) {
                nodeId = node.entry.id;
            }
            return this.contentApi.getContentUrl(nodeId, attachment, ticket);
        }
        return null;
    }
    getNodeContent(nodeId) {
        return from(this.nodesApi.getNodeContent(nodeId))
            .pipe(catchError((err) => this.handleError(err)));
    }
    getNode(nodeId, opts) {
        return from(this.nodesApi.getNode(nodeId, opts));
    }
    hasPermissions(node, permission, userId) {
        var _a, _b;
        let hasPermissions = false;
        userId = userId !== null && userId !== void 0 ? userId : this.authService.getEcmUsername();
        const permissions = [...(((_a = node.permissions) === null || _a === void 0 ? void 0 : _a.locallySet) || []), ...(((_b = node.permissions) === null || _b === void 0 ? void 0 : _b.inherited) || [])]
            .filter((currentPermission) => currentPermission.authorityId === userId);
        if (permissions.length) {
            if (permission && permission.startsWith('!')) {
                hasPermissions = !permissions.find((currentPermission) => currentPermission.name === permission.replace('!', ''));
            }
            else {
                hasPermissions = !!permissions.find((currentPermission) => currentPermission.name === permission);
            }
        }
        else {
            if (permission === PermissionsEnum.CONSUMER) {
                hasPermissions = true;
            }
            else if (permission === PermissionsEnum.NOT_CONSUMER) {
                hasPermissions = false;
            }
            else if (permission && permission.startsWith('!')) {
                hasPermissions = true;
            }
        }
        return hasPermissions;
    }
    hasAllowableOperations(node, allowableOperation) {
        let hasAllowableOperations = false;
        if (node && node.allowableOperations) {
            if (allowableOperation && allowableOperation.startsWith('!')) {
                hasAllowableOperations = !node.allowableOperations.find((currentOperation) => currentOperation === allowableOperation.replace('!', ''));
            }
            else {
                hasAllowableOperations = !!node.allowableOperations.find((currentOperation) => currentOperation === allowableOperation);
            }
        }
        else {
            if (allowableOperation && allowableOperation.startsWith('!')) {
                hasAllowableOperations = true;
            }
        }
        if (allowableOperation === AllowableOperationsEnum.COPY) {
            hasAllowableOperations = true;
        }
        if (allowableOperation === AllowableOperationsEnum.LOCK) {
            hasAllowableOperations = node.isFile;
            if (node.isLocked && node.allowableOperations) {
                hasAllowableOperations = !!~node.allowableOperations.indexOf('updatePermissions');
            }
        }
        return hasAllowableOperations;
    }
    handleError(error) {
        this.logService.error(error);
        return throwError(error || 'Server error');
    }
}
ContentService.ɵprov = ɵɵdefineInjectable({ factory: function ContentService_Factory() { return new ContentService(ɵɵinject(AuthenticationService), ɵɵinject(AlfrescoApiService), ɵɵinject(LogService), ɵɵinject(DomSanitizer), ɵɵinject(DownloadService), ɵɵinject(ThumbnailService)); }, token: ContentService, providedIn: "root" });
ContentService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
ContentService.ctorParameters = () => [
    { type: AuthenticationService },
    { type: AlfrescoApiService },
    { type: LogService },
    { type: DomSanitizer },
    { type: DownloadService },
    { type: ThumbnailService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const EXTENDIBLE_COMPONENT = new InjectionToken('extendible.component');

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CheckAllowableOperationDirective {
    constructor(elementRef, renderer, contentService, changeDetector, parentComponent) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.contentService = contentService;
        this.changeDetector = changeDetector;
        this.parentComponent = parentComponent;
        this.permission = null;
        this.nodes = [];
    }
    ngOnChanges(changes) {
        if (changes.nodes && !changes.nodes.firstChange) {
            this.updateElement();
        }
    }
    updateElement() {
        const enable = this.hasAllowableOperations(this.nodes, this.permission);
        if (enable) {
            this.enable();
        }
        else {
            this.disable();
        }
        return enable;
    }
    enable() {
        if (this.parentComponent) {
            this.parentComponent.disabled = false;
            this.changeDetector.detectChanges();
        }
        else {
            this.enableElement();
        }
    }
    disable() {
        if (this.parentComponent) {
            this.parentComponent.disabled = true;
            this.changeDetector.detectChanges();
        }
        else {
            this.disableElement();
        }
    }
    enableElement() {
        this.renderer.removeAttribute(this.elementRef.nativeElement, 'disabled');
    }
    disableElement() {
        this.renderer.setAttribute(this.elementRef.nativeElement, 'disabled', 'true');
    }
    hasAllowableOperations(nodes, permission) {
        if (nodes && nodes.length > 0) {
            return nodes.every((node) => this.contentService.hasAllowableOperations(node.entry, permission));
        }
        return false;
    }
}
CheckAllowableOperationDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-check-allowable-operation]'
            },] }
];
CheckAllowableOperationDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: ContentService },
    { type: ChangeDetectorRef },
    { type: undefined, decorators: [{ type: Host }, { type: Optional }, { type: Inject, args: [EXTENDIBLE_COMPONENT,] }] }
];
CheckAllowableOperationDirective.propDecorators = {
    permission: [{ type: Input, args: ['adf-check-allowable-operation',] }],
    nodes: [{ type: Input, args: ['adf-nodes',] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RestoreMessageModel {
}
class NodeRestoreDirective {
    constructor(alfrescoApiService, translation) {
        this.alfrescoApiService = alfrescoApiService;
        this.translation = translation;
        this.restore = new EventEmitter();
        this.restoreProcessStatus = this.processStatus();
    }
    get trashcanApi() {
        var _a;
        this._trashcanApi = (_a = this._trashcanApi) !== null && _a !== void 0 ? _a : new TrashcanApi(this.alfrescoApiService.getInstance());
        return this._trashcanApi;
    }
    onClick() {
        this.recover(this.selection);
    }
    recover(selection) {
        if (!selection.length) {
            return;
        }
        const nodesWithPath = this.getNodesWithPath(selection);
        if (selection.length && nodesWithPath.length) {
            this.restoreNodesBatch(nodesWithPath).pipe(tap((restoredNodes) => {
                const status = this.processStatus(restoredNodes);
                this.restoreProcessStatus.fail.push(...status.fail);
                this.restoreProcessStatus.success.push(...status.success);
            }), mergeMap(() => this.getDeletedNodes()))
                .subscribe((deletedNodesList) => {
                const { entries: nodeList } = deletedNodesList.list;
                const { fail: restoreErrorNodes } = this.restoreProcessStatus;
                const selectedNodes = this.diff(restoreErrorNodes, selection, false);
                const remainingNodes = this.diff(selectedNodes, nodeList);
                if (!remainingNodes.length) {
                    this.notification();
                }
                else {
                    this.recover(remainingNodes);
                }
            });
        }
        else {
            this.restoreProcessStatus.fail.push(...selection);
            this.notification();
            return;
        }
    }
    restoreNodesBatch(batch) {
        return forkJoin(batch.map((node) => this.restoreNode(node)));
    }
    getNodesWithPath(selection) {
        return selection.filter((node) => node.entry.path);
    }
    getDeletedNodes() {
        const promise = this.trashcanApi.listDeletedNodes({ include: ['path'] });
        return from(promise);
    }
    restoreNode(node) {
        const { entry } = node;
        const promise = this.trashcanApi.restoreDeletedNode(entry.id);
        return from(promise).pipe(map(() => ({
            status: 1,
            entry
        })), catchError((error) => {
            const { statusCode } = (JSON.parse(error.message)).error;
            return of({
                status: 0,
                statusCode,
                entry
            });
        }));
    }
    diff(selection, list, fromList = true) {
        const ids = selection.map((item) => item.entry.id);
        return list.filter((item) => {
            if (fromList) {
                return ids.includes(item.entry.id) ? item : null;
            }
            else {
                return !ids.includes(item.entry.id) ? item : null;
            }
        });
    }
    processStatus(data = []) {
        const status = {
            fail: [],
            success: [],
            get someFailed() {
                return !!(this.fail.length);
            },
            get someSucceeded() {
                return !!(this.success.length);
            },
            get oneFailed() {
                return this.fail.length === 1;
            },
            get oneSucceeded() {
                return this.success.length === 1;
            },
            get allSucceeded() {
                return this.someSucceeded && !this.someFailed;
            },
            get allFailed() {
                return this.someFailed && !this.someSucceeded;
            },
            reset() {
                this.fail = [];
                this.success = [];
            }
        };
        return data.reduce((acc, node) => {
            if (node.status) {
                acc.success.push(node);
            }
            else {
                acc.fail.push(node);
            }
            return acc;
        }, status);
    }
    getRestoreMessage() {
        const { restoreProcessStatus: status } = this;
        if (status.someFailed && !status.oneFailed) {
            return this.translation.instant('CORE.RESTORE_NODE.PARTIAL_PLURAL', {
                number: status.fail.length
            });
        }
        if (status.oneFailed && status.fail[0].statusCode) {
            if (status.fail[0].statusCode === 409) {
                return this.translation.instant('CORE.RESTORE_NODE.NODE_EXISTS', {
                    name: status.fail[0].entry.name
                });
            }
            else {
                return this.translation.instant('CORE.RESTORE_NODE.GENERIC', {
                    name: status.fail[0].entry.name
                });
            }
        }
        if (status.oneFailed && !status.fail[0].statusCode) {
            return this.translation.instant('CORE.RESTORE_NODE.LOCATION_MISSING', {
                name: status.fail[0].entry.name
            });
        }
        if (status.allSucceeded && !status.oneSucceeded) {
            return this.translation.instant('CORE.RESTORE_NODE.PLURAL');
        }
        if (status.allSucceeded && status.oneSucceeded) {
            return this.translation.instant('CORE.RESTORE_NODE.SINGULAR', {
                name: status.success[0].entry.name
            });
        }
        return null;
    }
    notification() {
        const status = Object.assign({}, this.restoreProcessStatus);
        const message = this.getRestoreMessage();
        this.reset();
        const action = (status.oneSucceeded && !status.someFailed) ? this.translation.instant('CORE.RESTORE_NODE.VIEW') : '';
        let path;
        if (status.success && status.success.length > 0) {
            path = status.success[0].entry.path;
        }
        this.restore.emit({
            message: message,
            action: action,
            path: path
        });
    }
    reset() {
        this.restoreProcessStatus.reset();
        this.selection = [];
    }
}
NodeRestoreDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-restore]'
            },] }
];
NodeRestoreDirective.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: TranslationService }
];
NodeRestoreDirective.propDecorators = {
    selection: [{ type: Input, args: ['adf-restore',] }],
    restore: [{ type: Output }],
    onClick: [{ type: HostListener, args: ['click',] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class UploadDirective {
    constructor(el, renderer, ngZone) {
        this.el = el;
        this.renderer = renderer;
        this.ngZone = ngZone;
        this.enabled = true;
        this.mode = ['drop'];
        this.isDragging = false;
        this.cssClassName = 'adf-upload__dragging';
        this.element = el.nativeElement;
    }
    ngOnInit() {
        if (this.isClickMode() && this.renderer) {
            const inputUpload = this.renderer.createElement('input');
            this.upload = this.el.nativeElement.parentElement.appendChild(inputUpload);
            this.upload.type = 'file';
            this.upload.style.display = 'none';
            this.upload.addEventListener('change', (event) => this.onSelectFiles(event));
            if (this.multiple) {
                this.upload.setAttribute('multiple', '');
            }
            if (this.accept) {
                this.upload.setAttribute('accept', this.accept);
            }
            if (this.directory) {
                this.upload.setAttribute('webkitdirectory', '');
            }
        }
        if (this.isDropMode()) {
            this.ngZone.runOutsideAngular(() => {
                this.element.addEventListener('dragenter', this.onDragEnter.bind(this));
                this.element.addEventListener('dragover', this.onDragOver.bind(this));
                this.element.addEventListener('dragleave', this.onDragLeave.bind(this));
                this.element.addEventListener('drop', this.onDrop.bind(this));
            });
        }
    }
    ngOnDestroy() {
        this.element.removeEventListener('dragenter', this.onDragEnter);
        this.element.removeEventListener('dragover', this.onDragOver);
        this.element.removeEventListener('dragleave', this.onDragLeave);
        this.element.removeEventListener('drop', this.onDrop);
    }
    onClick(event) {
        if (this.isClickMode() && this.upload) {
            event.preventDefault();
            this.upload.click();
        }
    }
    onDragEnter(event) {
        if (this.isDropMode()) {
            event.dataTransfer.dropEffect = 'copy';
            this.element.classList.add(this.cssClassName);
            this.isDragging = true;
        }
    }
    onDragOver(event) {
        event.preventDefault();
        if (this.isDropMode()) {
            event.dataTransfer.dropEffect = 'copy';
            this.element.classList.add(this.cssClassName);
            this.isDragging = true;
        }
        return false;
    }
    onDragLeave() {
        if (this.isDropMode()) {
            this.element.classList.remove(this.cssClassName);
            this.isDragging = false;
        }
    }
    onDrop(event) {
        if (this.isDropMode()) {
            event.stopPropagation();
            event.preventDefault();
            this.element.classList.remove(this.cssClassName);
            this.isDragging = false;
            const dataTransfer = this.getDataTransfer(event);
            if (dataTransfer) {
                this.getFilesDropped(dataTransfer).then((files) => {
                    this.onUploadFiles(files);
                });
            }
        }
        return false;
    }
    onUploadFiles(files) {
        if (this.enabled && files.length > 0) {
            const customEvent = new CustomEvent('upload-files', {
                detail: {
                    sender: this,
                    data: this.data,
                    files: files
                },
                bubbles: true
            });
            this.el.nativeElement.dispatchEvent(customEvent);
        }
    }
    hasMode(mode) {
        return this.enabled && mode && this.mode && this.mode.indexOf(mode) > -1;
    }
    isDropMode() {
        return this.hasMode('drop');
    }
    isClickMode() {
        return this.hasMode('click');
    }
    getDataTransfer(event) {
        if (event && event.dataTransfer) {
            return event.dataTransfer;
        }
        if (event && event.originalEvent && event.originalEvent.dataTransfer) {
            return event.originalEvent.dataTransfer;
        }
        return null;
    }
    getFilesDropped(dataTransfer) {
        return new Promise((resolve) => {
            const iterations = [];
            if (dataTransfer) {
                const items = dataTransfer.items;
                if (items) {
                    for (let i = 0; i < items.length; i++) {
                        if (typeof items[i].webkitGetAsEntry !== 'undefined') {
                            const item = items[i].webkitGetAsEntry();
                            if (item) {
                                if (item.isFile) {
                                    iterations.push(Promise.resolve({
                                        entry: item,
                                        file: items[i].getAsFile(),
                                        relativeFolder: '/'
                                    }));
                                }
                                else if (item.isDirectory) {
                                    iterations.push(new Promise((resolveFolder) => {
                                        FileUtils.flatten(item).then((files) => resolveFolder(files));
                                    }));
                                }
                            }
                        }
                        else {
                            iterations.push(Promise.resolve({
                                entry: null,
                                file: items[i].getAsFile(),
                                relativeFolder: '/'
                            }));
                        }
                    }
                }
                else {
                    const files = FileUtils
                        .toFileArray(dataTransfer.files)
                        .map((file) => ({
                        entry: null,
                        file: file,
                        relativeFolder: '/'
                    }));
                    iterations.push(Promise.resolve(files));
                }
            }
            Promise.all(iterations).then((result) => {
                resolve(result.reduce((a, b) => a.concat(b), []));
            });
        });
    }
    onSelectFiles(event) {
        if (this.isClickMode()) {
            const input = event.currentTarget;
            const files = FileUtils.toFileArray(input.files);
            this.onUploadFiles(files.map((file) => ({
                entry: null,
                file: file,
                relativeFolder: '/'
            })));
            event.target.value = '';
        }
    }
}
UploadDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-upload]'
            },] }
];
UploadDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: NgZone }
];
UploadDirective.propDecorators = {
    enabled: [{ type: Input, args: ['adf-upload',] }],
    data: [{ type: Input, args: ['adf-upload-data',] }],
    mode: [{ type: Input }],
    multiple: [{ type: Input }],
    accept: [{ type: Input }],
    directory: [{ type: Input }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
};

class DownloadZipService {
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
    }
    get downloadsApi() {
        var _a;
        this._downloadsApi = (_a = this._downloadsApi) !== null && _a !== void 0 ? _a : new DownloadsApi(this.apiService.getInstance());
        return this._downloadsApi;
    }
    createDownload(payload) {
        return from(this.downloadsApi.createDownload(payload)).pipe(catchError((err) => this.handleError(err)));
    }
    getDownload(downloadId) {
        return from(this.downloadsApi.getDownload(downloadId));
    }
    cancelDownload(downloadId) {
        this.downloadsApi.cancelDownload(downloadId);
    }
    handleError(error) {
        this.logService.error(error);
        return throwError(error || 'Server error');
    }
}
DownloadZipService.ɵprov = ɵɵdefineInjectable({ factory: function DownloadZipService_Factory() { return new DownloadZipService(ɵɵinject(AlfrescoApiService), ɵɵinject(LogService)); }, token: DownloadZipService, providedIn: "root" });
DownloadZipService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
DownloadZipService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: LogService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class NodeMetadata {
    constructor(metadata, nodeType) {
        this.metadata = metadata;
        this.nodeType = nodeType;
    }
}

class NodesApiService {
    constructor(apiService, preferences) {
        this.apiService = apiService;
        this.preferences = preferences;
    }
    get trashcanApi() {
        var _a;
        this._trashcanApi = (_a = this._trashcanApi) !== null && _a !== void 0 ? _a : new TrashcanApi(this.apiService.getInstance());
        return this._trashcanApi;
    }
    get nodesApi() {
        var _a;
        this._nodesApi = (_a = this._nodesApi) !== null && _a !== void 0 ? _a : new NodesApi(this.apiService.getInstance());
        return this._nodesApi;
    }
    getEntryFromEntity(entity) {
        return entity.entry;
    }
    getNode(nodeId, options = {}) {
        const defaults = {
            include: ['path', 'properties', 'allowableOperations', 'permissions']
        };
        const queryOptions = Object.assign(defaults, options);
        return from(this.nodesApi.getNode(nodeId, queryOptions)).pipe(map(this.getEntryFromEntity), catchError((err) => throwError(err)));
    }
    getNodeChildren(nodeId, options = {}) {
        const defaults = {
            maxItems: this.preferences.paginationSize,
            skipCount: 0,
            include: ['path', 'properties', 'allowableOperations', 'permissions']
        };
        const queryOptions = Object.assign(defaults, options);
        return from(this.nodesApi.listNodeChildren(nodeId, queryOptions)).pipe(catchError((err) => throwError(err)));
    }
    createNode(parentNodeId, nodeBody, options = {}) {
        return from(this.nodesApi.createNode(parentNodeId, nodeBody, options)).pipe(map(this.getEntryFromEntity), catchError((err) => throwError(err)));
    }
    createFolder(parentNodeId, nodeBody, options = {}) {
        const body = Object.assign({ nodeType: 'cm:folder' }, nodeBody);
        return this.createNode(parentNodeId, body, options);
    }
    updateNode(nodeId, nodeBody, options = {}) {
        const defaults = {
            include: ['path', 'properties', 'allowableOperations', 'permissions', 'definition']
        };
        const queryOptions = Object.assign(defaults, options);
        return from(this.nodesApi.updateNode(nodeId, nodeBody, queryOptions)).pipe(map(this.getEntryFromEntity), catchError((err) => throwError(err)));
    }
    deleteNode(nodeId, options = {}) {
        return from(this.nodesApi.deleteNode(nodeId, options)).pipe(catchError((err) => throwError(err)));
    }
    restoreNode(nodeId) {
        return from(this.trashcanApi.restoreDeletedNode(nodeId)).pipe(map(this.getEntryFromEntity), catchError((err) => throwError(err)));
    }
    getNodeMetadata(nodeId) {
        return from(this.nodesApi.getNode(nodeId))
            .pipe(map(this.cleanMetadataFromSemicolon));
    }
    createNodeMetadata(nodeType, nameSpace, data, path, name) {
        const properties = {};
        for (const key in data) {
            if (data[key]) {
                properties[nameSpace + ':' + key] = data[key];
            }
        }
        return this.createNodeInsideRoot(name || this.generateUuid(), nodeType, properties, path);
    }
    createNodeInsideRoot(name, nodeType, properties, path) {
        const body = {
            name: name,
            nodeType: nodeType,
            properties: properties,
            relativePath: path
        };
        return from(this.nodesApi.createNode('-root-', body, {}));
    }
    generateUuid() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
            const r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }
    cleanMetadataFromSemicolon(nodeEntry) {
        const metadata = {};
        if (nodeEntry && nodeEntry.entry.properties) {
            for (const key in nodeEntry.entry.properties) {
                if (key) {
                    if (key.indexOf(':') !== -1) {
                        metadata[key.split(':')[1]] = nodeEntry.entry.properties[key];
                    }
                    else {
                        metadata[key] = nodeEntry.entry.properties[key];
                    }
                }
            }
        }
        return new NodeMetadata(metadata, nodeEntry.entry.nodeType);
    }
}
NodesApiService.ɵprov = ɵɵdefineInjectable({ factory: function NodesApiService_Factory() { return new NodesApiService(ɵɵinject(AlfrescoApiService), ɵɵinject(UserPreferencesService)); }, token: NodesApiService, providedIn: "root" });
NodesApiService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
NodesApiService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: UserPreferencesService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DownloadZipDialogComponent {
    constructor(dialogRef, data, logService, downloadZipService, nodeService, contentService) {
        this.dialogRef = dialogRef;
        this.data = data;
        this.logService = logService;
        this.downloadZipService = downloadZipService;
        this.nodeService = nodeService;
        this.contentService = contentService;
        this.cancelled = false;
    }
    ngOnInit() {
        if (this.data && this.data.nodeIds && this.data.nodeIds.length > 0) {
            if (!this.cancelled) {
                this.downloadZip(this.data.nodeIds);
            }
            else {
                this.logService.log('Cancelled');
            }
        }
    }
    cancelDownload() {
        this.cancelled = true;
        this.downloadZipService.cancelDownload(this.downloadId);
        this.dialogRef.close(false);
    }
    downloadZip(nodeIds) {
        if (nodeIds && nodeIds.length > 0) {
            this.downloadZipService.createDownload({ nodeIds }).subscribe((data) => {
                if (data && data.entry && data.entry.id) {
                    const url = this.contentService.getContentUrl(data.entry.id, true);
                    this.nodeService.getNode(data.entry.id).subscribe((downloadNode) => {
                        this.logService.log(downloadNode);
                        const fileName = downloadNode.name;
                        this.downloadId = data.entry.id;
                        this.waitAndDownload(data.entry.id, url, fileName);
                    });
                }
            });
        }
    }
    waitAndDownload(downloadId, url, fileName) {
        if (this.cancelled) {
            return;
        }
        this.downloadZipService.getDownload(downloadId).subscribe((downloadEntry) => {
            if (downloadEntry.entry) {
                if (downloadEntry.entry.status === 'DONE') {
                    this.download(url, fileName);
                }
                else {
                    setTimeout(() => {
                        this.waitAndDownload(downloadId, url, fileName);
                    }, 1000);
                }
            }
        });
    }
    download(url, fileName) {
        if (url && fileName) {
            const link = document.createElement('a');
            link.style.display = 'none';
            link.download = fileName;
            link.href = url;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
        }
        this.dialogRef.close(true);
    }
}
DownloadZipDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-download-zip-dialog',
                template: "<h1 matDialogTitle>{{ 'CORE.DIALOG.DOWNLOAD_ZIP.TITLE' | translate }}</h1>\n<div mat-dialog-content>\n    <mat-progress-bar color=\"primary\" mode=\"indeterminate\"></mat-progress-bar>\n</div>\n<mat-dialog-actions align=\"end\">\n    <button mat-button color=\"primary\" id=\"cancel-button\" (click)=\"cancelDownload()\">\n        {{ 'CORE.DIALOG.DOWNLOAD_ZIP.ACTIONS.CANCEL' | translate }}\n    </button>\n</mat-dialog-actions>\n",
                host: { 'class': 'adf-download-zip-dialog' },
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-download-zip-dialog .mat-dialog-actions .mat-button-wrapper{text-transform:uppercase}"]
            },] }
];
DownloadZipDialogComponent.ctorParameters = () => [
    { type: MatDialogRef },
    { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] }] },
    { type: LogService },
    { type: DownloadZipService },
    { type: NodesApiService },
    { type: ContentService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class NodeDownloadDirective {
    constructor(apiService, downloadService, dialog) {
        this.apiService = apiService;
        this.downloadService = downloadService;
        this.dialog = dialog;
    }
    get contentApi() {
        var _a;
        this._contentApi = (_a = this._contentApi) !== null && _a !== void 0 ? _a : new ContentApi(this.apiService.getInstance());
        return this._contentApi;
    }
    onClick() {
        this.downloadNodes(this.nodes);
    }
    downloadNodes(selection) {
        if (!this.isSelectionValid(selection)) {
            return;
        }
        if (selection instanceof Array) {
            if (selection.length === 1) {
                this.downloadNode(selection[0]);
            }
            else {
                this.downloadZip(selection);
            }
        }
        else {
            this.downloadNode(selection);
        }
    }
    downloadNode(node) {
        if (node && node.entry) {
            const entry = node.entry;
            if (entry.isFile) {
                this.downloadFile(node);
            }
            if (entry.isFolder) {
                this.downloadZip([node]);
            }
            if (!entry.isFile && !entry.isFolder && entry.nodeId) {
                this.downloadFile(node);
            }
        }
    }
    isSelectionValid(selection) {
        return selection || (selection instanceof Array && selection.length > 0);
    }
    downloadFile(node) {
        if (node && node.entry) {
            const id = node.entry.nodeId || node.entry.id;
            let url, fileName;
            if (this.version) {
                url = this.contentApi.getVersionContentUrl(id, this.version.entry.id, true);
                fileName = this.version.entry.name;
            }
            else {
                url = this.contentApi.getContentUrl(id, true);
                fileName = node.entry.name;
            }
            this.downloadService.downloadUrl(url, fileName);
        }
    }
    downloadZip(selection) {
        if (selection && selection.length > 0) {
            const nodeIds = selection.map((node) => (node.entry.nodeId || node.entry.id));
            this.dialog.open(DownloadZipDialogComponent, {
                width: '600px',
                disableClose: true,
                data: {
                    nodeIds
                }
            });
        }
    }
}
NodeDownloadDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adfNodeDownload]'
            },] }
];
NodeDownloadDirective.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: DownloadService },
    { type: MatDialog }
];
NodeDownloadDirective.propDecorators = {
    nodes: [{ type: Input, args: ['adfNodeDownload',] }],
    version: [{ type: Input }],
    onClick: [{ type: HostListener, args: ['click',] }]
};

class VersionCompatibilityService {
    constructor(discoveryApiService) {
        this.discoveryApiService = discoveryApiService;
        this.acsVersionInitialized$ = new ReplaySubject();
        this.discoveryApiService.ecmProductInfo$
            .pipe(filter(acsInfo => !!acsInfo))
            .subscribe((acsInfo) => this.initializeAcsVersion(acsInfo.version));
    }
    initializeAcsVersion(acsVersion) {
        this.acsVersion = acsVersion;
        this.acsVersionInitialized$.next();
    }
    getAcsVersion() {
        return this.acsVersion;
    }
    isVersionSupported(requiredVersion) {
        const parsedRequiredVersion = this.parseVersion(requiredVersion);
        const currentVersion = this.getAcsVersion();
        let versionSupported = false;
        if (currentVersion) {
            if (+currentVersion.major > +parsedRequiredVersion.major) {
                versionSupported = true;
            }
            else if (currentVersion.major === parsedRequiredVersion.major &&
                +currentVersion.minor > +parsedRequiredVersion.minor) {
                versionSupported = true;
            }
            else if (currentVersion.major === parsedRequiredVersion.major &&
                currentVersion.minor === parsedRequiredVersion.minor &&
                +currentVersion.patch >= +parsedRequiredVersion.patch) {
                versionSupported = true;
            }
        }
        return versionSupported;
    }
    parseVersion(version) {
        const major = version.split('.')[0];
        const minor = version.split('.')[1] || '0';
        const patch = version.split('.')[2] || '0';
        return {
            major: major,
            minor: minor,
            patch: patch
        };
    }
}
VersionCompatibilityService.ɵprov = ɵɵdefineInjectable({ factory: function VersionCompatibilityService_Factory() { return new VersionCompatibilityService(ɵɵinject(DiscoveryApiService)); }, token: VersionCompatibilityService, providedIn: "root" });
VersionCompatibilityService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
VersionCompatibilityService.ctorParameters = () => [
    { type: DiscoveryApiService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class VersionCompatibilityDirective {
    constructor(templateRef, viewContainer, versionCompatibilityService) {
        this.templateRef = templateRef;
        this.viewContainer = viewContainer;
        this.versionCompatibilityService = versionCompatibilityService;
    }
    set version(requiredVersion) {
        this.validateAcsVersion(requiredVersion);
    }
    validateAcsVersion(requiredVersion) {
        this.versionCompatibilityService.acsVersionInitialized$.pipe(take(1)).subscribe(() => {
            this.viewContainer.clear();
            if (requiredVersion && this.versionCompatibilityService.isVersionSupported(requiredVersion)) {
                this.viewContainer.createEmbeddedView(this.templateRef);
            }
        });
    }
}
VersionCompatibilityDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-acs-version]'
            },] }
];
VersionCompatibilityDirective.ctorParameters = () => [
    { type: TemplateRef },
    { type: ViewContainerRef },
    { type: VersionCompatibilityService }
];
VersionCompatibilityDirective.propDecorators = {
    version: [{ type: Input, args: ['adf-acs-version',] }]
};

class TooltipCardComponent {
    constructor(sanitizer) {
        this.sanitizer = sanitizer;
        this.image = '';
        this.text = '';
        this.htmlContent = '';
        this.width = '300';
    }
    sanitizedHtmlContent() {
        return this.sanitizer.sanitize(SecurityContext.HTML, this.htmlContent);
    }
}
TooltipCardComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-tooltip-card-component',
                template: "<div @tooltip class=\"adf-tooltip-card\" [style.width.px]=\"width\">\n    <img *ngIf=\"image \" [src]=\"image\" [width]=\"width\" alt=\"{{text}}\">\n    <hr *ngIf=\"image\" />\n    <p *ngIf=\"text\">{{text}}</p>\n    <div *ngIf=\"htmlContent\" [innerHTML]=\"sanitizedHtmlContent()\" class=\"adf-tooltip-card-content\"></div>\n</div>\n",
                animations: [
                    trigger('tooltip', [
                        transition(':enter', [
                            style({ opacity: 0 }),
                            animate(200, style({ opacity: 1 }))
                        ]),
                        transition(':leave', [
                            animate(200, style({ opacity: 0 }))
                        ])
                    ])
                ],
                styles: [":host{display:block}div.adf-tooltip-card{background-color:var(--theme-card-bg-color);border:1px solid var(--theme-primary-color);border-radius:6px;box-shadow:0 5px 5px -3px rgba(0,0,0,.2),0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12);padding:12px}div.adf-tooltip-card div,div.adf-tooltip-card p{color:var(--adf-tooltip-card-color);font-size:var(--theme-caption-font-size);margin:0}div.adf-tooltip-card hr{border:1px solid var(--theme-primary-color);margin:6px 0}div.adf-tooltip-card img{border-radius:6px}::ng-deep .cdk-overlay-connected-position-bounding-box{margin-top:10px!important}"]
            },] }
];
TooltipCardComponent.ctorParameters = () => [
    { type: DomSanitizer }
];
TooltipCardComponent.propDecorators = {
    image: [{ type: Input }],
    text: [{ type: Input }],
    htmlContent: [{ type: Input }],
    width: [{ type: Input }]
};

class TooltipCardDirective {
    constructor(overlay, overlayPositionBuilder, elementRef) {
        this.overlay = overlay;
        this.overlayPositionBuilder = overlayPositionBuilder;
        this.elementRef = elementRef;
        this.text = '';
        this.image = '';
        this.width = '300';
        this.htmlContent = '';
        this.originX = 'start';
        this.originY = 'top';
        this.overlayX = 'start';
        this.overlayY = 'bottom';
        this.offsetX = 0;
        this.offsetY = -8;
    }
    ngOnDestroy() {
        this.hide();
    }
    ngOnInit() {
        const positionStrategy = this.overlayPositionBuilder
            .flexibleConnectedTo(this.elementRef)
            .withPositions([{
                originX: this.originX,
                originY: this.originY,
                overlayX: this.overlayX,
                overlayY: this.overlayY,
                offsetY: this.offsetY,
                offsetX: this.offsetX
            }]);
        this.overlayRef = this.overlay.create({ positionStrategy });
    }
    show() {
        const tooltipRef = this.overlayRef.attach(new ComponentPortal(TooltipCardComponent));
        tooltipRef.instance.text = this.text;
        tooltipRef.instance.image = this.image;
        tooltipRef.instance.width = this.width;
        tooltipRef.instance.htmlContent = this.htmlContent;
    }
    hide() {
        this.overlayRef.detach();
    }
}
TooltipCardDirective.decorators = [
    { type: Directive, args: [{ selector: '[adf-tooltip-card]' },] }
];
TooltipCardDirective.ctorParameters = () => [
    { type: Overlay },
    { type: OverlayPositionBuilder },
    { type: ElementRef }
];
TooltipCardDirective.propDecorators = {
    text: [{ type: Input, args: ['adf-tooltip-card',] }],
    image: [{ type: Input }],
    width: [{ type: Input }],
    htmlContent: [{ type: Input }],
    originX: [{ type: Input }],
    originY: [{ type: Input }],
    overlayX: [{ type: Input }],
    overlayY: [{ type: Input }],
    offsetX: [{ type: Input }],
    offsetY: [{ type: Input }],
    show: [{ type: HostListener, args: ['mouseenter',] }],
    hide: [{ type: HostListener, args: ['mouseleave',] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const SELECT_ITEM_HEIGHT_EM = 3;
class InfiniteSelectScrollDirective {
    constructor(matSelect) {
        this.matSelect = matSelect;
        this.scrollEnd = new EventEmitter();
        this.onDestroy$ = new Subject();
        this.itemHeightToWaitBeforeLoadNext = 0;
    }
    ngAfterViewInit() {
        this.matSelect.openedChange
            .pipe(takeUntil(this.onDestroy$))
            .subscribe((opened) => {
            if (opened) {
                this.itemHeightToWaitBeforeLoadNext = (this.getItemHeight() * (InfiniteSelectScrollDirective.MAX_ITEMS / 2));
                this.matSelect.panel.nativeElement.addEventListener('scroll', (event) => this.handleScrollEvent(event));
            }
        });
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
    handleScrollEvent(event) {
        if (this.isScrollInNextFetchArea(event)) {
            this.scrollEnd.emit(event);
        }
    }
    isScrollInNextFetchArea(event) {
        const target = event.target;
        return target.scrollTop >= (target.scrollHeight - target.offsetHeight - this.itemHeightToWaitBeforeLoadNext);
    }
    getItemHeight() {
        return parseFloat(getComputedStyle(this.matSelect.panel.nativeElement).fontSize || '0') * SELECT_ITEM_HEIGHT_EM;
    }
}
InfiniteSelectScrollDirective.MAX_ITEMS = 50;
InfiniteSelectScrollDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-infinite-select-scroll]'
            },] }
];
InfiniteSelectScrollDirective.ctorParameters = () => [
    { type: MatSelect, decorators: [{ type: Inject, args: [MatSelect,] }] }
];
InfiniteSelectScrollDirective.propDecorators = {
    scrollEnd: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class LibraryFavoriteDirective {
    constructor(alfrescoApiService) {
        this.alfrescoApiService = alfrescoApiService;
        this.library = null;
        this.toggle = new EventEmitter();
        this.error = new EventEmitter();
        this.targetLibrary = null;
    }
    get favoritesApi() {
        var _a;
        this._favoritesApi = (_a = this._favoritesApi) !== null && _a !== void 0 ? _a : new FavoritesApi(this.alfrescoApiService.getInstance());
        return this._favoritesApi;
    }
    onClick() {
        const guid = this.targetLibrary.entry.guid;
        if (this.targetLibrary.isFavorite) {
            this.removeFavorite(guid);
        }
        else {
            this.addFavorite({
                target: {
                    site: {
                        guid
                    }
                }
            });
        }
    }
    ngOnChanges(changes) {
        if (!changes.library.currentValue) {
            this.targetLibrary = null;
            return;
        }
        this.targetLibrary = changes.library.currentValue;
        this.markFavoriteLibrary(changes.library.currentValue);
    }
    isFavorite() {
        return this.targetLibrary && this.targetLibrary.isFavorite;
    }
    markFavoriteLibrary(library) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.targetLibrary.isFavorite === undefined) {
                try {
                    yield this.favoritesApi.getFavoriteSite('-me-', library.entry.id);
                    this.targetLibrary.isFavorite = true;
                }
                catch (_a) {
                    this.targetLibrary.isFavorite = false;
                }
            }
            else {
                this.targetLibrary = library;
            }
        });
    }
    addFavorite(favoriteBody) {
        this.favoritesApi
            .createFavorite('-me-', favoriteBody)
            .then((libraryEntry) => {
            this.targetLibrary.isFavorite = true;
            this.toggle.emit(libraryEntry);
        })
            .catch((error) => this.error.emit(error));
    }
    removeFavorite(favoriteId) {
        this.favoritesApi
            .deleteFavorite('-me-', favoriteId)
            .then((libraryBody) => {
            this.targetLibrary.isFavorite = false;
            this.toggle.emit(libraryBody);
        })
            .catch((error) => this.error.emit(error));
    }
}
LibraryFavoriteDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-favorite-library]',
                exportAs: 'favoriteLibrary'
            },] }
];
LibraryFavoriteDirective.ctorParameters = () => [
    { type: AlfrescoApiService }
];
LibraryFavoriteDirective.propDecorators = {
    library: [{ type: Input, args: ['adf-favorite-library',] }],
    toggle: [{ type: Output }],
    error: [{ type: Output }],
    onClick: [{ type: HostListener, args: ['click',] }]
};

class SitesService {
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
    }
    get sitesApi() {
        var _a;
        this._sitesApi = (_a = this._sitesApi) !== null && _a !== void 0 ? _a : new SitesApi(this.apiService.getInstance());
        return this._sitesApi;
    }
    createSite(siteBody) {
        return from(this.sitesApi.createSite(siteBody))
            .pipe(catchError((err) => this.handleError(err)));
    }
    getSites(opts = {}) {
        const defaultOptions = {
            skipCount: 0,
            include: ['properties']
        };
        const queryOptions = Object.assign({}, defaultOptions, opts);
        return from(this.sitesApi.listSites(queryOptions))
            .pipe(catchError((err) => this.handleError(err)));
    }
    getSite(siteId, opts) {
        return from(this.sitesApi.getSite(siteId, opts))
            .pipe(catchError((err) => this.handleError(err)));
    }
    deleteSite(siteId, permanentFlag = true) {
        const options = {};
        options.permanent = permanentFlag;
        return from(this.sitesApi.deleteSite(siteId, options))
            .pipe(catchError((err) => this.handleError(err)));
    }
    getSiteContent(siteId) {
        return this.getSite(siteId, { relations: ['containers'] });
    }
    getSiteMembers(siteId) {
        return this.getSite(siteId, { relations: ['members'] });
    }
    listSiteMemberships(siteId, opts) {
        return from(this.sitesApi.listSiteMemberships(siteId, opts));
    }
    getEcmCurrentLoggedUserName() {
        return this.apiService.getInstance().getEcmUsername();
    }
    getSiteNameFromNodePath(node) {
        let siteName = '';
        if (node.path && node.path.elements) {
            const foundNode = node.path
                .elements.find((pathNode) => pathNode.nodeType === 'st:site' &&
                pathNode.name !== 'Sites');
            siteName = foundNode ? foundNode.name : '';
        }
        return siteName.toLocaleLowerCase();
    }
    getSiteMembershipRequests(opts) {
        return from(this.sitesApi.getSiteMembershipRequests(opts))
            .pipe(catchError((err) => this.handleError(err)));
    }
    createSiteMembership(siteId, siteMembershipBodyCreate, opts) {
        return from(this.sitesApi.createSiteMembership(siteId, siteMembershipBodyCreate, opts))
            .pipe(catchError((err) => this.handleError(err)));
    }
    updateSiteMembership(siteId, personId, siteMembershipBodyUpdate, opts) {
        return from(this.sitesApi.updateSiteMembership(siteId, personId, siteMembershipBodyUpdate, opts))
            .pipe(catchError((err) => this.handleError(err)));
    }
    deleteSiteMembership(siteId, personId) {
        return from(this.sitesApi.deleteSiteMembership(siteId, personId))
            .pipe(catchError((err) => this.handleError(err)));
    }
    approveSiteMembershipRequest(siteId, inviteeId, opts) {
        return from(this.sitesApi.approveSiteMembershipRequest(siteId, inviteeId, opts))
            .pipe(catchError((err) => this.handleError(err)));
    }
    rejectSiteMembershipRequest(siteId, inviteeId, opts) {
        return from(this.sitesApi.rejectSiteMembershipRequest(siteId, inviteeId, opts))
            .pipe(catchError((err) => this.handleError(err)));
    }
    listSiteGroups(siteId, opts) {
        return from(this.sitesApi.listSiteGroups(siteId, opts))
            .pipe(catchError((err) => this.handleError(err)));
    }
    createSiteGroupMembership(siteId, siteMembershipBodyCreate) {
        return from(this.sitesApi.createSiteGroupMembership(siteId, siteMembershipBodyCreate))
            .pipe(catchError((err) => this.handleError(err)));
    }
    getSiteGroupMembership(siteId, groupId) {
        return from(this.sitesApi.getSiteGroupMembership(siteId, groupId))
            .pipe(catchError((err) => this.handleError(err)));
    }
    updateSiteGroupMembership(siteId, groupId, siteMembershipBodyUpdate) {
        return from(this.sitesApi.updateSiteGroupMembership(siteId, groupId, siteMembershipBodyUpdate))
            .pipe(catchError((err) => this.handleError(err)));
    }
    deleteSiteGroupMembership(siteId, groupId) {
        return from(this.sitesApi.deleteSiteGroupMembership(siteId, groupId))
            .pipe(catchError((err) => this.handleError(err)));
    }
    handleError(error) {
        this.logService.error(error);
        return throwError(error || 'Server error');
    }
}
SitesService.ɵprov = ɵɵdefineInjectable({ factory: function SitesService_Factory() { return new SitesService(ɵɵinject(AlfrescoApiService), ɵɵinject(LogService)); }, token: SitesService, providedIn: "root" });
SitesService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
SitesService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: LogService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class LibraryMembershipDirective {
    constructor(alfrescoApiService, sitesService, versionCompatibilityService) {
        this.alfrescoApiService = alfrescoApiService;
        this.sitesService = sitesService;
        this.versionCompatibilityService = versionCompatibilityService;
        this.targetSite = null;
        this.isJoinRequested = new BehaviorSubject(false);
        this.selection = null;
        this.isAdmin = false;
        this.toggle = new EventEmitter();
        this.error = new EventEmitter();
    }
    get sitesApi() {
        var _a;
        this._sitesApi = (_a = this._sitesApi) !== null && _a !== void 0 ? _a : new SitesApi(this.alfrescoApiService.getInstance());
        return this._sitesApi;
    }
    onClick() {
        this.toggleMembershipRequest();
    }
    ngOnChanges(changes) {
        if (!changes.selection.currentValue || !changes.selection.currentValue.entry) {
            this.targetSite = null;
            return;
        }
        this.targetSite = changes.selection.currentValue.entry;
        this.markMembershipRequest();
    }
    toggleMembershipRequest() {
        if (!this.targetSite) {
            return;
        }
        if (this.targetSite.joinRequested) {
            this.cancelJoinRequest().subscribe(() => {
                this.targetSite.joinRequested = false;
                this.isJoinRequested.next(false);
                const info = {
                    updatedEntry: this.targetSite,
                    shouldReload: false,
                    i18nKey: 'APP.MESSAGES.INFO.JOIN_CANCELED'
                };
                this.toggle.emit(info);
            }, (error) => {
                const errWithMessage = {
                    error,
                    i18nKey: 'APP.MESSAGES.ERRORS.JOIN_CANCEL_FAILED'
                };
                this.error.emit(errWithMessage);
            });
        }
        if (!this.targetSite.joinRequested && !this.isAdmin) {
            this.joinLibraryRequest().subscribe((createdMembership) => {
                this.targetSite.joinRequested = true;
                this.isJoinRequested.next(true);
                if (createdMembership.entry && createdMembership.entry.site && createdMembership.entry.site.role) {
                    const info = {
                        shouldReload: true,
                        i18nKey: 'APP.MESSAGES.INFO.JOINED'
                    };
                    this.toggle.emit(info);
                }
                else {
                    const info = {
                        updatedEntry: this.targetSite,
                        shouldReload: false,
                        i18nKey: 'APP.MESSAGES.INFO.JOIN_REQUESTED'
                    };
                    this.toggle.emit(info);
                }
            }, (error) => {
                const errWithMessage = {
                    error,
                    i18nKey: 'APP.MESSAGES.ERRORS.JOIN_REQUEST_FAILED'
                };
                const senderEmailCheck = 'Failed to resolve sender mail address';
                const receiverEmailCheck = 'All recipients for the mail action were invalid';
                if (error.message) {
                    if (error.message.includes(senderEmailCheck)) {
                        errWithMessage.i18nKey = 'APP.MESSAGES.ERRORS.INVALID_SENDER_EMAIL';
                    }
                    else if (error.message.includes(receiverEmailCheck)) {
                        errWithMessage.i18nKey = 'APP.MESSAGES.ERRORS.INVALID_RECEIVER_EMAIL';
                    }
                }
                this.error.emit(errWithMessage);
            });
        }
        if (this.isAdmin) {
            this.joinLibrary().subscribe((createdMembership) => {
                if (createdMembership.entry && createdMembership.entry.role) {
                    const info = {
                        shouldReload: true,
                        i18nKey: 'APP.MESSAGES.INFO.JOINED'
                    };
                    this.toggle.emit(info);
                }
            }, (error) => {
                const errWithMessage = {
                    error,
                    i18nKey: 'APP.MESSAGES.ERRORS.JOIN_REQUEST_FAILED'
                };
                const senderEmailCheck = 'Failed to resolve sender mail address';
                const receiverEmailCheck = 'All recipients for the mail action were invalid';
                if (error.message) {
                    if (error.message.includes(senderEmailCheck)) {
                        errWithMessage.i18nKey = 'APP.MESSAGES.ERRORS.INVALID_SENDER_EMAIL';
                    }
                    else if (error.message.includes(receiverEmailCheck)) {
                        errWithMessage.i18nKey = 'APP.MESSAGES.ERRORS.INVALID_RECEIVER_EMAIL';
                    }
                }
                this.error.emit(errWithMessage);
            });
        }
    }
    markMembershipRequest() {
        if (!this.targetSite) {
            return;
        }
        this.getMembershipRequest().subscribe((data) => {
            if (data.entry.id === this.targetSite.id) {
                this.targetSite.joinRequested = true;
                this.isJoinRequested.next(true);
            }
        }, () => {
            this.targetSite.joinRequested = false;
            this.isJoinRequested.next(false);
        });
    }
    joinLibraryRequest() {
        const memberBody = {
            id: this.targetSite.id
        };
        if (this.versionCompatibilityService.isVersionSupported('7.0.0')) {
            memberBody.client = 'workspace';
        }
        return from(this.sitesApi.createSiteMembershipRequestForPerson('-me-', memberBody));
    }
    joinLibrary() {
        return this.sitesService.createSiteMembership(this.targetSite.id, {
            role: 'SiteConsumer',
            id: '-me-'
        });
    }
    cancelJoinRequest() {
        return from(this.sitesApi.deleteSiteMembershipRequestForPerson('-me-', this.targetSite.id));
    }
    getMembershipRequest() {
        return from(this.sitesApi.getSiteMembershipRequestForPerson('-me-', this.targetSite.id));
    }
}
LibraryMembershipDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-library-membership]',
                exportAs: 'libraryMembership'
            },] }
];
LibraryMembershipDirective.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: SitesService },
    { type: VersionCompatibilityService }
];
LibraryMembershipDirective.propDecorators = {
    selection: [{ type: Input, args: ['adf-library-membership',] }],
    isAdmin: [{ type: Input }],
    toggle: [{ type: Output }],
    error: [{ type: Output }],
    onClick: [{ type: HostListener, args: ['click',] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DirectiveModule {
}
DirectiveModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    OverlayModule
                ],
                declarations: [
                    HighlightDirective,
                    LogoutDirective,
                    NodeDeleteDirective,
                    NodeFavoriteDirective,
                    CheckAllowableOperationDirective,
                    NodeRestoreDirective,
                    NodeDownloadDirective,
                    UploadDirective,
                    VersionCompatibilityDirective,
                    TooltipCardDirective,
                    TooltipCardComponent,
                    InfiniteSelectScrollDirective,
                    LibraryFavoriteDirective,
                    LibraryMembershipDirective
                ],
                exports: [
                    HighlightDirective,
                    LogoutDirective,
                    NodeDeleteDirective,
                    NodeFavoriteDirective,
                    CheckAllowableOperationDirective,
                    NodeRestoreDirective,
                    NodeDownloadDirective,
                    UploadDirective,
                    VersionCompatibilityDirective,
                    TooltipCardDirective,
                    InfiniteSelectScrollDirective,
                    LibraryFavoriteDirective,
                    LibraryMembershipDirective
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DataTableCellComponent {
    constructor(alfrescoApiService) {
        this.alfrescoApiService = alfrescoApiService;
        this.value$ = new BehaviorSubject('');
        this.resolverFn = null;
        this.onDestroy$ = new Subject();
    }
    ngOnInit() {
        this.updateValue();
        this.alfrescoApiService.nodeUpdated
            .pipe(takeUntil(this.onDestroy$))
            .subscribe(node => {
            if (this.row) {
                if (this.row['node'].entry.id === node.id) {
                    this.row['node'].entry = node;
                    this.row['cache'][this.column.key] = this.column.key.split('.').reduce((source, key) => source ? source[key] : '', node);
                    this.updateValue();
                }
            }
        });
    }
    updateValue() {
        if (this.column && this.column.key && this.row && this.data) {
            const value = this.data.getValue(this.row, this.column, this.resolverFn);
            this.value$.next(value);
            if (!this.tooltip) {
                this.tooltip = value;
            }
        }
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
}
DataTableCellComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-datatable-cell',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: `
        <ng-container>
            <span *ngIf="copyContent; else defaultCell"
                adf-clipboard="CLIPBOARD.CLICK_TO_COPY"
                [clipboard-notification]="'CLIPBOARD.SUCCESS_COPY'"
                [attr.aria-label]="value$ | async"
                [title]="tooltip"
                class="adf-datatable-cell-value"
                >{{ value$ | async }}</span>
        </ng-container>
        <ng-template #defaultCell>
            <span
                [attr.aria-label]="value$ | async"
                [title]="tooltip"
                class="adf-datatable-cell-value"
            >{{ value$ | async }}</span>
        </ng-template>
    `,
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-datatable-content-cell' }
            },] }
];
DataTableCellComponent.ctorParameters = () => [
    { type: AlfrescoApiService }
];
DataTableCellComponent.propDecorators = {
    data: [{ type: Input }],
    column: [{ type: Input }],
    row: [{ type: Input }],
    copyContent: [{ type: Input }],
    tooltip: [{ type: Input }],
    resolverFn: [{ type: Input }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DataTableRowComponent {
    constructor(element) {
        this.element = element;
        this.disabled = false;
        this.select = new EventEmitter();
    }
    get isSelected() {
        if (!this.row) {
            return false;
        }
        return this.row.isSelected;
    }
    get isAriaSelected() {
        if (!this.row) {
            return false;
        }
        return this.row.isSelected;
    }
    get ariaLabel() {
        if (!this.row) {
            return null;
        }
        if (this.row.isSelected) {
            return this.row.getValue('name') + ' selected' || '';
        }
        else {
            return this.row.getValue('name') || '';
        }
    }
    get tabindex() {
        return this.disabled ? null : 0;
    }
    onKeyDown(event) {
        if (event.target.tagName === this.element.nativeElement.tagName) {
            event.preventDefault();
            this.select.emit(event);
        }
    }
    focus() {
        this.element.nativeElement.focus();
    }
}
DataTableRowComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-datatable-row',
                template: `<ng-content></ng-content>`,
                encapsulation: ViewEncapsulation.None,
                host: {
                    class: 'adf-datatable-row',
                    tabindex: '0',
                    role: 'row'
                }
            },] }
];
DataTableRowComponent.ctorParameters = () => [
    { type: ElementRef }
];
DataTableRowComponent.propDecorators = {
    row: [{ type: Input }],
    disabled: [{ type: Input }],
    select: [{ type: Output }],
    isSelected: [{ type: HostBinding, args: ['class.adf-is-selected',] }],
    isAriaSelected: [{ type: HostBinding, args: ['attr.aria-selected',] }],
    ariaLabel: [{ type: HostBinding, args: ['attr.aria-label',] }],
    tabindex: [{ type: HostBinding, args: ['attr.tabindex',] }],
    onKeyDown: [{ type: HostListener, args: ['keydown.space', ['$event'],] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DataColumnComponent {
    constructor() {
        this.type = 'text';
        this.sortable = true;
        this.title = '';
        this.editable = false;
        this.focus = true;
    }
    ngOnInit() {
        if (!this.srTitle && this.key === '$thumbnail') {
            this.srTitle = 'Thumbnail';
        }
    }
}
DataColumnComponent.decorators = [
    { type: Component, args: [{
                selector: 'data-column',
                template: ''
            },] }
];
DataColumnComponent.propDecorators = {
    key: [{ type: Input }],
    type: [{ type: Input }],
    format: [{ type: Input }],
    sortable: [{ type: Input }],
    title: [{ type: Input }],
    template: [{ type: ContentChild, args: [TemplateRef,] }],
    formatTooltip: [{ type: Input }],
    srTitle: [{ type: Input, args: ['sr-title',] }],
    cssClass: [{ type: Input, args: ['class',] }],
    copyContent: [{ type: Input }],
    editable: [{ type: Input }],
    focus: [{ type: Input }],
    sortingKey: [{ type: Input }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DataColumnListComponent {
}
DataColumnListComponent.decorators = [
    { type: Component, args: [{
                selector: 'data-columns',
                template: ''
            },] }
];
DataColumnListComponent.propDecorators = {
    columns: [{ type: ContentChildren, args: [DataColumnComponent,] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class BaseEvent {
    constructor() {
        this.isDefaultPrevented = false;
    }
    get defaultPrevented() {
        return this.isDefaultPrevented;
    }
    preventDefault() {
        this.isDefaultPrevented = true;
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class BaseUIEvent extends BaseEvent {
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FileUploadOptions {
}
var FileUploadStatus;
(function (FileUploadStatus) {
    FileUploadStatus[FileUploadStatus["Pending"] = 0] = "Pending";
    FileUploadStatus[FileUploadStatus["Complete"] = 1] = "Complete";
    FileUploadStatus[FileUploadStatus["Starting"] = 2] = "Starting";
    FileUploadStatus[FileUploadStatus["Progress"] = 3] = "Progress";
    FileUploadStatus[FileUploadStatus["Cancelled"] = 4] = "Cancelled";
    FileUploadStatus[FileUploadStatus["Aborted"] = 5] = "Aborted";
    FileUploadStatus[FileUploadStatus["Error"] = 6] = "Error";
    FileUploadStatus[FileUploadStatus["Deleted"] = 7] = "Deleted";
})(FileUploadStatus || (FileUploadStatus = {}));
class FileModel {
    constructor(file, options, id) {
        this.status = FileUploadStatus.Pending;
        this.file = file;
        this.id = id;
        this.name = file.name;
        this.size = file.size;
        this.data = null;
        this.errorCode = null;
        this.progress = {
            loaded: 0,
            total: 0,
            percent: 0
        };
        this.options = Object.assign({}, {
            newVersion: false
        }, options);
    }
    get extension() {
        return this.name.slice((Math.max(0, this.name.lastIndexOf('.')) || Infinity) + 1);
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FileUploadEvent {
    constructor(file, status = FileUploadStatus.Pending, error = null) {
        this.file = file;
        this.status = status;
        this.error = error;
    }
}
class FileUploadCompleteEvent extends FileUploadEvent {
    constructor(file, totalComplete = 0, data, totalAborted = 0) {
        super(file, FileUploadStatus.Complete);
        this.totalComplete = totalComplete;
        this.data = data;
        this.totalAborted = totalAborted;
    }
}
class FileUploadDeleteEvent extends FileUploadEvent {
    constructor(file, totalComplete = 0) {
        super(file, FileUploadStatus.Deleted);
        this.totalComplete = totalComplete;
    }
}
class FileUploadErrorEvent extends FileUploadEvent {
    constructor(file, error, totalError = 0) {
        super(file, FileUploadStatus.Error);
        this.error = error;
        this.totalError = totalError;
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DataRowEvent extends BaseUIEvent {
    constructor(value, domEvent, sender) {
        super();
        this.value = value;
        this.event = domEvent;
        this.sender = sender;
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DataCellEventModel {
    constructor(row, col, actions) {
        this.row = row;
        this.col = col;
        this.actions = actions || [];
    }
}
class DataCellEvent extends BaseEvent {
    constructor(row, col, actions) {
        super();
        this.value = new DataCellEventModel(row, col, actions);
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DataRowActionModel {
    constructor(row, action) {
        this.row = row;
        this.action = action;
    }
}
class DataRowActionEvent extends BaseEvent {
    get args() {
        return this.value;
    }
    constructor(row, action) {
        super();
        this.value = new DataRowActionModel(row, action);
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var DisplayMode;
(function (DisplayMode) {
    DisplayMode["List"] = "list";
    DisplayMode["Gallery"] = "gallery";
})(DisplayMode || (DisplayMode = {}));
var ShowHeaderMode;
(function (ShowHeaderMode) {
    ShowHeaderMode["Never"] = "never";
    ShowHeaderMode["Always"] = "always";
    ShowHeaderMode["Data"] = "data";
})(ShowHeaderMode || (ShowHeaderMode = {}));
class DataTableComponent {
    constructor(elementRef, differs) {
        this.elementRef = elementRef;
        this.display = DisplayMode.List;
        this.rows = [];
        this.sorting = [];
        this.columns = [];
        this.selectionMode = 'single';
        this.multiselect = false;
        this.actions = false;
        this.actionsPosition = 'right';
        this.actionsVisibleOnHover = false;
        this.contextMenu = false;
        this.rowStyleClass = '';
        this.showHeader = ShowHeaderMode.Data;
        this.stickyHeader = false;
        this.rowClick = new EventEmitter();
        this.rowDblClick = new EventEmitter();
        this.showRowContextMenu = new EventEmitter();
        this.showRowActionsMenu = new EventEmitter();
        this.executeRowAction = new EventEmitter();
        this.loading = false;
        this.noPermission = false;
        this.rowMenuCacheEnabled = true;
        this.resolverFn = null;
        this.allowFiltering = false;
        this.isSelectAllIndeterminate = false;
        this.isSelectAllChecked = false;
        this.selection = new Array();
        this.fakeRows = [];
        this.rowMenuCache = {};
        this.subscriptions = [];
        if (differs) {
            this.differ = differs.find([]).create(null);
        }
        this.click$ = new Observable((observer) => this.clickObserver = observer)
            .pipe(share());
    }
    onKeydown(event) {
        this.keyManager.onKeydown(event);
    }
    ngAfterContentInit() {
        if (this.columnList) {
            this.subscriptions.push(this.columnList.columns.changes.subscribe(() => {
                this.setTableSchema();
            }));
        }
        this.datatableLayoutFix();
        this.setTableSchema();
    }
    ngAfterViewInit() {
        this.keyManager = new FocusKeyManager(this.rowsList)
            .withWrap()
            .skipPredicate(item => item.disabled);
    }
    ngOnChanges(changes) {
        this.initAndSubscribeClickStream();
        const dataChanges = changes['data'];
        const rowChanges = changes['rows'];
        const columnChanges = changes['columns'];
        if (this.isPropertyChanged(dataChanges) || this.isPropertyChanged(rowChanges) || this.isPropertyChanged(columnChanges)) {
            if (this.isTableEmpty()) {
                this.initTable();
            }
            else {
                if (dataChanges) {
                    this.data = changes['data'].currentValue;
                    this.resetSelection();
                }
                else if (rowChanges) {
                    this.setTableRows(changes['rows'].currentValue);
                    this.setTableSorting(this.sorting);
                }
                else {
                    this.setTableColumns(changes['columns'].currentValue);
                }
            }
            return;
        }
        if (changes.selectionMode && !changes.selectionMode.isFirstChange()) {
            this.resetSelection();
            this.emitRowSelectionEvent('row-unselect', null);
        }
        if (this.isPropertyChanged(changes['sorting'])) {
            this.setTableSorting(changes['sorting'].currentValue);
        }
        if (this.isPropertyChanged(changes['display'])) {
            this.datatableLayoutFix();
        }
    }
    isColumnSortActive(column) {
        if (!column || !this.data.getSorting()) {
            return false;
        }
        return column.key === this.data.getSorting().key;
    }
    ngDoCheck() {
        const changes = this.differ.diff(this.rows);
        if (changes) {
            this.setTableRows(this.rows);
        }
    }
    isPropertyChanged(property) {
        return !!(property && property.currentValue);
    }
    convertToRowsData(rows) {
        return rows.map((row) => new ObjectDataRow(row, row.isSelected));
    }
    convertToColumnsData(columns) {
        return columns.map((column) => new ObjectDataColumn(column));
    }
    convertToDataSorting(sorting) {
        if (sorting && sorting.length > 0) {
            return new DataSorting(sorting[0], sorting[1]);
        }
        return null;
    }
    initAndSubscribeClickStream() {
        this.unsubscribeClickStream();
        const singleClickStream = this.click$
            .pipe(buffer(this.click$.pipe(debounceTime(250))), map((list) => list), filter((x) => x.length === 1));
        this.singleClickStreamSub = singleClickStream.subscribe((dataRowEvents) => {
            const event = dataRowEvents[0];
            this.handleRowSelection(event.value, event.event);
            this.rowClick.emit(event);
            if (!event.defaultPrevented) {
                this.elementRef.nativeElement.dispatchEvent(new CustomEvent('row-click', {
                    detail: event,
                    bubbles: true
                }));
            }
        });
        const multiClickStream = this.click$
            .pipe(buffer(this.click$.pipe(debounceTime(250))), map((list) => list), filter((x) => x.length >= 2));
        this.multiClickStreamSub = multiClickStream.subscribe((dataRowEvents) => {
            const event = dataRowEvents[0];
            this.rowDblClick.emit(event);
            if (!event.defaultPrevented) {
                this.elementRef.nativeElement.dispatchEvent(new CustomEvent('row-dblclick', {
                    detail: event,
                    bubbles: true
                }));
            }
        });
    }
    unsubscribeClickStream() {
        if (this.singleClickStreamSub) {
            this.singleClickStreamSub.unsubscribe();
            this.singleClickStreamSub = null;
        }
        if (this.multiClickStreamSub) {
            this.multiClickStreamSub.unsubscribe();
            this.multiClickStreamSub = null;
        }
    }
    initTable() {
        const runtimeColumns = this.getRuntimeColumns();
        this.data = new ObjectDataTableAdapter(this.rows, runtimeColumns);
        this.setTableSorting(this.sorting);
        this.resetSelection();
        this.rowMenuCache = {};
    }
    isTableEmpty() {
        return this.data === undefined || this.data === null;
    }
    setTableRows(rows) {
        if (this.data) {
            this.resetSelection();
            const rowsData = this.convertToRowsData(rows);
            this.data.setRows(rowsData);
        }
    }
    setTableColumns(columns) {
        if (this.data) {
            this.resetSelection();
            const columnsData = this.convertToColumnsData(columns);
            this.data.setColumns(columnsData);
        }
    }
    getRuntimeColumns() {
        return [
            ...(this.columns || []),
            ...this.getSchemaFromHtml()
        ];
    }
    setTableSchema() {
        const columns = this.getRuntimeColumns();
        if (this.data && columns.length > 0) {
            this.data.setColumns(columns);
        }
    }
    setTableSorting(sorting) {
        if (this.data) {
            this.data.setSorting(this.convertToDataSorting(sorting));
        }
    }
    getSchemaFromHtml() {
        let schema = [];
        if (this.columnList && this.columnList.columns && this.columnList.columns.length > 0) {
            schema = this.columnList.columns.map((c) => c);
        }
        return schema;
    }
    onRowClick(row, mouseEvent) {
        if (mouseEvent) {
            mouseEvent.preventDefault();
        }
        if (row) {
            const rowIndex = this.data.getRows().indexOf(row) + (this.isHeaderListVisible() ? 1 : 0);
            this.keyManager.setActiveItem(rowIndex);
            const dataRowEvent = new DataRowEvent(row, mouseEvent, this);
            this.clickObserver.next(dataRowEvent);
        }
    }
    onEnterKeyPressed(row, e) {
        if (row) {
            this.handleRowSelection(row, e);
        }
    }
    isHeaderListVisible() {
        return this.isHeaderVisible() && this.display === DisplayMode.List;
    }
    handleRowSelection(row, e) {
        if (this.data) {
            if (this.isSingleSelectionMode()) {
                this.resetSelection();
                this.selectRow(row, true);
                this.emitRowSelectionEvent('row-select', row);
            }
            if (this.isMultiSelectionMode()) {
                const modifier = e && (e.metaKey || e.ctrlKey);
                let newValue;
                if (this.selection.length === 1) {
                    newValue = !row.isSelected;
                }
                else {
                    newValue = modifier ? !row.isSelected : true;
                }
                const domEventName = newValue ? 'row-select' : 'row-unselect';
                if (!modifier) {
                    this.resetSelection();
                }
                this.selectRow(row, newValue);
                this.emitRowSelectionEvent(domEventName, row);
            }
        }
    }
    resetSelection() {
        if (this.data) {
            const rows = this.data.getRows();
            if (rows && rows.length > 0) {
                rows.forEach((r) => r.isSelected = false);
            }
            this.selection = [];
        }
        this.isSelectAllChecked = false;
    }
    onRowDblClick(row, event) {
        if (event) {
            event.preventDefault();
        }
        const dataRowEvent = new DataRowEvent(row, event, this);
        this.clickObserver.next(dataRowEvent);
    }
    onRowEnterKeyDown(row, keyboardEvent) {
        if (keyboardEvent.key === 'Enter') {
            this.onKeyboardNavigate(row, keyboardEvent);
        }
    }
    onRowKeyUp(row, keyboardEvent) {
        const event = new CustomEvent('row-keyup', {
            detail: {
                row: row,
                keyboardEvent: keyboardEvent,
                sender: this
            },
            bubbles: true
        });
        this.elementRef.nativeElement.dispatchEvent(event);
        if (event.defaultPrevented) {
            keyboardEvent.preventDefault();
        }
    }
    onKeyboardNavigate(row, keyboardEvent) {
        if (keyboardEvent) {
            keyboardEvent.preventDefault();
        }
        const event = new DataRowEvent(row, keyboardEvent, this);
        this.rowDblClick.emit(event);
        this.elementRef.nativeElement.dispatchEvent(new CustomEvent('row-dblclick', {
            detail: event,
            bubbles: true
        }));
    }
    onColumnHeaderClick(column) {
        var _a;
        if (column && column.sortable) {
            const current = this.data.getSorting();
            let newDirection = 'asc';
            if (current && column.key === current.key) {
                newDirection = ((_a = current.direction) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === 'asc' ? 'desc' : 'asc';
            }
            this.sorting = [column.key, newDirection];
            this.data.setSorting(new DataSorting(column.key, newDirection));
            this.emitSortingChangedEvent(column.key, column.sortingKey, newDirection);
        }
        this.keyManager.updateActiveItem(0);
    }
    onSelectAllClick(matCheckboxChange) {
        this.isSelectAllChecked = matCheckboxChange.checked;
        this.isSelectAllIndeterminate = false;
        if (this.multiselect) {
            const rows = this.data.getRows();
            if (rows && rows.length > 0) {
                for (let i = 0; i < rows.length; i++) {
                    this.selectRow(rows[i], matCheckboxChange.checked);
                }
            }
            const domEventName = matCheckboxChange.checked ? 'row-select' : 'row-unselect';
            const row = this.selection.length > 0 ? this.selection[0] : null;
            this.emitRowSelectionEvent(domEventName, row);
        }
    }
    onCheckboxChange(row, event) {
        const newValue = event.checked;
        this.selectRow(row, newValue);
        const domEventName = newValue ? 'row-select' : 'row-unselect';
        this.emitRowSelectionEvent(domEventName, row);
        this.checkSelectAllCheckboxState();
    }
    checkSelectAllCheckboxState() {
        if (this.multiselect) {
            let numberOfSelectedRows = 0;
            const rows = this.data.getRows();
            rows.forEach((row) => {
                if (row.isSelected) {
                    numberOfSelectedRows++;
                }
            });
            if (numberOfSelectedRows === rows.length) {
                this.isSelectAllChecked = true;
                this.isSelectAllIndeterminate = false;
            }
            else if (numberOfSelectedRows > 0 && numberOfSelectedRows < rows.length) {
                this.isSelectAllChecked = false;
                this.isSelectAllIndeterminate = true;
            }
            else {
                this.isSelectAllChecked = false;
                this.isSelectAllIndeterminate = false;
            }
        }
    }
    onImageLoadingError(event, row) {
        if (event) {
            const element = event.target;
            if (this.fallbackThumbnail) {
                element.src = this.fallbackThumbnail;
            }
            else {
                element.src = row.imageErrorResolver(event);
            }
        }
    }
    isIconValue(row, col) {
        if (row && col) {
            const value = row.getValue(col.key);
            return value && value.startsWith('material-icons://');
        }
        return false;
    }
    asIconValue(row, col) {
        if (this.isIconValue(row, col)) {
            const value = row.getValue(col.key) || '';
            return value.replace('material-icons://', '');
        }
        return null;
    }
    iconAltTextKey(value) {
        return value ? 'ICONS.' + value.substring(value.lastIndexOf('/') + 1).replace(/\.[a-z]+/, '') : '';
    }
    isColumnSorted(col, direction) {
        if (col && direction) {
            const sorting = this.data.getSorting();
            return sorting && sorting.key === col.key && sorting.direction.toLocaleLowerCase() === direction;
        }
        return false;
    }
    getContextMenuActions(row, col) {
        const event = new DataCellEvent(row, col, []);
        this.showRowContextMenu.emit(event);
        return event.value.actions;
    }
    getRowActions(row, col) {
        const id = row.getValue('id');
        if (!this.rowMenuCache[id]) {
            const event = new DataCellEvent(row, col, []);
            this.showRowActionsMenu.emit(event);
            if (!this.rowMenuCacheEnabled) {
                return this.getVisibleActions(event.value.actions);
            }
            this.rowMenuCache[id] = event.value.actions;
        }
        return this.getVisibleActions(this.rowMenuCache[id]);
    }
    getVisibleActions(actions) {
        return actions.filter((action) => action.visible || action.visible === undefined);
    }
    onExecuteRowAction(row, action) {
        if (action.disabled || action.disabled) {
            event.stopPropagation();
        }
        else {
            this.executeRowAction.emit(new DataRowActionEvent(row, action));
        }
    }
    getHideActionsWithoutHoverClass(actionsMenuTrigger) {
        return { 'adf-datatable-hide-actions-without-hover': this.actionsVisibleOnHover && !actionsMenuTrigger.menuOpen };
    }
    rowAllowsDrop(row) {
        return row.isDropTarget === true;
    }
    hasSelectionMode() {
        return this.isSingleSelectionMode() || this.isMultiSelectionMode();
    }
    isSingleSelectionMode() {
        return this.selectionMode && this.selectionMode.toLowerCase() === 'single';
    }
    isMultiSelectionMode() {
        return this.selectionMode && this.selectionMode.toLowerCase() === 'multiple';
    }
    getRowStyle(row) {
        row.cssClass = row.cssClass ? row.cssClass : '';
        this.rowStyleClass = this.rowStyleClass ? this.rowStyleClass : '';
        return `${row.cssClass} ${this.rowStyleClass}`;
    }
    getSortingKey() {
        if (this.data.getSorting()) {
            return this.data.getSorting().key;
        }
        return null;
    }
    selectRow(row, value) {
        if (row) {
            row.isSelected = value;
            const idx = (row === null || row === void 0 ? void 0 : row.id) ? this.findSelectionById(row.id) : this.selection.indexOf(row);
            if (value) {
                if (idx < 0) {
                    this.selection.push(row);
                }
            }
            else {
                if (idx > -1) {
                    this.selection.splice(idx, 1);
                }
            }
        }
    }
    findSelectionById(id) {
        return this.selection.findIndex(selection => (selection === null || selection === void 0 ? void 0 : selection.id) === id);
    }
    getCellTooltip(row, col) {
        if (row && col && col.formatTooltip) {
            const result = col.formatTooltip(row, col);
            if (result) {
                return result;
            }
        }
        return null;
    }
    getSortableColumns() {
        return this.data.getColumns().filter((column) => {
            return column.sortable === true;
        });
    }
    isEmpty() {
        return this.data.getRows().length === 0;
    }
    isHeaderVisible() {
        let headerVisibility;
        if (this.showHeader === ShowHeaderMode.Data) {
            headerVisibility = !this.loading && !this.noPermission && !this.isEmpty();
        }
        else if (this.showHeader === ShowHeaderMode.Always) {
            headerVisibility = !this.loading && !this.noPermission;
        }
        else if (this.showHeader === ShowHeaderMode.Never) {
            headerVisibility = false;
        }
        return headerVisibility;
    }
    isStickyHeaderEnabled() {
        return this.stickyHeader && this.isHeaderVisible();
    }
    emitRowSelectionEvent(name, row) {
        const domEvent = new CustomEvent(name, {
            detail: {
                row: row,
                selection: this.selection
            },
            bubbles: true
        });
        this.elementRef.nativeElement.dispatchEvent(domEvent);
    }
    emitSortingChangedEvent(key, sortingKey, direction) {
        const domEvent = new CustomEvent('sorting-changed', {
            detail: {
                key,
                sortingKey,
                direction
            },
            bubbles: true
        });
        this.elementRef.nativeElement.dispatchEvent(domEvent);
    }
    ngOnDestroy() {
        this.unsubscribeClickStream();
        this.subscriptions.forEach((s) => s.unsubscribe());
        this.subscriptions = [];
        if (this.dataRowsChanged) {
            this.dataRowsChanged.unsubscribe();
            this.dataRowsChanged = null;
        }
    }
    datatableLayoutFix() {
        const maxGalleryRows = 25;
        if (this.display === 'gallery') {
            for (let i = 0; i < maxGalleryRows; i++) {
                this.fakeRows.push('');
            }
        }
        else {
            this.fakeRows = [];
        }
    }
    getNameColumnValue() {
        return this.data.getColumns().find((el) => {
            return el.key.includes('name');
        });
    }
    getAutomationValue(row) {
        const name = this.getNameColumnValue();
        return name ? row.getValue(name.key) : '';
    }
    getAriaSort(column) {
        if (!this.isColumnSortActive(column)) {
            return 'ADF-DATATABLE.ACCESSIBILITY.SORT_NONE';
        }
        return this.isColumnSorted(column, 'asc') ?
            'ADF-DATATABLE.ACCESSIBILITY.SORT_ASCENDING' :
            'ADF-DATATABLE.ACCESSIBILITY.SORT_DESCENDING';
    }
    getSortLiveAnnouncement(column) {
        if (!this.isColumnSortActive(column)) {
            return 'ADF-DATATABLE.ACCESSIBILITY.SORT_DEFAULT';
        }
        return this.isColumnSorted(column, 'asc') ?
            'ADF-DATATABLE.ACCESSIBILITY.SORT_ASCENDING_BY' :
            'ADF-DATATABLE.ACCESSIBILITY.SORT_DESCENDING_BY';
    }
}
DataTableComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-datatable',
                template: "<div\n    role=\"grid\"\n    *ngIf=\"data\" class=\"adf-full-width\"\n    [class.adf-datatable-card]=\"display === 'gallery'\"\n    [class.adf-datatable-list]=\"display === 'list'\"\n    [class.adf-sticky-header]=\"isStickyHeaderEnabled()\"\n    [class.adf-datatable--empty]=\"(isEmpty() && !isHeaderVisible()) || loading\"\n    [class.adf-datatable--empty--header-visible]=\"isEmpty() && isHeaderVisible()\">\n    <div *ngIf=\"isHeaderVisible()\" class=\"adf-datatable-header\" role=\"rowgroup\" [ngClass]=\"{ 'adf-sr-only': !isHeaderVisible() }\">\n        <adf-datatable-row\n            data-automation-id=\"datatable-row-header\"\n            [disabled]=\"!isHeaderVisible()\"\n            class=\"adf-datatable-row\"\n            *ngIf=\"display === 'list'\"\n            role=\"row\">\n            <!-- Actions (left) -->\n            <div *ngIf=\"actions && actionsPosition === 'left'\" class=\"adf-actions-column adf-datatable-cell-header\">\n                <span class=\"adf-sr-only\">{{ 'ADF-DATATABLE.ACCESSIBILITY.ACTIONS' | translate }}</span>\n            </div>\n            <!-- Columns -->\n            <div *ngIf=\"multiselect\" class=\"adf-datatable-cell-header adf-datatable-checkbox\">\n                <mat-checkbox [indeterminate]=\"isSelectAllIndeterminate\" [checked]=\"isSelectAllChecked\" (change)=\"onSelectAllClick($event)\" class=\"adf-checkbox-sr-only\">{{ 'ADF-DATATABLE.ACCESSIBILITY.SELECT_ALL' | translate }}</mat-checkbox>\n            </div>\n            <div class=\"adf-datatable-cell--{{col.type || 'text'}} {{col.cssClass}} adf-datatable-cell-header\"\n                 *ngFor=\"let col of data.getColumns()\"\n                 [class.adf-sortable]=\"col.sortable\"\n                 [attr.data-automation-id]=\"'auto_id_' + col.key\"\n                 [class.adf-datatable__header--sorted-asc]=\"isColumnSorted(col, 'asc')\"\n                 [class.adf-datatable__header--sorted-desc]=\"isColumnSorted(col, 'desc')\"\n                 (click)=\"onColumnHeaderClick(col)\"\n                 (keyup.enter)=\"onColumnHeaderClick(col)\"\n                 role=\"columnheader\"\n                 [attr.tabindex]=\"isHeaderVisible() ? 0 : null\"\n                 [attr.aria-sort]=\"col.sortable ? (getAriaSort(col) | translate) : null\"\n                 adf-drop-zone dropTarget=\"header\" [dropColumn]=\"col\">\n                <ng-container *ngIf=\"!col.header\">\n                    <span *ngIf=\"col.title\" class=\"adf-datatable-cell-value\">{{ col.title | translate}}</span>\n                    <span *ngIf=\"col.title && col.sortable\" class=\"adf-sr-only\" aria-live=\"polite\">{{ getSortLiveAnnouncement(col) | translate: { string: col.title | translate } }}</span>\n                    <ng-template *ngIf=\"allowFiltering\" [ngTemplateOutlet]=\"headerFilterTemplate\" [ngTemplateOutletContext]=\"{$implicit: col}\"></ng-template>\n                </ng-container>\n                <ng-template *ngIf=\"col.header\" [ngTemplateOutlet]=\"col.header\" [ngTemplateOutletContext]=\"{$implicit: col}\"></ng-template>\n            </div>\n            <!-- Actions (right) -->\n            <div *ngIf=\"actions && actionsPosition === 'right'\" class=\"adf-actions-column adf-datatable-cell-header adf-datatable__actions-cell\">\n                <span class=\"adf-sr-only\">{{ 'ADF-DATATABLE.ACCESSIBILITY.ACTIONS' | translate }}</span>\n            </div>\n        </adf-datatable-row>\n        <mat-form-field *ngIf=\"display === 'gallery' && isHeaderVisible()\">\n            <mat-select [value]=\"getSortingKey()\" [attr.data-automation-id]=\"'grid-view-sorting'\">\n                <mat-option *ngFor=\"let col of getSortableColumns()\"\n                            [value]=\"col.key\"\n                            [attr.data-automation-id]=\"'grid-view-sorting-'+col.title\"\n                            (click)=\"onColumnHeaderClick(col)\"\n                            (keyup.enter)=\"onColumnHeaderClick(col)\">\n                    {{ col.title | translate}}\n                </mat-option>\n            </mat-select>\n        </mat-form-field>\n    </div>\n\n    <div class=\"adf-datatable-body\" role=\"rowgroup\">\n        <ng-container *ngIf=\"!loading && !noPermission\">\n            <adf-datatable-row *ngFor=\"let row of data.getRows(); let idx = index\"\n                [row]=\"row\"\n                (select)=\"onEnterKeyPressed(row, $event)\"\n                (keyup)=\"onRowKeyUp(row, $event)\"\n                (keydown)=\"onRowEnterKeyDown(row, $event)\"\n                [adf-upload]=\"rowAllowsDrop(row)\"\n                [adf-upload-data]=\"row\"\n                [ngStyle]=\"rowStyle\"\n                [ngClass]=\"getRowStyle(row)\"\n                [attr.data-automation-id]=\"'datatable-row-' + idx\">\n                <!-- Actions (left) -->\n                <div *ngIf=\"actions && actionsPosition === 'left'\" role=\"gridcell\" class=\"adf-datatable-cell\">\n                    <button mat-icon-button [matMenuTriggerFor]=\"menu\" #actionsMenuTrigger=\"matMenuTrigger\"\n                            [ngClass]=\"getHideActionsWithoutHoverClass(actionsMenuTrigger)\"\n                            [title]=\"'ADF-DATATABLE.CONTENT-ACTIONS.TOOLTIP' | translate\"\n                            [attr.id]=\"'action_menu_left_' + idx\"\n                            [attr.data-automation-id]=\"'action_menu_' + idx\">\n                        <mat-icon>more_vert</mat-icon>\n                    </button>\n                    <mat-menu #menu=\"matMenu\">\n                        <button mat-menu-item *ngFor=\"let action of getRowActions(row)\"\n                                [attr.data-automation-id]=\"action.title\"\n                                [disabled]=\"action.disabled\"\n                                (click)=\"onExecuteRowAction(row, action)\">\n                            <mat-icon *ngIf=\"action.icon\">{{ action.icon }}</mat-icon>\n                            <span>{{ action.title | translate }}</span>\n                        </button>\n                    </mat-menu>\n                </div>\n\n                <div *ngIf=\"multiselect\" class=\"adf-datatable-cell adf-datatable-checkbox\">\n                    <mat-checkbox\n                        [checked]=\"row.isSelected\"\n                        [attr.aria-checked]=\"row.isSelected\"\n                        role=\"checkbox\"\n                        (change)=\"onCheckboxChange(row, $event)\"\n                        class=\"adf-checkbox-sr-only\">\n                        {{ 'ADF-DATATABLE.ACCESSIBILITY.SELECT_FILE' | translate }}\n                    </mat-checkbox>\n                </div>\n                <div *ngFor=\"let col of data.getColumns()\"\n                     role=\"gridcell\"\n                     class=\"adf-datatable-cell adf-datatable-cell--{{col.type || 'text'}} {{col.cssClass}}\"\n                     [attr.title]=\"col.title | translate\"\n                     [attr.data-automation-id]=\"getAutomationValue(row)\"\n                     [attr.aria-selected]=\"row.isSelected ? true : false\"\n                     [attr.aria-label]=\"col.title ? (col.title | translate) : null\"\n                     (click)=\"onRowClick(row, $event)\"\n                     (keydown.enter)=\"onEnterKeyPressed(row, $any($event))\"\n                     [adf-context-menu]=\"getContextMenuActions(row, col)\"\n                     [adf-context-menu-enabled]=\"contextMenu\"\n                     adf-drop-zone dropTarget=\"cell\" [dropColumn]=\"col\" [dropRow]=\"row\">\n                    <div *ngIf=\"!col.template\" class=\"adf-datatable-cell-container\">\n                        <ng-container [ngSwitch]=\"col.type\">\n                            <div *ngSwitchCase=\"'image'\" class=\"adf-cell-value\">\n                                <mat-icon *ngIf=\"isIconValue(row, col); else no_iconvalue\">{{ asIconValue(row, col) }}\n                                </mat-icon>\n                                <ng-template #no_iconvalue>\n                                    <mat-icon class=\"adf-datatable-selected\"\n                                              *ngIf=\"row.isSelected && !multiselect; else no_selected_row\" svgIcon=\"selected\">\n                                    </mat-icon>\n                                    <ng-template #no_selected_row>\n                                        <img class=\"adf-datatable-center-img-ie\"\n                                            [attr.aria-label]=\" (data.getValue(row, col) | fileType) === 'disable' ?\n                                                ('ADF-DATATABLE.ACCESSIBILITY.ICON_DISABLED' | translate) :\n                                                'ADF-DATATABLE.ACCESSIBILITY.ICON_TEXT' | translate:{\n                                                    type: 'ADF-DATATABLE.FILE_TYPE.' + (data.getValue(row, col) | fileType | uppercase) | translate\n                                                }\"\n                                            [attr.alt]=\" (data.getValue(row, col) | fileType) === 'disable' ?\n                                                ('ADF-DATATABLE.ACCESSIBILITY.ICON_DISABLED' | translate) :\n                                                'ADF-DATATABLE.ACCESSIBILITY.ICON_TEXT' | translate:{\n                                                        type: 'ADF-DATATABLE.FILE_TYPE.' + (data.getValue(row, col) | fileType | uppercase) | translate\n                                                }\"\n                                            src=\"{{ data.getValue(row, col) }}\"\n                                            (error)=\"onImageLoadingError($event, row)\">\n                                    </ng-template>\n                                </ng-template>\n                            </div>\n                            <div *ngSwitchCase=\"'icon'\" class=\"adf-cell-value\">\n                                <mat-icon>{{ data.getValue(row, col) }}</mat-icon>\n                            </div>\n                            <div *ngSwitchCase=\"'date'\" class=\"adf-cell-value\" [attr.tabindex]=\"data.getValue(row, col, resolverFn)? 0 : -1\"\n                                 [attr.data-automation-id]=\"'date_' + (data.getValue(row, col, resolverFn) | adfLocalizedDate: 'medium') \">\n                                <adf-date-cell class=\"adf-datatable-center-date-column-ie\"\n                                    [data]=\"data\"\n                                    [column]=\"col\"\n                                    [row]=\"row\"\n                                    [resolverFn]=\"resolverFn\"\n                                    [tooltip]=\"getCellTooltip(row, col)\">\n                                </adf-date-cell>\n                            </div>\n                            <div *ngSwitchCase=\"'location'\" [attr.tabindex]=\"data.getValue(row, col, resolverFn)? 0 : -1\"  class=\"adf-cell-value\"\n                                 [attr.data-automation-id]=\"'location' + data.getValue(row, col, resolverFn)\">\n                                <adf-location-cell\n                                    [data]=\"data\"\n                                    [column]=\"col\"\n                                    [row]=\"row\"\n                                    [resolverFn]=\"resolverFn\"\n                                    [tooltip]=\"getCellTooltip(row, col)\">\n                                </adf-location-cell>\n                            </div>\n                            <div *ngSwitchCase=\"'fileSize'\" [attr.tabindex]=\"data.getValue(row, col, resolverFn)? 0 : -1\" class=\"adf-cell-value\"\n                                 [attr.data-automation-id]=\"'fileSize_' + data.getValue(row, col, resolverFn)\">\n                                <adf-filesize-cell class=\"adf-datatable-center-size-column-ie\"\n                                    [data]=\"data\"\n                                    [column]=\"col\"\n                                    [row]=\"row\"\n                                    [resolverFn]=\"resolverFn\"\n                                    [tooltip]=\"getCellTooltip(row, col)\">\n                                </adf-filesize-cell>\n                            </div>\n                            <div *ngSwitchCase=\"'text'\" [attr.tabindex]=\"data.getValue(row, col, resolverFn)? 0 : -1\"  class=\"adf-cell-value\"\n                                 [attr.data-automation-id]=\"'text_' + data.getValue(row, col, resolverFn)\">\n                                <adf-datatable-cell\n                                    [copyContent]=\"col.copyContent\"\n                                    [data]=\"data\"\n                                    [column]=\"col\"\n                                    [row]=\"row\"\n                                    [resolverFn]=\"resolverFn\"\n                                    [tooltip]=\"getCellTooltip(row, col)\">\n                                </adf-datatable-cell>\n                            </div>\n                            <div *ngSwitchCase=\"'json'\" [attr.tabindex]=\"data.getValue(row, col, resolverFn)? 0 : -1\" class=\"adf-cell-value\">\n                                <adf-json-cell\n                                    [editable]=\"col.editable\"\n                                    [data]=\"data\"\n                                    [column]=\"col\"\n                                    [resolverFn]=\"resolverFn\"\n                                    [row]=\"row\">\n                                </adf-json-cell>\n                            </div>\n                            <span *ngSwitchDefault class=\"adf-cell-value\">\n                    <!-- empty cell for unknown column type -->\n                    </span>\n                        </ng-container>\n                    </div>\n                    <div *ngIf=\"col.template\" class=\"adf-datatable-cell-container\">\n                        <div class=\"adf-cell-value\" [attr.tabindex]=\"col.focus ? 0 : null\">\n                            <ng-container\n                                [ngTemplateOutlet]=\"col.template\"\n                                [ngTemplateOutletContext]=\"{ $implicit: { data: data, row: row, col: col }, value: data.getValue(row, col, resolverFn) }\">\n                            </ng-container>\n                        </div>\n                    </div>\n                </div>\n\n                <!-- Actions (right) -->\n                <div *ngIf=\"actions && actionsPosition === 'right'\"\n                     role=\"gridcell\"\n                     class=\"adf-datatable-cell adf-datatable__actions-cell adf-datatable-center-actions-column-ie\">\n                    <button mat-icon-button [matMenuTriggerFor]=\"menu\" #actionsMenuTrigger=\"matMenuTrigger\"\n                            [ngClass]=\"getHideActionsWithoutHoverClass(actionsMenuTrigger)\"\n                            [attr.aria-label]=\"'ADF-DATATABLE.ACCESSIBILITY.ROW_OPTION_BUTTON' | translate\"\n                            [title]=\"'ADF-DATATABLE.CONTENT-ACTIONS.TOOLTIP' | translate\"\n                            [attr.id]=\"'action_menu_right_' + idx\"\n                            [attr.data-automation-id]=\"'action_menu_' + idx\">\n                        <mat-icon>more_vert</mat-icon>\n                    </button>\n                    <mat-menu #menu=\"matMenu\">\n                        <button mat-menu-item *ngFor=\"let action of getRowActions(row)\"\n                                [attr.data-automation-id]=\"action.title\"\n                                [attr.aria-label]=\"action.title | translate\"\n                                [disabled]=\"action.disabled\"\n                                (click)=\"onExecuteRowAction(row, action)\">\n                            <mat-icon *ngIf=\"action.icon\">{{ action.icon }}</mat-icon>\n                            <span>{{ action.title | translate }}</span>\n                        </button>\n                    </mat-menu>\n                </div>\n            </adf-datatable-row>\n            <div *ngIf=\"isEmpty()\"\n                 role=\"row\"\n                 [class.adf-datatable-row]=\"display === 'list'\"\n                 [class.adf-datatable-card-empty]=\"display === 'gallery'\">\n                <div class=\"adf-no-content-container adf-datatable-cell\" role=\"gridcell\">\n                    <ng-template *ngIf=\"noContentTemplate\"\n                                 ngFor [ngForOf]=\"[data]\"\n                                 [ngForTemplate]=\"noContentTemplate\">\n                    </ng-template>\n                    <ng-content select=\"adf-empty-list\"></ng-content>\n                </div>\n            </div>\n            <div *ngFor=\"let row of fakeRows\"\n                 class=\"adf-datatable-row adf-datatable-row-empty-card\">\n            </div>\n        </ng-container>\n        <div *ngIf=\"!loading && noPermission\"\n             role=\"row\"\n             [class.adf-datatable-row]=\"display === 'list'\"\n             [class.adf-datatable-card-permissions]=\"display === 'gallery'\"\n             class=\"adf-no-permission__row\">\n            <div class=\"adf-no-permission__cell adf-no-content-container adf-datatable-cell\">\n                <ng-template *ngIf=\"noPermissionTemplate\"\n                             ngFor [ngForOf]=\"[data]\"\n                             [ngForTemplate]=\"noPermissionTemplate\">\n                </ng-template>\n            </div>\n        </div>\n        <div *ngIf=\"loading\"\n             [class.adf-datatable-row]=\"display === 'list'\"\n             [class.adf-datatable-card-loading]=\"display === 'gallery'\">\n            <div class=\"adf-no-content-container adf-datatable-cell\">\n                <ng-template *ngIf=\"loadingTemplate\"\n                             ngFor [ngForOf]=\"[data]\"\n                             [ngForTemplate]=\"loadingTemplate\">\n                </ng-template>\n            </div>\n        </div>\n    </div>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-datatable' },
                styles: [".adf-datatable{height:100%;overflow-y:scroll}.adf-datatable .adf-full-width{width:100%}.adf-datatable-card{border:1px solid var(--theme-fg-divider)}.adf-datatable-card .adf-datatable-body{align-content:flex-start;align-items:flex-start;display:flex;flex-flow:row wrap;justify-content:space-evenly;width:100%}.adf-datatable-card .adf-datatable-body .adf-datatable-row{display:flex;flex:0 1 24%;flex-direction:column;height:200px;margin:6px;max-width:288px!important;min-width:288px!important;overflow:hidden!important;padding:15px;position:relative;transition:all .3s ease;transition:box-shadow .28s cubic-bezier(.4,0,.2,1);width:288px!important}.adf-datatable-card .adf-datatable-body .adf-datatable-row:not([class*=mat-elevation-z]){box-shadow:0 3px 1px -2px rgba(0,0,0,.2),0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12)}.adf-datatable-card .adf-datatable-body .adf-datatable-row-empty-card{height:0!important;margin-bottom:0;margin-top:0;padding-bottom:0;padding-top:0}.adf-datatable-card .adf-datatable-body .adf-is-selected{background:var(--adf-datatable-selected-color);padding-bottom:31px}.adf-datatable-card .adf-datatable-body .adf-datatable-card-permission{min-height:250px;width:100%}.adf-datatable-card .adf-datatable-body .adf-datatable-card-permission .adf-datatable-cell{height:240px!important}.adf-datatable-card .adf-datatable-body .adf-datatable-card-loading{min-height:250px;width:100%}.adf-datatable-card .adf-datatable-body .adf-datatable-card-loading .adf-datatable-cell{height:240px!important}.adf-datatable-card .adf-datatable-body .adf-datatable-card-empty{min-height:380px;width:100%}.adf-datatable-card .adf-datatable-body .adf-datatable-card-empty .adf-datatable-cell{height:370px!important}.adf-datatable-card .adf-datatable-body .adf-datatable-cell--image{margin-left:8px}.adf-datatable-card .adf-datatable-body .adf-datatable-cell{flex:0 1 24%;height:136px!important;outline:none;overflow:hidden;text-align:left;text-overflow:ellipsis;white-space:nowrap}.adf-datatable-card .adf-datatable-body .adf-datatable-cell:before{color:var(--theme-text-color);content:attr(title);float:left;margin-left:10px;overflow:hidden;text-align:left;text-overflow:ellipsis;white-space:nowrap;width:140px}.adf-datatable-card .adf-datatable-body .adf-datatable-cell .adf-datatable-cell-value{display:block;overflow:hidden;text-overflow:ellipsis}.adf-datatable-card .adf-datatable-body .adf-datatable__actions-cell{height:42px!important;position:absolute;right:0;top:4px;width:42px!important}.adf-datatable-card .adf-datatable-body .adf-datatable-row:not(:hover) .adf-datatable-hide-actions-without-hover{display:none}.adf-datatable-card .adf-datatable-body .adf-image-table-cell{border-bottom:1px solid var(--theme-fg-divider);margin:8px;overflow:visible;padding:4px}.adf-datatable-card .adf-datatable-body .adf-image-table-cell .adf-datatable-cell-container{float:left;width:42px}.adf-datatable-card .adf-datatable-body .adf-image-table-cell:after{content:attr(filename);float:left;margin:2px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:140px}.adf-datatable-card .adf-datatable-body .adf-datatable-checkbox{margin:8px}.adf-datatable-card .adf-datatable-header{float:right;margin-right:18px}.adf-datatable-list{background-color:var(--theme-card-bg-color);border:1px solid var(--theme-border-color);box-sizing:border-box;display:flex;flex-direction:column;overflow-x:auto}@media screen and (-ms-high-contrast:active),screen and (-ms-high-contrast:none){.adf-datatable-list .adf-datatable-center-size-column-ie{padding-top:17px}.adf-datatable-list .adf-datatable-center-actions-column-ie{padding-top:7px!important}.adf-datatable-list .adf-datatable-center-date-column-ie{position:relative!important}.adf-datatable-list .adf-datatable-center-date-column-ie .adf-datatable-cell-value{width:100%}.adf-datatable-list .adf-datatable-center-img-ie{height:56px;min-width:0;padding:0;width:24px}}.adf-datatable-list .adf-datatable-header{box-sizing:border-box;display:flex;flex-direction:column;min-width:100%;width:-webkit-fit-content;width:-moz-fit-content;width:fit-content}.adf-datatable-list .adf-datatable-cell{color:var(--theme-text-fg-color)}.adf-datatable-list .adf-datatable-row:focus,.adf-datatable-list .adf-datatable-row:hover{background-color:var(--theme-bg-hover-color)}.adf-datatable-list .adf-datatable-row:focus{outline:1px solid var(--theme-accent-color-a200);outline-offset:-1px}.adf-datatable-list .adf-datatable-row .adf-cell-value:focus,.adf-datatable-list .adf-datatable-row .adf-datatable-cell-header:focus{outline:1px solid var(--theme-accent-color-a200);outline-offset:-1px}.adf-datatable-list .adf-datatable-body{background-color:inherit;display:flex;flex-direction:column;min-width:100%;width:-webkit-fit-content;width:-moz-fit-content;width:fit-content}.adf-datatable-list .adf-datatable-body .adf-datatable-row{-webkit-touch-callout:none;-webkit-user-select:none;border-top:1px solid var(--theme-border-color);cursor:pointer;min-height:56px;transition-duration:.28s;transition-property:background-color;transition-timing-function:cubic-bezier(.4,0,.2,1);user-select:none}.adf-datatable-list .adf-datatable-body .adf-datatable-row.adf-is-selected,.adf-datatable-list .adf-datatable-body .adf-datatable-row.adf-is-selected:hover{background-color:var(--theme-selected-button-bg-color)}.adf-datatable-list .adf-datatable-body .adf-datatable-row:last-child{border-bottom:1px solid var(--theme-border-color)}.adf-datatable-list .adf-datatable-row{align-items:center;display:flex;padding-left:15px;padding-right:15px}.adf-datatable-list .adf-datatable-row .adf-datatable-checkbox{max-width:50px;width:50px}@media screen and (-ms-high-contrast:active),screen and (-ms-high-contrast:none){.adf-datatable-list .adf-datatable-row .adf-datatable-checkbox{padding-top:15px}}.adf-datatable-list .adf-datatable-cell,.adf-datatable-list .adf-datatable-cell-header{box-sizing:border-box;min-width:50px;text-align:left}.adf-datatable-list .adf-datatable-cell--text,.adf-datatable-list .adf-datatable-cell-header--text{position:relative;text-align:left}.adf-datatable-list .adf-datatable-cell--date,.adf-datatable-list .adf-datatable-cell-header--date{text-align:left}.adf-datatable-list .adf-datatable-cell--number,.adf-datatable-list .adf-datatable-cell-header--number{text-align:right}.adf-datatable-list .adf-datatable-cell--icon,.adf-datatable-list .adf-datatable-cell--image,.adf-datatable-list .adf-datatable-cell-header--icon,.adf-datatable-list .adf-datatable-cell-header--image{min-width:50px;padding-left:24px;padding-right:24px;text-align:left;width:50px}.adf-datatable-list .adf-datatable-cell--fileSize,.adf-datatable-list .adf-datatable-cell-header--fileSize{min-width:50px}.adf-datatable-list .adf-datatable-cell-header{-webkit-touch-callout:none;-webkit-user-select:none;box-sizing:border-box;color:var(--theme-text-fg-color);cursor:pointer;font-size:12px;font-weight:700;letter-spacing:0;line-height:24px;min-height:56px!important;padding-bottom:8px;padding-top:12px!important;position:relative;text-overflow:ellipsis;user-select:none;vertical-align:bottom}.adf-datatable-list .adf-datatable-cell-header.adf-sortable{-webkit-touch-callout:none;-webkit-user-select:none;align-items:center;display:flex;user-select:none}.adf-datatable-list .adf-datatable-cell-header.adf-sortable:hover{cursor:pointer}.adf-datatable-list .adf-datatable-cell-header.adf-datatable__header--sorted-asc,.adf-datatable-list .adf-datatable-cell-header.adf-datatable__header--sorted-desc{color:var(--theme-text-fg-color)}.adf-datatable-list .adf-datatable-cell-header.adf-datatable__header--sorted-asc:before,.adf-datatable-list .adf-datatable-cell-header.adf-datatable__header--sorted-desc:before{-webkit-font-feature-settings:\"liga\";-webkit-font-smoothing:antialiased;content:\"\\e5d8\";display:inline-block;font-family:Material Icons;font-feature-settings:\"liga\";font-size:24px;font-size:16px;font-style:normal;font-weight:400;left:5px;letter-spacing:normal;line-height:1;position:relative;right:5px;text-transform:none;vertical-align:sub;word-wrap:normal}.adf-datatable-list .adf-datatable-cell-header.adf-datatable__header--sorted-desc:before{content:\"\\e5db\"}.adf-datatable-list .adf-datatable-cell-header.adf-datatable-cell--fileSize.adf-datatable__header--sorted-asc:before,.adf-datatable-list .adf-datatable-cell-header.adf-datatable-cell--fileSize.adf-datatable__header--sorted-desc:before{left:-3px;right:-3px}.adf-datatable-list .adf-datatable-cell-header.adf-datatable-checkbox{align-items:center;display:flex}.adf-datatable-list .adf-datatable-cell-header.adf-expand-cell-1,.adf-datatable-list .adf-datatable-cell.adf-expand-cell-1{flex-grow:1}.adf-datatable-list .adf-datatable-cell-header.adf-expand-cell-2,.adf-datatable-list .adf-datatable-cell.adf-expand-cell-2{flex-grow:2}.adf-datatable-list .adf-datatable-cell-header.adf-expand-cell-3,.adf-datatable-list .adf-datatable-cell.adf-expand-cell-3{flex-grow:3}.adf-datatable-list .adf-datatable-cell-header.adf-expand-cell-4,.adf-datatable-list .adf-datatable-cell.adf-expand-cell-4{flex-grow:4}.adf-datatable-list .adf-datatable-cell-header.adf-expand-cell-5,.adf-datatable-list .adf-datatable-cell.adf-expand-cell-5{flex-grow:5}.adf-datatable-list .adf-datatable-cell-header.adf-no-grow-cell,.adf-datatable-list .adf-datatable-cell.adf-no-grow-cell{flex-grow:0;min-width:100px}.adf-datatable-list .adf-datatable-cell,.adf-datatable-list .adf-datatable-cell-header{align-items:center;display:flex;flex:1;min-height:inherit;padding:0}.adf-datatable-list .adf-datatable-cell-header .adf-datatable-cell-container,.adf-datatable-list .adf-datatable-cell .adf-datatable-cell-container{align-items:center;display:flex;min-height:inherit;overflow:hidden;width:100%}.adf-datatable-list .adf-datatable-cell-header .adf-datatable-cell-value,.adf-datatable-list .adf-datatable-cell .adf-datatable-cell-value{display:block;padding:10px;word-break:break-word}@media screen and (-ms-high-contrast:active),screen and (-ms-high-contrast:none){.adf-datatable-list .adf-datatable-cell-header .adf-datatable-cell-value,.adf-datatable-list .adf-datatable-cell .adf-datatable-cell-value{padding:17px 10px 10px}}.adf-datatable-list .adf-datatable-cell--fileSize .adf-datatable-cell-value,.adf-datatable-list .adf-datatable-cell-header--fileSize .adf-datatable-cell-value{padding:0 10px 0 0}.adf-datatable-list .adf-cell-value{align-items:center;display:flex;min-height:inherit;width:100%;word-break:break-all}.adf-datatable-list .adf-datatable-cell--image,.adf-datatable-list .adf-datatable__actions-cell{display:flex;max-width:50px}.adf-datatable-list .adf-datatable-row:not(:hover) .adf-datatable-hide-actions-without-hover{display:none}.adf-datatable-list .adf-datatable-cell--image{max-width:50px}.adf-datatable-list .adf-location-cell a{color:var(--theme-text-fg-color);text-decoration:none}.adf-datatable-list .adf-location-cell a:hover{color:var(--adf-datatable-cell-link-hover-color);text-decoration:underline}.adf-datatable-list .adf-sr-only{border:0;clip:rect(0,0,0,0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px}.adf-datatable-list .adf-is-selected{background:var(--adf-datatable-selected-color)}.adf-datatable-list .adf-datatable-link{color:var(--theme-text-fg-color);text-decoration:none}.adf-datatable-list .adf-datatable-link:hover{color:var(--adf-datatable-cell-link-hover-color);text-decoration:underline}.adf-datatable-list .adf-dynamic-column .adf-datatable-link:hover{text-decoration:none}.adf-datatable-list .adf-dynamic-column .adf-datatable-link:hover .adf-datatable-cell-value{text-decoration:underline}.adf-datatable-list .adf-datatable-cell-header .adf-datatable-link .adf-datatable-cell-value,.adf-datatable-list .adf-datatable-cell .adf-datatable-link .adf-datatable-cell-value{padding:0 10px}.adf-datatable-list .adf-ellipsis-cell{overflow:hidden;padding:0 4px;position:sticky;text-overflow:ellipsis;white-space:nowrap}.adf-datatable-list .adf-ellipsis-cell.adf-datatable-cell-header,.adf-datatable-list .adf-ellipsis-cell .adf-datatable-content-cell{max-width:calc(100% - .1px);overflow:hidden;text-overflow:ellipsis}.adf-datatable-list .adf-ellipsis-cell.adf-datatable-cell-header .adf-datatable-cell-value,.adf-datatable-list .adf-ellipsis-cell .adf-datatable-content-cell .adf-datatable-cell-value{overflow:hidden;text-overflow:ellipsis}.adf-datatable-list .adf-ellipsis-cell .adf-datatable-content-cell{overflow:unset;position:absolute}@media screen and (-ms-high-contrast:active),screen and (-ms-high-contrast:none){.adf-datatable-list .adf-ellipsis-cell .adf-cell-value{top:100%}}.adf-datatable-list .adf-ellipsis-cell>div:after{content:attr(title);display:block;height:0;overflow:hidden}.adf-datatable-list .adf-no-content-container{border:none!important;justify-content:center;padding:0!important;width:100%}.adf-datatable-list .adf-no-content-container>img{width:100%}.adf-datatable-list .adf-loading-content-container{padding:0!important;width:100%}.adf-datatable-list .adf-loading-content-container>img{width:100%}.adf-datatable-list .adf-no-permission__row:hover{background-color:inherit;cursor:default}.adf-datatable-list .adf-no-permission__cell{padding:0!important}.adf-datatable-list .adf-hidden{display:none}@media (max-width:768px){.adf-datatable-list .adf-desktop-only{display:none!important}}@media (max-device-width:768px){.adf-datatable-list .adf-desktop-only{display:none!important}}.adf-checkbox-sr-only .mat-checkbox-label{border:0;clip:rect(0,0,0,0);height:1px;margin:-1px;overflow:hidden;padding:0;position:absolute;width:1px}.adf-sticky-header{border-top:0;height:100%}.adf-sticky-header .adf-datatable-header{border-bottom:1px solid var(--theme-border-color);border-top:1px solid var(--theme-border-color);display:block;margin-right:0}.adf-sticky-header .adf-datatable-body{display:block;flex:1;margin-top:-1px;overflow-y:scroll}.adf-upload__dragging>div{border-bottom:1px dashed var(--theme-accent-color-a200)!important;border-top:1px dashed var(--theme-accent-color-a200)!important}.adf-upload__dragging>div:first-child{border-left:1px dashed var(--theme-accent-color-a200)}.adf-upload__dragging>div:last-child{border-right:1px dashed var(--theme-accent-color-a200)!important}.adf-datatable--empty{align-items:center;display:flex;flex:1;flex-direction:column;height:100%;height:inherit;justify-content:center;min-height:0;overflow:hidden}.adf-datatable--empty .adf-datatable-body .adf-datatable-row{background-color:var(--theme-card-bg-color);border:none!important;height:100%}.adf-datatable--empty .adf-datatable-body .adf-datatable-row:focus,.adf-datatable--empty .adf-datatable-body .adf-datatable-row:hover{background-color:unset;cursor:default}.adf-datatable--empty--header-visible .adf-datatable-header{border:1px solid var(--theme-border-color)}.adf-datatable--empty--header-visible .adf-datatable-body{align-items:center;display:flex;flex:1;flex-direction:column;height:100%;justify-content:center;min-height:0;overflow:hidden}.adf-datatable--empty--header-visible .adf-datatable-body .adf-datatable-row{background-color:var(--theme-card-bg-color);border:none!important;height:100%}.adf-datatable--empty--header-visible .adf-datatable-body .adf-datatable-row:focus,.adf-datatable--empty--header-visible .adf-datatable-body .adf-datatable-row:hover{background-color:unset;cursor:default}"]
            },] }
];
DataTableComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: IterableDiffers }
];
DataTableComponent.propDecorators = {
    rowsList: [{ type: ViewChildren, args: [DataTableRowComponent,] }],
    columnList: [{ type: ContentChild, args: [DataColumnListComponent,] }],
    data: [{ type: Input }],
    display: [{ type: Input }],
    rows: [{ type: Input }],
    sorting: [{ type: Input }],
    columns: [{ type: Input }],
    selectionMode: [{ type: Input }],
    multiselect: [{ type: Input }],
    actions: [{ type: Input }],
    actionsPosition: [{ type: Input }],
    actionsVisibleOnHover: [{ type: Input }],
    fallbackThumbnail: [{ type: Input }],
    contextMenu: [{ type: Input }],
    rowStyle: [{ type: Input }],
    rowStyleClass: [{ type: Input }],
    showHeader: [{ type: Input }],
    stickyHeader: [{ type: Input }],
    rowClick: [{ type: Output }],
    rowDblClick: [{ type: Output }],
    showRowContextMenu: [{ type: Output }],
    showRowActionsMenu: [{ type: Output }],
    executeRowAction: [{ type: Output }],
    loading: [{ type: Input }],
    noPermission: [{ type: Input }],
    rowMenuCacheEnabled: [{ type: Input }],
    resolverFn: [{ type: Input }],
    allowFiltering: [{ type: Input }],
    onKeydown: [{ type: HostListener, args: ['keyup', ['$event'],] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DateCellComponent extends DataTableCellComponent {
    constructor(userPreferenceService, alfrescoApiService, appConfig) {
        super(alfrescoApiService);
        this.dateFormat = appConfig.get('dateValues.defaultDateFormat', DateCellComponent.DATE_FORMAT);
        if (userPreferenceService) {
            userPreferenceService
                .select(UserPreferenceValues.Locale)
                .pipe(takeUntil(this.onDestroy$))
                .subscribe(locale => this.currentLocale = locale);
        }
    }
    get format() {
        if (this.column) {
            return this.column.format || this.dateFormat;
        }
        return this.dateFormat;
    }
}
DateCellComponent.DATE_FORMAT = 'medium';
DateCellComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-date-cell',
                template: `
        <ng-container>
            <span
                [attr.aria-label]="value$ | async | adfTimeAgo: currentLocale"
                title="{{ tooltip | adfLocalizedDate: 'medium' }}"
                class="adf-datatable-cell-value"
                *ngIf="format === 'timeAgo'; else standard_date">
                {{ value$ | async | adfTimeAgo: currentLocale }}
            </span>
        </ng-container>
        <ng-template #standard_date>
            <span
                class="adf-datatable-cell-value"
                title="{{ tooltip | adfLocalizedDate: format }}"
                class="adf-datatable-cell-value"
                [attr.aria-label]="value$ | async | adfLocalizedDate: format">
                {{ value$ | async | adfLocalizedDate: format }}
            </span>
        </ng-template>
    `,
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-date-cell adf-datatable-content-cell' }
            },] }
];
DateCellComponent.ctorParameters = () => [
    { type: UserPreferencesService },
    { type: AlfrescoApiService },
    { type: AppConfigService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class EmptyListComponent {
}
EmptyListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-empty-list',
                template: "<div class=\"adf-empty-list_template\">\n    <ng-content select=\"[adf-empty-list-header]\"></ng-content>\n    <ng-content select=\"[adf-empty-list-body]\"></ng-content>\n    <ng-content select=\"[adf-empty-list-footer]\"></ng-content>\n    <ng-content></ng-content>\n</div>",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-empty-list_template{margin-bottom:20px;margin-top:20px;text-align:center}"]
            },] }
];
class EmptyListHeaderDirective {
}
EmptyListHeaderDirective.decorators = [
    { type: Directive, args: [{ selector: '[adf-empty-list-header]' },] }
];
class EmptyListBodyDirective {
}
EmptyListBodyDirective.decorators = [
    { type: Directive, args: [{ selector: '[adf-empty-list-body]' },] }
];
class EmptyListFooterDirective {
}
EmptyListFooterDirective.decorators = [
    { type: Directive, args: [{ selector: '[adf-empty-list-footer]' },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FileSizeCellComponent extends DataTableCellComponent {
    constructor(alfrescoApiService) {
        super(alfrescoApiService);
    }
}
FileSizeCellComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-filesize-cell',
                template: `
        <ng-container *ngIf="(value$ | async | adfFileSize) as fileSize">
            <span
                [title]="tooltip"
                [attr.aria-label]="fileSize"
                >{{ fileSize }}</span
            >
        </ng-container>
    `,
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-filesize-cell' }
            },] }
];
FileSizeCellComponent.ctorParameters = () => [
    { type: AlfrescoApiService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class LocationCellComponent extends DataTableCellComponent {
    constructor(alfrescoApiService) {
        super(alfrescoApiService);
    }
    ngOnInit() {
        if (this.column && this.column.key && this.row && this.data) {
            const path = this.data.getValue(this.row, this.column, this.resolverFn);
            if (path && path.name && path.elements) {
                this.value$.next(path.name.split('/').pop());
                if (!this.tooltip) {
                    this.tooltip = path.name;
                }
                const parent = path.elements[path.elements.length - 1];
                this.link = [this.column.format, parent.id];
            }
        }
    }
}
LocationCellComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-location-cell',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: `
        <ng-container>
            <a href="" [title]="tooltip" [routerLink]="link">
                {{ value$ | async }}
            </a>
        </ng-container>
    `,
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-location-cell adf-datatable-content-cell' }
            },] }
];
LocationCellComponent.ctorParameters = () => [
    { type: AlfrescoApiService }
];
LocationCellComponent.propDecorators = {
    link: [{ type: Input }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class LoadingContentTemplateDirective {
    constructor(dataTable) {
        this.dataTable = dataTable;
    }
    ngAfterContentInit() {
        if (this.dataTable) {
            this.dataTable.loadingTemplate = this.template;
        }
    }
}
LoadingContentTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: 'adf-loading-content-template, loading-content-template'
            },] }
];
LoadingContentTemplateDirective.ctorParameters = () => [
    { type: DataTableComponent }
];
LoadingContentTemplateDirective.propDecorators = {
    template: [{ type: ContentChild, args: [TemplateRef,] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class NoContentTemplateDirective {
    constructor(dataTable) {
        this.dataTable = dataTable;
    }
    ngAfterContentInit() {
        if (this.dataTable) {
            this.dataTable.noContentTemplate = this.template;
        }
    }
}
NoContentTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: 'adf-no-content-template, no-content-template'
            },] }
];
NoContentTemplateDirective.ctorParameters = () => [
    { type: DataTableComponent }
];
NoContentTemplateDirective.propDecorators = {
    template: [{ type: ContentChild, args: [TemplateRef,] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class NoPermissionTemplateDirective {
    constructor(dataTable) {
        this.dataTable = dataTable;
    }
    ngAfterContentInit() {
        if (this.dataTable) {
            this.dataTable.noPermissionTemplate = this.template;
        }
    }
}
NoPermissionTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: 'adf-no-permission-template, no-permission-template'
            },] }
];
NoPermissionTemplateDirective.ctorParameters = () => [
    { type: DataTableComponent }
];
NoPermissionTemplateDirective.propDecorators = {
    template: [{ type: ContentChild, args: [TemplateRef,] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class HeaderFilterTemplateDirective {
    constructor(dataTable) {
        this.dataTable = dataTable;
    }
    ngAfterContentInit() {
        if (this.dataTable) {
            this.dataTable.headerFilterTemplate = this.template;
        }
    }
}
HeaderFilterTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: 'adf-header-filter-template'
            },] }
];
HeaderFilterTemplateDirective.ctorParameters = () => [
    { type: DataTableComponent }
];
HeaderFilterTemplateDirective.propDecorators = {
    template: [{ type: ContentChild, args: [TemplateRef,] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CustomEmptyContentTemplateDirective {
}
CustomEmptyContentTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: 'adf-custom-empty-content-template, empty-folder-content'
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CustomLoadingContentTemplateDirective {
}
CustomLoadingContentTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: 'adf-custom-loading-content-template'
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CustomNoPermissionTemplateDirective {
}
CustomNoPermissionTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: 'adf-custom-no-permission-template, no-permission-content'
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class EditJsonDialogComponent {
    constructor(settings) {
        this.settings = settings;
        this.editable = false;
        this.title = 'JSON';
        this.value = '';
    }
    ngOnInit() {
        if (this.settings) {
            this.editable = this.settings.editable;
            this.value = this.settings.value || '';
            this.title = this.settings.title || 'JSON';
        }
    }
}
EditJsonDialogComponent.decorators = [
    { type: Component, args: [{
                template: "<h1 mat-dialog-title>{{ title | translate }}</h1>\n<mat-dialog-content>\n    <textarea [(ngModel)]=\"value\" [attr.readonly]=\"!editable ? true : null\"></textarea>\n</mat-dialog-content>\n\n<mat-dialog-actions align=\"end\">\n    <button mat-button mat-dialog-close cdkFocusInitial>\n        {{ 'CORE.DIALOG.EDIT_JSON.CLOSE' | translate }}\n    </button>\n    <button *ngIf=\"editable\" mat-button [mat-dialog-close]=\"value\">\n        {{ 'CORE.DIALOG.EDIT_JSON.UPDATE' | translate }}\n    </button>\n</mat-dialog-actions>\n",
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-edit-json-dialog' },
                styles: [".adf-edit-json-dialog .mat-dialog-content{height:300px;overflow:hidden}.adf-edit-json-dialog textarea{-moz-box-sizing:border-box;-webkit-box-sizing:border-box;box-sizing:border-box;height:100%;margin:0;padding:0;resize:none;width:100%}.adf-edit-json-dialog textarea:focus{outline:none}"]
            },] }
];
EditJsonDialogComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] }] }
];
EditJsonDialogComponent.propDecorators = {
    value: [{ type: Input }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class JsonCellComponent extends DataTableCellComponent {
    constructor(dialog, alfrescoApiService) {
        super(alfrescoApiService);
        this.dialog = dialog;
        this.editable = false;
    }
    ngOnInit() {
        if (this.column && this.column.key && this.row && this.data) {
            this.value$.next(this.data.getValue(this.row, this.column, this.resolverFn));
        }
    }
    view() {
        const rawValue = this.data.getValue(this.row, this.column, this.resolverFn);
        const value = typeof rawValue === 'object'
            ? JSON.stringify(rawValue || {}, null, 2)
            : rawValue;
        const settings = {
            title: this.column.title,
            editable: this.editable,
            value
        };
        this.dialog.open(EditJsonDialogComponent, {
            data: settings,
            minWidth: '50%',
            minHeight: '50%'
        }).afterClosed().subscribe(() => {
            if (typeof rawValue === 'object') {
            }
            else {
            }
        });
    }
}
JsonCellComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-json-cell',
                changeDetection: ChangeDetectionStrategy.OnPush,
                template: `
        <ng-container *ngIf="value$ | async as value; else editEmpty">
            <button mat-button color="primary" (click)="view()">json</button>
        </ng-container>

        <ng-template #editEmpty>
            <button *ngIf="editable" mat-button color="primary" (click)="view()">json</button>
        </ng-template>
    `,
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-datatable-content-cell' },
                styles: [".adf-datatable-json-cell{white-space:pre-wrap;word-wrap:break-word}.adf-datatable-cell-value{position:relative}"]
            },] }
];
JsonCellComponent.ctorParameters = () => [
    { type: MatDialog },
    { type: AlfrescoApiService }
];
JsonCellComponent.propDecorators = {
    editable: [{ type: Input }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var NOTIFICATION_TYPE;
(function (NOTIFICATION_TYPE) {
    NOTIFICATION_TYPE["INFO"] = "info";
    NOTIFICATION_TYPE["WARN"] = "warning";
    NOTIFICATION_TYPE["ERROR"] = "error";
    NOTIFICATION_TYPE["RECURSIVE"] = "recursive";
})(NOTIFICATION_TYPE || (NOTIFICATION_TYPE = {}));

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const rootInitiator = {
    key: '*',
    displayName: 'SYSTEM'
};
function info(messages, initiator = rootInitiator) {
    return {
        type: NOTIFICATION_TYPE.INFO,
        datetime: new Date(),
        initiator,
        messages: [].concat(messages)
    };
}
function warning(messages, initiator = rootInitiator) {
    return {
        type: NOTIFICATION_TYPE.WARN,
        datetime: new Date(),
        initiator,
        messages: [].concat(messages)
    };
}
function error(messages, initiator = rootInitiator) {
    return {
        type: NOTIFICATION_TYPE.ERROR,
        datetime: new Date(),
        initiator,
        messages: [].concat(messages)
    };
}

const INFO_SNACK_CLASS = 'adf-info-snackbar';
const WARN_SNACK_CLASS = 'adf-warning-snackbar';
const ERROR_SNACK_CLASS = 'adf-error-snackbar';
class NotificationService {
    constructor(snackBar, translationService, appConfigService) {
        this.snackBar = snackBar;
        this.translationService = translationService;
        this.appConfigService = appConfigService;
        this.DEFAULT_DURATION_MESSAGE = 5000;
        this.notifications$ = new Subject();
        this.DEFAULT_DURATION_MESSAGE = this.appConfigService.get(AppConfigValues.NOTIFY_DURATION) || this.DEFAULT_DURATION_MESSAGE;
    }
    openSnackMessage(message, config, interpolateArgs) {
        return this.dispatchNotification(message, null, config, interpolateArgs);
    }
    openSnackMessageAction(message, action, config, interpolateArgs) {
        return this.dispatchNotification(message, action, config, interpolateArgs);
    }
    showError(message, action, interpolateArgs) {
        return this.dispatchNotification(message, action, { panelClass: ERROR_SNACK_CLASS }, interpolateArgs);
    }
    showInfo(message, action, interpolateArgs) {
        return this.dispatchNotification(message, action, { panelClass: INFO_SNACK_CLASS }, interpolateArgs);
    }
    showWarning(message, action, interpolateArgs) {
        return this.dispatchNotification(message, action, { panelClass: WARN_SNACK_CLASS }, interpolateArgs);
    }
    dismissSnackMessageAction() {
        return this.snackBar.dismiss();
    }
    pushToNotificationHistory(notification) {
        this.notifications$.next(notification);
    }
    dispatchNotification(message, action, config, interpolateArgs) {
        const translatedMessage = this.translationService.instant(message, interpolateArgs);
        const translatedAction = this.translationService.instant(action, interpolateArgs);
        const createNotification = this.getNotificationCreator(config);
        this.notifications$.next(createNotification(translatedMessage));
        return this.snackBar.open(translatedMessage, translatedAction, Object.assign({ duration: (typeof config === 'number') ? config : this.DEFAULT_DURATION_MESSAGE, panelClass: INFO_SNACK_CLASS }, ((typeof config === 'object') ? config : {})));
    }
    getNotificationCreator(config) {
        let panelClass = null;
        if (typeof config === 'object') {
            panelClass = Array.isArray(config.panelClass) ? config.panelClass[0] : config.panelClass;
        }
        switch (panelClass) {
            case ERROR_SNACK_CLASS:
                return error;
            case WARN_SNACK_CLASS:
                return warning;
            default:
                return info;
        }
    }
}
NotificationService.ɵprov = ɵɵdefineInjectable({ factory: function NotificationService_Factory() { return new NotificationService(ɵɵinject(MatSnackBar), ɵɵinject(TranslationService), ɵɵinject(AppConfigService)); }, token: NotificationService, providedIn: "root" });
NotificationService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
NotificationService.ctorParameters = () => [
    { type: MatSnackBar },
    { type: TranslationService },
    { type: AppConfigService }
];

class ClipboardService {
    constructor(document, logService, notificationService) {
        this.document = document;
        this.logService = logService;
        this.notificationService = notificationService;
    }
    isTargetValid(target) {
        if (target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement) {
            return !target.hasAttribute('disabled');
        }
        return false;
    }
    copyToClipboard(target, message) {
        if (this.isTargetValid(target)) {
            try {
                target.select();
                target.setSelectionRange(0, target.value.length);
                this.document.execCommand('copy');
                this.notify(message);
            }
            catch (error) {
                this.logService.error(error);
            }
        }
    }
    copyContentToClipboard(content, message) {
        try {
            document.addEventListener('copy', (e) => {
                e.clipboardData.setData('text/plain', (content));
                e.preventDefault();
                document.removeEventListener('copy', null);
            });
            document.execCommand('copy');
            this.notify(message);
        }
        catch (error) {
            this.logService.error(error);
        }
    }
    notify(message) {
        if (message) {
            this.notificationService.openSnackMessage(message);
        }
    }
}
ClipboardService.ɵprov = ɵɵdefineInjectable({ factory: function ClipboardService_Factory() { return new ClipboardService(ɵɵinject(DOCUMENT), ɵɵinject(LogService), ɵɵinject(NotificationService)); }, token: ClipboardService, providedIn: "root" });
ClipboardService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
ClipboardService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: LogService },
    { type: NotificationService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ClipboardDirective {
    constructor(clipboardService, viewContainerRef, resolver) {
        this.clipboardService = clipboardService;
        this.viewContainerRef = viewContainerRef;
        this.resolver = resolver;
    }
    handleClickEvent(event) {
        event.preventDefault();
        event.stopPropagation();
        this.copyToClipboard();
    }
    showTooltip() {
        if (this.placeholder) {
            const componentFactory = this.resolver.resolveComponentFactory(ClipboardComponent);
            const componentRef = this.viewContainerRef.createComponent(componentFactory).instance;
            componentRef.placeholder = this.placeholder;
        }
    }
    closeTooltip() {
        this.viewContainerRef.remove();
    }
    copyToClipboard() {
        const isValidTarget = this.clipboardService.isTargetValid(this.target);
        if (isValidTarget) {
            this.clipboardService.copyToClipboard(this.target, this.message);
        }
        else {
            this.copyContentToClipboard(this.viewContainerRef.element.nativeElement.innerHTML);
        }
    }
    copyContentToClipboard(content) {
        this.clipboardService.copyContentToClipboard(content, this.message);
    }
}
ClipboardDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-clipboard]',
                exportAs: 'adfClipboard'
            },] }
];
ClipboardDirective.ctorParameters = () => [
    { type: ClipboardService },
    { type: ViewContainerRef },
    { type: ComponentFactoryResolver }
];
ClipboardDirective.propDecorators = {
    placeholder: [{ type: Input, args: ['adf-clipboard',] }],
    target: [{ type: Input }],
    message: [{ type: Input, args: ['clipboard-notification',] }],
    handleClickEvent: [{ type: HostListener, args: ['click', ['$event'],] }],
    showTooltip: [{ type: HostListener, args: ['mouseenter',] }],
    closeTooltip: [{ type: HostListener, args: ['mouseleave',] }]
};
class ClipboardComponent {
    ngOnInit() {
        this.placeholder = this.placeholder || 'CLIPBOARD.CLICK_TO_COPY';
    }
}
ClipboardComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-copy-content-tooltip',
                template: `<span class='adf-copy-tooltip'>{{ placeholder | translate }} </span>`,
                encapsulation: ViewEncapsulation.None
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ClipboardModule {
}
ClipboardModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    TranslateModule
                ],
                declarations: [
                    ClipboardDirective,
                    ClipboardComponent
                ],
                exports: [
                    ClipboardDirective
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DropZoneDirective {
    constructor(elementRef, ngZone) {
        this.ngZone = ngZone;
        this.dropTarget = 'cell';
        this.element = elementRef.nativeElement;
    }
    ngOnInit() {
        this.ngZone.runOutsideAngular(() => {
            this.element.addEventListener('dragenter', this.onDragEnter.bind(this));
            this.element.addEventListener('dragover', this.onDragOver.bind(this));
            this.element.addEventListener('drop', this.onDrop.bind(this));
        });
    }
    ngOnDestroy() {
        this.element.removeEventListener('dragenter', this.onDragEnter);
        this.element.removeEventListener('dragover', this.onDragOver);
        this.element.removeEventListener('drop', this.onDrop);
    }
    onDragEnter(event) {
        const domEvent = this.dispatchDomEvent(event, 'dragenter');
        if (domEvent.defaultPrevented) {
            event.dataTransfer.dropEffect = 'copy';
            event.preventDefault();
            event.stopPropagation();
        }
    }
    onDragOver(event) {
        const domEvent = this.dispatchDomEvent(event, 'dragover');
        if (domEvent.defaultPrevented) {
            event.dataTransfer.dropEffect = 'copy';
            event.preventDefault();
            event.stopPropagation();
        }
    }
    onDrop(event) {
        const domEvent = this.dispatchDomEvent(event, 'drop');
        if (domEvent.defaultPrevented) {
            event.preventDefault();
            event.stopPropagation();
        }
    }
    dispatchDomEvent(originalEvent, eventName) {
        const domEvent = new CustomEvent(`${this.dropTarget}-${eventName}`, {
            detail: {
                target: this.dropTarget,
                event: originalEvent,
                column: this.dropColumn,
                row: this.dropRow
            },
            bubbles: true
        });
        this.element.dispatchEvent(domEvent);
        return domEvent;
    }
}
DropZoneDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-drop-zone]'
            },] }
];
DropZoneDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone }
];
DropZoneDirective.propDecorators = {
    dropTarget: [{ type: Input }],
    dropRow: [{ type: Input }],
    dropColumn: [{ type: Input }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DateColumnHeaderComponent {
    constructor(columnComponent) {
        this.columnComponent = columnComponent;
    }
    ngAfterContentInit() {
        if (this.columnComponent) {
            this.columnComponent.header = this.header;
        }
    }
}
DateColumnHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-data-column-header',
                template: ''
            },] }
];
DateColumnHeaderComponent.ctorParameters = () => [
    { type: DataColumnComponent }
];
DateColumnHeaderComponent.propDecorators = {
    header: [{ type: ContentChild, args: [TemplateRef,] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DataColumnModule {
}
DataColumnModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule
                ],
                declarations: [
                    DataColumnComponent,
                    DataColumnListComponent,
                    DateColumnHeaderComponent
                ],
                exports: [
                    DataColumnComponent,
                    DataColumnListComponent,
                    DateColumnHeaderComponent
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DataTableModule {
}
DataTableModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    RouterModule,
                    MaterialModule,
                    CommonModule,
                    TranslateModule,
                    DataColumnModule,
                    ContextMenuModule,
                    PipeModule,
                    DirectiveModule,
                    ClipboardModule
                ],
                declarations: [
                    DataTableComponent,
                    EmptyListComponent,
                    EmptyListHeaderDirective,
                    EmptyListBodyDirective,
                    EmptyListFooterDirective,
                    DataTableCellComponent,
                    DataTableRowComponent,
                    DateCellComponent,
                    FileSizeCellComponent,
                    LocationCellComponent,
                    JsonCellComponent,
                    NoContentTemplateDirective,
                    NoPermissionTemplateDirective,
                    LoadingContentTemplateDirective,
                    HeaderFilterTemplateDirective,
                    CustomEmptyContentTemplateDirective,
                    CustomLoadingContentTemplateDirective,
                    CustomNoPermissionTemplateDirective,
                    DropZoneDirective
                ],
                exports: [
                    DataTableComponent,
                    EmptyListComponent,
                    EmptyListHeaderDirective,
                    EmptyListBodyDirective,
                    EmptyListFooterDirective,
                    DataTableCellComponent,
                    DataTableRowComponent,
                    DateCellComponent,
                    FileSizeCellComponent,
                    LocationCellComponent,
                    JsonCellComponent,
                    NoContentTemplateDirective,
                    NoPermissionTemplateDirective,
                    LoadingContentTemplateDirective,
                    HeaderFilterTemplateDirective,
                    CustomEmptyContentTemplateDirective,
                    CustomLoadingContentTemplateDirective,
                    CustomNoPermissionTemplateDirective,
                    DropZoneDirective
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AboutModule {
}
AboutModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    TranslateModule,
                    DataTableModule
                ],
                declarations: [
                    AboutApplicationModulesComponent,
                    AboutProductVersionComponent,
                    AboutGithubLinkComponent,
                    AboutServerSettingsComponent
                ],
                exports: [
                    AboutApplicationModulesComponent,
                    AboutProductVersionComponent,
                    AboutGithubLinkComponent,
                    AboutServerSettingsComponent
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class ViewUtilService {
    constructor(apiService, logService, translateService) {
        this.apiService = apiService;
        this.logService = logService;
        this.translateService = translateService;
        this.maxRetries = 5;
        this.mimeTypes = {
            text: ['text/plain', 'text/csv', 'text/xml', 'text/html', 'application/x-javascript'],
            pdf: ['application/pdf'],
            image: ['image/png', 'image/jpeg', 'image/gif', 'image/bmp', 'image/svg+xml'],
            media: ['video/mp4', 'video/webm', 'video/ogg', 'audio/mpeg', 'audio/ogg', 'audio/wav']
        };
        this.TRY_TIMEOUT = 10000;
        this.viewerTypeChange = new Subject();
        this.urlFileContentChange = new Subject();
    }
    get renditionsApi() {
        var _a;
        this._renditionsApi = (_a = this._renditionsApi) !== null && _a !== void 0 ? _a : new RenditionsApi(this.apiService.getInstance());
        return this._renditionsApi;
    }
    get contentApi() {
        var _a;
        this._contentApi = (_a = this._contentApi) !== null && _a !== void 0 ? _a : new ContentApi(this.apiService.getInstance());
        return this._contentApi;
    }
    get versionsApi() {
        var _a;
        this._versionsApi = (_a = this._versionsApi) !== null && _a !== void 0 ? _a : new VersionsApi(this.apiService.getInstance());
        return this._versionsApi;
    }
    printFile(url, type) {
        const pwa = window.open(url, ViewUtilService.TARGET);
        if (pwa) {
            if (type === ViewUtilService.ContentGroup.IMAGE) {
                pwa.onfocus = () => {
                    setTimeout(() => {
                        pwa.close();
                    }, 500);
                };
            }
            pwa.onload = () => {
                pwa.print();
            };
        }
    }
    printFileGeneric(objectId, mimeType) {
        const nodeId = objectId;
        const type = this.getViewerTypeByMimeType(mimeType);
        this.getRendition(nodeId, ViewUtilService.ContentGroup.PDF)
            .then((value) => {
            const url = this.getRenditionUrl(nodeId, type, (!!value));
            const printType = (type === ViewUtilService.ContentGroup.PDF
                || type === ViewUtilService.ContentGroup.TEXT)
                ? ViewUtilService.ContentGroup.PDF : type;
            this.printFile(url, printType);
        })
            .catch((err) => {
            this.logService.error('Error with Printing');
            this.logService.error(err);
        });
    }
    getRenditionUrl(nodeId, type, renditionExists) {
        return (renditionExists && type !== ViewUtilService.ContentGroup.IMAGE) ?
            this.contentApi.getRenditionUrl(nodeId, ViewUtilService.ContentGroup.PDF) :
            this.contentApi.getContentUrl(nodeId, false);
    }
    waitRendition(nodeId, renditionId, retries) {
        return __awaiter(this, void 0, void 0, function* () {
            const rendition = yield this.renditionsApi.getRendition(nodeId, renditionId);
            if (this.maxRetries < retries) {
                const status = rendition.entry.status.toString();
                if (status === 'CREATED') {
                    return rendition;
                }
                else {
                    retries += 1;
                    yield this.wait(1000);
                    return this.waitRendition(nodeId, renditionId, retries);
                }
            }
            return Promise.resolve(null);
        });
    }
    getViewerTypeByMimeType(mimeType) {
        if (mimeType) {
            mimeType = mimeType.toLowerCase();
            const editorTypes = Object.keys(this.mimeTypes);
            for (const type of editorTypes) {
                if (this.mimeTypes[type].indexOf(mimeType) >= 0) {
                    return type;
                }
            }
        }
        return 'unknown';
    }
    wait(ms) {
        return new Promise((resolve) => setTimeout(resolve, ms));
    }
    getRendition(nodeId, renditionId) {
        return __awaiter(this, void 0, void 0, function* () {
            const renditionPaging = yield this.renditionsApi.listRenditions(nodeId);
            let rendition = renditionPaging.list.entries.find((renditionEntry) => renditionEntry.entry.id.toLowerCase() === renditionId);
            if (rendition) {
                const status = rendition.entry.status.toString();
                if (status === 'NOT_CREATED') {
                    try {
                        yield this.renditionsApi.createRendition(nodeId, { id: renditionId });
                        rendition = yield this.waitRendition(nodeId, renditionId, 0);
                    }
                    catch (err) {
                        this.logService.error(err);
                    }
                }
            }
            return new Promise((resolve) => resolve(rendition));
        });
    }
    displayNodeRendition(nodeId, versionId) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const rendition = versionId ? yield this.resolveNodeRendition(nodeId, 'pdf', versionId) :
                    yield this.resolveNodeRendition(nodeId, 'pdf');
                if (rendition) {
                    const renditionId = rendition.entry.id;
                    if (renditionId === 'pdf') {
                        this.viewerTypeChange.next('pdf');
                    }
                    else if (renditionId === 'imgpreview') {
                        this.viewerTypeChange.next('image');
                    }
                    const urlFileContent = versionId ? this.contentApi.getVersionRenditionUrl(nodeId, versionId, renditionId) :
                        this.contentApi.getRenditionUrl(nodeId, renditionId);
                    this.urlFileContentChange.next(urlFileContent);
                }
            }
            catch (err) {
                this.logService.error(err);
            }
        });
    }
    resolveNodeRendition(nodeId, renditionId, versionId) {
        return __awaiter(this, void 0, void 0, function* () {
            renditionId = renditionId.toLowerCase();
            const supportedRendition = versionId ? yield this.versionsApi.listVersionRenditions(nodeId, versionId) :
                yield this.renditionsApi.listRenditions(nodeId);
            let rendition = supportedRendition.list.entries.find((renditionEntry) => renditionEntry.entry.id.toLowerCase() === renditionId);
            if (!rendition) {
                renditionId = 'imgpreview';
                rendition = supportedRendition.list.entries.find((renditionEntry) => renditionEntry.entry.id.toLowerCase() === renditionId);
            }
            if (rendition) {
                const status = rendition.entry.status.toString();
                if (status === 'NOT_CREATED') {
                    try {
                        if (versionId) {
                            yield this.versionsApi.createVersionRendition(nodeId, versionId, { id: renditionId }).then(() => {
                                this.viewerTypeChange.next('in_creation');
                            });
                        }
                        else {
                            yield this.renditionsApi.createRendition(nodeId, { id: renditionId }).then(() => {
                                this.viewerTypeChange.next('in_creation');
                            });
                        }
                        try {
                            rendition = versionId ? yield this.waitNodeRendition(nodeId, renditionId, versionId) : yield this.waitNodeRendition(nodeId, renditionId);
                        }
                        catch (e) {
                            this.viewerTypeChange.next('error_in_creation');
                            rendition = null;
                        }
                    }
                    catch (err) {
                        this.logService.error(err);
                    }
                }
            }
            return rendition;
        });
    }
    waitNodeRendition(nodeId, renditionId, versionId) {
        return __awaiter(this, void 0, void 0, function* () {
            let currentRetry = 0;
            return new Promise((resolve, reject) => {
                const intervalId = setInterval(() => {
                    currentRetry++;
                    if (this.maxRetries >= currentRetry) {
                        if (versionId) {
                            this.versionsApi.getVersionRendition(nodeId, versionId, renditionId).then((rendition) => {
                                const status = rendition.entry.status.toString();
                                if (status === 'CREATED') {
                                    this.handleNodeRendition(nodeId, renditionId, versionId);
                                    clearInterval(intervalId);
                                    return resolve(rendition);
                                }
                            }, () => {
                                return reject();
                            });
                        }
                        else {
                            this.renditionsApi.getRendition(nodeId, renditionId).then((rendition) => {
                                const status = rendition.entry.status.toString();
                                if (status === 'CREATED') {
                                    this.handleNodeRendition(nodeId, renditionId);
                                    clearInterval(intervalId);
                                    return resolve(rendition);
                                }
                            }, () => {
                                return reject();
                            });
                        }
                    }
                    else {
                        clearInterval(intervalId);
                        return reject();
                    }
                }, this.TRY_TIMEOUT);
            });
        });
    }
    handleNodeRendition(nodeId, renditionId, versionId) {
        return __awaiter(this, void 0, void 0, function* () {
            if (renditionId === 'pdf') {
                this.viewerTypeChange.next('pdf');
            }
            else if (renditionId === 'imgpreview') {
                this.viewerTypeChange.next('image');
            }
            const urlFileContent = versionId ? this.contentApi.getVersionRenditionUrl(nodeId, versionId, renditionId) :
                this.contentApi.getRenditionUrl(nodeId, renditionId);
            this.urlFileContentChange.next(urlFileContent);
        });
    }
    generateMediaTracks(nodeId) {
        return __awaiter(this, void 0, void 0, function* () {
            return this.isRenditionAvailable(nodeId, ViewUtilService.SUBTITLES_RENDITION_NAME)
                .then((value) => {
                const tracks = [];
                if (value) {
                    tracks.push({
                        kind: 'subtitles',
                        src: this.contentApi.getRenditionUrl(nodeId, ViewUtilService.SUBTITLES_RENDITION_NAME),
                        label: this.translateService.instant('ADF_VIEWER.SUBTITLES')
                    });
                }
                return tracks;
            })
                .catch((err) => {
                this.logService.error('Error while retrieving ' + ViewUtilService.SUBTITLES_RENDITION_NAME + ' rendition');
                this.logService.error(err);
                return [];
            });
        });
    }
    isRenditionAvailable(nodeId, renditionId) {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            const renditionPaging = yield this.renditionsApi.listRenditions(nodeId);
            const rendition = renditionPaging.list.entries.find((renditionEntry) => renditionEntry.entry.id.toLowerCase() === renditionId);
            return ((_b = (_a = rendition === null || rendition === void 0 ? void 0 : rendition.entry) === null || _a === void 0 ? void 0 : _a.status) === null || _b === void 0 ? void 0 : _b.toString()) === 'CREATED' || false;
        });
    }
}
ViewUtilService.TARGET = '_new';
ViewUtilService.ContentGroup = {
    IMAGE: 'image',
    MEDIA: 'media',
    PDF: 'pdf',
    TEXT: 'text'
};
ViewUtilService.SUBTITLES_RENDITION_NAME = 'webvtt';
ViewUtilService.ɵprov = ɵɵdefineInjectable({ factory: function ViewUtilService_Factory() { return new ViewUtilService(ɵɵinject(AlfrescoApiService), ɵɵinject(LogService), ɵɵinject(TranslationService)); }, token: ViewUtilService, providedIn: "root" });
ViewUtilService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
ViewUtilService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: LogService },
    { type: TranslationService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ViewerMoreActionsComponent {
}
ViewerMoreActionsComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-viewer-more-actions',
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: { class: 'adf-viewer-more-actions' },
                template: `<ng-content></ng-content>`
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ViewerOpenWithComponent {
}
ViewerOpenWithComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-viewer-open-with',
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: { class: 'adf-viewer-open-with' },
                template: `<ng-content></ng-content>`
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ViewerSidebarComponent {
    onKeyDown(event) {
        event.cancelBubble = true;
    }
    onKeyUp(event) {
        event.cancelBubble = true;
    }
}
ViewerSidebarComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-viewer-sidebar',
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: { class: 'adf-viewer-sidebar' },
                template: `<ng-content></ng-content>`
            },] }
];
ViewerSidebarComponent.propDecorators = {
    onKeyDown: [{ type: HostListener, args: ['keydown', ['$event'],] }],
    onKeyUp: [{ type: HostListener, args: ['keyup', ['$event'],] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ViewerToolbarComponent {
}
ViewerToolbarComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-viewer-toolbar',
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: { class: 'adf-viewer-toolbar' },
                template: `<ng-content></ng-content>`
            },] }
];

const MIN_CANCELLABLE_FILE_SIZE = 1000000;
const MAX_CANCELLABLE_FILE_PERCENTAGE = 50;
class UploadService {
    constructor(apiService, appConfigService, discoveryApiService) {
        this.apiService = apiService;
        this.appConfigService = appConfigService;
        this.discoveryApiService = discoveryApiService;
        this.cache = {};
        this.totalComplete = 0;
        this.totalAborted = 0;
        this.totalError = 0;
        this.excludedFileList = [];
        this.excludedFoldersList = [];
        this.matchingOptions = null;
        this.folderMatchingOptions = null;
        this.activeTask = null;
        this.queue = [];
        this.queueChanged = new Subject();
        this.fileUpload = new Subject();
        this.fileUploadStarting = new Subject();
        this.fileUploadCancelled = new Subject();
        this.fileUploadProgress = new Subject();
        this.fileUploadAborted = new Subject();
        this.fileUploadError = new Subject();
        this.fileUploadComplete = new Subject();
        this.fileUploadDeleted = new Subject();
        this.fileDeleted = new Subject();
        this.discoveryApiService.ecmProductInfo$.pipe(filter(info => !!info))
            .subscribe(({ status }) => {
            this.isThumbnailGenerationEnabled = status.isThumbnailGenerationEnabled;
        });
    }
    get uploadApi() {
        var _a;
        this._uploadApi = (_a = this._uploadApi) !== null && _a !== void 0 ? _a : new UploadApi(this.apiService.getInstance());
        return this._uploadApi;
    }
    get nodesApi() {
        var _a;
        this._nodesApi = (_a = this._nodesApi) !== null && _a !== void 0 ? _a : new NodesApi(this.apiService.getInstance());
        return this._nodesApi;
    }
    get versionsApi() {
        var _a;
        this._versionsApi = (_a = this._versionsApi) !== null && _a !== void 0 ? _a : new VersionsApi(this.apiService.getInstance());
        return this._versionsApi;
    }
    isUploading() {
        const finishedFileStates = [FileUploadStatus.Complete, FileUploadStatus.Cancelled, FileUploadStatus.Aborted, FileUploadStatus.Error, FileUploadStatus.Deleted];
        return this.queue.reduce((stillUploading, currentFile) => {
            return stillUploading || finishedFileStates.indexOf(currentFile.status) === -1;
        }, false);
    }
    getQueue() {
        return this.queue;
    }
    addToQueue(...files) {
        const allowedFiles = files.filter((currentFile) => this.filterElement(currentFile));
        this.queue = this.queue.concat(allowedFiles);
        this.queueChanged.next(this.queue);
        return allowedFiles;
    }
    filterElement(file) {
        this.excludedFileList = this.appConfigService.get('files.excluded');
        this.excludedFoldersList = this.appConfigService.get('folders.excluded');
        let isAllowed = true;
        if (this.excludedFileList) {
            this.matchingOptions = this.appConfigService.get('files.match-options');
            isAllowed = this.isFileNameAllowed(file);
        }
        if (isAllowed && this.excludedFoldersList) {
            this.folderMatchingOptions = this.appConfigService.get('folders.match-options');
            isAllowed = this.isParentFolderAllowed(file);
        }
        return isAllowed;
    }
    isParentFolderAllowed(file) {
        let isAllowed = true;
        const currentFile = file.file;
        const fileRelativePath = currentFile.webkitRelativePath ? currentFile.webkitRelativePath : file.options.path;
        if (currentFile && fileRelativePath) {
            isAllowed =
                this.excludedFoldersList.filter((folderToExclude) => {
                    return fileRelativePath
                        .split('/')
                        .some((pathElement) => {
                        const minimatch = new Minimatch(folderToExclude, this.folderMatchingOptions);
                        return minimatch.match(pathElement);
                    });
                }).length === 0;
        }
        return isAllowed;
    }
    isFileNameAllowed(file) {
        return (this.excludedFileList.filter((pattern) => {
            const minimatch = new Minimatch(pattern, this.matchingOptions);
            return minimatch.match(file.name);
        }).length === 0);
    }
    uploadFilesInTheQueue(successEmitter, errorEmitter) {
        if (!this.activeTask) {
            const file = this.queue.find((currentFile) => currentFile.status === FileUploadStatus.Pending);
            if (file) {
                this.onUploadStarting(file);
                const promise = this.beginUpload(file, successEmitter, errorEmitter);
                this.activeTask = promise;
                this.cache[file.name] = promise;
                const next = () => {
                    this.activeTask = null;
                    setTimeout(() => this.uploadFilesInTheQueue(successEmitter, errorEmitter), 100);
                };
                promise.next = next;
                promise.then(() => next(), () => next());
            }
        }
    }
    cancelUpload(...files) {
        files.forEach((file) => {
            const promise = this.cache[file.name];
            if (promise) {
                if (this.isSaveToAbortFile(file)) {
                    promise.abort();
                }
                this.abortedFile = file.name;
                delete this.cache[file.name];
                promise.next();
            }
            else {
                const performAction = this.getAction(file);
                performAction();
            }
        });
    }
    clearQueue() {
        this.queue = [];
        this.totalComplete = 0;
        this.totalAborted = 0;
        this.totalError = 0;
    }
    getUploadPromise(file) {
        const opts = {
            include: ['allowableOperations']
        };
        if (this.isThumbnailGenerationEnabled) {
            opts.renditions = 'doclib';
        }
        if (file.options && file.options.versioningEnabled !== undefined) {
            opts.versioningEnabled = file.options.versioningEnabled;
        }
        if (file.options.newVersion === true) {
            opts.overwrite = true;
            opts.majorVersion = file.options.majorVersion;
            opts.comment = file.options.comment;
            opts.name = file.name;
        }
        else {
            opts.autoRename = true;
        }
        if (file.options.nodeType) {
            opts.nodeType = file.options.nodeType;
        }
        if (file.id) {
            return this.nodesApi.updateNodeContent(file.id, file.file, opts);
        }
        else {
            const nodeBody = Object.assign({}, file.options);
            delete nodeBody['versioningEnabled'];
            return this.uploadApi.uploadFile(file.file, file.options.path, file.options.parentId, nodeBody, opts);
        }
    }
    beginUpload(file, successEmitter, errorEmitter) {
        const promise = this.getUploadPromise(file);
        promise
            .on('progress', (progress) => {
            this.onUploadProgress(file, progress);
        })
            .on('abort', () => {
            this.onUploadAborted(file);
            if (successEmitter) {
                successEmitter.emit({ value: 'File aborted' });
            }
        })
            .on('error', (err) => {
            this.onUploadError(file, err);
            if (errorEmitter) {
                errorEmitter.emit({ value: 'Error file uploaded' });
            }
        })
            .on('success', (data) => {
            if (this.abortedFile === file.name) {
                this.onUploadAborted(file);
                if (file.id === undefined) {
                    this.deleteAbortedNode(data.entry.id);
                }
                else {
                    this.deleteAbortedNodeVersion(data.entry.id, data.entry.properties['cm:versionLabel']);
                }
                if (successEmitter) {
                    successEmitter.emit({ value: 'File deleted' });
                }
            }
            else {
                this.onUploadComplete(file, data);
                if (successEmitter) {
                    successEmitter.emit({ value: data });
                }
            }
        })
            .catch(() => {
        });
        return promise;
    }
    onUploadStarting(file) {
        if (file) {
            file.status = FileUploadStatus.Starting;
            const event = new FileUploadEvent(file, FileUploadStatus.Starting);
            this.fileUpload.next(event);
            this.fileUploadStarting.next(event);
        }
    }
    onUploadProgress(file, progress) {
        if (file) {
            file.progress = progress;
            file.status = FileUploadStatus.Progress;
            const event = new FileUploadEvent(file, FileUploadStatus.Progress);
            this.fileUpload.next(event);
            this.fileUploadProgress.next(event);
        }
    }
    onUploadError(file, error) {
        if (file) {
            file.errorCode = (error || {}).status;
            file.status = FileUploadStatus.Error;
            this.totalError++;
            const promise = this.cache[file.name];
            if (promise) {
                delete this.cache[file.name];
            }
            const event = new FileUploadErrorEvent(file, error, this.totalError);
            this.fileUpload.next(event);
            this.fileUploadError.next(event);
        }
    }
    onUploadComplete(file, data) {
        if (file) {
            file.status = FileUploadStatus.Complete;
            file.data = data;
            this.totalComplete++;
            const promise = this.cache[file.name];
            if (promise) {
                delete this.cache[file.name];
            }
            const event = new FileUploadCompleteEvent(file, this.totalComplete, data, this.totalAborted);
            this.fileUpload.next(event);
            this.fileUploadComplete.next(event);
        }
    }
    onUploadAborted(file) {
        if (file) {
            file.status = FileUploadStatus.Aborted;
            this.totalAborted++;
            const event = new FileUploadEvent(file, FileUploadStatus.Aborted);
            this.fileUpload.next(event);
            this.fileUploadAborted.next(event);
        }
    }
    onUploadCancelled(file) {
        if (file) {
            file.status = FileUploadStatus.Cancelled;
            const event = new FileUploadEvent(file, FileUploadStatus.Cancelled);
            this.fileUpload.next(event);
            this.fileUploadCancelled.next(event);
        }
    }
    onUploadDeleted(file) {
        if (file) {
            file.status = FileUploadStatus.Deleted;
            this.totalComplete--;
            const event = new FileUploadDeleteEvent(file, this.totalComplete);
            this.fileUpload.next(event);
            this.fileUploadDeleted.next(event);
        }
    }
    getAction(file) {
        const actions = {
            [FileUploadStatus.Pending]: () => this.onUploadCancelled(file),
            [FileUploadStatus.Deleted]: () => this.onUploadDeleted(file),
            [FileUploadStatus.Error]: () => this.onUploadError(file, null)
        };
        return actions[file.status];
    }
    deleteAbortedNode(nodeId) {
        this.nodesApi.deleteNode(nodeId, { permanent: true })
            .then(() => (this.abortedFile = undefined));
    }
    deleteAbortedNodeVersion(nodeId, versionId) {
        this.versionsApi.deleteVersion(nodeId, versionId)
            .then(() => (this.abortedFile = undefined));
    }
    isSaveToAbortFile(file) {
        return (file.size > MIN_CANCELLABLE_FILE_SIZE &&
            file.progress.percent < MAX_CANCELLABLE_FILE_PERCENTAGE);
    }
}
UploadService.ɵprov = ɵɵdefineInjectable({ factory: function UploadService_Factory() { return new UploadService(ɵɵinject(AlfrescoApiService), ɵɵinject(AppConfigService), ɵɵinject(DiscoveryApiService)); }, token: UploadService, providedIn: "root" });
UploadService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
UploadService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: AppConfigService },
    { type: DiscoveryApiService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class UserProcessModel {
    constructor(input) {
        if (input) {
            this.id = input.id;
            this.email = input.email || null;
            this.firstName = input.firstName || null;
            this.lastName = input.lastName || null;
            this.pictureId = input.pictureId || null;
            this.externalId = input.externalId || null;
            this.userImage = input.userImage;
        }
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CommentModel {
    constructor(obj) {
        if (obj) {
            this.id = obj.id;
            this.message = obj.message;
            this.created = obj.created;
            this.createdBy = obj.createdBy;
            this.isSelected = obj.isSelected ? obj.isSelected : false;
        }
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class EcmCompanyModel {
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RedirectionModel {
    constructor(obj) {
        if (obj) {
            this.provider = obj.provider;
            this.url = obj.url || null;
        }
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PaginationModel extends Pagination {
    constructor(input) {
        super(input);
        if (input) {
            this.count = input.count;
            this.hasMoreItems = input.hasMoreItems ? input.hasMoreItems : false;
            this.merge = input.merge ? input.merge : false;
            this.totalItems = input.totalItems;
            this.skipCount = input.skipCount;
            this.maxItems = input.maxItems;
        }
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RequestPaginationModel {
    constructor(input) {
        this.merge = false;
        if (input) {
            Object.assign(this, input);
        }
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DecimalNumberModel {
    constructor(obj) {
        if (obj) {
            this.minIntegerDigits = obj.minIntegerDigits;
            this.minFractionDigits = obj.minFractionDigits;
            this.maxFractionDigits = obj.maxFractionDigits;
        }
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class BpmUserModel {
    constructor(input) {
        if (input) {
            this.apps = input.apps;
            this.capabilities = input.capabilities;
            this.company = input.company;
            this.created = input.created;
            this.email = input.email;
            this.externalId = input.externalId;
            this.firstName = input.firstName;
            this.lastName = input.lastName;
            this.fullname = input.fullname;
            this.groups = input.groups;
            this.id = input.id;
            this.lastUpdate = input.lastUpdate;
            this.latestSyncTimeStamp = input.latestSyncTimeStamp;
            this.password = input.password;
            this.pictureId = input.pictureId;
            this.status = input.status;
            this.tenantId = input.tenantId;
            this.tenantName = input.tenantName;
            this.tenantPictureId = input.tenantPictureId;
            this.type = input.type;
        }
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class EcmUserModel {
    constructor(obj) {
        this.id = obj && obj.id || null;
        this.firstName = obj && obj.firstName;
        this.lastName = obj && obj.lastName;
        this.description = obj && obj.description || null;
        this.avatarId = obj && obj.avatarId || null;
        this.email = obj && obj.email || null;
        this.skypeId = obj && obj.skypeId;
        this.googleId = obj && obj.googleId;
        this.instantMessageId = obj && obj.instantMessageId;
        this.jobTitle = obj && obj.jobTitle || null;
        this.location = obj && obj.location || null;
        this.company = obj && obj.company;
        this.mobile = obj && obj.mobile;
        this.telephone = obj && obj.telephone;
        this.statusUpdatedAt = obj && obj.statusUpdatedAt;
        this.userStatus = obj && obj.userStatus;
        this.enabled = obj && obj.enabled;
        this.emailNotificationsEnabled = obj && obj.emailNotificationsEnabled;
        this.aspectNames = obj && obj.aspectNames;
        this.properties = obj && obj.properties;
        this.capabilities = obj && obj.capabilities;
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class IdentityRoleModel {
    constructor(obj) {
        if (obj) {
            this.id = obj.id || null;
            this.name = obj.name || null;
            this.description = obj.description || null;
            this.clientRole = obj.clientRole || null;
            this.composite = obj.composite || null;
            this.containerId = obj.containerId || null;
            this.scopeParamRequired = obj.scopeParamRequired || null;
        }
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var SearchTextStateEnum;
(function (SearchTextStateEnum) {
    SearchTextStateEnum["expanded"] = "expanded";
    SearchTextStateEnum["collapsed"] = "collapsed";
})(SearchTextStateEnum || (SearchTextStateEnum = {}));

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ViewerComponent {
    constructor(apiService, viewUtilService, logService, extensionService, contentService, uploadService, el, dialog, cdr) {
        this.apiService = apiService;
        this.viewUtilService = viewUtilService;
        this.logService = logService;
        this.extensionService = extensionService;
        this.contentService = contentService;
        this.uploadService = uploadService;
        this.el = el;
        this.dialog = dialog;
        this.cdr = cdr;
        this.urlFile = '';
        this.urlFileViewer = null;
        this.nodeId = null;
        this.versionId = null;
        this.sharedLinkId = null;
        this.overlayMode = false;
        this.showViewer = true;
        this.showToolbar = true;
        this.allowGoBack = true;
        this.allowDownload = true;
        this.allowPrint = false;
        this.allowFullScreen = true;
        this.allowNavigate = false;
        this.canNavigateBefore = true;
        this.canNavigateNext = true;
        this.allowLeftSidebar = false;
        this.allowRightSidebar = false;
        this.allowThumbnails = true;
        this.showRightSidebar = false;
        this.showLeftSidebar = false;
        this.sidebarRightTemplate = null;
        this.sidebarLeftTemplate = null;
        this.thumbnailsTemplate = null;
        this.maxRetries = 30;
        this.goBack = new EventEmitter();
        this.print = new EventEmitter();
        this.showViewerChange = new EventEmitter();
        this.extensionChange = new EventEmitter();
        this.navigateBefore = new EventEmitter();
        this.navigateNext = new EventEmitter();
        this.invalidSharedLink = new EventEmitter();
        this.TRY_TIMEOUT = 10000;
        this.viewerType = 'unknown';
        this.isLoading = false;
        this.extensionTemplates = [];
        this.sidebarRightTemplateContext = { node: null };
        this.sidebarLeftTemplateContext = { node: null };
        this.readOnly = true;
        this.cacheTypeForContent = '';
        this.extensions = {
            image: ['png', 'jpg', 'jpeg', 'gif', 'bpm', 'svg'],
            media: ['wav', 'mp4', 'mp3', 'webm', 'ogg'],
            text: ['txt', 'xml', 'html', 'json', 'ts', 'css', 'md'],
            pdf: ['pdf']
        };
        this.mimeTypes = {
            text: ['text/plain', 'text/csv', 'text/xml', 'text/html', 'application/x-javascript'],
            pdf: ['application/pdf'],
            image: ['image/png', 'image/jpeg', 'image/gif', 'image/bmp', 'image/svg+xml'],
            media: ['video/mp4', 'video/webm', 'video/ogg', 'audio/mpeg', 'audio/mp3', 'audio/ogg', 'audio/wav']
        };
        this.onDestroy$ = new Subject();
        this.shouldCloseViewer = true;
        this.keyDown$ = fromEvent(document, 'keydown');
        viewUtilService.maxRetries = this.maxRetries;
    }
    get viewerExtensions() {
        return this.extensionService.getViewerExtensions();
    }
    get externalExtensions() {
        return this.viewerExtensions.map(ext => ext.fileExtension);
    }
    get externalViewer() {
        if (!this._externalViewer) {
            this._externalViewer = this.viewerExtensions.find(ext => ext.fileExtension === '*');
        }
        return this._externalViewer;
    }
    get sharedLinksApi() {
        var _a;
        this._sharedLinksApi = (_a = this._sharedLinksApi) !== null && _a !== void 0 ? _a : new SharedlinksApi(this.apiService.getInstance());
        return this._sharedLinksApi;
    }
    get versionsApi() {
        var _a;
        this._versionsApi = (_a = this._versionsApi) !== null && _a !== void 0 ? _a : new VersionsApi(this.apiService.getInstance());
        return this._versionsApi;
    }
    get nodesApi() {
        var _a;
        this._nodesApi = (_a = this._nodesApi) !== null && _a !== void 0 ? _a : new NodesApi(this.apiService.getInstance());
        return this._nodesApi;
    }
    get contentApi() {
        var _a;
        this._contentApi = (_a = this._contentApi) !== null && _a !== void 0 ? _a : new ContentApi(this.apiService.getInstance());
        return this._contentApi;
    }
    isSourceDefined() {
        return !!(this.urlFile || this.blobFile || this.nodeId || this.sharedLinkId);
    }
    ngOnInit() {
        this.apiService.nodeUpdated.pipe(filter((node) => {
            return node && node.id === this.nodeId &&
                (node.name !== this.fileName ||
                    this.getNodeVersionProperty(this.nodeEntry.entry) !== this.getNodeVersionProperty(node));
        }), takeUntil(this.onDestroy$)).subscribe((node) => this.onNodeUpdated(node));
        this.viewUtilService.viewerTypeChange.pipe(takeUntil(this.onDestroy$)).subscribe((type) => {
            this.viewerType = type;
        });
        this.viewUtilService.urlFileContentChange.pipe(takeUntil(this.onDestroy$)).subscribe((content) => {
            this.urlFileContent = content;
        });
        this.closeOverlayManager();
        this.cacheTypeForContent = '';
    }
    getNodeVersionProperty(node) {
        var _a;
        return (_a = node === null || node === void 0 ? void 0 : node.properties['cm:versionLabel']) !== null && _a !== void 0 ? _a : '';
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
    onNodeUpdated(node) {
        if (node && node.id === this.nodeId) {
            this.cacheTypeForContent = 'no-cache';
            this.generateCacheBusterNumber();
            this.isLoading = true;
            this.setUpNodeFile(node).then(() => {
                this.isLoading = false;
            });
        }
    }
    ngOnChanges() {
        if (this.showViewer) {
            if (!this.isSourceDefined()) {
                throw new Error('A content source attribute value is missing.');
            }
            this.isLoading = true;
            if (this.blobFile) {
                this.setUpBlobData();
                this.isLoading = false;
            }
            else if (this.urlFile) {
                this.setUpUrlFile();
                this.isLoading = false;
            }
            else if (this.nodeId) {
                this.setupNode();
            }
            else if (this.sharedLinkId) {
                this.setupSharedLink();
            }
        }
    }
    setupSharedLink() {
        this.allowGoBack = false;
        this.sharedLinksApi.getSharedLink(this.sharedLinkId).then((sharedLinkEntry) => {
            this.setUpSharedLinkFile(sharedLinkEntry);
            this.isLoading = false;
        }, () => {
            this.isLoading = false;
            this.logService.error('This sharedLink does not exist');
            this.invalidSharedLink.next();
        });
    }
    setupNode() {
        this.nodesApi.getNode(this.nodeId, { include: ['allowableOperations'] }).then((node) => {
            this.nodeEntry = node;
            if (this.versionId) {
                this.versionsApi.getVersion(this.nodeId, this.versionId).then((version) => {
                    this.versionEntry = version;
                    this.setUpNodeFile(node.entry, version.entry).then(() => {
                        this.isLoading = false;
                    });
                });
            }
            else {
                this.setUpNodeFile(node.entry).then(() => {
                    this.isLoading = false;
                    this.cdr.detectChanges();
                });
            }
        }, () => {
            this.isLoading = false;
            this.logService.error('This node does not exist');
        });
    }
    setUpBlobData() {
        this.fileTitle = this.getDisplayName('Unknown');
        this.mimeType = this.blobFile.type;
        this.viewerType = this.getViewerTypeByMimeType(this.mimeType);
        this.allowDownload = false;
        this.extensionChange.emit(this.mimeType);
        this.scrollTop();
    }
    setUpUrlFile() {
        const filenameFromUrl = this.getFilenameFromUrl(this.urlFile);
        this.fileTitle = this.getDisplayName(filenameFromUrl);
        this.extension = this.getFileExtension(filenameFromUrl);
        this.urlFileContent = this.urlFile;
        this.fileName = this.displayName;
        this.viewerType = this.urlFileViewer || this.getViewerType(this.extension, this.mimeType);
        this.extensionChange.emit(this.extension);
        this.scrollTop();
    }
    setUpNodeFile(nodeData, versionData) {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            this.readOnly = !this.contentService.hasAllowableOperations(nodeData, 'update');
            if (versionData && versionData.content) {
                this.mimeType = versionData.content.mimeType;
            }
            else if (nodeData.content) {
                this.mimeType = nodeData.content.mimeType;
            }
            this.fileTitle = this.getDisplayName(versionData ? versionData.name : nodeData.name);
            const currentFileVersion = ((_b = (_a = this.nodeEntry) === null || _a === void 0 ? void 0 : _a.entry) === null || _b === void 0 ? void 0 : _b.properties) && this.nodeEntry.entry.properties['cm:versionLabel'] ?
                encodeURI((_d = (_c = this.nodeEntry) === null || _c === void 0 ? void 0 : _c.entry) === null || _d === void 0 ? void 0 : _d.properties['cm:versionLabel']) : encodeURI('1.0');
            this.urlFileContent = versionData ? this.contentApi.getVersionContentUrl(this.nodeId, versionData.id) :
                this.contentApi.getContentUrl(this.nodeId);
            this.urlFileContent = this.cacheBusterNumber ? this.urlFileContent + '&' + currentFileVersion + '&' + this.cacheBusterNumber :
                this.urlFileContent + '&' + currentFileVersion;
            this.extension = this.getFileExtension(versionData ? versionData.name : nodeData.name);
            this.fileName = versionData ? versionData.name : nodeData.name;
            this.viewerType = this.getViewerType(this.extension, this.mimeType);
            if (this.viewerType === 'unknown') {
                if (versionData) {
                    yield this.viewUtilService.displayNodeRendition(nodeData.id, versionData.id);
                }
                else {
                    yield this.viewUtilService.displayNodeRendition(nodeData.id);
                }
            }
            this.extensionChange.emit(this.extension);
            this.sidebarRightTemplateContext.node = nodeData;
            this.sidebarLeftTemplateContext.node = nodeData;
            this.scrollTop();
        });
    }
    getViewerType(extension, mimeType) {
        let viewerType = this.getViewerTypeByExtension(extension);
        if (viewerType === 'unknown') {
            viewerType = this.getViewerTypeByMimeType(mimeType);
        }
        return viewerType;
    }
    setUpSharedLinkFile(details) {
        this.mimeType = details.entry.content.mimeType;
        this.fileTitle = this.getDisplayName(details.entry.name);
        this.extension = this.getFileExtension(details.entry.name);
        this.fileName = details.entry.name;
        this.urlFileContent = this.contentApi.getSharedLinkContentUrl(this.sharedLinkId, false);
        this.viewerType = this.getViewerType(this.extension, this.mimeType);
        if (this.viewerType === 'unknown') {
            this.displaySharedLinkRendition(this.sharedLinkId);
        }
        this.extensionChange.emit(this.extension);
    }
    toggleSidebar() {
        this.showRightSidebar = !this.showRightSidebar;
        if (this.showRightSidebar && this.nodeId) {
            this.nodesApi.getNode(this.nodeId, { include: ['allowableOperations'] })
                .then((nodeEntry) => {
                this.sidebarRightTemplateContext.node = nodeEntry.entry;
            });
        }
    }
    toggleLeftSidebar() {
        this.showLeftSidebar = !this.showLeftSidebar;
        if (this.showRightSidebar && this.nodeId) {
            this.nodesApi.getNode(this.nodeId, { include: ['allowableOperations'] })
                .then((nodeEntry) => {
                this.sidebarLeftTemplateContext.node = nodeEntry.entry;
            });
        }
    }
    getDisplayName(name) {
        return this.displayName || name;
    }
    scrollTop() {
        window.scrollTo(0, 1);
    }
    getViewerTypeByMimeType(mimeType) {
        if (mimeType) {
            mimeType = mimeType.toLowerCase();
            const editorTypes = Object.keys(this.mimeTypes);
            for (const type of editorTypes) {
                if (this.mimeTypes[type].indexOf(mimeType) >= 0) {
                    return type;
                }
            }
        }
        return 'unknown';
    }
    getViewerTypeByExtension(extension) {
        if (extension) {
            extension = extension.toLowerCase();
        }
        if (this.isExternalViewer()) {
            return 'external';
        }
        if (this.isCustomViewerExtension(extension)) {
            return 'custom';
        }
        if (this.extensions.image.indexOf(extension) >= 0) {
            return 'image';
        }
        if (this.extensions.media.indexOf(extension) >= 0) {
            return 'media';
        }
        if (this.extensions.text.indexOf(extension) >= 0) {
            return 'text';
        }
        if (this.extensions.pdf.indexOf(extension) >= 0) {
            return 'pdf';
        }
        return 'unknown';
    }
    onBackButtonClick() {
        this.close();
    }
    onNavigateBeforeClick(event) {
        this.navigateBefore.next(event);
    }
    onNavigateNextClick(event) {
        this.navigateNext.next(event);
    }
    close() {
        if (this.otherMenu) {
            this.otherMenu.hidden = false;
        }
        this.showViewer = false;
        this.showViewerChange.emit(this.showViewer);
    }
    getFilenameFromUrl(url) {
        const anchor = url.indexOf('#');
        const query = url.indexOf('?');
        const end = Math.min(anchor > 0 ? anchor : url.length, query > 0 ? query : url.length);
        return url.substring(url.lastIndexOf('/', end) + 1, end);
    }
    getFileExtension(fileName) {
        if (fileName) {
            const match = fileName.match(/\.([^\./\?\#]+)($|\?|\#)/);
            return match ? match[1] : null;
        }
        return null;
    }
    isExternalViewer() {
        return !!this.viewerExtensions.find(ext => ext.fileExtension === '*');
    }
    isCustomViewerExtension(extension) {
        const extensions = this.externalExtensions || [];
        if (extension && extensions.length > 0) {
            extension = extension.toLowerCase();
            return extensions.flat().indexOf(extension) >= 0;
        }
        return false;
    }
    handleKeyboardEvent(event) {
        if (event && event.defaultPrevented) {
            return;
        }
        const key = event.keyCode;
        if (key === 37 && this.canNavigateBefore) {
            event.preventDefault();
            this.onNavigateBeforeClick(event);
        }
        if (key === 39 && this.canNavigateNext) {
            event.preventDefault();
            this.onNavigateNextClick(event);
        }
        if (key === 70 && event.ctrlKey) {
            event.preventDefault();
            this.enterFullScreen();
        }
    }
    printContent() {
        if (this.allowPrint) {
            const args = new BaseEvent();
            this.print.next(args);
            if (!args.defaultPrevented) {
                this.viewUtilService.printFileGeneric(this.nodeId, this.mimeType);
            }
        }
    }
    enterFullScreen() {
        if (this.allowFullScreen) {
            const container = this.el.nativeElement.querySelector('.adf-viewer__fullscreen-container');
            if (container) {
                if (container.requestFullscreen) {
                    container.requestFullscreen();
                }
                else if (container.webkitRequestFullscreen) {
                    container.webkitRequestFullscreen();
                }
                else if (container.mozRequestFullScreen) {
                    container.mozRequestFullScreen();
                }
                else if (container.msRequestFullscreen) {
                    container.msRequestFullscreen();
                }
            }
        }
    }
    displaySharedLinkRendition(sharedId) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const rendition = yield this.sharedLinksApi.getSharedLinkRendition(sharedId, 'pdf');
                if (rendition.entry.status.toString() === 'CREATED') {
                    this.viewerType = 'pdf';
                    this.urlFileContent = this.contentApi.getSharedLinkRenditionUrl(sharedId, 'pdf');
                }
            }
            catch (error) {
                this.logService.error(error);
                try {
                    const rendition = yield this.sharedLinksApi.getSharedLinkRendition(sharedId, 'imgpreview');
                    if (rendition.entry.status.toString() === 'CREATED') {
                        this.viewerType = 'image';
                        this.urlFileContent = this.contentApi.getSharedLinkRenditionUrl(sharedId, 'imgpreview');
                    }
                }
                catch (error) {
                    this.logService.error(error);
                }
            }
        });
    }
    checkExtensions(extensionAllowed) {
        if (typeof extensionAllowed === 'string') {
            return this.extension.toLowerCase() === extensionAllowed.toLowerCase();
        }
        else if (extensionAllowed.length > 0) {
            return extensionAllowed.find((currentExtension) => {
                return this.extension.toLowerCase() === currentExtension.toLowerCase();
            });
        }
    }
    onSubmitFile(newImageBlob) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
        if (((_b = (_a = this === null || this === void 0 ? void 0 : this.nodeEntry) === null || _a === void 0 ? void 0 : _a.entry) === null || _b === void 0 ? void 0 : _b.id) && !this.readOnly) {
            const newImageFile = new File([newImageBlob], (_d = (_c = this === null || this === void 0 ? void 0 : this.nodeEntry) === null || _c === void 0 ? void 0 : _c.entry) === null || _d === void 0 ? void 0 : _d.name, { type: (_g = (_f = (_e = this === null || this === void 0 ? void 0 : this.nodeEntry) === null || _e === void 0 ? void 0 : _e.entry) === null || _f === void 0 ? void 0 : _f.content) === null || _g === void 0 ? void 0 : _g.mimeType });
            const newFile = new FileModel(newImageFile, {
                majorVersion: false,
                newVersion: true,
                parentId: (_j = (_h = this === null || this === void 0 ? void 0 : this.nodeEntry) === null || _h === void 0 ? void 0 : _h.entry) === null || _j === void 0 ? void 0 : _j.parentId,
                nodeType: (_m = (_l = (_k = this === null || this === void 0 ? void 0 : this.nodeEntry) === null || _k === void 0 ? void 0 : _k.entry) === null || _l === void 0 ? void 0 : _l.content) === null || _m === void 0 ? void 0 : _m.mimeType
            }, (_p = (_o = this === null || this === void 0 ? void 0 : this.nodeEntry) === null || _o === void 0 ? void 0 : _o.entry) === null || _p === void 0 ? void 0 : _p.id);
            this.uploadService.addToQueue(...[newFile]);
            this.uploadService.uploadFilesInTheQueue();
        }
    }
    onUnsupportedFile() {
        this.viewerType = 'unknown';
    }
    closeOverlayManager() {
        this.dialog.afterOpened.pipe(skipWhile(() => !this.overlayMode), takeUntil(this.onDestroy$)).subscribe(() => this.shouldCloseViewer = false);
        this.dialog.afterAllClosed.pipe(skipWhile(() => !this.overlayMode), takeUntil(this.onDestroy$)).subscribe(() => this.shouldCloseViewer = true);
        this.keyDown$.pipe(skipWhile(() => !this.overlayMode), filter((e) => e.keyCode === 27), takeUntil(this.onDestroy$)).subscribe((event) => {
            event.preventDefault();
            if (this.shouldCloseViewer) {
                this.close();
            }
        });
    }
    generateCacheBusterNumber() {
        this.cacheBusterNumber = Date.now();
    }
}
ViewerComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-viewer',
                template: "<div *ngIf=\"showViewer\"\n     class=\"adf-viewer-container\"\n     [class.adf-viewer-overlay-container]=\"overlayMode\"\n     [class.adf-viewer-inline-container]=\"!overlayMode\">\n\n    <div class=\"adf-viewer-content\"\n         fxLayout=\"column\"\n         [cdkTrapFocus]=\"overlayMode\"\n         cdkTrapFocusAutoCapture>\n        <ng-content select=\"adf-viewer-toolbar\"></ng-content>\n        <ng-container *ngIf=\"showToolbar && !toolbar\">\n            <adf-toolbar id=\"adf-viewer-toolbar\" class=\"adf-viewer-toolbar\">\n                <adf-toolbar-title>\n\n                    <ng-container *ngIf=\"allowLeftSidebar\">\n                        <button mat-icon-button\n                                [attr.aria-expanded]=\"showLeftSidebar\"\n                                [attr.aria-label]=\"'ADF_VIEWER.ACTIONS.INFO' | translate\"\n                                title=\"{{ 'ADF_VIEWER.ACTIONS.INFO' | translate }}\"\n                                data-automation-id=\"adf-toolbar-left-sidebar\"\n                                [color]=\"showLeftSidebar ? 'accent' : null\"\n                                (click)=\"toggleLeftSidebar()\">\n                            <mat-icon>info_outline</mat-icon>\n                        </button>\n                    </ng-container>\n\n                    <button *ngIf=\"allowGoBack\"\n                            class=\"adf-viewer-close-button\"\n                            data-automation-id=\"adf-toolbar-back\"\n                            [attr.aria-label]=\"'ADF_VIEWER.ACTIONS.CLOSE' | translate\"\n                            mat-icon-button\n                            title=\"{{ 'ADF_VIEWER.ACTIONS.CLOSE' | translate }}\"\n                            (click)=\"onBackButtonClick()\">\n                        <mat-icon>close</mat-icon>\n                    </button>\n                </adf-toolbar-title>\n\n                <div fxFlex=\"1 1 auto\"\n                     class=\"adf-viewer__file-title\">\n                    <button *ngIf=\"allowNavigate && canNavigateBefore\"\n                            data-automation-id=\"adf-toolbar-pref-file\"\n                            mat-icon-button\n                            [attr.aria-label]=\"'ADF_VIEWER.ACTIONS.PREV_FILE' | translate\"\n                            title=\"{{ 'ADF_VIEWER.ACTIONS.PREV_FILE' | translate }}\"\n                            (click)=\"onNavigateBeforeClick($event)\">\n                        <mat-icon>navigate_before</mat-icon>\n                    </button>\n                    <img class=\"adf-viewer__mimeicon\"\n                         [alt]=\"mimeType\"\n                         [src]=\"mimeType | adfMimeTypeIcon\"\n                         data-automation-id=\"adf-file-thumbnail\">\n                    <span class=\"adf-viewer__display-name\"\n                          id=\"adf-viewer-display-name\">{{ fileTitle }}</span>\n                    <button *ngIf=\"allowNavigate && canNavigateNext\"\n                            data-automation-id=\"adf-toolbar-next-file\"\n                            mat-icon-button\n                            [attr.aria-label]=\"'ADF_VIEWER.ACTIONS.NEXT_FILE' | translate\"\n                            title=\"{{ 'ADF_VIEWER.ACTIONS.NEXT_FILE' | translate }}\"\n                            (click)=\"onNavigateNextClick($event)\">\n                        <mat-icon>navigate_next</mat-icon>\n                    </button>\n                </div>\n\n                <ng-content select=\"adf-viewer-toolbar-actions\"></ng-content>\n\n                <ng-container *ngIf=\"mnuOpenWith\"\n                              data-automation-id='adf-toolbar-custom-btn'>\n                    <button id=\"adf-viewer-openwith\"\n                            mat-button\n                            [matMenuTriggerFor]=\"mnuOpenWith\"\n                            data-automation-id=\"adf-toolbar-open-with\">\n                        <span>{{ 'ADF_VIEWER.ACTIONS.OPEN_WITH' | translate }}</span>\n                        <mat-icon>arrow_drop_down</mat-icon>\n                    </button>\n                    <mat-menu #mnuOpenWith=\"matMenu\"\n                              [overlapTrigger]=\"false\">\n                        <ng-content select=\"adf-viewer-open-with\"></ng-content>\n                    </mat-menu>\n                </ng-container>\n\n                <adf-toolbar-divider></adf-toolbar-divider>\n\n                <button id=\"adf-viewer-download\"\n                        *ngIf=\"allowDownload\"\n                        mat-icon-button\n                        [attr.aria-label]=\"'ADF_VIEWER.ACTIONS.DOWNLOAD' | translate\"\n                        title=\"{{ 'ADF_VIEWER.ACTIONS.DOWNLOAD' | translate }}\"\n                        data-automation-id=\"adf-toolbar-download\"\n                        [adfNodeDownload]=\"nodeEntry\"\n                        [version]=\"versionEntry\">\n                    <mat-icon>file_download</mat-icon>\n                </button>\n\n                <button id=\"adf-viewer-print\"\n                        *ngIf=\"allowPrint\"\n                        mat-icon-button\n                        [attr.aria-label]=\"'ADF_VIEWER.ACTIONS.PRINT' | translate\"\n                        title=\"{{ 'ADF_VIEWER.ACTIONS.PRINT' | translate }}\"\n                        data-automation-id=\"adf-toolbar-print\"\n                        (click)=\"printContent()\">\n                    <mat-icon>print</mat-icon>\n                </button>\n\n                <button id=\"adf-viewer-fullscreen\"\n                        *ngIf=\"viewerType !== 'media' && allowFullScreen\"\n                        mat-icon-button\n                        [attr.aria-label]=\"'ADF_VIEWER.ACTIONS.FULLSCREEN' | translate\"\n                        title=\"{{ 'ADF_VIEWER.ACTIONS.FULLSCREEN' | translate }}\"\n                        data-automation-id=\"adf-toolbar-fullscreen\"\n                        (click)=\"enterFullScreen()\">\n                    <mat-icon>fullscreen</mat-icon>\n                </button>\n\n                <ng-container *ngIf=\"allowRightSidebar\">\n                    <adf-toolbar-divider></adf-toolbar-divider>\n\n                    <button mat-icon-button\n                            [attr.aria-expanded]=\"showRightSidebar\"\n                            [attr.aria-label]=\"'ADF_VIEWER.ACTIONS.INFO' | translate\"\n                            title=\"{{ 'ADF_VIEWER.ACTIONS.INFO' | translate }}\"\n                            data-automation-id=\"adf-toolbar-sidebar\"\n                            [color]=\"showRightSidebar ? 'accent' : null\"\n                            (click)=\"toggleSidebar()\">\n                        <mat-icon>info_outline</mat-icon>\n                    </button>\n\n                </ng-container>\n\n                <ng-container *ngIf=\"mnuMoreActions\">\n                    <button id=\"adf-viewer-moreactions\"\n                            mat-icon-button\n                            [matMenuTriggerFor]=\"mnuMoreActions\"\n                            [attr.aria-label]=\"'ADF_VIEWER.ACTIONS.MORE_ACTIONS' | translate\"\n                            title=\"{{ 'ADF_VIEWER.ACTIONS.MORE_ACTIONS' | translate }}\"\n                            data-automation-id=\"adf-toolbar-more-actions\">\n                        <mat-icon>more_vert</mat-icon>\n                    </button>\n                    <mat-menu #mnuMoreActions=\"matMenu\"\n                              [overlapTrigger]=\"false\">\n                        <ng-content select=\"adf-viewer-more-actions\"></ng-content>\n                    </mat-menu>\n                </ng-container>\n\n            </adf-toolbar>\n        </ng-container>\n\n        <div fxLayout=\"row\"\n             fxFlex=\"1 1 auto\">\n            <ng-container *ngIf=\"allowRightSidebar && showRightSidebar\">\n                <div class=\"adf-viewer__sidebar\"\n                     [ngClass]=\"'adf-viewer__sidebar__right'\"\n                     fxFlexOrder=\"4\"\n                     id=\"adf-right-sidebar\">\n                    <ng-container *ngIf=\"sidebarRightTemplate\">\n                        <ng-container *ngTemplateOutlet=\"sidebarRightTemplate;context:sidebarRightTemplateContext\">\n                        </ng-container>\n                    </ng-container>\n                    <ng-content *ngIf=\"!sidebarRightTemplate\"\n                                select=\"adf-viewer-sidebar\"></ng-content>\n                </div>\n            </ng-container>\n\n            <ng-container *ngIf=\"allowLeftSidebar && showLeftSidebar\">\n                <div class=\"adf-viewer__sidebar\"\n                     [ngClass]=\"'adf-viewer__sidebar__left'\"\n                     fxFlexOrder=\"1\"\n                     id=\"adf-left-sidebar\">\n                    <ng-container *ngIf=\"sidebarLeftTemplate\">\n                        <ng-container *ngTemplateOutlet=\"sidebarLeftTemplate;context:sidebarLeftTemplateContext\">\n                        </ng-container>\n                    </ng-container>\n                    <ng-content *ngIf=\"!sidebarLeftTemplate\"\n                                select=\"adf-viewer-sidebar\"></ng-content>\n                </div>\n            </ng-container>\n\n            <div *ngIf=\"isLoading\"\n                 class=\"adf-viewer-main\"\n                 fxFlexOrder=\"1\"\n                 fxFlex=\"1 1 auto\">\n                <div class=\"adf-viewer-layout-content adf-viewer__fullscreen-container\">\n                    <div class=\"adf-viewer-content-container\">\n                        <ng-container *ngIf=\"isLoading\">\n                            <div class=\"adf-viewer__loading-screen\"\n                                 fxFlex=\"1 1 auto\">\n                                <h2>{{ 'ADF_VIEWER.LOADING' | translate }}</h2>\n                                <div>\n                                    <mat-spinner></mat-spinner>\n                                </div>\n                            </div>\n                        </ng-container>\n\n                    </div>\n                </div>\n            </div>\n\n            <div *ngIf=\"!isLoading\"\n                 class=\"adf-viewer-main\"\n                 fxFlexOrder=\"1\"\n                 fxFlex=\"1 1 auto\">\n                <div class=\"adf-viewer-layout-content adf-viewer__fullscreen-container\">\n                    <div class=\"adf-viewer-content-container\" [ngSwitch]=\"viewerType\">\n                        <ng-container *ngSwitchCase=\"'external'\">\n                            <adf-preview-extension\n                                *ngIf=\"!!externalViewer\"\n                                [id]=\"externalViewer.component\"\n                                [node]=\"nodeEntry?.entry\"\n                                [url]=\"urlFileContent\"\n                                [extension]=\"externalViewer.fileExtension\"\n                                [attr.data-automation-id]=\"externalViewer.component\">\n                            </adf-preview-extension>\n                        </ng-container>\n\n                        <ng-container *ngSwitchCase=\"'pdf'\">\n                            <adf-pdf-viewer (close)=\"onBackButtonClick()\"\n                                            [thumbnailsTemplate]=\"thumbnailsTemplate\"\n                                            [allowThumbnails]=\"allowThumbnails\"\n                                            [blobFile]=\"blobFile\"\n                                            [urlFile]=\"urlFileContent\"\n                                            [nameFile]=\"displayName\"\n                                            [cacheType]=\"cacheTypeForContent\"\n                                            (error)=\"onUnsupportedFile()\"></adf-pdf-viewer>\n                        </ng-container>\n\n                        <ng-container *ngSwitchCase=\"'image'\">\n                            <adf-img-viewer [urlFile]=\"urlFileContent\"\n                                            [nameFile]=\"displayName\"\n                                            [blobFile]=\"blobFile\"\n                                            [readOnly]=\"readOnly\"\n                                            (error)=\"onUnsupportedFile()\"\n                                            (submit)=\"onSubmitFile($event)\"\n                            ></adf-img-viewer>\n                        </ng-container>\n\n                        <ng-container *ngSwitchCase=\"'media'\">\n                            <adf-media-player id=\"adf-mdedia-player\"\n                                              [urlFile]=\"urlFileContent\"\n                                              [nodeId]=\"nodeEntry?.entry?.id\"\n                                              [mimeType]=\"mimeType\"\n                                              [blobFile]=\"blobFile\"\n                                              [nameFile]=\"displayName\"\n                                              (error)=\"onUnsupportedFile()\"></adf-media-player>\n                        </ng-container>\n\n                        <ng-container *ngSwitchCase=\"'text'\">\n                            <adf-txt-viewer [urlFile]=\"urlFileContent\"\n                                            [blobFile]=\"blobFile\"></adf-txt-viewer>\n                        </ng-container>\n\n                        <ng-container *ngSwitchCase=\"'in_creation'\">\n                            <div class=\"adf-viewer__loading-screen\"\n                                 fxFlex=\"1 1 auto\">\n                                <h2>{{ 'ADF_VIEWER.LOADING' | translate }}</h2>\n                                <div>\n                                    <mat-spinner></mat-spinner>\n                                </div>\n                            </div>\n                        </ng-container>\n\n                        <ng-container *ngSwitchCase=\"'custom'\">\n                            <ng-container *ngFor=\"let ext of viewerExtensions\">\n                                <adf-preview-extension *ngIf=\"checkExtensions(ext.fileExtension)\"\n                                                       [id]=\"ext.component\"\n                                                       [node]=\"nodeEntry.entry\"\n                                                       [url]=\"urlFileContent\"\n                                                       [extension]=\"extension\"\n                                                       [attr.data-automation-id]=\"ext.component\">\n                                </adf-preview-extension>\n                            </ng-container>\n\n                            <span class=\"adf-viewer-custom-content\"\n                                  *ngFor=\"let extensionTemplate of extensionTemplates\">\n                                <ng-template *ngIf=\"extensionTemplate.isVisible\"\n                                             [ngTemplateOutlet]=\"extensionTemplate.template\"\n                                             [ngTemplateOutletContext]=\"{ urlFileContent: urlFileContent, extension:extension }\">\n                                </ng-template>\n                            </span>\n                        </ng-container>\n\n                        <ng-container *ngSwitchDefault>\n                            <adf-viewer-unknown-format></adf-viewer-unknown-format>\n                        </ng-container>\n                    </div>\n                </div>\n            </div>\n\n        </div>\n    </div>\n</div>\n",
                host: { 'class': 'adf-viewer' },
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-full-screen,.adf-viewer-container .adf-viewer-content,.adf-viewer-container .adf-viewer-layout,.adf-viewer-container .adf-viewer-layout-content,.adf-viewer-inline-container{background-color:var(--theme-card-bg-color);height:100%;width:100%}.adf-viewer{height:100%;position:absolute;width:100%}.adf-viewer .mat-toolbar{color:var(--theme-text-color)}.adf-viewer .mat-toolbar .adf-toolbar-title{width:auto}.adf-viewer-main{width:0}.adf-viewer__mimeicon{height:18px;vertical-align:middle;width:18px}.adf-viewer-toolbar .mat-toolbar{background-color:var(--theme-card-bg-bold-color)}.adf-viewer__file-title{text-align:center}.adf-viewer__display-name{color:var(--theme-text-fg-color);display:inline-block;font-size:16px;font-stretch:normal;font-style:normal;font-weight:400;letter-spacing:-.4px;line-height:1.5;max-width:400px;opacity:.87;overflow:hidden;text-overflow:ellipsis;vertical-align:middle}.adf-viewer-container .adf-viewer-layout-content{background-color:var(--theme-background-color);display:flex;flex:1;flex-direction:row;flex-wrap:wrap;overflow-x:hidden;overflow-y:hidden;position:relative;z-index:1}.adf-viewer-container .adf-viewer-layout-content>div{align-items:stretch;display:flex;flex-flow:row wrap;height:100%;margin:0 auto}.adf-viewer-container .adf-viewer-layout{display:flex;flex-direction:row;overflow-x:hidden;overflow-y:auto;position:relative}.adf-viewer-container .adf-viewer-content{flex:1}.adf-viewer-container .adf-viewer-content>div{height:0}.adf-viewer-overlay-container .adf-viewer-content{left:0;position:fixed;top:0;z-index:1000}.adf-viewer-content-container{display:flex;justify-content:center}.adf-viewer-custom-content{width:100vw}.adf-viewer-unknown-content,.adf-viewer__loading-screen{align-items:center;display:flex}.adf-viewer__loading-screen{flex-direction:column;height:85vh;justify-content:center}.adf-viewer__loading-screen .mat-spinner{margin:0 auto}.adf-viewer__sidebar{background-color:var(--theme-background-color);box-shadow:0 2px 4px 0 var(--theme-text-fg-shadow-color);display:block;overflow:auto;padding:0;width:350px}.adf-viewer__sidebar__right{border-left:1px solid var(--theme-border-color)}.adf-viewer__sidebar__left{border-right:1px solid var(--theme-border-color)}.adf-viewer__thumbnails{background:#e6e6e6;display:flex;flex-direction:column;padding:0;width:180px}.adf-viewer__thumbnails .adf-info-drawer-layout{background:#e6e6e6;display:flex;flex:1;flex-direction:column}.adf-viewer__thumbnails .adf-info-drawer-layout-header{margin-bottom:0}.adf-viewer__thumbnails .adf-info-drawer-layout-content{height:100%;overflow:hidden;padding:0}.adf-viewer__thumbnails .adf-info-drawer-content{height:100%}.adf-viewer__thumbnails .adf-info-drawer-layout-content>:last-child{height:100%;overflow:hidden}.adf-viewer__toolbar-page-scale{border:1px solid var(--theme-border-color);cursor:default;font-size:14px;height:24px;line-height:24px;margin-left:4px;margin-right:4px;text-align:center;width:79px}"]
            },] }
];
ViewerComponent.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: ViewUtilService },
    { type: LogService },
    { type: AppExtensionService },
    { type: ContentService },
    { type: UploadService },
    { type: ElementRef },
    { type: MatDialog },
    { type: ChangeDetectorRef }
];
ViewerComponent.propDecorators = {
    toolbar: [{ type: ContentChild, args: [ViewerToolbarComponent,] }],
    sidebar: [{ type: ContentChild, args: [ViewerSidebarComponent,] }],
    mnuOpenWith: [{ type: ContentChild, args: [ViewerOpenWithComponent,] }],
    mnuMoreActions: [{ type: ContentChild, args: [ViewerMoreActionsComponent,] }],
    urlFile: [{ type: Input }],
    urlFileViewer: [{ type: Input }],
    blobFile: [{ type: Input }],
    nodeId: [{ type: Input }],
    versionId: [{ type: Input }],
    sharedLinkId: [{ type: Input }],
    overlayMode: [{ type: Input }],
    showViewer: [{ type: Input }],
    showToolbar: [{ type: Input }],
    displayName: [{ type: Input }],
    allowGoBack: [{ type: Input }],
    allowDownload: [{ type: Input }],
    allowPrint: [{ type: Input }],
    allowFullScreen: [{ type: Input }],
    allowNavigate: [{ type: Input }],
    canNavigateBefore: [{ type: Input }],
    canNavigateNext: [{ type: Input }],
    allowLeftSidebar: [{ type: Input }],
    allowRightSidebar: [{ type: Input }],
    allowThumbnails: [{ type: Input }],
    showRightSidebar: [{ type: Input }],
    showLeftSidebar: [{ type: Input }],
    sidebarRightTemplate: [{ type: Input }],
    sidebarLeftTemplate: [{ type: Input }],
    thumbnailsTemplate: [{ type: Input }],
    mimeType: [{ type: Input }],
    fileName: [{ type: Input }],
    maxRetries: [{ type: Input }],
    goBack: [{ type: Output }],
    print: [{ type: Output }],
    showViewerChange: [{ type: Output }],
    extensionChange: [{ type: Output }],
    navigateBefore: [{ type: Output }],
    navigateNext: [{ type: Output }],
    invalidSharedLink: [{ type: Output }],
    handleKeyboardEvent: [{ type: HostListener, args: ['document:keyup', ['$event'],] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ImgViewerComponent {
    constructor(appConfigService, contentService) {
        this.appConfigService = appConfigService;
        this.contentService = contentService;
        this.showToolbar = true;
        this.readOnly = true;
        this.error = new EventEmitter();
        this.submit = new EventEmitter();
        this.scale = 1.0;
        this.isEditing = false;
        this.initializeScaling();
    }
    get currentScaleText() {
        return Math.round(this.scale * 100) + '%';
    }
    initializeScaling() {
        const scaling = this.appConfigService.get('adf-viewer.image-viewer-scaling', undefined) / 100;
        if (scaling) {
            this.scale = scaling;
        }
    }
    ngAfterViewInit() {
        this.cropper = new Cropper(this.imageElement.nativeElement, {
            autoCrop: false,
            dragMode: 'move',
            background: false,
            scalable: true,
            zoomOnWheel: false,
            toggleDragModeOnDblclick: false,
            viewMode: 1,
            checkCrossOrigin: false,
            ready: () => {
                this.updateCanvasContainer();
            }
        });
    }
    ngOnDestroy() {
        this.cropper.destroy();
    }
    onKeyDown(event) {
        switch (event.key) {
            case 'ArrowLeft':
                event.preventDefault();
                this.cropper.move(-3, 0);
                break;
            case 'ArrowUp':
                event.preventDefault();
                this.cropper.move(0, -3);
                break;
            case 'ArrowRight':
                event.preventDefault();
                this.cropper.move(3, 0);
                break;
            case 'ArrowDown':
                event.preventDefault();
                this.cropper.move(0, 3);
                break;
            case 'i':
                this.zoomIn();
                break;
            case 'o':
                this.zoomOut();
                break;
            case 'r':
                this.rotateImage();
                break;
            default:
        }
    }
    ngOnChanges(changes) {
        const blobFile = changes['blobFile'];
        if (blobFile && blobFile.currentValue) {
            this.urlFile = this.contentService.createTrustedUrl(this.blobFile);
            return;
        }
        if (!this.urlFile && !this.blobFile) {
            throw new Error('Attribute urlFile or blobFile is required');
        }
    }
    zoomIn() {
        this.cropper.zoom(0.2);
        this.scale = +((this.scale + 0.2).toFixed(1));
    }
    zoomOut() {
        if (this.scale > 0.2) {
            this.cropper.zoom(-0.2);
            this.scale = +((this.scale - 0.2).toFixed(1));
        }
    }
    rotateImage() {
        this.isEditing = true;
        this.cropper.rotate(-90);
    }
    cropImage() {
        this.isEditing = true;
        this.cropper.setDragMode('crop');
        this.cropper.crop();
    }
    save() {
        this.isEditing = false;
        this.cropper.setDragMode('move');
        this.cropper.getCroppedCanvas().toBlob((blob) => {
            this.submit.emit(blob);
            this.cropper.replace(this.cropper.getCroppedCanvas().toDataURL());
            this.cropper.clear();
        });
    }
    reset() {
        this.isEditing = false;
        this.cropper.clear();
        this.cropper.reset();
        this.cropper.setDragMode('move');
        this.scale = 1.0;
        this.updateCanvasContainer();
    }
    updateCanvasContainer() {
        if (this.imageElement.nativeElement.width < this.cropper.getContainerData().width) {
            const width = this.imageElement.nativeElement.width;
            const height = this.imageElement.nativeElement.height;
            const top = (this.cropper.getContainerData().height - this.imageElement.nativeElement.height) / 2;
            const left = (this.cropper.getContainerData().width - this.imageElement.nativeElement.width) / 2;
            this.cropper.setCanvasData({
                width,
                height,
                top,
                left
            });
        }
    }
    onImageError() {
        this.error.emit();
    }
}
ImgViewerComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-img-viewer',
                template: "<div id=\"adf-image-container\" (keydown)=\"onKeyDown($event)\" class=\"adf-image-container\" tabindex=\"0\" role=\"img\" [attr.aria-label]=\"nameFile\" data-automation-id=\"adf-image-container\">\n    <img #image id=\"viewer-image\" [src]=\"urlFile\" [alt]=\"nameFile\" (error)=\"onImageError()\" />\n</div>\n\n<div class=\"adf-image-viewer__toolbar\" *ngIf=\"showToolbar\">\n    <adf-toolbar class=\"adf-main-toolbar\">\n        <button\n            id=\"viewer-zoom-out-button\"\n            title=\"{{ 'ADF_VIEWER.ARIA.ZOOM_OUT' | translate }}\"\n            attr.aria-label=\"{{ 'ADF_VIEWER.ARIA.ZOOM_OUT' | translate }}\"\n            mat-icon-button\n            (click)=\"zoomOut()\">\n            <mat-icon>zoom_out</mat-icon>\n        </button>\n\n        <div class=\"adf-viewer__toolbar-page-scale\" data-automation-id=\"adf-page-scale\">\n            {{ currentScaleText }}\n        </div>\n\n        <button\n            id=\"viewer-zoom-in-button\"\n            mat-icon-button\n            title=\"{{ 'ADF_VIEWER.ARIA.ZOOM_IN' | translate }}\"\n            attr.aria-label=\"{{ 'ADF_VIEWER.ARIA.ZOOM_IN' | translate }}\"\n            (click)=\"zoomIn()\">\n            <mat-icon>zoom_in</mat-icon>\n        </button>\n\n        <button\n            *ngIf=\"!readOnly\" id=\"viewer-rotate-button\"\n            title=\"{{ 'ADF_VIEWER.ARIA.ROTATE' | translate }}\"\n            attr.aria-label=\"{{ 'ADF_VIEWER.ARIA.ROTATE' | translate }}\"\n            mat-icon-button\n            (click)=\"rotateImage()\">\n            <mat-icon>rotate_left</mat-icon>\n        </button>\n        <button\n            *ngIf=\"!readOnly\" id=\"viewer-crop-button\"\n            title=\"{{ 'ADF_VIEWER.ARIA.CROP' | translate }}\"\n            attr.aria-label=\"{{ 'ADF_VIEWER.ARIA.CROP' | translate }}\"\n            mat-icon-button\n            (click)=\"cropImage()\">\n            <mat-icon>crop</mat-icon>\n        </button>\n\n        <button\n            id=\"viewer-reset-button\"\n            title=\"{{ 'ADF_VIEWER.ARIA.RESET' | translate }}\"\n            attr.aria-label=\"{{ 'ADF_VIEWER.ARIA.RESET' | translate }}\"\n            mat-icon-button\n            (click)=\"reset()\">\n            <mat-icon>zoom_out_map</mat-icon>\n        </button>\n\n    </adf-toolbar>\n\n    <adf-toolbar class=\"adf-secondary-toolbar\" *ngIf=\"!readOnly && isEditing\">\n        <button\n            id=\"viewer-cancel-button\"\n            title=\"{{ 'ADF_VIEWER.ARIA.CANCEL' | translate }}\"\n            attr.aria-label=\"{{ 'ADF_VIEWER.ARIA.CANCEL' | translate }}\"\n            mat-icon-button\n            (click)=\"reset()\">\n            <mat-icon>close</mat-icon>\n        </button>\n\n        <button\n            id=\"viewer-save-button\"\n            title=\"{{ 'ADF_VIEWER.ARIA.SAVE' | translate }}\"\n            attr.aria-label=\"{{ 'ADF_VIEWER.ARIA.SAVE' | translate }}\"\n            mat-icon-button\n            (click)=\"save()\">\n            <mat-icon>check</mat-icon>\n        </button>\n\n    </adf-toolbar>\n</div>\n",
                host: { 'class': 'adf-image-viewer' },
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-image-viewer{width:100%}.adf-image-viewer .adf-image-container{align-items:center;display:flex;height:90vh;justify-content:center}.adf-image-viewer .adf-image-container:focus{outline:1px solid var(--theme-accent-color-a200);outline-offset:-1px}.adf-image-viewer .adf-image-container img{max-height:100%;max-width:100%}@media screen and (-ms-high-contrast:active),screen and (-ms-high-contrast:none){.adf-image-viewer .adf-image-container img{height:100%}}.adf-image-viewer__toolbar{bottom:5px;left:50%;position:absolute;transform:translateX(-50%)}.adf-image-viewer__toolbar .adf-toolbar .mat-toolbar{background-color:var(--theme-card-bg-color);border-radius:2px;border-width:0;box-shadow:0 2px 2px 0 rgba(0,0,0,.24),0 0 2px 0 rgba(0,0,0,.12);max-height:48px}.adf-image-viewer__toolbar .adf-main-toolbar{display:inline-block}.adf-image-viewer__toolbar .adf-secondary-toolbar{display:inline-block;margin-left:10px}"]
            },] }
];
ImgViewerComponent.ctorParameters = () => [
    { type: AppConfigService },
    { type: ContentService }
];
ImgViewerComponent.propDecorators = {
    showToolbar: [{ type: Input }],
    readOnly: [{ type: Input }],
    urlFile: [{ type: Input }],
    blobFile: [{ type: Input }],
    nameFile: [{ type: Input }],
    error: [{ type: Output }],
    submit: [{ type: Output }],
    imageElement: [{ type: ViewChild, args: ['image', { static: false },] }],
    onKeyDown: [{ type: HostListener, args: ['document:keydown', ['$event'],] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class MediaPlayerComponent {
    constructor(contentService, viewUtils) {
        this.contentService = contentService;
        this.viewUtils = viewUtils;
        this.tracks = [];
        this.error = new EventEmitter();
    }
    ngOnChanges(changes) {
        const blobFile = changes['blobFile'];
        const nodeId = changes['nodeId'];
        if (blobFile && blobFile.currentValue) {
            this.urlFile = this.contentService.createTrustedUrl(this.blobFile);
            return;
        }
        if (nodeId && nodeId.currentValue) {
            this.viewUtils.generateMediaTracks(this.nodeId).then((tracks) => this.tracks = tracks);
        }
        if (!this.urlFile && !this.blobFile) {
            throw new Error('Attribute urlFile or blobFile is required');
        }
    }
    onMediaPlayerError() {
        this.error.emit();
    }
}
MediaPlayerComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-media-player',
                template: "<video controls [ngClass]=\"{'adf-audio-file': mimeType && mimeType.startsWith('audio')}\">\n    <source [src]=\"urlFile\" [type]=\"mimeType\" (error)=\"onMediaPlayerError()\"/>\n    <track *ngFor=\"let track of tracks\" [kind]=\"track.kind\" [label]=\"track.label\" [srclang]=\"track.srclang\" [src]=\"track.src\"/>\n</video>\n",
                host: { 'class': 'adf-media-player' },
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-media-player{display:flex}.adf-media-player video{display:flex;flex:1;max-height:90vh;max-width:100%}.adf-media-player video.adf-audio-file::-webkit-media-text-track-container{transform:translateY(-50%)!important}"]
            },] }
];
MediaPlayerComponent.ctorParameters = () => [
    { type: ContentService },
    { type: ViewUtilService }
];
MediaPlayerComponent.propDecorators = {
    urlFile: [{ type: Input }],
    blobFile: [{ type: Input }],
    mimeType: [{ type: Input }],
    nameFile: [{ type: Input }],
    nodeId: [{ type: Input }],
    tracks: [{ type: Input }],
    error: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PdfPasswordDialogComponent {
    constructor(dialogRef, data) {
        this.dialogRef = dialogRef;
        this.data = data;
    }
    ngOnInit() {
        this.passwordFormControl = new FormControl('', [Validators.required]);
    }
    isError() {
        return this.data.reason === pdfjsLib.PasswordResponses.INCORRECT_PASSWORD;
    }
    isValid() {
        return !this.passwordFormControl.hasError('required');
    }
    submit() {
        this.dialogRef.close(this.passwordFormControl.value);
    }
}
PdfPasswordDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-pdf-viewer-password-dialog',
                template: "<div mat-dialog-title>\n    <mat-icon>lock</mat-icon>\n</div>\n\n<mat-dialog-content>\n    <form (submit)=\"submit()\">\n        <mat-form-field class=\"adf-full-width\">\n            <input matInput\n                   data-automation-id='adf-password-dialog-input'\n                   type=\"password\"\n                   placeholder=\"{{ 'ADF_VIEWER.PDF_DIALOG.PLACEHOLDER' | translate }}\"\n                   [formControl]=\"passwordFormControl\" />\n        </mat-form-field>\n\n        <mat-error *ngIf=\"isError()\" data-automation-id='adf-password-dialog-error'>{{ 'ADF_VIEWER.PDF_DIALOG.ERROR' | translate }}</mat-error>\n    </form>\n</mat-dialog-content>\n\n<mat-dialog-actions class=\"adf-dialog-buttons\">\n    <span class=\"adf-fill-remaining-space\"></span>\n\n    <button mat-button mat-dialog-close data-automation-id='adf-password-dialog-close'>{{ 'ADF_VIEWER.PDF_DIALOG.CLOSE' | translate }}</button>\n\n    <button mat-button\n            data-automation-id='adf-password-dialog-submit'\n            class=\"adf-dialog-action-button\"\n            [disabled]=\"!isValid()\"\n            (click)=\"submit()\">\n        {{ 'ADF_VIEWER.PDF_DIALOG.SUBMIT' | translate }}\n    </button>\n</mat-dialog-actions>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-fill-remaining-space{flex:1 1 auto}.adf-full-width{width:100%}.adf-dialog-buttons button{text-transform:uppercase}.adf-dialog-action-button:enabled{color:var(--theme-primary-color)}"]
            },] }
];
PdfPasswordDialogComponent.ctorParameters = () => [
    { type: MatDialogRef },
    { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] }] }
];

class RenderingQueueServices {
    constructor() {
        this.renderingStates = {
            INITIAL: 0,
            RUNNING: 1,
            PAUSED: 2,
            FINISHED: 3
        };
        this.CLEANUP_TIMEOUT = 30000;
        this.pdfViewer = null;
        this.pdfThumbnailViewer = null;
        this.onIdle = null;
        this.highestPriorityPage = null;
        this.idleTimeout = null;
        this.printing = false;
        this.isThumbnailViewEnabled = false;
    }
    setViewer(pdfViewer) {
        this.pdfViewer = pdfViewer;
    }
    setThumbnailViewer(pdfThumbnailViewer) {
        this.pdfThumbnailViewer = pdfThumbnailViewer;
    }
    isHighestPriority(view) {
        return this.highestPriorityPage === view.renderingId;
    }
    renderHighestPriority(currentlyVisiblePages) {
        if (this.idleTimeout) {
            clearTimeout(this.idleTimeout);
            this.idleTimeout = null;
        }
        if (this.pdfViewer.forceRendering(currentlyVisiblePages)) {
            return;
        }
        if (this.pdfThumbnailViewer && this.isThumbnailViewEnabled) {
            if (this.pdfThumbnailViewer.forceRendering()) {
                return;
            }
        }
        if (this.printing) {
            return;
        }
        if (this.onIdle) {
            this.idleTimeout = setTimeout(this.onIdle.bind(this), this.CLEANUP_TIMEOUT);
        }
    }
    getHighestPriority(visible, views, scrolledDown) {
        const visibleViews = visible.views;
        const numVisible = visibleViews.length;
        if (numVisible === 0) {
            return false;
        }
        for (let i = 0; i < numVisible; ++i) {
            const view = visibleViews[i].view;
            if (!this.isViewFinished(view)) {
                return view;
            }
        }
        if (scrolledDown) {
            const nextPageIndex = visible.last.id;
            if (views[nextPageIndex] && !this.isViewFinished(views[nextPageIndex])) {
                return views[nextPageIndex];
            }
        }
        else {
            const previousPageIndex = visible.first.id - 2;
            if (views[previousPageIndex] && !this.isViewFinished(views[previousPageIndex])) {
                return views[previousPageIndex];
            }
        }
        return null;
    }
    isViewFinished(view) {
        return view.renderingState === this.renderingStates.FINISHED;
    }
    renderView(view) {
        const state = view.renderingState;
        switch (state) {
            case this.renderingStates.FINISHED:
                return false;
            case this.renderingStates.PAUSED:
                this.highestPriorityPage = view.renderingId;
                view.resume();
                break;
            case this.renderingStates.RUNNING:
                this.highestPriorityPage = view.renderingId;
                break;
            case this.renderingStates.INITIAL:
                this.highestPriorityPage = view.renderingId;
                const continueRendering = function () {
                    this.renderHighestPriority();
                }.bind(this);
                view.draw().then(continueRendering, continueRendering);
                break;
            default:
                break;
        }
        return true;
    }
}
RenderingQueueServices.decorators = [
    { type: Injectable }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PdfViewerComponent {
    constructor(dialog, renderingQueueServices, logService, appConfigService) {
        this.dialog = dialog;
        this.renderingQueueServices = renderingQueueServices;
        this.logService = logService;
        this.appConfigService = appConfigService;
        this.showToolbar = true;
        this.allowThumbnails = false;
        this.thumbnailsTemplate = null;
        this.cacheType = '';
        this.rendered = new EventEmitter();
        this.error = new EventEmitter();
        this.close = new EventEmitter();
        this.currentScaleMode = 'auto';
        this.currentScale = 1;
        this.MAX_AUTO_SCALE = 1.25;
        this.DEFAULT_SCALE_DELTA = 1.1;
        this.MIN_SCALE = 0.25;
        this.MAX_SCALE = 10.0;
        this.isPanelDisabled = true;
        this.showThumbnails = false;
        this.pdfThumbnailsContext = { viewer: null };
        this.eventBus = new pdfjsViewer.EventBus();
        this.pdfjsDefaultOptions = {
            disableAutoFetch: true,
            disableStream: true
        };
        this.pdfjsWorkerDestroy$ = new Subject();
        this.onDestroy$ = new Subject();
        this.onPageChange = this.onPageChange.bind(this);
        this.onPagesLoaded = this.onPagesLoaded.bind(this);
        this.onPageRendered = this.onPageRendered.bind(this);
        this.randomPdfId = this.generateUuid();
        this.currentScale = this.getUserScaling();
        this.pdfjsWorkerDestroy$.pipe(catchError(() => null), delay(700)).subscribe(() => this.destroyPdJsWorker());
    }
    get currentScaleText() {
        return Math.round(this.currentScale * 100) + '%';
    }
    getUserScaling() {
        const scaleConfig = this.appConfigService.get('adf-viewer.pdf-viewer-scaling', undefined) / 100;
        if (scaleConfig) {
            return this.checkLimits(scaleConfig);
        }
        else {
            return 1;
        }
    }
    checkLimits(scaleConfig) {
        if (scaleConfig > this.MAX_SCALE) {
            return this.MAX_SCALE;
        }
        else if (scaleConfig < this.MIN_SCALE) {
            return this.MIN_SCALE;
        }
        else {
            return scaleConfig;
        }
    }
    ngOnChanges(changes) {
        const blobFile = changes['blobFile'];
        if (blobFile && blobFile.currentValue) {
            const reader = new FileReader();
            reader.onload = () => __awaiter(this, void 0, void 0, function* () {
                const pdfSource = Object.assign(Object.assign({}, this.pdfjsDefaultOptions), { data: reader.result, withCredentials: this.appConfigService.get('auth.withCredentials', undefined) });
                this.executePdf(pdfSource);
            });
            reader.readAsArrayBuffer(blobFile.currentValue);
        }
        const urlFile = changes['urlFile'];
        if (urlFile && urlFile.currentValue) {
            const pdfSource = Object.assign(Object.assign({}, this.pdfjsDefaultOptions), { url: urlFile.currentValue, withCredentials: this.appConfigService.get('auth.withCredentials', undefined) });
            if (this.cacheType) {
                pdfSource.httpHeaders = {
                    'Cache-Control': this.cacheType
                };
            }
            this.executePdf(pdfSource);
        }
        if (!this.urlFile && !this.blobFile) {
            throw new Error('Attribute urlFile or blobFile is required');
        }
    }
    executePdf(pdfOptions) {
        pdfjsLib.GlobalWorkerOptions.workerSrc = 'pdf.worker.min.js';
        this.loadingTask = pdfjsLib.getDocument(pdfOptions);
        this.loadingTask.onPassword = (callback, reason) => {
            this.onPdfPassword(callback, reason);
        };
        this.loadingTask.onProgress = (progressData) => {
            const level = progressData.loaded / progressData.total;
            this.loadingPercent = Math.round(level * 100);
        };
        this.loadingTask.promise.then((pdfDocument) => {
            this.totalPages = pdfDocument.numPages;
            this.page = 1;
            this.displayPage = 1;
            this.initPDFViewer(pdfDocument);
            return pdfDocument.getPage(1);
        })
            .then(() => this.scalePage('auto'))
            .catch(() => this.error.emit());
    }
    initPDFViewer(pdfDocument) {
        const viewer = this.getViewer();
        const container = this.getDocumentContainer();
        if (viewer && container) {
            this.pdfViewer = new pdfjsViewer.PDFViewer({
                container: container,
                viewer: viewer,
                renderingQueue: this.renderingQueueServices,
                eventBus: this.eventBus
            });
            this.eventBus.on('pagechanging', this.onPageChange);
            this.eventBus.on('pagesloaded', this.onPagesLoaded);
            this.eventBus.on('textlayerrendered', this.onPageRendered);
            this.renderingQueueServices.setViewer(this.pdfViewer);
            this.pdfViewer.setDocument(pdfDocument);
            this.pdfThumbnailsContext.viewer = this.pdfViewer;
        }
    }
    ngOnDestroy() {
        if (this.pdfViewer) {
            this.eventBus.off('pagechanging');
            this.eventBus.off('pagesloaded');
            this.eventBus.off('textlayerrendered');
        }
        if (this.loadingTask) {
            this.pdfjsWorkerDestroy$.next();
        }
        this.onDestroy$.next();
        this.pdfjsWorkerDestroy$.complete();
        this.onDestroy$.complete();
    }
    destroyPdJsWorker() {
        this.loadingTask.destroy();
        this.loadingTask = null;
    }
    toggleThumbnails() {
        this.showThumbnails = !this.showThumbnails;
    }
    scalePage(scaleMode) {
        this.currentScaleMode = scaleMode;
        const viewerContainer = document.getElementById(`${this.randomPdfId}-viewer-main-container`);
        const documentContainer = this.getDocumentContainer();
        if (this.pdfViewer && documentContainer) {
            let widthContainer;
            let heightContainer;
            if (viewerContainer && viewerContainer.clientWidth <= documentContainer.clientWidth) {
                widthContainer = viewerContainer.clientWidth;
                heightContainer = viewerContainer.clientHeight;
            }
            else {
                widthContainer = documentContainer.clientWidth;
                heightContainer = documentContainer.clientHeight;
            }
            const currentPage = this.pdfViewer._pages[this.pdfViewer._currentPageNumber - 1];
            const padding = 20;
            const pageWidthScale = (widthContainer - padding) / currentPage.width * currentPage.scale;
            const pageHeightScale = (heightContainer - padding) / currentPage.width * currentPage.scale;
            let scale = this.getUserScaling();
            if (!scale) {
                switch (this.currentScaleMode) {
                    case 'page-actual':
                        scale = 1;
                        break;
                    case 'page-width':
                        scale = pageWidthScale;
                        break;
                    case 'page-height':
                        scale = pageHeightScale;
                        break;
                    case 'page-fit':
                        scale = Math.min(pageWidthScale, pageHeightScale);
                        break;
                    case 'auto':
                        let horizontalScale;
                        if (this.isLandscape) {
                            horizontalScale = Math.min(pageHeightScale, pageWidthScale);
                        }
                        else {
                            horizontalScale = pageWidthScale;
                        }
                        horizontalScale = Math.round(horizontalScale);
                        scale = Math.min(this.MAX_AUTO_SCALE, horizontalScale);
                        scale = this.checkPageFitInContainer(scale);
                        break;
                    default:
                        this.logService.error('pdfViewSetScale: \'' + scaleMode + '\' is an unknown zoom value.');
                        return;
                }
                this.setScaleUpdatePages(scale);
            }
            else {
                this.currentScale = 0;
                scale = this.checkPageFitInContainer(scale);
                this.setScaleUpdatePages(scale);
            }
        }
    }
    getDocumentContainer() {
        return document.getElementById(`${this.randomPdfId}-viewer-pdf-viewer`);
    }
    getViewer() {
        return document.getElementById(`${this.randomPdfId}-viewer-viewerPdf`);
    }
    checkPageFitInContainer(scale) {
        const documentContainerSize = this.getDocumentContainer();
        const page = this.pdfViewer._pages[this.pdfViewer._currentPageNumber - 1];
        if (page.width > documentContainerSize.clientWidth) {
            scale = Math.fround((documentContainerSize.clientWidth - 20) / page.width);
            if (scale < this.MIN_SCALE) {
                scale = this.MIN_SCALE;
            }
        }
        return scale;
    }
    setScaleUpdatePages(newScale) {
        if (this.pdfViewer) {
            if (!this.isSameScale(this.currentScale, newScale)) {
                this.currentScale = newScale;
                this.pdfViewer._pages.forEach(function (currentPage) {
                    currentPage.update(newScale);
                });
            }
            this.pdfViewer.update();
        }
    }
    isSameScale(oldScale, newScale) {
        return (newScale === oldScale);
    }
    isLandscape(width, height) {
        return (width > height);
    }
    onResize() {
        this.scalePage(this.currentScaleMode);
    }
    pageFit() {
        if (this.currentScaleMode !== 'page-fit') {
            this.scalePage('page-fit');
        }
        else {
            this.scalePage('auto');
        }
    }
    zoomIn(ticks) {
        let newScale = this.currentScale;
        do {
            newScale = (newScale * this.DEFAULT_SCALE_DELTA).toFixed(2);
            newScale = Math.ceil(newScale * 10) / 10;
            newScale = Math.min(this.MAX_SCALE, newScale);
        } while (--ticks > 0 && newScale < this.MAX_SCALE);
        this.currentScaleMode = 'auto';
        this.setScaleUpdatePages(newScale);
    }
    zoomOut(ticks) {
        let newScale = this.currentScale;
        do {
            newScale = (newScale / this.DEFAULT_SCALE_DELTA).toFixed(2);
            newScale = Math.floor(newScale * 10) / 10;
            newScale = Math.max(this.MIN_SCALE, newScale);
        } while (--ticks > 0 && newScale > this.MIN_SCALE);
        this.currentScaleMode = 'auto';
        this.setScaleUpdatePages(newScale);
    }
    previousPage() {
        if (this.pdfViewer && this.page > 1) {
            this.page--;
            this.displayPage = this.page;
            this.pdfViewer.currentPageNumber = this.page;
        }
    }
    nextPage() {
        if (this.pdfViewer && this.page < this.totalPages) {
            this.page++;
            this.displayPage = this.page;
            this.pdfViewer.currentPageNumber = this.page;
        }
    }
    inputPage(page) {
        const pageInput = parseInt(page, 10);
        if (!isNaN(pageInput) && pageInput > 0 && pageInput <= this.totalPages) {
            this.page = pageInput;
            this.displayPage = this.page;
            this.pdfViewer.currentPageNumber = this.page;
        }
        else {
            this.displayPage = this.page;
        }
    }
    onPageChange(event) {
        if (event.source && event.source.container.id === `${this.randomPdfId}-viewer-pdf-viewer`) {
            this.page = event.pageNumber;
            this.displayPage = event.pageNumber;
        }
    }
    onPdfPassword(callback, reason) {
        this.dialog
            .open(PdfPasswordDialogComponent, {
            width: '400px',
            data: { reason }
        })
            .afterClosed().subscribe((password) => {
            if (password) {
                callback(password);
            }
            else {
                this.close.emit();
            }
        });
    }
    onPageRendered() {
        this.rendered.emit();
    }
    onPagesLoaded() {
        this.isPanelDisabled = false;
    }
    handleKeyboardEvent(event) {
        const key = event.keyCode;
        if (key === 39) {
            this.nextPage();
        }
        else if (key === 37) {
            this.previousPage();
        }
    }
    generateUuid() {
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function (c) {
            const r = Math.random() * 16 | 0, v = c === 'x' ? r : (r & 0x3 | 0x8);
            return v.toString(16);
        });
    }
}
PdfViewerComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-pdf-viewer',
                template: "<div class=\"adf-pdf-viewer__container\">\n    <ng-container *ngIf=\"showThumbnails\">\n        <div class=\"adf-pdf-viewer__thumbnails\">\n            <div class=\"adf-thumbnails-template__container\">\n                <div class=\"adf-thumbnails-template__buttons\">\n                    <button\n                        mat-icon-button\n                        data-automation-id='adf-thumbnails-close'\n                        (click)=\"toggleThumbnails()\"\n                        [attr.aria-label]=\"'ADF_VIEWER.ARIA.THUMBNAILS_PANLEL_CLOSE' | translate\"\n                        title=\"{{ 'ADF_VIEWER.ACTIONS.CLOSE' | translate }}\">\n                        <mat-icon>close</mat-icon>\n                    </button>\n                </div>\n\n                <ng-container *ngIf=\"thumbnailsTemplate\">\n                    <ng-container *ngTemplateOutlet=\"thumbnailsTemplate;context:pdfThumbnailsContext\"></ng-container>\n                </ng-container>\n\n                <ng-container *ngIf=\"!thumbnailsTemplate\">\n                    <adf-pdf-thumbnails (close)=\"toggleThumbnails()\" [pdfViewer]=\"pdfViewer\"></adf-pdf-thumbnails>\n                </ng-container>\n            </div>\n        </div>\n    </ng-container>\n\n    <div class=\"adf-pdf-viewer__content\">\n        <div [id]=\"randomPdfId+'-viewer-pdf-viewer'\" class=\"adf-viewer-pdf-viewer\" (window:resize)=\"onResize()\">\n            <div [id]=\"randomPdfId+'-viewer-viewerPdf'\" class=\"adf-pdfViewer\" role=\"document\" tabindex=\"0\" aria-expanded=\"true\">\n                <div id=\"loader-container\" class=\"adf-loader-container\">\n                    <div class=\"adf-loader-item\">\n                        <mat-progress-bar mode=\"indeterminate\"></mat-progress-bar>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </div>\n</div>\n\n<div class=\"adf-pdf-viewer__toolbar\" *ngIf=\"showToolbar\">\n    <adf-toolbar>\n\n        <ng-container *ngIf=\"allowThumbnails\">\n            <button mat-icon-button\n                    [attr.aria-label]=\"'ADF_VIEWER.ARIA.THUMBNAILS' | translate\"\n                    [attr.aria-expanded]=\"showThumbnails\"\n                    data-automation-id=\"adf-thumbnails-button\"\n                    [disabled]=\"isPanelDisabled\"\n                    (click)=\"toggleThumbnails()\">\n                <mat-icon>dashboard</mat-icon>\n            </button>\n            <adf-toolbar-divider></adf-toolbar-divider>\n        </ng-container>\n\n        <button\n            id=\"viewer-previous-page-button\"\n            title=\"{{ 'ADF_VIEWER.ARIA.PREVIOUS_PAGE' | translate }}\"\n            attr.aria-label=\"{{ 'ADF_VIEWER.ARIA.PREVIOUS_PAGE' | translate }}\"\n            mat-icon-button\n            (click)=\"previousPage()\">\n            <mat-icon>keyboard_arrow_up</mat-icon>\n        </button>\n\n        <button\n            id=\"viewer-next-page-button\"\n            title=\"{{ 'ADF_VIEWER.ARIA.NEXT_PAGE' | translate }}\"\n            attr.aria-label=\"{{ 'ADF_VIEWER.ARIA.NEXT_PAGE' | translate }}\"\n            mat-icon-button\n            (click)=\"nextPage()\">\n            <mat-icon>keyboard_arrow_down</mat-icon>\n        </button>\n\n        <div class=\"adf-pdf-viewer__toolbar-page-selector\">\n            <span>{{ 'ADF_VIEWER.PAGE_LABEL.SHOWING' | translate }}</span>\n            <input #page\n                   type=\"text\"\n                   data-automation-id=\"adf-page-selector\"\n                   pattern=\"-?[0-9]*(\\.[0-9]+)?\"\n                   value=\"{{ displayPage }}\"\n                   (keyup.enter)=\"inputPage(page.value)\">\n            <span>{{ 'ADF_VIEWER.PAGE_LABEL.OF' | translate }} {{ totalPages }}</span>\n        </div>\n\n        <div class=\"adf-viewer__toolbar-page-scale\" data-automation-id=\"adf-page-scale\">\n            {{ currentScaleText }}\n        </div>\n\n        <button\n            id=\"viewer-zoom-in-button\"\n            title=\"{{ 'ADF_VIEWER.ARIA.ZOOM_IN' | translate }}\"\n            attr.aria-label=\"{{ 'ADF_VIEWER.ARIA.ZOOM_IN' | translate }}\"\n            mat-icon-button\n            (click)=\"zoomIn()\">\n            <mat-icon>zoom_in</mat-icon>\n        </button>\n\n        <button\n            id=\"viewer-zoom-out-button\"\n            title=\"{{ 'ADF_VIEWER.ARIA.ZOOM_OUT' | translate }}\"\n            attr.aria-label=\"{{ 'ADF_VIEWER.ARIA.ZOOM_OUT' | translate }}\"\n            mat-icon-button\n            (click)=\"zoomOut()\">\n            <mat-icon>zoom_out</mat-icon>\n        </button>\n\n        <button\n            id=\"viewer-scale-page-button\"\n            title=\"{{ 'ADF_VIEWER.ARIA.FIT_PAGE' | translate }}\"\n            attr.aria-label=\"{{ 'ADF_VIEWER.ARIA.FIT_PAGE' | translate }}\"\n            mat-icon-button\n            (click)=\"pageFit()\">\n            <mat-icon>zoom_out_map</mat-icon>\n        </button>\n\n    </adf-toolbar>\n</div>\n",
                providers: [RenderingQueueServices],
                host: { 'class': 'adf-pdf-viewer' },
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-pdf-viewer .textLayer>span{color:transparent;cursor:text;position:absolute;transform-origin:0 0;white-space:pre}.adf-pdf-viewer .textLayer .highlight{background-color:#b400aa;border-radius:4px;margin:-1px;padding:1px}.adf-pdf-viewer .textLayer .highlight.begin{border-radius:4px 0 0 4px}.adf-pdf-viewer .textLayer .highlight.end{border-radius:0 4px 4px 0}.adf-pdf-viewer .textLayer .highlight.middle{border-radius:0}.adf-pdf-viewer .textLayer .highlight.selected{background-color:#006400}.adf-pdf-viewer .textLayer ::selection{background:#00f}.adf-pdf-viewer .textLayer .endOfContent{-webkit-user-select:none;bottom:0;cursor:default;display:block;left:0;position:absolute;right:0;top:100%;user-select:none;z-index:-1}.adf-pdf-viewer .textLayer .endOfContent.active{top:0}.adf-pdf-viewer .annotationLayer section{position:absolute}.adf-pdf-viewer .annotationLayer .buttonWidgetAnnotation.pushButton>a,.adf-pdf-viewer .annotationLayer .linkAnnotation>a{font-size:1em;height:100%;left:0;position:absolute;top:0;width:100%}.adf-pdf-viewer .annotationLayer .buttonWidgetAnnotation.pushButton>a:hover,.adf-pdf-viewer .annotationLayer .linkAnnotation>a:hover{background:#ff0;box-shadow:0 2px 10px #ff0;opacity:.2}.adf-pdf-viewer .annotationLayer .textAnnotation img{cursor:pointer;position:absolute}.adf-pdf-viewer .annotationLayer .buttonWidgetAnnotation.checkBox input,.adf-pdf-viewer .annotationLayer .buttonWidgetAnnotation.radioButton input,.adf-pdf-viewer .annotationLayer .choiceWidgetAnnotation select,.adf-pdf-viewer .annotationLayer .textWidgetAnnotation input,.adf-pdf-viewer .annotationLayer .textWidgetAnnotation textarea{background-color:rgba(0,54,255,.13);border:1px solid transparent;box-sizing:border-box;font-size:9px;height:100%;margin:0;padding:0 3px;vertical-align:top;width:100%}.adf-pdf-viewer .annotationLayer .choiceWidgetAnnotation select option{padding:0}.adf-pdf-viewer .annotationLayer .buttonWidgetAnnotation.radioButton input{border-radius:50%}.adf-pdf-viewer .annotationLayer .textWidgetAnnotation textarea{font:message-box;font-size:9px;resize:none}.adf-pdf-viewer .annotationLayer .buttonWidgetAnnotation.checkBox input[disabled],.adf-pdf-viewer .annotationLayer .buttonWidgetAnnotation.radioButton input[disabled],.adf-pdf-viewer .annotationLayer .choiceWidgetAnnotation select[disabled],.adf-pdf-viewer .annotationLayer .textWidgetAnnotation input[disabled],.adf-pdf-viewer .annotationLayer .textWidgetAnnotation textarea[disabled]{background:none;border:1px solid transparent;cursor:not-allowed}.adf-pdf-viewer .annotationLayer .buttonWidgetAnnotation.checkBox input:hover,.adf-pdf-viewer .annotationLayer .buttonWidgetAnnotation.radioButton input:hover,.adf-pdf-viewer .annotationLayer .choiceWidgetAnnotation select:hover,.adf-pdf-viewer .annotationLayer .textWidgetAnnotation input:hover,.adf-pdf-viewer .annotationLayer .textWidgetAnnotation textarea:hover{border:1px solid #000}.adf-pdf-viewer .annotationLayer .choiceWidgetAnnotation select:focus,.adf-pdf-viewer .annotationLayer .textWidgetAnnotation input:focus,.adf-pdf-viewer .annotationLayer .textWidgetAnnotation textarea:focus{background:none;border:1px solid transparent}.adf-pdf-viewer .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after,.adf-pdf-viewer .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before,.adf-pdf-viewer .annotationLayer .buttonWidgetAnnotation.radioButton input:checked:before{background-color:#000;content:\"\";display:block;position:absolute}.adf-pdf-viewer .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after,.adf-pdf-viewer .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before{height:80%;left:45%;width:1px}.adf-pdf-viewer .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:before{transform:rotate(45deg)}.adf-pdf-viewer .annotationLayer .buttonWidgetAnnotation.checkBox input:checked:after{transform:rotate(-45deg)}.adf-pdf-viewer .annotationLayer .buttonWidgetAnnotation.radioButton input:checked:before{border-radius:50%;height:50%;left:30%;top:20%;width:50%}.adf-pdf-viewer .annotationLayer .textWidgetAnnotation input.comb{font-family:monospace;padding-left:2px;padding-right:0}.adf-pdf-viewer .annotationLayer .textWidgetAnnotation input.comb:focus{width:115%}.adf-pdf-viewer .annotationLayer .buttonWidgetAnnotation.checkBox input,.adf-pdf-viewer .annotationLayer .buttonWidgetAnnotation.radioButton input{-moz-appearance:none;-webkit-appearance:none;appearance:none;padding:0}.adf-pdf-viewer .annotationLayer .popupWrapper{position:absolute;width:20em}.adf-pdf-viewer .annotationLayer .popup{background-color:#ff9;border-radius:2px;box-shadow:0 2px 5px #888;cursor:pointer;font:message-box;font-size:9px;margin-left:5px;max-width:20em;padding:6px;position:absolute;word-wrap:break-word;z-index:200}.adf-pdf-viewer .annotationLayer .popup>*{font-size:9px}.adf-pdf-viewer .annotationLayer .popup h1{display:inline-block}.adf-pdf-viewer .annotationLayer .popup span{display:inline-block;margin-left:5px}.adf-pdf-viewer .annotationLayer .popup p{border-top:1px solid #333;margin-top:2px;padding-top:2px}.adf-pdf-viewer .annotationLayer .caretAnnotation,.adf-pdf-viewer .annotationLayer .circleAnnotation svg ellipse,.adf-pdf-viewer .annotationLayer .fileAttachmentAnnotation,.adf-pdf-viewer .annotationLayer .freeTextAnnotation,.adf-pdf-viewer .annotationLayer .highlightAnnotation,.adf-pdf-viewer .annotationLayer .inkAnnotation svg polyline,.adf-pdf-viewer .annotationLayer .lineAnnotation svg line,.adf-pdf-viewer .annotationLayer .polygonAnnotation svg polygon,.adf-pdf-viewer .annotationLayer .polylineAnnotation svg polyline,.adf-pdf-viewer .annotationLayer .squareAnnotation svg rect,.adf-pdf-viewer .annotationLayer .squigglyAnnotation,.adf-pdf-viewer .annotationLayer .stampAnnotation,.adf-pdf-viewer .annotationLayer .strikeoutAnnotation,.adf-pdf-viewer .annotationLayer .underlineAnnotation{cursor:pointer}.adf-pdf-viewer .pdfViewer .canvasWrapper{overflow:hidden}.adf-pdf-viewer .pdfViewer .page{background-clip:content-box;background-color:#fff;border:9px solid transparent;direction:ltr;height:1056px;margin:1px auto -8px;overflow:visible;position:relative;width:816px}.adf-pdf-viewer .pdfViewer.removePageBorders .page{border:none;margin:0 auto 10px}.adf-pdf-viewer .pdfViewer.singlePageView{display:inline-block}.adf-pdf-viewer .pdfViewer.singlePageView .page{border:none;margin:0}.adf-pdf-viewer .pdfViewer.scrollHorizontal,.adf-pdf-viewer .pdfViewer.scrollWrapped,.adf-pdf-viewer .spread{margin-left:3.5px;margin-right:3.5px;text-align:center}.adf-pdf-viewer .pdfViewer.scrollHorizontal,.adf-pdf-viewer .spread{white-space:nowrap}.adf-pdf-viewer .pdfViewer.removePageBorders,.adf-pdf-viewer .pdfViewer.scrollHorizontal .spread,.adf-pdf-viewer .pdfViewer.scrollWrapped .spread{margin-left:0;margin-right:0}.adf-pdf-viewer .pdfViewer.scrollHorizontal .page,.adf-pdf-viewer .pdfViewer.scrollHorizontal .spread,.adf-pdf-viewer .pdfViewer.scrollWrapped .page,.adf-pdf-viewer .pdfViewer.scrollWrapped .spread,.adf-pdf-viewer .spread .page{display:inline-block;vertical-align:middle}.adf-pdf-viewer .pdfViewer.scrollHorizontal .page,.adf-pdf-viewer .pdfViewer.scrollWrapped .page,.adf-pdf-viewer .spread .page{margin-left:-3.5px;margin-right:-3.5px}.adf-pdf-viewer .pdfViewer.removePageBorders.scrollHorizontal .page,.adf-pdf-viewer .pdfViewer.removePageBorders.scrollWrapped .page,.adf-pdf-viewer .pdfViewer.removePageBorders .spread .page{margin-left:5px;margin-right:5px}.adf-pdf-viewer .pdfViewer .page canvas{display:block;margin:0}.adf-pdf-viewer .pdfViewer .page canvas[hidden]{display:none}.adf-pdf-viewer .pdfViewer .page .loadingIcon{bottom:0;display:block;left:0;position:absolute;right:0;top:0}.adf-pdf-viewer .pdfPresentationMode .pdfViewer{margin-left:0;margin-right:0}.adf-pdf-viewer .pdfPresentationMode .pdfViewer .page,.adf-pdf-viewer .pdfPresentationMode .pdfViewer .spread{display:block}.adf-pdf-viewer .pdfPresentationMode .pdfViewer .page,.adf-pdf-viewer .pdfPresentationMode .pdfViewer.removePageBorders .page{margin-left:auto;margin-right:auto}.adf-pdf-viewer .pdfPresentationMode:-webkit-full-screen .pdfViewer .page{border:0;margin-bottom:100%}.adf-pdf-viewer .pdfPresentationMode:fullscreen .pdfViewer .page{border:0;margin-bottom:100%}.adf-pdf-viewer .textLayer{border:1px solid grey;bottom:0;left:0;line-height:1;opacity:.2;overflow:hidden;position:absolute;right:0;top:0}.adf-pdf-viewer .textLayer>div{color:transparent;cursor:text;position:absolute;transform-origin:0 0;white-space:pre}.adf-pdf-viewer .textLayer .adf-highlight{background-color:#b400aa;border-radius:4px;margin:-1px;padding:1px}.adf-pdf-viewer .textLayer .adf-highlight.adf-begin{border-radius:4px 0 0 4px}.adf-pdf-viewer .textLayer .adf-highlight.adf-end{border-radius:0 4px 4px 0}.adf-pdf-viewer .textLayer .adf-highlight.adf-middle{border-radius:0}.adf-pdf-viewer .textLayer .adf-highlight.adf-selected{background-color:#006400}.adf-pdf-viewer .textLayer::selection{background:#00f}.adf-pdf-viewer .textLayer::-moz-selection{background:#00f}.adf-pdf-viewer .textLayer .adf-endOfContent{-moz-user-select:none;-ms-user-select:none;-webkit-user-select:none;bottom:0;cursor:default;display:block;left:0;position:absolute;right:0;top:100%;user-select:none;z-index:-1}.adf-pdf-viewer .textLayer .adf-endOfContent.adf-active{top:0}.adf-pdf-viewer .adf-annotationLayer section{position:absolute}.adf-pdf-viewer .adf-annotationLayer .adf-linkAnnotation>a{background:url(\"data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\") 0 0 repeat;font-size:1em;height:100%;left:0;position:absolute;top:0;width:100%}.adf-pdf-viewer .adf-annotationLayer .adf-linkAnnotation>a:hover{background:#ff0;box-shadow:0 2px 10px #ff0;opacity:.2}.adf-pdf-viewer .adf-annotationLayer .adf-textAnnotation img{cursor:pointer;position:absolute}.adf-pdf-viewer .adf-annotationLayer .adf-popupWrapper{position:absolute;width:20em}.adf-pdf-viewer .adf-annotationLayer .adf-popup{background-color:#ff9;border-radius:2px;box-shadow:0 2px 5px #333;cursor:pointer;margin-left:5px;max-width:20em;padding:.6em;position:absolute;word-wrap:break-word;z-index:200}.adf-pdf-viewer .adf-annotationLayer .adf-popup h1{border-bottom:1px solid #000;font-size:1em;padding-bottom:.2em}.adf-pdf-viewer .adf-annotationLayer .adf-popup p{padding-top:.2em}.adf-pdf-viewer .adf-annotationLayer .adf-fileAttachmentAnnotation,.adf-pdf-viewer .adf-annotationLayer .adf-highlightAnnotation,.adf-pdf-viewer .adf-annotationLayer .adf-squigglyAnnotation,.adf-pdf-viewer .adf-annotationLayer .adf-strikeoutAnnotation,.adf-pdf-viewer .adf-annotationLayer .adf-underlineAnnotation{cursor:pointer}.adf-pdf-viewer .adf-pdfViewer .canvasWrapper{overflow:hidden}.adf-pdf-viewer .adf-pdfViewer .page{background-clip:content-box;background-color:#fff;border:9px solid transparent;direction:ltr;height:1056px;margin:1px auto -8px;overflow:visible;position:relative;width:816px}.adf-pdf-viewer .adf-pdfViewer .page canvas{display:block;margin:0}.adf-pdf-viewer .adf-pdfViewer .page .adf-loadingIcon{bottom:0;display:block;left:0;position:absolute;right:0;top:0}.adf-pdf-viewer .adf-pdfViewer .page *{margin:0;padding:0}.adf-pdf-viewer .adf-pdfViewer.adf-removePageBorders .adf-page{border:none;margin:0 auto 10px}.adf-pdf-viewer .adf-pdfViewer .adf-loadingIcon{animation:load8 1.1s linear infinite;border:1.1em solid rgba(3,0,2,.2);border-left-color:#030002;border-radius:50%;font-size:5px;height:100px;left:50%!important;margin-left:-50px;margin-top:-50px;text-indent:-9999em;top:50%!important;transform:translateZ(0);width:100px}.adf-pdf-viewer .adf-pdfViewer .adf-loadingIcon:after{border-radius:50%}.adf-pdf-viewer .adf-hidden,.adf-pdf-viewer [hidden]{display:none!important}@keyframes load8{0%{transform:rotate(0deg)}to{transform:rotate(1turn)}}.adf-viewer-pdf-viewer{-webkit-overflow-scrolling:touch;bottom:0;left:0;outline:none;overflow:auto;position:absolute;right:0;top:0}html[dir=ltr] .adf-viewer-pdf-viewer{box-shadow:inset 1px 0 0 hsla(0,0%,100%,.05)}html[dir=rtl] .adf-viewer-pdf-viewer{box-shadow:inset -1px 0 0 hsla(0,0%,100%,.05)}", ".adf-pdf-viewer,.adf-viewer-content-container{height:100%;width:100%}.adf-pdf-viewer{margin:0}.adf-pdf-viewer .adf-loader-container{-moz-box-flex-direction:row;-webkit-box-flex-direction:row;display:flex;flex-direction:row;height:100%}.adf-pdf-viewer__thumbnails{background-color:rgba(0,0,0,.12);height:100%;position:relative;width:190px}.adf-pdf-viewer .adf-thumbnails-template__container{display:flex;flex-direction:column;height:100%}.adf-pdf-viewer .adf-thumbnails-template__buttons{align-items:flex-end;color:var(--theme-text-color);display:flex;height:45px;justify-content:flex-end}.adf-pdf-viewer__container{display:flex;height:100vh}.adf-pdf-viewer__content{flex:1 1 auto;position:relative}.adf-pdf-viewer .adf-loader-item{margin:auto;max-height:100px;max-width:300px}.adf-pdf-viewer__toolbar{bottom:5px;left:50%;position:absolute;transform:translateX(-50%)}.adf-pdf-viewer__toolbar .adf-toolbar .mat-toolbar{background-color:var(--theme-card-bg-color);border-radius:2px;border-width:0;box-shadow:0 2px 2px 0 rgba(0,0,0,.24),0 0 2px 0 rgba(0,0,0,.12);max-height:48px}.adf-pdf-viewer__toolbar-page-selector{font-size:14px;padding-left:10px;padding-right:10px}.adf-pdf-viewer__toolbar-page-selector>input{background-color:var(--theme-card-bg-color);border:1px solid var(--theme-border-color);color:inherit;font-size:14px;height:24px;line-height:24px;margin-right:4px;outline-color:grey;outline-width:1px;padding:5px;text-align:right;width:33px}"]
            },] }
];
PdfViewerComponent.ctorParameters = () => [
    { type: MatDialog },
    { type: RenderingQueueServices },
    { type: LogService },
    { type: AppConfigService }
];
PdfViewerComponent.propDecorators = {
    urlFile: [{ type: Input }],
    blobFile: [{ type: Input }],
    nameFile: [{ type: Input }],
    showToolbar: [{ type: Input }],
    allowThumbnails: [{ type: Input }],
    thumbnailsTemplate: [{ type: Input }],
    cacheType: [{ type: Input }],
    rendered: [{ type: Output }],
    error: [{ type: Output }],
    close: [{ type: Output }],
    handleKeyboardEvent: [{ type: HostListener, args: ['document:keydown', ['$event'],] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PdfThumbComponent {
    constructor(sanitizer, element) {
        this.sanitizer = sanitizer;
        this.element = element;
        this.page = null;
    }
    ngOnInit() {
        this.image$ = this.page.getPage().then((page) => this.getThumb(page));
    }
    focus() {
        this.element.nativeElement.focus();
    }
    getThumb(page) {
        const viewport = page.getViewport({ scale: 1 });
        const canvas = this.getCanvas();
        const scale = Math.min((canvas.height / viewport.height), (canvas.width / viewport.width));
        return page.render({
            canvasContext: canvas.getContext('2d'),
            viewport: page.getViewport({ scale: scale })
        }).promise.then(() => {
            const imageSource = canvas.toDataURL();
            return this.sanitizer.bypassSecurityTrustUrl(imageSource);
        });
    }
    getCanvas() {
        const canvas = document.createElement('canvas');
        canvas.width = this.page.getWidth();
        canvas.height = this.page.getHeight();
        return canvas;
    }
}
PdfThumbComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-pdf-thumb',
                template: "<ng-container *ngIf=\"image$ | async as image\">\n    <img [src]=\"image\" [alt]=\"'ADF_VIEWER.SIDEBAR.THUMBNAILS.PAGE' | translate: { pageNum: page.id }\"\n        title=\"{{ 'ADF_VIEWER.SIDEBAR.THUMBNAILS.PAGE' | translate: { pageNum: page.id } }}\"\n        [attr.aria-label]=\"'ADF_VIEWER.SIDEBAR.THUMBNAILS.PAGE' | translate: { pageNum: page.id }\">\n</ng-container>\n",
                encapsulation: ViewEncapsulation.None,
                host: { tabindex: '0' }
            },] }
];
PdfThumbComponent.ctorParameters = () => [
    { type: DomSanitizer },
    { type: ElementRef }
];
PdfThumbComponent.propDecorators = {
    page: [{ type: Input }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PdfThumbListComponent {
    constructor(element, document) {
        this.element = element;
        this.document = document;
        this.close = new EventEmitter();
        this.virtualHeight = 0;
        this.translateY = 0;
        this.renderItems = [];
        this.width = 91;
        this.currentHeight = 0;
        this.items = [];
        this.margin = 15;
        this.itemHeight = 114 + this.margin;
        this.previouslyFocusedElement = null;
        this.calculateItems = this.calculateItems.bind(this);
        this.onPageChange = this.onPageChange.bind(this);
    }
    onKeydown(event) {
        const keyCode = event.keyCode;
        if (keyCode === UP_ARROW && this.canSelectPreviousItem()) {
            this.pdfViewer.currentPageNumber -= 1;
        }
        if (keyCode === DOWN_ARROW && this.canSelectNextItem()) {
            this.pdfViewer.currentPageNumber += 1;
        }
        if (keyCode === ESCAPE) {
            this.close.emit();
        }
        this.keyManager.setFocusOrigin('keyboard');
        event.preventDefault();
    }
    onResize() {
        this.calculateItems();
    }
    ngOnInit() {
        this.pdfViewer.eventBus.on('pagechanging', this.onPageChange);
        this.element.nativeElement.addEventListener('scroll', this.calculateItems, true);
        this.setHeight(this.pdfViewer.currentPageNumber);
        this.items = this.getPages();
        this.calculateItems();
        this.previouslyFocusedElement = this.document.activeElement;
    }
    ngAfterViewInit() {
        this.keyManager = new FocusKeyManager(this.thumbsList);
        this.thumbsList.changes
            .pipe(delay(0))
            .subscribe(() => this.keyManager.setActiveItem(this.getPageIndex(this.pdfViewer.currentPageNumber)));
        setTimeout(() => {
            this.scrollInto(this.pdfViewer.currentPageNumber);
            this.keyManager.setActiveItem(this.getPageIndex(this.pdfViewer.currentPageNumber));
        }, 0);
    }
    ngOnDestroy() {
        this.element.nativeElement.removeEventListener('scroll', this.calculateItems, true);
        this.pdfViewer.eventBus.on('pagechanging', this.onPageChange);
        if (this.previouslyFocusedElement) {
            this.previouslyFocusedElement.focus();
            this.previouslyFocusedElement = null;
        }
    }
    trackByFn(_, item) {
        return item.id;
    }
    isSelected(pageNumber) {
        return this.pdfViewer.currentPageNumber === pageNumber;
    }
    goTo(pageNumber) {
        this.pdfViewer.currentPageNumber = pageNumber;
    }
    scrollInto(pageNumber) {
        if (this.items.length) {
            const index = this.items.findIndex((element) => element.id === pageNumber);
            if (index < 0 || index >= this.items.length) {
                return;
            }
            this.element.nativeElement.scrollTop = index * this.itemHeight;
            this.calculateItems();
        }
    }
    getPages() {
        return this.pdfViewer._pages.map((page) => ({
            id: page.id,
            getWidth: () => {
                return this.width;
            },
            getHeight: () => {
                return this.currentHeight;
            },
            getPage: () => this.pdfViewer.pdfDocument.getPage(page.id)
        }));
    }
    setHeight(id) {
        const height = this.pdfViewer.pdfDocument.getPage(id).then((page) => this.calculateHeight(page));
        return height;
    }
    calculateHeight(page) {
        const viewport = page.getViewport({ scale: 1 });
        const pageRatio = viewport.width / viewport.height;
        const height = Math.floor(this.width / pageRatio);
        this.currentHeight = height;
        this.itemHeight = height + this.margin;
    }
    calculateItems() {
        const { element, viewPort, itemsInView } = this.getContainerSetup();
        const indexByScrollTop = element.scrollTop / viewPort * this.items.length / itemsInView;
        const start = Math.floor(indexByScrollTop);
        const end = Math.ceil(indexByScrollTop) + (itemsInView);
        this.translateY = this.itemHeight * Math.ceil(start);
        this.virtualHeight = this.itemHeight * this.items.length - this.translateY;
        this.renderItems = this.items.slice(start, end);
    }
    getContainerSetup() {
        const element = this.element.nativeElement;
        const elementRec = element.getBoundingClientRect();
        const itemsInView = Math.ceil(elementRec.height / this.itemHeight);
        const viewPort = (this.itemHeight * this.items.length) / itemsInView;
        return {
            element,
            viewPort,
            itemsInView
        };
    }
    onPageChange(event) {
        const index = this.renderItems.findIndex((element) => element.id === event.pageNumber);
        if (index < 0) {
            this.scrollInto(event.pageNumber);
        }
        if (index >= this.renderItems.length - 1) {
            this.element.nativeElement.scrollTop += this.itemHeight;
        }
        this.keyManager.setActiveItem(this.getPageIndex(event.pageNumber));
    }
    getPageIndex(pageNumber) {
        const thumbsListArray = this.thumbsList.toArray();
        return thumbsListArray.findIndex(el => el.page.id === pageNumber);
    }
    canSelectNextItem() {
        return this.pdfViewer.currentPageNumber !== this.pdfViewer.pagesCount;
    }
    canSelectPreviousItem() {
        return this.pdfViewer.currentPageNumber !== 1;
    }
}
PdfThumbListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-pdf-thumbnails',
                template: "<div class=\"adf-pdf-thumbnails__content\"\n    data-automation-id='adf-thumbnails-content'\n    [style.height.px]=\"virtualHeight\"\n    [style.transform]=\"'translate(-50%, ' + translateY + 'px)'\">\n    <adf-pdf-thumb *ngFor=\"let page of renderItems; trackBy: trackByFn\"\n        class=\"adf-pdf-thumbnails__thumb\"\n        [id]=\"page.id\"\n        [ngClass]=\"{'adf-pdf-thumbnails__thumb--selected' : isSelected(page.id)}\"\n        [page]=\"page\"\n        (click)=\"goTo(page.id)\">\n    </adf-pdf-thumb>\n</div>\n",
                host: { class: 'adf-pdf-thumbnails' },
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-pdf-thumbnails{display:block;height:100%;overflow:hidden;overflow-y:auto;position:relative}.adf-pdf-thumbnails__content{height:0;left:50%;position:absolute;top:5px}.adf-pdf-thumbnails__thumb{background:var(--theme-background-color);cursor:pointer;display:block;margin-bottom:15px;width:91px}.adf-pdf-thumbnails__thumb:hover{box-shadow:0 0 5px 0 var(--theme-text-bold-color)}.adf-pdf-thumbnails__thumb--selected{border:2px solid var(--theme-accent-color-a200)}"]
            },] }
];
PdfThumbListComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] }
];
PdfThumbListComponent.propDecorators = {
    pdfViewer: [{ type: Input }],
    close: [{ type: Output }],
    template: [{ type: ContentChild, args: [TemplateRef,] }],
    thumbsList: [{ type: ViewChildren, args: [PdfThumbComponent,] }],
    onKeydown: [{ type: HostListener, args: ['keydown', ['$event'],] }],
    onResize: [{ type: HostListener, args: ['window:resize',] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TxtViewerComponent {
    constructor(http, appConfigService) {
        this.http = http;
        this.appConfigService = appConfigService;
    }
    ngOnChanges(changes) {
        const blobFile = changes['blobFile'];
        if (blobFile && blobFile.currentValue) {
            return this.readBlob(blobFile.currentValue);
        }
        const urlFile = changes['urlFile'];
        if (urlFile && urlFile.currentValue) {
            return this.getUrlContent(urlFile.currentValue);
        }
        if (!this.urlFile && !this.blobFile) {
            throw new Error('Attribute urlFile or blobFile is required');
        }
        return Promise.resolve();
    }
    getUrlContent(url) {
        const withCredentialsMode = this.appConfigService.get('auth.withCredentials', false);
        return new Promise((resolve, reject) => {
            this.http.get(url, { responseType: 'text', withCredentials: withCredentialsMode }).subscribe((res) => {
                this.content = res;
                resolve();
            }, (event) => {
                reject(event);
            });
        });
    }
    readBlob(blob) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => {
                this.content = reader.result;
                resolve();
            };
            reader.onerror = (error) => {
                reject(error);
            };
            reader.readAsText(blob);
        });
    }
}
TxtViewerComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-txt-viewer',
                template: "<pre class=\"adf-txt-viewer-content\">\n    {{content}}\n</pre>\n",
                host: { 'class': 'adf-txt-viewer' },
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-txt-viewer{background-color:var(--theme-background-color);height:100%;overflow:auto;width:100%}"]
            },] }
];
TxtViewerComponent.ctorParameters = () => [
    { type: HttpClient },
    { type: AppConfigService }
];
TxtViewerComponent.propDecorators = {
    urlFile: [{ type: Input }],
    blobFile: [{ type: Input }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class UnknownFormatComponent {
}
UnknownFormatComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-viewer-unknown-format',
                template: "<div class=\"adf-viewer__unknown-format-view\">\n    <div>\n        <mat-icon class=\"icon\">error</mat-icon>\n        <div class=\"adf-viewer__unknown-label\">{{ 'ADF_VIEWER.UNKNOWN_FORMAT' | translate }}</div>\n    </div>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-viewer__unknown-format-view{color:var(--theme-text-fg-color);display:flex;flex:1;flex-direction:column;height:90vh;justify-content:center;text-align:center}"]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ViewerToolbarActionsComponent {
}
ViewerToolbarActionsComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-viewer-toolbar-actions',
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: { class: 'adf-viewer-toolbar-actions' },
                template: `<ng-content></ng-content>`
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ViewerExtensionDirective {
    constructor(viewerComponent) {
        this.viewerComponent = viewerComponent;
        this.onDestroy$ = new Subject();
    }
    ngAfterContentInit() {
        this.templateModel = { template: this.template, isVisible: false };
        this.viewerComponent.extensionTemplates.push(this.templateModel);
        this.viewerComponent.extensionChange
            .pipe(takeUntil(this.onDestroy$))
            .subscribe(fileExtension => {
            this.templateModel.isVisible = this.isVisible(fileExtension);
        });
        if (this.supportedExtensions instanceof Array) {
            this.supportedExtensions.forEach((extension) => {
                this.viewerComponent.externalExtensions.push(extension);
            });
        }
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
    isVisible(fileExtension) {
        let supportedExtension;
        if (this.supportedExtensions && (this.supportedExtensions instanceof Array)) {
            supportedExtension = this.supportedExtensions.find((extension) => {
                return extension.toLowerCase() === fileExtension;
            });
        }
        return !!supportedExtension;
    }
}
ViewerExtensionDirective.decorators = [
    { type: Directive, args: [{
                selector: 'adf-viewer-extension'
            },] }
];
ViewerExtensionDirective.ctorParameters = () => [
    { type: ViewerComponent }
];
ViewerExtensionDirective.propDecorators = {
    template: [{ type: ContentChild, args: [TemplateRef,] }],
    urlFileContent: [{ type: Input }],
    extension: [{ type: Input }],
    supportedExtensions: [{ type: Input }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ToolbarDividerComponent {
}
ToolbarDividerComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-toolbar-divider',
                template: '<div></div>',
                host: { 'class': 'adf-toolbar-divider' },
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [`
        .adf-toolbar-divider > div {
            height: 24px;
            width: 1px;
            background: rgba(0, 0, 0, 0.26);
            margin-left: 5px;
            margin-right: 5px;
        }
    `]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ToolbarTitleComponent {
}
ToolbarTitleComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-toolbar-title',
                template: '<ng-content></ng-content>',
                host: { 'class': 'adf-toolbar-title' }
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ToolbarComponent {
    constructor() {
        this.title = '';
    }
}
ToolbarComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-toolbar',
                template: "<mat-toolbar [color]=\"color\">\n    <span class=\"adf-toolbar-title\" *ngIf=\"title\">{{ title | translate }}</span>\n    <ng-content select=\"adf-toolbar-title\"></ng-content>\n    <ng-content></ng-content>\n</mat-toolbar>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                host: { 'class': 'adf-toolbar' },
                styles: [".adf-toolbar--spacer{flex:1 1 auto}.adf-toolbar-title{display:flex;overflow:hidden;width:100%}.adf-toolbar .mat-toolbar{border:1px solid var(--theme-border-color);color:var(--theme-text-color);min-height:48px}.adf-toolbar .mat-toolbar-row{font-size:14px;height:48px;white-space:normal}.adf-toolbar .mat-toolbar-single-row{height:64px;padding:0 16px}.adf-toolbar.adf-toolbar--inline .mat-toolbar{background-color:inherit;border:none!important;padding:0}"]
            },] }
];
ToolbarComponent.propDecorators = {
    title: [{ type: Input }],
    color: [{ type: Input }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ToolbarModule {
}
ToolbarModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    TranslateModule
                ],
                declarations: [
                    ToolbarComponent,
                    ToolbarTitleComponent,
                    ToolbarDividerComponent
                ],
                exports: [
                    ToolbarComponent,
                    ToolbarTitleComponent,
                    ToolbarDividerComponent
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ViewerModule {
}
ViewerModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    TranslateModule,
                    FormsModule,
                    ReactiveFormsModule,
                    ToolbarModule,
                    PipeModule,
                    FlexLayoutModule,
                    DirectiveModule,
                    A11yModule,
                    ExtensionsModule
                ],
                declarations: [
                    PdfPasswordDialogComponent,
                    ViewerComponent,
                    ImgViewerComponent,
                    TxtViewerComponent,
                    MediaPlayerComponent,
                    PdfViewerComponent,
                    PdfThumbComponent,
                    PdfThumbListComponent,
                    ViewerExtensionDirective,
                    UnknownFormatComponent,
                    ViewerToolbarComponent,
                    ViewerSidebarComponent,
                    ViewerOpenWithComponent,
                    ViewerMoreActionsComponent,
                    ViewerToolbarActionsComponent
                ],
                exports: [
                    ViewerComponent,
                    ImgViewerComponent,
                    TxtViewerComponent,
                    MediaPlayerComponent,
                    PdfViewerComponent,
                    PdfPasswordDialogComponent,
                    PdfThumbComponent,
                    PdfThumbListComponent,
                    ViewerExtensionDirective,
                    UnknownFormatComponent,
                    ViewerToolbarComponent,
                    ViewerSidebarComponent,
                    ViewerOpenWithComponent,
                    ViewerMoreActionsComponent,
                    ViewerToolbarActionsComponent
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class BpmUserService {
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
    }
    get profileApi() {
        var _a;
        this._profileApi = (_a = this._profileApi) !== null && _a !== void 0 ? _a : new UserProfileApi(this.apiService.getInstance());
        return this._profileApi;
    }
    getCurrentUserInfo() {
        return from(this.profileApi.getProfile())
            .pipe(map((userRepresentation) => {
            return new BpmUserModel(userRepresentation);
        }), catchError((err) => this.handleError(err)));
    }
    getCurrentUserProfileImage() {
        return this.profileApi.getProfilePictureUrl();
    }
    handleError(error) {
        this.logService.error(error);
        return throwError(error || 'Server error');
    }
}
BpmUserService.ɵprov = ɵɵdefineInjectable({ factory: function BpmUserService_Factory() { return new BpmUserService(ɵɵinject(AlfrescoApiService), ɵɵinject(LogService)); }, token: BpmUserService, providedIn: "root" });
BpmUserService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
BpmUserService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: LogService }
];

class EcmUserService {
    constructor(apiService, contentService) {
        this.apiService = apiService;
        this.contentService = contentService;
    }
    get peopleApi() {
        var _a;
        this._peopleApi = (_a = this._peopleApi) !== null && _a !== void 0 ? _a : new PeopleApi(this.apiService.getInstance());
        return this._peopleApi;
    }
    getUserInfo(userName) {
        return from(this.peopleApi.getPerson(userName))
            .pipe(map((personEntry) => new EcmUserModel(personEntry.entry)));
    }
    getCurrentUserInfo() {
        return this.getUserInfo('-me-');
    }
    getUserProfileImage(avatarId) {
        return this.contentService.getContentUrl(avatarId);
    }
}
EcmUserService.ɵprov = ɵɵdefineInjectable({ factory: function EcmUserService_Factory() { return new EcmUserService(ɵɵinject(AlfrescoApiService), ɵɵinject(ContentService)); }, token: EcmUserService, providedIn: "root" });
EcmUserService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
EcmUserService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: ContentService }
];

const JSON_TYPE = ['application/json'];
class OAuth2Service {
    constructor(alfrescoApiService) {
        this.alfrescoApiService = alfrescoApiService;
    }
    get apiClient() {
        return this.alfrescoApiService.getInstance().oauth2Auth;
    }
    request(opts) {
        return from(this.apiClient.callCustomApi(opts.url, opts.httpMethod, opts.pathParams, opts.queryParams, {}, {}, opts.bodyParam, JSON_TYPE, JSON_TYPE, Object));
    }
    get(opts) {
        return this.request(Object.assign(Object.assign({}, opts), { httpMethod: 'GET' }));
    }
    put(opts) {
        return this.request(Object.assign(Object.assign({}, opts), { httpMethod: 'PUT' }));
    }
    post(opts) {
        return this.request(Object.assign(Object.assign({}, opts), { httpMethod: 'POST' }));
    }
    delete(opts) {
        return this.request(Object.assign(Object.assign({}, opts), { httpMethod: 'DELETE' }));
    }
}
OAuth2Service.ɵprov = ɵɵdefineInjectable({ factory: function OAuth2Service_Factory() { return new OAuth2Service(ɵɵinject(AlfrescoApiService)); }, token: OAuth2Service, providedIn: "root" });
OAuth2Service.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
OAuth2Service.ctorParameters = () => [
    { type: AlfrescoApiService }
];

class IdentityUserService {
    constructor(jwtHelperService, oAuth2Service, appConfigService) {
        this.jwtHelperService = jwtHelperService;
        this.oAuth2Service = oAuth2Service;
        this.appConfigService = appConfigService;
    }
    get identityHost() {
        return `${this.appConfigService.get('identityHost')}`;
    }
    buildUserUrl() {
        return `${this.identityHost}/users`;
    }
    getCurrentUserInfo() {
        const familyName = this.jwtHelperService.getValueFromLocalAccessToken(JwtHelperService.FAMILY_NAME);
        const givenName = this.jwtHelperService.getValueFromLocalAccessToken(JwtHelperService.GIVEN_NAME);
        const email = this.jwtHelperService.getValueFromLocalAccessToken(JwtHelperService.USER_EMAIL);
        const username = this.jwtHelperService.getValueFromLocalAccessToken(JwtHelperService.USER_PREFERRED_USERNAME);
        return { firstName: givenName, lastName: familyName, email: email, username: username };
    }
    findUsersByName(search) {
        if (search === '') {
            return of([]);
        }
        const url = this.buildUserUrl();
        const queryParams = { search: search };
        return this.oAuth2Service.get({ url, queryParams });
    }
    findUserByUsername(username) {
        if (username === '') {
            return of([]);
        }
        const url = this.buildUserUrl();
        const queryParams = { username: username };
        return this.oAuth2Service.get({ url, queryParams });
    }
    findUserByEmail(email) {
        if (email === '') {
            return of([]);
        }
        const url = this.buildUserUrl();
        const queryParams = { email: email };
        return this.oAuth2Service.get({ url, queryParams });
    }
    findUserById(id) {
        if (id === '') {
            return of([]);
        }
        const url = this.buildUserUrl() + '/' + id;
        return this.oAuth2Service.get({ url });
    }
    getClientRoles(userId, clientId) {
        const url = `${this.identityHost}/users/${userId}/role-mappings/clients/${clientId}/composite`;
        return this.oAuth2Service.get({ url });
    }
    checkUserHasClientApp(userId, clientId) {
        return this.getClientRoles(userId, clientId).pipe(map((clientRoles) => clientRoles.length > 0));
    }
    checkUserHasAnyClientAppRole(userId, clientId, roleNames) {
        return this.getClientRoles(userId, clientId).pipe(map((clientRoles) => {
            let hasRole = false;
            if (clientRoles.length > 0) {
                roleNames.forEach((roleName) => {
                    const role = clientRoles.find(({ name }) => name === roleName);
                    if (role) {
                        hasRole = true;
                        return;
                    }
                });
            }
            return hasRole;
        }));
    }
    getClientIdByApplicationName(applicationName) {
        const url = `${this.identityHost}/clients`;
        const queryParams = { clientId: applicationName };
        return this.oAuth2Service
            .get({ url, queryParams })
            .pipe(map((response) => response && response.length > 0 ? response[0].id : ''));
    }
    checkUserHasApplicationAccess(userId, applicationName) {
        return this.getClientIdByApplicationName(applicationName).pipe(switchMap((clientId) => {
            return this.checkUserHasClientApp(userId, clientId);
        }));
    }
    checkUserHasAnyApplicationRole(userId, applicationName, roleNames) {
        return this.getClientIdByApplicationName(applicationName).pipe(switchMap((clientId) => {
            return this.checkUserHasAnyClientAppRole(userId, clientId, roleNames);
        }));
    }
    getUsers() {
        const url = this.buildUserUrl();
        return this.oAuth2Service.get({ url });
    }
    getUserRoles(userId) {
        const url = `${this.identityHost}/users/${userId}/role-mappings/realm/composite`;
        return this.oAuth2Service.get({ url });
    }
    getUsersByRolesWithCurrentUser(roleNames) {
        return __awaiter(this, void 0, void 0, function* () {
            const filteredUsers = [];
            if (roleNames && roleNames.length > 0) {
                const users = yield this.getUsers().toPromise();
                for (let i = 0; i < users.length; i++) {
                    const hasAnyRole = yield this.userHasAnyRole(users[i].id, roleNames);
                    if (hasAnyRole) {
                        filteredUsers.push(users[i]);
                    }
                }
            }
            return filteredUsers;
        });
    }
    getUsersByRolesWithoutCurrentUser(roleNames) {
        return __awaiter(this, void 0, void 0, function* () {
            const filteredUsers = [];
            if (roleNames && roleNames.length > 0) {
                const currentUser = this.getCurrentUserInfo();
                let users = yield this.getUsers().toPromise();
                users = users.filter(({ username }) => username !== currentUser.username);
                for (let i = 0; i < users.length; i++) {
                    const hasAnyRole = yield this.userHasAnyRole(users[i].id, roleNames);
                    if (hasAnyRole) {
                        filteredUsers.push(users[i]);
                    }
                }
            }
            return filteredUsers;
        });
    }
    userHasAnyRole(userId, roleNames) {
        return __awaiter(this, void 0, void 0, function* () {
            const userRoles = yield this.getUserRoles(userId).toPromise();
            const hasAnyRole = roleNames.some((roleName) => {
                const filteredRoles = userRoles.filter((userRole) => {
                    return userRole.name.toLocaleLowerCase() === roleName.toLocaleLowerCase();
                });
                return filteredRoles.length > 0;
            });
            return hasAnyRole;
        });
    }
    checkUserHasRole(userId, roleNames) {
        return this.getUserRoles(userId).pipe(map((userRoles) => {
            let hasRole = false;
            if (userRoles && userRoles.length > 0) {
                roleNames.forEach((roleName) => {
                    const role = userRoles.find(({ name }) => roleName === name);
                    if (role) {
                        hasRole = true;
                        return;
                    }
                });
            }
            return hasRole;
        }));
    }
    queryUsers(requestQuery) {
        const url = this.buildUserUrl();
        const queryParams = { first: requestQuery.first, max: requestQuery.max };
        return this.getTotalUsersCount().pipe(switchMap((totalCount) => this.oAuth2Service.get({ url, queryParams }).pipe(map((response) => {
            return {
                entries: response,
                pagination: {
                    skipCount: requestQuery.first,
                    maxItems: requestQuery.max,
                    count: totalCount,
                    hasMoreItems: false,
                    totalItems: totalCount
                }
            };
        }))));
    }
    getTotalUsersCount() {
        const url = this.buildUserUrl() + `/count`;
        return this.oAuth2Service.get({ url });
    }
    createUser(newUser) {
        const url = this.buildUserUrl();
        const bodyParam = JSON.stringify(newUser);
        return this.oAuth2Service.post({ url, bodyParam });
    }
    updateUser(userId, updatedUser) {
        const url = this.buildUserUrl() + '/' + userId;
        const bodyParam = JSON.stringify(updatedUser);
        return this.oAuth2Service.put({ url, bodyParam });
    }
    deleteUser(userId) {
        const url = this.buildUserUrl() + '/' + userId;
        return this.oAuth2Service.delete({ url });
    }
    changePassword(userId, newPassword) {
        const url = this.buildUserUrl() + '/' + userId + '/reset-password';
        const bodyParam = JSON.stringify(newPassword);
        return this.oAuth2Service.put({ url, bodyParam });
    }
    getInvolvedGroups(userId) {
        const url = this.buildUserUrl() + '/' + userId + '/groups/';
        const pathParams = { id: userId };
        return this.oAuth2Service.get({ url, pathParams });
    }
    joinGroup(joinGroupRequest) {
        const url = this.buildUserUrl() + '/' + joinGroupRequest.userId + '/groups/' + joinGroupRequest.groupId;
        const bodyParam = JSON.stringify(joinGroupRequest);
        return this.oAuth2Service.put({ url, bodyParam });
    }
    leaveGroup(userId, groupId) {
        const url = this.buildUserUrl() + '/' + userId + '/groups/' + groupId;
        return this.oAuth2Service.delete({ url });
    }
    getAvailableRoles(userId) {
        const url = this.buildUserUrl() + '/' + userId + '/role-mappings/realm/available';
        return this.oAuth2Service.get({ url });
    }
    getAssignedRoles(userId) {
        const url = this.buildUserUrl() + '/' + userId + '/role-mappings/realm';
        const pathParams = { id: userId };
        return this.oAuth2Service.get({ url, pathParams });
    }
    getEffectiveRoles(userId) {
        const url = this.buildUserUrl() + '/' + userId + '/role-mappings/realm/composite';
        const pathParams = { id: userId };
        return this.oAuth2Service.get({ url, pathParams });
    }
    assignRoles(userId, roles) {
        const url = this.buildUserUrl() + '/' + userId + '/role-mappings/realm';
        const bodyParam = JSON.stringify(roles);
        return this.oAuth2Service.post({ url, bodyParam });
    }
    removeRoles(userId, removedRoles) {
        const url = this.buildUserUrl() + '/' + userId + '/role-mappings/realm';
        const bodyParam = JSON.stringify(removedRoles);
        return this.oAuth2Service.delete({ url, bodyParam });
    }
}
IdentityUserService.ɵprov = ɵɵdefineInjectable({ factory: function IdentityUserService_Factory() { return new IdentityUserService(ɵɵinject(JwtHelperService), ɵɵinject(OAuth2Service), ɵɵinject(AppConfigService)); }, token: IdentityUserService, providedIn: "root" });
IdentityUserService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
IdentityUserService.ctorParameters = () => [
    { type: JwtHelperService },
    { type: OAuth2Service },
    { type: AppConfigService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class UserInfoComponent {
    constructor(ecmUserService, bpmUserService, identityUserService, authService) {
        this.ecmUserService = ecmUserService;
        this.bpmUserService = bpmUserService;
        this.identityUserService = identityUserService;
        this.authService = authService;
        this.ecmBackgroundImage = './assets/images/ecm-background.png';
        this.bpmBackgroundImage = './assets/images/bpm-background.png';
        this.menuPositionX = 'after';
        this.menuPositionY = 'below';
        this.showName = true;
        this.namePosition = 'right';
        this.destroy$ = new Subject();
    }
    ngOnInit() {
        this.getUserInfo();
    }
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
    getUserInfo() {
        if (this.authService.isOauth()) {
            this.loadIdentityUserInfo();
            this.mode = 'SSO';
            if (this.authService.isEcmLoggedIn()) {
                this.loadEcmUserInfo();
            }
        }
        else if (this.isAllLoggedIn()) {
            this.loadEcmUserInfo();
            this.loadBpmUserInfo();
            this.mode = 'ALL';
        }
        else if (this.isEcmLoggedIn()) {
            this.loadEcmUserInfo();
            this.mode = 'CONTENT';
        }
        else if (this.isBpmLoggedIn()) {
            this.loadBpmUserInfo();
            this.mode = 'PROCESS';
        }
    }
    onKeyPress(event) {
        this.closeUserModal(event);
    }
    closeUserModal($event) {
        if ($event.keyCode === 27) {
            this.trigger.closeMenu();
        }
    }
    get isLoggedIn() {
        if (this.authService.isKerberosEnabled()) {
            return true;
        }
        return this.authService.isLoggedIn();
    }
    loadEcmUserInfo() {
        this.ecmUser$ = this.ecmUserService.getCurrentUserInfo();
    }
    loadBpmUserInfo() {
        this.bpmUser$ = this.bpmUserService.getCurrentUserInfo();
    }
    loadIdentityUserInfo() {
        this.identityUser$ = of(this.identityUserService.getCurrentUserInfo());
    }
    isAllLoggedIn() {
        return (this.authService.isEcmLoggedIn() && this.authService.isBpmLoggedIn()) || (this.authService.isALLProvider() && this.authService.isKerberosEnabled());
    }
    isBpmLoggedIn() {
        return this.authService.isBpmLoggedIn() || (this.authService.isECMProvider() && this.authService.isKerberosEnabled());
    }
    isEcmLoggedIn() {
        return this.authService.isEcmLoggedIn() || (this.authService.isECMProvider() && this.authService.isKerberosEnabled());
    }
    stopClosing(event) {
        event.stopPropagation();
    }
    getEcmAvatar(avatarId) {
        return this.ecmUserService.getUserProfileImage(avatarId);
    }
    getBpmUserImage() {
        return this.bpmUserService.getCurrentUserProfileImage();
    }
    get showOnRight() {
        return this.namePosition === 'right';
    }
}
UserInfoComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-userinfo',
                template: "<div id=\"userinfo_container\" [class.adf-userinfo-name-right]=\"showOnRight\" (keyup)=\"onKeyPress($event)\"\n     class=\"adf-userinfo-container\" *ngIf=\"isLoggedIn\">\n\n    <ng-container *ngIf=\"showName\">\n        <span *ngIf=\"identityUser$ | async as identityUser; else showBpmAndEcmUserFullNames\"\n              id=\"adf-userinfo-identity-name-display\"\n              class=\"adf-userinfo-name\">{{identityUser | fullName}}</span>\n        <ng-template #showBpmAndEcmUserFullNames>\n            <span *ngIf=\"ecmUser$ | async as ecmUser; else showBpmUserFullName\" id=\"adf-userinfo-ecm-name-display\"\n                  class=\"adf-userinfo-name\">{{ecmUser | fullName}}</span>\n            <ng-template #showBpmUserFullName>\n                <span *ngIf=\"bpmUser$ | async as bpmUser\" id=\"adf-userinfo-bpm-name-display\"\n                      class=\"adf-userinfo-name\">{{bpmUser | fullName}}</span>\n            </ng-template>\n        </ng-template>\n    </ng-container>\n\n    <button mat-button [matMenuTriggerFor]=\"menu\" class=\"adf-userinfo-menu_button\"\n            data-automation-id=\"adf-user-profile\">\n        <div class=\"adf-userinfo-button-profile\" id=\"user-profile\">\n            <div *ngIf=\"identityUser$ | async as identityUser; else showBpmAndEcmUserImage\" id=\"identity-user-image\">\n                <div *ngIf=\"(ecmUser$ | async)?.avatarId as avatarId; else initialTemplate\">\n                    <div class=\"adf-userinfo-profile-container\">\n                        <img id=\"logged-user-img\" [src]=\"getEcmAvatar(avatarId)\" alt=\"user-info-profile-button\"\n                             class=\"adf-userinfo-profile-image\"/>\n                    </div>\n                </div>\n                <ng-template #initialTemplate>\n                    <div [innerHTML]=\"identityUser | usernameInitials:'adf-userinfo-pic'\"></div>\n                </ng-template>\n            </div>\n            <ng-template #showBpmAndEcmUserImage>\n                <div *ngIf=\"ecmUser$ | async as ecmUser; else showBpmUserImage\" id=\"ecm-user-image\">\n                    <div *ngIf=\"ecmUser.avatarId; else initialTemplate\" class=\"adf-userinfo-profile-container\">\n                        <img id=\"logged-user-img\" [src]=\"getEcmAvatar(ecmUser.avatarId)\" alt=\"user-info-profile-button\"\n                             class=\"adf-userinfo-profile-image\"/>\n                    </div>\n                    <ng-template #initialTemplate>\n                        <div [outerHTML]=\"ecmUser | usernameInitials:'adf-userinfo-pic'\"></div>\n                    </ng-template>\n                </div>\n                <ng-template #showBpmUserImage>\n                    <div *ngIf=\"bpmUser$ | async as bpmUser\" id=\"bpm-user-image\">\n                        <div *ngIf=\"bpmUser.pictureId; else initialTemplate\" class=\"adf-userinfo-profile-container\">\n                            <img id=\"logged-user-img\" [src]=\"getBpmUserImage()\" alt=\"user-info-profile-button\"\n                                 class=\"adf-userinfo-profile-image\"/>\n                        </div>\n                        <ng-template #initialTemplate>\n                            <div [outerHTML]=\"bpmUser | usernameInitials:'adf-userinfo-pic'\"></div>\n                        </ng-template>\n                    </div>\n                </ng-template>\n            </ng-template>\n        </div>\n    </button>\n    <mat-menu #menu=\"matMenu\" id=\"user-profile-lists\" [xPosition]=\"menuPositionX\" [yPosition]=\"menuPositionY\"\n              [overlapTrigger]=\"false\" class=\"adf-userinfo-menu\">\n        <mat-tab-group id=\"tab-group-env\" (click)=\"stopClosing($event)\" selectedIndex=\"0\"\n                       class=\"adf-userinfo-tab\" [class.adf-hide-tab]=\"!(bpmUser$ | async) || !(ecmUser$ | async)\">\n            <mat-tab id=\"ecm-panel\" label=\"{{ 'USER_PROFILE.TAB.CS' | translate }}\"\n                     *ngIf=\"mode==='CONTENT' || mode==='ALL'\">\n                <mat-card class=\"adf-userinfo-card\" *ngIf=\"ecmUser$ | async as ecmUser\">\n                    <mat-card-header class=\"adf-userinfo-card-header\"\n                                     [style.background-image]=\"'url(' + ecmBackgroundImage + ')'\">\n                        <div *ngIf=\"ecmUser.avatarId; else initialTemplate\"\n                             class=\"adf-userinfo-profile-container adf-hide-small\">\n                            <img class=\"adf-userinfo-profile-picture\" id=\"ecm-user-detail-image\"\n                                 alt=\"ecm-profile-image\" [src]=\"getEcmAvatar(ecmUser.avatarId)\"/>\n                        </div>\n                        <ng-template #initialTemplate>\n                            <div\n                                [outerHTML]=\"ecmUser | usernameInitials:'adf-userinfo-profile-initials adf-hide-small'\"></div>\n                        </ng-template>\n\n                        <div class=\"adf-userinfo-title\" id=\"ecm-username\">{{ecmUser | fullName}}</div>\n                    </mat-card-header>\n                    <mat-card-content>\n                        <div class=\"adf-userinfo-supporting-text\">\n                            <div class=\"adf-userinfo-detail\">\n                                <span id=\"ecm-full-name\"\n                                      class=\"adf-userinfo__detail-title\">{{ecmUser | fullName}}</span>\n                                <span class=\"adf-userinfo__detail-profile\" id=\"ecm-email\"> {{ecmUser.email}} </span>\n                            </div>\n                            <div class=\"adf-userinfo-detail\">\n                                    <span class=\"adf-userinfo__secondary-info\" id=\"ecm-job-title-label\">\n                                        {{ 'USER_PROFILE.LABELS.ECM.JOB_TITLE' | translate }}\n                                        <span id=\"ecm-job-title\"\n                                              class=\"adf-userinfo__detail-profile\"> {{ ecmUser.jobTitle ? ecmUser.jobTitle : 'N/A' }} </span>\n                                    </span>\n                            </div>\n                        </div>\n                    </mat-card-content>\n                </mat-card>\n            </mat-tab>\n            <mat-tab id=\"bpm-panel\" label=\"{{ 'USER_PROFILE.TAB.PS' | translate }}\"\n                     *ngIf=\"mode==='PROCESS' || mode==='ALL'\">\n                <mat-card class=\"adf-userinfo-card\" *ngIf=\"bpmUser$ | async as bpmUser\">\n                    <mat-card-header class=\"adf-userinfo-card-header\"\n                                     [style.background-image]=\"'url(' + bpmBackgroundImage + ')'\">\n                        <img *ngIf=\"bpmUser.pictureId; else initialTemplate\"\n                             class=\"adf-userinfo-profile-picture adf-hide-small\" id=\"bpm-user-detail-image\"\n                             alt=\"bpm-profile-image\" [src]=\"getBpmUserImage()\"/>\n                        <ng-template #initialTemplate>\n                            <div\n                                [outerHTML]=\"bpmUser | usernameInitials:'adf-userinfo-profile-initials adf-hide-small'\"></div>\n                        </ng-template>\n                        <div class=\"adf-userinfo-title\" id=\"bpm-username\">{{bpmUser | fullName}}</div>\n                    </mat-card-header>\n                    <mat-card-content>\n                        <div class=\"adf-userinfo-supporting-text\">\n                            <div class=\"adf-userinfo-detail\">\n                                <span id=\"bpm-full-name\"\n                                      class=\"adf-userinfo__detail-title\">{{ bpmUser | fullName }}</span>\n                                <span class=\"adf-userinfo__detail-profile\" id=\"bpm-email\"> {{bpmUser.email}} </span>\n                            </div>\n                            <div class=\"adf-userinfo-detail\">\n                                <span id=\"bpm-tenant\" class=\"adf-userinfo__secondary-info\">\n                                    {{ 'USER_PROFILE.LABELS.BPM.TENANT' | translate }}\n                                    <span\n                                        class=\"adf-userinfo__detail-profile\">{{ bpmUser.tenantName ? bpmUser.tenantName : '' }}</span>\n                                </span>\n                            </div>\n                        </div>\n                    </mat-card-content>\n                </mat-card>\n            </mat-tab>\n            <mat-tab id=\"identity-panel\" *ngIf=\"mode==='SSO'\">\n                <mat-card class=\"adf-userinfo-card\" *ngIf=\"identityUser$ | async as identityUser\">\n                    <mat-card-header class=\"adf-userinfo-card-header\"\n                                     [style.background-image]=\"'url(' + bpmBackgroundImage + ')'\">\n                        <div *ngIf=\"ecmUser$ | async as ecmUser\">\n                            <div *ngIf=\"ecmUser.avatarId; else initialTemplate\"\n                                 class=\"adf-userinfo-profile-container adf-hide-small\">\n                                <img class=\"adf-userinfo-profile-picture\" id=\"ecm-user-detail-image\"\n                                     alt=\"ecm-profile-image\" [src]=\"getEcmAvatar(ecmUser.avatarId)\"/>\n                            </div>\n                        </div>\n                        <ng-template #initialTemplate>\n                            <div\n                                [outerHTML]=\"identityUser | usernameInitials:'adf-userinfo-profile-initials adf-hide-small'\"></div>\n                        </ng-template>\n                        <div class=\"adf-userinfo-title\" id=\"identity-username\">{{identityUser | fullName}}</div>\n                    </mat-card-header>\n                    <mat-card-content>\n                        <div class=\"adf-userinfo-supporting-text\">\n                            <div class=\"adf-userinfo-detail\">\n                                <span id=\"identity-full-name\"\n                                      class=\"adf-userinfo__detail-title\">{{identityUser | fullName}}</span>\n                                <span class=\"adf-userinfo__detail-profile\"\n                                      id=\"identity-email\"> {{identityUser.email}} </span>\n                            </div>\n                        </div>\n                    </mat-card-content>\n                </mat-card>\n            </mat-tab>\n        </mat-tab-group>\n    </mat-menu>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-userinfo-container{align-items:center;display:flex;padding:0 5px}.adf-userinfo-name-right{flex-direction:row-reverse}.adf-userinfo-name{padding:0 5px}@media screen and (max-width:959px){.adf-userinfo-name{display:none}}.adf-userinfo-pic{border-radius:100px;display:inline-block;font-size:18px;font-weight:bolder;line-height:40px;text-transform:uppercase}.adf-userinfo-pic,.adf-userinfo-profile-image{background:var(--adf-user-info-color);height:40px;text-align:center;vertical-align:middle;width:40px}.adf-userinfo-profile-image{border-radius:90%;cursor:pointer;margin-left:0;margin-right:0}.adf-userinfo-profile-container{display:inline-block}.adf-userinfo-menu_button.mat-button{border-radius:90%;height:40px;margin-right:0;min-width:40px;padding:0}.adf-userinfo-tab .mat-tab-header{align-self:center;min-width:250px;width:100%}.adf-userinfo-tab .mat-tab-label{flex:auto;font-size:14px;font-weight:500;line-height:48px;text-align:center;text-transform:uppercase}.adf-userinfo-card-header{align-items:center;box-sizing:border-box;display:flex;height:100px;justify-content:stretch;line-height:normal}.adf-userinfo-card.mat-card{padding:0}.adf-userinfo-supporting-text{column-count:2;display:flex;font-size:14px;font-weight:400;justify-content:space-between;letter-spacing:0;line-height:18px;overflow:hidden;padding:32px}@media screen and (max-width:599px){.adf-userinfo-supporting-text{padding:10px}}.adf-userinfo-title{font-size:21px}.adf-userinfo__detail-profile{align-items:flex-start;display:block;font-size:14px;font-weight:400;letter-spacing:0;line-height:18px;margin:0;padding:0}.adf-userinfo__detail-title{align-items:flex-start;font-size:16px;font-weight:400;letter-spacing:.04em;line-height:20px;text-overflow:ellipsis}.adf-userinfo__secondary-info{align-items:flex-end;font-size:14px;font-weight:400;letter-spacing:0;line-height:18px}.adf-userinfo-profile-initials,.adf-userinfo-profile-picture{background:var(--adf-user-info-color);background-size:cover;border-radius:50%;height:80px;margin-left:0;margin-right:8px;width:80px}.adf-userinfo-profile-initials{display:flex;font-size:35px;font-weight:400;justify-content:space-around;letter-spacing:0;line-height:78px;overflow:hidden;text-transform:uppercase}.adf-userinfo-button-profile{border:0;display:inline-block;vertical-align:middle}.adf-userinfo-detail{text-align:left}.adf-hide-tab .mat-tab-label-active{display:none!important}@media only screen and (min-device-width:480px){.mat-menu-panel.adf-userinfo-menu{max-height:450px;min-width:450px;overflow:auto;padding:0}}.mat-menu-panel.adf-userinfo-menu .mat-menu-content{padding:0}"]
            },] }
];
UserInfoComponent.ctorParameters = () => [
    { type: EcmUserService },
    { type: BpmUserService },
    { type: IdentityUserService },
    { type: AuthenticationService }
];
UserInfoComponent.propDecorators = {
    trigger: [{ type: ViewChild, args: [MatMenuTrigger,] }],
    ecmBackgroundImage: [{ type: Input }],
    bpmBackgroundImage: [{ type: Input }],
    menuPositionX: [{ type: Input }],
    menuPositionY: [{ type: Input }],
    showName: [{ type: Input }],
    namePosition: [{ type: Input }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class UserInfoModule {
}
UserInfoModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    TranslateModule,
                    PipeModule
                ],
                declarations: [
                    UserInfoComponent
                ],
                exports: [
                    UserInfoComponent
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class HostSettingsComponent {
    constructor(formBuilder, storageService, alfrescoApiService, appConfig) {
        this.formBuilder = formBuilder;
        this.storageService = storageService;
        this.alfrescoApiService = alfrescoApiService;
        this.appConfig = appConfig;
        this.HOST_REGEX = '^(http|https):\/\/.*[^/]$';
        this.providers = ['BPM', 'ECM', 'ALL'];
        this.showSelectProviders = true;
        this.error = new EventEmitter();
        this.cancel = new EventEmitter();
        this.success = new EventEmitter();
    }
    ngOnInit() {
        if (this.providers.length === 1) {
            this.showSelectProviders = false;
        }
        const providerSelected = this.appConfig.get(AppConfigValues.PROVIDERS);
        const authType = this.appConfig.get(AppConfigValues.AUTHTYPE, 'BASIC');
        this.form = this.formBuilder.group({
            providersControl: [providerSelected, Validators.required],
            authType: authType
        });
        this.addFormGroups();
        if (authType === 'OAUTH') {
            this.addOAuthFormGroup();
            this.addIdentityHostFormControl();
        }
        this.form.get('authType').valueChanges.subscribe((value) => {
            if (value === 'BASIC') {
                this.form.removeControl('oauthConfig');
                this.form.removeControl('identityHost');
            }
            else {
                this.addOAuthFormGroup();
                this.addIdentityHostFormControl();
            }
        });
        this.providersControl.valueChanges.subscribe(() => {
            this.removeFormGroups();
            this.addFormGroups();
        });
    }
    removeFormGroups() {
        this.form.removeControl('bpmHost');
        this.form.removeControl('ecmHost');
    }
    addFormGroups() {
        this.addBPMFormControl();
        this.addECMFormControl();
    }
    addOAuthFormGroup() {
        const oauthFormGroup = this.createOAuthFormGroup();
        this.form.addControl('oauthConfig', oauthFormGroup);
    }
    addBPMFormControl() {
        if ((this.isBPM() || this.isALL() || this.isOAUTH()) && !this.bpmHost) {
            const bpmFormControl = this.createBPMFormControl();
            this.form.addControl('bpmHost', bpmFormControl);
        }
    }
    addIdentityHostFormControl() {
        const identityHostFormControl = this.createIdentityFormControl();
        this.form.addControl('identityHost', identityHostFormControl);
    }
    addECMFormControl() {
        if ((this.isECM() || this.isALL()) && !this.ecmHost) {
            const ecmFormControl = this.createECMFormControl();
            this.form.addControl('ecmHost', ecmFormControl);
        }
    }
    createOAuthFormGroup() {
        const oauth = this.appConfig.get(AppConfigValues.OAUTHCONFIG, {});
        return this.formBuilder.group({
            host: [oauth.host, [Validators.required, Validators.pattern(this.HOST_REGEX)]],
            clientId: [oauth.clientId, Validators.required],
            redirectUri: [oauth.redirectUri, Validators.required],
            redirectUriLogout: [oauth.redirectUriLogout],
            scope: [oauth.scope, Validators.required],
            secret: oauth.secret,
            silentLogin: oauth.silentLogin,
            implicitFlow: oauth.implicitFlow,
            publicUrls: [oauth.publicUrls]
        });
    }
    createBPMFormControl() {
        return new FormControl(this.appConfig.get(AppConfigValues.BPMHOST), [Validators.required, Validators.pattern(this.HOST_REGEX)]);
    }
    createIdentityFormControl() {
        return new FormControl(this.appConfig.get(AppConfigValues.IDENTITY_HOST), [Validators.required, Validators.pattern(this.HOST_REGEX)]);
    }
    createECMFormControl() {
        return new FormControl(this.appConfig.get(AppConfigValues.ECMHOST), [Validators.required, Validators.pattern(this.HOST_REGEX)]);
    }
    onCancel() {
        this.cancel.emit(true);
    }
    onSubmit(values) {
        this.storageService.setItem(AppConfigValues.PROVIDERS, values.providersControl);
        if (this.isBPM()) {
            this.saveBPMValues(values);
        }
        else if (this.isECM()) {
            this.saveECMValues(values);
        }
        else if (this.isALL()) {
            this.saveECMValues(values);
            this.saveBPMValues(values);
        }
        if (this.isOAUTH()) {
            this.saveOAuthValues(values);
        }
        this.storageService.setItem(AppConfigValues.AUTHTYPE, values.authType);
        this.alfrescoApiService.reset();
        this.alfrescoApiService.getInstance().invalidateSession();
        this.success.emit(true);
    }
    keyDownFunction(event) {
        if (event.keyCode === ENTER && this.form.valid) {
            this.onSubmit(this.form.value);
        }
    }
    saveOAuthValues(values) {
        if (values.oauthConfig.publicUrls && (typeof values.oauthConfig.publicUrls === 'string')) {
            values.oauthConfig.publicUrls = values.oauthConfig.publicUrls.split(',');
        }
        this.storageService.setItem(AppConfigValues.OAUTHCONFIG, JSON.stringify(values.oauthConfig));
        this.storageService.setItem(AppConfigValues.IDENTITY_HOST, values.identityHost);
    }
    saveBPMValues(values) {
        this.storageService.setItem(AppConfigValues.BPMHOST, values.bpmHost);
    }
    saveECMValues(values) {
        this.storageService.setItem(AppConfigValues.ECMHOST, values.ecmHost);
    }
    isBPM() {
        return this.providersControl.value === 'BPM';
    }
    isECM() {
        return this.providersControl.value === 'ECM';
    }
    isALL() {
        return this.providersControl.value === 'ALL';
    }
    isOAUTH() {
        return this.form.get('authType').value === 'OAUTH';
    }
    get providersControl() {
        return this.form.get('providersControl');
    }
    get bpmHost() {
        return this.form.get('bpmHost');
    }
    get ecmHost() {
        return this.form.get('ecmHost');
    }
    get host() {
        return this.oauthConfig.get('host');
    }
    get identityHost() {
        return this.form.get('identityHost');
    }
    get clientId() {
        return this.oauthConfig.get('clientId');
    }
    get scope() {
        return this.oauthConfig.get('scope');
    }
    get secretId() {
        return this.oauthConfig.get('secretId');
    }
    get implicitFlow() {
        return this.oauthConfig.get('implicitFlow');
    }
    get silentLogin() {
        return this.oauthConfig.get('silentLogin');
    }
    get redirectUri() {
        return this.oauthConfig.get('redirectUri');
    }
    get publicUrls() {
        return this.oauthConfig.get('publicUrls');
    }
    get redirectUriLogout() {
        return this.oauthConfig.get('redirectUriLogout');
    }
    get oauthConfig() {
        return this.form.get('oauthConfig');
    }
}
HostSettingsComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-host-settings',
                template: "<div class=\"adf-setting-container\">\n    <mat-toolbar color=\"primary\" class=\"adf-setting-toolbar\">\n        <h3>{{'CORE.HOST_SETTINGS.TITLE' | translate}}</h3>\n    </mat-toolbar>\n    <mat-card class=\"adf-setting-card\">\n        <form id=\"host-form\" [formGroup]=\"form\" (submit)=\"onSubmit(form.value)\" (keydown)=\"keyDownFunction($event)\">\n\n            <mat-form-field *ngIf=\"showSelectProviders\">\n                <mat-select  id=\"adf-provider-selector\" placeholder=\"Provider\" [formControl]=\"providersControl\">\n                    <mat-option *ngFor=\"let provider of providers\" [value]=\"provider\">\n                        {{ provider }}\n                    </mat-option>\n                </mat-select>\n            </mat-form-field>\n\n            <div class=\"adf-authentication-type\">\n                <div> {{'CORE.HOST_SETTINGS.TYPE-AUTH' | translate }} : </div>\n                <mat-radio-group formControlName=\"authType\" >\n                <mat-radio-button value=\"BASIC\">{{'CORE.HOST_SETTINGS.BASIC' | translate }}\n                </mat-radio-button>\n                <mat-radio-button value=\"OAUTH\">{{'CORE.HOST_SETTINGS.SSO' | translate }}\n                </mat-radio-button>\n            </mat-radio-group>\n            </div>\n\n            <ng-container *ngIf=\"isALL() || isECM()\">\n                <mat-card-content>\n                    <mat-form-field class=\"adf-full-width\">\n                        <mat-label>{{'CORE.HOST_SETTINGS.CS-HOST' | translate }}</mat-label>\n                        <input matInput [formControl]=\"ecmHost\" data-automation-id=\"ecmHost\" type=\"text\"\n                               id=\"ecmHost\" placeholder=\"http(s)://host|ip:port(/path)\">\n                        <mat-error *ngIf=\"ecmHost.hasError('pattern')\">\n                            {{ 'CORE.HOST_SETTINGS.NOT_VALID'| translate }}\n                        </mat-error>\n                        <mat-error *ngIf=\"ecmHost.hasError('required')\">\n                            {{ 'CORE.HOST_SETTINGS.REQUIRED'| translate }}\n                        </mat-error>\n                    </mat-form-field>\n                    <p>\n                </mat-card-content>\n            </ng-container>\n\n            <ng-container *ngIf=\"isALL() || isBPM()\">\n                <mat-card-content>\n                    <mat-form-field class=\"adf-full-width\">\n                        <mat-label>{{'CORE.HOST_SETTINGS.BP-HOST' | translate }}</mat-label>\n                        <input matInput [formControl]=\"bpmHost\" data-automation-id=\"bpmHost\" type=\"text\"\n                               id=\"bpmHost\" placeholder=\"http(s)://host|ip:port(/path)\">\n                        <mat-error *ngIf=\"bpmHost.hasError('pattern')\">\n                            {{ 'CORE.HOST_SETTINGS.NOT_VALID'| translate }}\n                        </mat-error>\n                        <mat-error *ngIf=\"bpmHost.hasError('required')\">\n                            {{ 'CORE.HOST_SETTINGS.REQUIRED'| translate }}\n                        </mat-error>\n                    </mat-form-field>\n                </mat-card-content>\n            </ng-container>\n\n            <ng-container *ngIf=\"isOAUTH()\">\n                <mat-card-content>\n                    <mat-form-field class=\"adf-full-width\">\n                        <mat-label>Identity Host</mat-label>\n                        <input matInput name=\"identityHost\" id=\"identityHost\" formControlName=\"identityHost\"\n                                placeholder=\"http(s)://host|ip:port(/path)\">\n                        <mat-error *ngIf=\"identityHost.hasError('pattern')\">\n                            {{ 'CORE.HOST_SETTINGS.NOT_VALID'| translate }}\n                        </mat-error>\n                        <mat-error *ngIf=\"identityHost.hasError('required')\">\n                            {{ 'CORE.HOST_SETTINGS.REQUIRED'| translate }}\n                        </mat-error>\n                    </mat-form-field>\n                </mat-card-content>\n            </ng-container>\n\n            <ng-container *ngIf=\"isOAUTH()\">\n                <div formGroupName=\"oauthConfig\">\n                    <mat-form-field class=\"adf-full-width\">\n                        <mat-label>Auth Host</mat-label>\n                        <input matInput name=\"host\" id=\"oauthHost\" formControlName=\"host\"\n                               placeholder=\"http(s)://host|ip:port(/path)\">\n                        <mat-error *ngIf=\"host.hasError('pattern')\">\n                            {{ 'CORE.HOST_SETTINGS.NOT_VALID'| translate }}\n                        </mat-error>\n                        <mat-error *ngIf=\"host.hasError('required')\">\n                            {{ 'CORE.HOST_SETTINGS.REQUIRED'| translate }}\n                        </mat-error>\n                    </mat-form-field>\n                    <mat-form-field class=\"adf-full-width\">\n                        <mat-label>{{ 'CORE.HOST_SETTINGS.CLIENT'| translate }}</mat-label>\n                        <input matInput name=\"clientId\" id=\"clientId\" formControlName=\"clientId\"\n                               placeholder=\"Client Id\">\n                        <mat-error *ngIf=\"clientId.hasError('required')\">\n                            {{ 'CORE.HOST_SETTINGS.REQUIRED'| translate }}\n                        </mat-error>\n                    </mat-form-field>\n\n                    <mat-form-field class=\"adf-full-width\">\n                        <mat-label>{{ 'CORE.HOST_SETTINGS.SCOPE'| translate }}</mat-label>\n                        <input matInput name=\"{{ 'CORE.HOST_SETTINGS.SCOPE'| translate }}\"\n                               formControlName=\"scope\" placeholder=\"Scope Id\">\n                        <mat-error *ngIf=\"scope.hasError('required')\">\n                            {{ 'CORE.HOST_SETTINGS.REQUIRED'| translate }}\n                        </mat-error>\n                    </mat-form-field>\n\n                    <label for=\"silentLogin\">{{ 'CORE.HOST_SETTINGS.SILENT'| translate }}</label>\n                    <mat-slide-toggle class=\"adf-full-width\" name=\"silentLogin\" [color]=\"'primary'\"\n                                      formControlName=\"silentLogin\">\n                    </mat-slide-toggle>\n\n                    <label for=\"implicitFlow\">{{ 'CORE.HOST_SETTINGS.IMPLICIT-FLOW'| translate }}</label>\n                    <mat-slide-toggle class=\"adf-full-width\" name=\"implicitFlow\" [color]=\"'primary'\"\n                                      formControlName=\"implicitFlow\">\n                    </mat-slide-toggle>\n\n\n                    <mat-form-field class=\"adf-full-width\">\n                        <mat-label>{{ 'CORE.HOST_SETTINGS.REDIRECT'| translate }}</mat-label>\n                        <input matInput placeholder=\"{{ 'CORE.HOST_SETTINGS.REDIRECT'| translate }}\"\n                               name=\"redirectUri\" formControlName=\"redirectUri\">\n                        <mat-error *ngIf=\"redirectUri.hasError('required')\">\n                            {{ 'CORE.HOST_SETTINGS.REQUIRED'| translate }}\n                        </mat-error>\n                    </mat-form-field>\n\n                    <mat-form-field class=\"adf-full-width\">\n                        <mat-label>{{ 'CORE.HOST_SETTINGS.REDIRECT_LOGOUT'| translate }}</mat-label>\n                        <input id=\"logout-url\" matInput placeholder=\"{{ 'CORE.HOST_SETTINGS.REDIRECT_LOGOUT'| translate }}\"\n                               name=\"redirectUriLogout\" formControlName=\"redirectUriLogout\">\n                    </mat-form-field>\n\n                    <mat-form-field class=\"adf-full-width\">\n                        <mat-label>{{ 'CORE.HOST_SETTINGS.PUBLIC_URLS'| translate }}</mat-label>\n                        <input id=\"public-url\" matInput placeholder=\"{{ 'CORE.HOST_SETTINGS.PUBLIC_URLS'| translate }}\"\n                               name=\"publicUrls\" formControlName=\"publicUrls\">\n                    </mat-form-field>\n\n                </div>\n            </ng-container>\n            <mat-card-actions class=\"adf-actions\">\n                <button mat-button (click)=\"onCancel()\" color=\"primary\">\n                    {{'CORE.HOST_SETTINGS.BACK' | translate }}\n                </button>\n                <button type=\"submit\" id=\"host-button\" class=\"adf-login-button\" mat-raised-button\n                        color=\"primary\" data-automation-id=\"host-button\"\n                        [disabled]=\"!form.valid\">\n                    {{'CORE.HOST_SETTINGS.APPLY' | translate }}\n                </button>\n            </mat-card-actions>\n        </form>\n    </mat-card>\n</div>\n",
                host: {
                    'class': 'adf-host-settings'
                },
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-host-settings{align-items:center;display:flex;min-height:100%}.adf-host-settings .adf-authentication-type{margin-bottom:20px;margin-top:10px}.adf-host-settings .adf-setting-container{border-collapse:collapse;border-spacing:0;display:table;margin:0 auto;width:800px}.adf-host-settings .adf-setting-card-padding{display:table-cell;margin:0;vertical-align:middle;width:50%}.adf-host-settings .adf-settings-link-icon{margin-right:10px;position:relative;top:6px}.adf-host-settings .adf-settings-actions{display:flex;justify-content:flex-end}.adf-host-settings .adf-full-width{width:100%}"]
            },] }
];
HostSettingsComponent.ctorParameters = () => [
    { type: FormBuilder },
    { type: StorageService },
    { type: AlfrescoApiService },
    { type: AppConfigService }
];
HostSettingsComponent.propDecorators = {
    providers: [{ type: Input }],
    error: [{ type: Output }],
    cancel: [{ type: Output }],
    success: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class HostSettingsModule {
}
HostSettingsModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    TranslateModule,
                    FormsModule,
                    ReactiveFormsModule
                ],
                declarations: [
                    HostSettingsComponent
                ],
                exports: [
                    HostSettingsComponent
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PaginationComponent {
    constructor(elementRef, renderer, cdr, userPreferencesService, translate) {
        this.elementRef = elementRef;
        this.renderer = renderer;
        this.cdr = cdr;
        this.userPreferencesService = userPreferencesService;
        this.translate = translate;
        this._isEmpty = true;
        this._hasItems = false;
        this.change = new EventEmitter();
        this.changePageNumber = new EventEmitter();
        this.changePageSize = new EventEmitter();
        this.nextPage = new EventEmitter();
        this.prevPage = new EventEmitter();
        this.onDestroy$ = new Subject();
    }
    get pagination() {
        return this._pagination;
    }
    set pagination(value) {
        value = value || PaginationComponent.DEFAULT_PAGINATION;
        this._pagination = value;
        this._hasItems = value && value.count > 0;
        this._isEmpty = !this.hasItems;
        if (this._isEmpty) {
            this.renderer.addClass(this.elementRef.nativeElement, 'adf-pagination__empty');
        }
        else {
            this.renderer.removeClass(this.elementRef.nativeElement, 'adf-pagination__empty');
        }
        this.cdr.detectChanges();
    }
    ngOnInit() {
        this.userPreferencesService
            .select(UserPreferenceValues.PaginationSize)
            .pipe(takeUntil(this.onDestroy$))
            .subscribe(maxItems => {
            this.pagination = Object.assign(Object.assign(Object.assign({}, PaginationComponent.DEFAULT_PAGINATION), this.pagination), { maxItems });
        });
        if (!this.supportedPageSizes) {
            this.supportedPageSizes = this.userPreferencesService.supportedPageSizes;
        }
        if (this.target) {
            this.target.pagination
                .pipe(takeUntil(this.onDestroy$))
                .subscribe(pagination => {
                if (pagination.count === 0 && !this.isFirstPage) {
                    this.goPrevious();
                }
                this.pagination = Object.assign({}, pagination);
            });
        }
        if (!this.pagination) {
            this.pagination = Object.assign({}, PaginationComponent.DEFAULT_PAGINATION);
        }
    }
    get lastPage() {
        const { maxItems, totalItems } = this.pagination;
        return (totalItems && maxItems)
            ? Math.ceil(totalItems / maxItems)
            : 1;
    }
    get current() {
        const { maxItems, skipCount } = this.pagination;
        return (skipCount && maxItems)
            ? Math.floor(skipCount / maxItems) + 1
            : 1;
    }
    get isLastPage() {
        if (!this.pagination.totalItems && this.pagination.hasMoreItems) {
            return false;
        }
        return this.current === this.lastPage;
    }
    get isFirstPage() {
        return this.current === 1;
    }
    get next() {
        return this.isLastPage ? this.current : this.current + 1;
    }
    get previous() {
        return this.isFirstPage ? 1 : this.current - 1;
    }
    get hasItems() {
        return this._hasItems;
    }
    get isEmpty() {
        return this._isEmpty;
    }
    get range() {
        const { skipCount, maxItems, totalItems } = this.pagination;
        let start = 0;
        if (totalItems || totalItems !== 0) {
            start = skipCount + 1;
        }
        const end = this.isLastPage ? totalItems : skipCount + maxItems;
        return [start, end];
    }
    get pages() {
        return Array(this.lastPage)
            .fill('n')
            .map((_, index) => (index + 1));
    }
    get itemRangeText() {
        const rangeString = this.range.join('-');
        let translation = this.translate.instant('CORE.PAGINATION.ITEMS_RANGE', {
            range: rangeString,
            total: this.pagination.totalItems
        });
        if (!this.pagination.totalItems) {
            translation = translation.substr(0, translation.indexOf(rangeString) + rangeString.length);
        }
        return translation;
    }
    goNext() {
        if (this.hasItems) {
            const maxItems = this.pagination.maxItems;
            const skipCount = (this.next - 1) * maxItems;
            this.pagination = Object.assign(Object.assign({}, this.pagination), { skipCount });
            this.handlePaginationEvent('NEXT_PAGE');
        }
    }
    goPrevious() {
        if (this.hasItems) {
            const maxItems = this.pagination.maxItems;
            const skipCount = (this.previous - 1) * maxItems;
            this.pagination = Object.assign(Object.assign({}, this.pagination), { skipCount });
            this.handlePaginationEvent('PREV_PAGE');
        }
    }
    onChangePageNumber(pageNumber) {
        if (this.hasItems) {
            const maxItems = this.pagination.maxItems;
            const skipCount = (pageNumber - 1) * maxItems;
            this.pagination = Object.assign(Object.assign({}, this.pagination), { skipCount });
            this.handlePaginationEvent('CHANGE_PAGE_NUMBER');
        }
    }
    onChangePageSize(maxItems) {
        this.pagination = Object.assign(Object.assign({}, this.pagination), { skipCount: 0, maxItems });
        this.userPreferencesService.paginationSize = maxItems;
        this.handlePaginationEvent('CHANGE_PAGE_SIZE');
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
    handlePaginationEvent(action) {
        const paginationModel = Object.assign({}, this.pagination);
        if (action === 'NEXT_PAGE') {
            this.nextPage.emit(paginationModel);
        }
        if (action === 'PREV_PAGE') {
            this.prevPage.emit(paginationModel);
        }
        if (action === 'CHANGE_PAGE_NUMBER') {
            this.changePageNumber.emit(paginationModel);
        }
        if (action === 'CHANGE_PAGE_SIZE') {
            this.changePageSize.emit(paginationModel);
        }
        this.change.emit(paginationModel);
        if (this.target) {
            this.target.updatePagination(paginationModel);
        }
    }
}
PaginationComponent.DEFAULT_PAGINATION = {
    skipCount: 0,
    maxItems: 25,
    totalItems: 0,
    count: 0,
    hasMoreItems: false
};
PaginationComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-pagination',
                host: { 'class': 'adf-pagination' },
                template: "<ng-container *ngIf=\"hasItems\">\n    <div class=\"adf-pagination__block adf-pagination__range-block\">\n        <span class=\"adf-pagination__range\">\n            {{ itemRangeText }}\n        </span>\n    </div>\n\n    <div class=\"adf-pagination__block adf-pagination__perpage-block\">\n        <span>\n            {{ 'CORE.PAGINATION.ITEMS_PER_PAGE' | translate }}\n        </span>\n\n        <span class=\"adf-pagination__max-items\">\n            {{ pagination.maxItems }}\n        </span>\n\n        <button\n            mat-icon-button\n            [attr.aria-label]=\"'CORE.PAGINATION.ARIA.ITEMS_PER_PAGE' | translate\"\n            [matMenuTriggerFor]=\"pageSizeMenu\">\n            <mat-icon>arrow_drop_down</mat-icon>\n        </button>\n\n        <mat-menu #pageSizeMenu=\"matMenu\" class=\"adf-pagination__page-selector\">\n            <button\n                mat-menu-item\n                *ngFor=\"let pageSize of supportedPageSizes\"\n                (click)=\"onChangePageSize(pageSize)\">\n                {{ pageSize }}\n            </button>\n        </mat-menu>\n    </div>\n\n    <div class=\"adf-pagination__block adf-pagination__actualinfo-block\">\n        <span class=\"adf-pagination__current-page\">\n            {{ 'CORE.PAGINATION.CURRENT_PAGE' | translate: { number: current } }}\n        </span>\n\n        <button\n            mat-icon-button\n            data-automation-id=\"page-selector\"\n            [attr.aria-label]=\"'CORE.PAGINATION.ARIA.CURRENT_PAGE' | translate\"\n            [matMenuTriggerFor]=\"pagesMenu\"\n            *ngIf=\"pages.length > 1\">\n            <mat-icon>arrow_drop_down</mat-icon>\n        </button>\n\n        <div *ngIf=\"pagination.totalItems\">\n            <span class=\"adf-pagination__total-pages\">\n                {{ 'CORE.PAGINATION.TOTAL_PAGES' | translate: { total: pages.length } }}\n            </span>\n        </div>\n\n        <mat-menu #pagesMenu=\"matMenu\" class=\"adf-pagination__page-selector\">\n            <button\n                mat-menu-item\n                *ngFor=\"let pageNumber of pages\"\n                (click)=\"onChangePageNumber(pageNumber)\">\n                {{ pageNumber }}\n            </button>\n        </mat-menu>\n    </div>\n\n    <div class=\"adf-pagination__block adf-pagination__controls-block\">\n        <button\n            class=\"adf-pagination__previous-button\"\n            mat-icon-button\n            [attr.aria-label]=\"'CORE.PAGINATION.ARIA.PREVIOUS_PAGE' | translate\"\n            [disabled]=\"isFirstPage\"\n            (click)=\"goPrevious()\">\n            <mat-icon>keyboard_arrow_left</mat-icon>\n        </button>\n\n        <button\n            class=\"adf-pagination__next-button\"\n            mat-icon-button\n            [attr.aria-label]=\"'CORE.PAGINATION.ARIA.NEXT_PAGE' | translate\"\n            [disabled]=\"isLastPage\"\n            (click)=\"goNext()\">\n            <mat-icon>keyboard_arrow_right</mat-icon>\n        </button>\n    </div>\n</ng-container>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-pagination{border-top:none;color:var(--theme-text-fg-color);display:flex;height:48px;line-height:20px}.adf-pagination__block{align-items:center;border-right:none;display:flex;padding:0 8px}.adf-pagination__block:first-child{flex:1 1 auto;padding-left:24px}.adf-pagination__block:last-child{border-right-width:0}@media (max-width:599.9px){.adf-pagination{flex-wrap:wrap;justify-content:space-between;padding:0 16px}.adf-pagination__perpage-block,.adf-pagination__range-block{display:none}.adf-pagination__actualinfo-block{border-right:none}.adf-pagination__controls-block{padding-right:0}}.adf-pagination__max-items{margin-left:10px}.adf-pagination__current-page,.adf-pagination__max-items{margin-right:5px}.adf-pagination__current-page,.adf-pagination__current-page+button,.adf-pagination__max-items,.adf-pagination__max-items+button{color:var(--theme-text-fg-color)}.adf-pagination__current-page+button,.adf-pagination__max-items+button{margin-left:-10px}.adf-pagination__next-button,.adf-pagination__previous-button{margin:0 5px}.adf-pagination__page-selector{max-height:250px!important}.adf-pagination.adf-pagination__empty{border-top:none;height:48px}.adf-pagination button[mat-icon-button]{height:32px;line-height:32px;width:32px}"]
            },] }
];
PaginationComponent.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 },
    { type: ChangeDetectorRef },
    { type: UserPreferencesService },
    { type: TranslateService }
];
PaginationComponent.propDecorators = {
    target: [{ type: Input }],
    supportedPageSizes: [{ type: Input }],
    pagination: [{ type: Input }],
    change: [{ type: Output }],
    changePageNumber: [{ type: Output }],
    changePageSize: [{ type: Output }],
    nextPage: [{ type: Output }],
    prevPage: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class InfinitePaginationComponent {
    constructor(cdr, userPreferencesService) {
        this.cdr = cdr;
        this.userPreferencesService = userPreferencesService;
        this.onDestroy$ = new Subject();
        this.isLoading = false;
        this.loadMore = new EventEmitter();
        this.pagination = InfinitePaginationComponent.DEFAULT_PAGINATION;
        this.requestPaginationModel = {
            skipCount: 0,
            merge: true
        };
    }
    set target(target) {
        if (target) {
            this._target = target;
            target.pagination
                .pipe(takeUntil(this.onDestroy$))
                .subscribe(pagination => {
                this.isLoading = false;
                this.pagination = pagination;
                if (!this.pagination.hasMoreItems) {
                    this.pagination.hasMoreItems = false;
                }
                this.cdr.detectChanges();
            });
        }
    }
    get target() {
        return this._target;
    }
    ngOnInit() {
        this.userPreferencesService
            .select(UserPreferenceValues.PaginationSize)
            .pipe(takeUntil(this.onDestroy$))
            .subscribe((pageSize) => {
            this.pageSize = this.pageSize || pageSize;
            this.requestPaginationModel.maxItems = this.pageSize;
        });
    }
    onLoadMore() {
        this.requestPaginationModel.skipCount = 0;
        this.requestPaginationModel.merge = false;
        this.requestPaginationModel.maxItems += this.pageSize;
        this.loadMore.next(this.requestPaginationModel);
        if (this._target) {
            this.isLoading = true;
            this._target.updatePagination(this.requestPaginationModel);
        }
    }
    reset() {
        this.pagination.skipCount = 0;
        this.pagination.maxItems = this.pageSize;
        if (this._target) {
            this._target.updatePagination(this.pagination);
        }
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
}
InfinitePaginationComponent.DEFAULT_PAGINATION = new Pagination({
    skipCount: 0,
    maxItems: 25,
    totalItems: 0
});
InfinitePaginationComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-infinite-pagination',
                host: { 'class': 'infinite-adf-pagination' },
                template: "<div *ngIf=\"pagination?.hasMoreItems || isLoading\" class=\"adf-infinite-pagination\">\n\n    <button mat-button\n        *ngIf=\"!isLoading\"\n        class=\"adf-infinite-pagination-load-more\"\n        (click)=\"onLoadMore()\"\n        data-automation-id=\"adf-infinite-pagination-button\">\n            <ng-content></ng-content>\n    </button>\n\n    <mat-progress-bar *ngIf=\"isLoading\"\n        mode=\"indeterminate\"\n        class=\"adf-infinite-pagination-spinner\"\n        data-automation-id=\"adf-infinite-pagination-spinner\"></mat-progress-bar>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-infinite-pagination{display:flex;justify-content:space-around;min-height:56px}.adf-infinite-pagination-load-more{margin-bottom:10px;margin-top:10px}"]
            },] }
];
InfinitePaginationComponent.ctorParameters = () => [
    { type: ChangeDetectorRef },
    { type: UserPreferencesService }
];
InfinitePaginationComponent.propDecorators = {
    target: [{ type: Input }],
    pageSize: [{ type: Input }],
    isLoading: [{ type: Input, args: ['loading',] }],
    loadMore: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PaginationModule {
}
PaginationModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    TranslateModule
                ],
                declarations: [
                    InfinitePaginationComponent,
                    PaginationComponent
                ],
                exports: [
                    InfinitePaginationComponent,
                    PaginationComponent
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class LoginErrorEvent {
    constructor(err) {
        this.err = err;
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class LoginSubmitEvent {
    constructor(_values) {
        this._defaultPrevented = false;
        this._values = _values;
    }
    get values() {
        return this._values;
    }
    get defaultPrevented() {
        return this._defaultPrevented;
    }
    preventDefault() {
        this._defaultPrevented = true;
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class LoginSuccessEvent {
    constructor(token, username, password) {
        this.token = token;
        this.username = username;
        this.password = password;
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var LoginSteps;
(function (LoginSteps) {
    LoginSteps[LoginSteps["Landing"] = 0] = "Landing";
    LoginSteps[LoginSteps["Checking"] = 1] = "Checking";
    LoginSteps[LoginSteps["Welcome"] = 2] = "Welcome";
})(LoginSteps || (LoginSteps = {}));
class LoginComponent {
    constructor(_fb, authService, translateService, logService, router, appConfig, userPreferences, route, sanitizer, alfrescoApiService) {
        this._fb = _fb;
        this.authService = authService;
        this.translateService = translateService;
        this.logService = logService;
        this.router = router;
        this.appConfig = appConfig;
        this.userPreferences = userPreferences;
        this.route = route;
        this.sanitizer = sanitizer;
        this.alfrescoApiService = alfrescoApiService;
        this.isPasswordShow = false;
        this.showRememberMe = true;
        this.showLoginActions = true;
        this.needHelpLink = '';
        this.registerLink = '';
        this.logoImageUrl = './assets/images/alfresco-logo.svg';
        this.backgroundImageUrl = './assets/images/background.svg';
        this.copyrightText = '\u00A9 2016 Alfresco Software, Inc. All Rights Reserved.';
        this.successRoute = null;
        this.success = new EventEmitter();
        this.error = new EventEmitter();
        this.executeSubmit = new EventEmitter();
        this.implicitFlow = false;
        this.isError = false;
        this.actualLoginStep = LoginSteps.Landing;
        this.LoginSteps = LoginSteps;
        this.rememberMe = true;
        this.minLength = 2;
        this.onDestroy$ = new Subject();
    }
    ngOnInit() {
        this.initFormError();
        this.initFormFieldsDefault();
        this.initFormFieldsMessages();
        this.successRoute = this.appConfig.get('successRoute', this.successRoute);
        if (this.authService.isLoggedIn()) {
            this.router.navigate([this.successRoute]);
        }
        else {
            if (this.authService.isOauth()) {
                const oauth = this.appConfig.get(AppConfigValues.OAUTHCONFIG, null);
                if (oauth && oauth.silentLogin) {
                    this.redirectToImplicitLogin();
                }
                else if (oauth && oauth.implicitFlow) {
                    this.implicitFlow = true;
                }
            }
            this.route.queryParams.subscribe((params) => {
                const url = params['redirectUrl'];
                const provider = this.appConfig.get(AppConfigValues.PROVIDERS);
                this.authService.setRedirect({ provider, url });
            });
        }
        if (this.fieldsValidation) {
            this.form = this._fb.group(this.fieldsValidation);
        }
        this.form.valueChanges
            .pipe(takeUntil(this.onDestroy$))
            .subscribe(data => this.onValueChanged(data));
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
    submit() {
        this.onSubmit(this.form.value);
    }
    redirectToImplicitLogin() {
        this.alfrescoApiService.getInstance().oauth2Auth.implicitLogin();
    }
    onSubmit(values) {
        this.disableError();
        const args = new LoginSubmitEvent({
            controls: { username: this.form.controls.username }
        });
        this.executeSubmit.emit(args);
        if (!args.defaultPrevented) {
            this.performLogin(values);
        }
    }
    implicitLogin() {
        if (this.authService.isLoggedIn()) {
            this.router.navigate([this.successRoute]);
        }
        this.authService.ssoImplicitLogin();
    }
    onValueChanged(data) {
        this.disableError();
        for (const field in this.formError) {
            if (field) {
                this.formError[field] = '';
                const hasError = (this.form.controls[field].errors && data[field] !== '') ||
                    (this.form.controls[field].dirty &&
                        !this.form.controls[field].valid);
                if (hasError) {
                    for (const key in this.form.controls[field].errors) {
                        if (key) {
                            const message = this._message[field][key];
                            if (message && message.value) {
                                const translated = this.translateService.instant(message.value, message.params);
                                this.formError[field] += translated;
                            }
                        }
                    }
                }
            }
        }
    }
    performLogin(values) {
        this.actualLoginStep = LoginSteps.Checking;
        this.authService
            .login(values.username, values.password, this.rememberMe)
            .subscribe((token) => {
            const redirectUrl = this.authService.getRedirect();
            this.actualLoginStep = LoginSteps.Welcome;
            this.userPreferences.setStoragePrefix(values.username);
            values.password = null;
            this.success.emit(new LoginSuccessEvent(token, values.username, null));
            if (redirectUrl) {
                this.authService.setRedirect(null);
                this.router.navigateByUrl(redirectUrl);
            }
            else if (this.successRoute) {
                this.router.navigate([this.successRoute]);
            }
        }, (err) => {
            this.actualLoginStep = LoginSteps.Landing;
            this.displayErrorMessage(err);
            this.isError = true;
            this.error.emit(new LoginErrorEvent(err));
        }, () => this.logService.info('Login done'));
    }
    displayErrorMessage(err) {
        if (err.error &&
            err.error.crossDomain &&
            err.error.message.indexOf('Access-Control-Allow-Origin') !== -1) {
            this.errorMsg = err.error.message;
        }
        else if (err.status === 403 &&
            err.message.indexOf('Invalid CSRF-token') !== -1) {
            this.errorMsg = 'LOGIN.MESSAGES.LOGIN-ERROR-CSRF';
        }
        else if (err.status === 403 &&
            err.message.indexOf('The system is currently in read-only mode') !==
                -1) {
            this.errorMsg = 'LOGIN.MESSAGES.LOGIN-ECM-LICENSE';
        }
        else {
            this.errorMsg = 'LOGIN.MESSAGES.LOGIN-ERROR-CREDENTIALS';
        }
    }
    addCustomFormError(field, msg) {
        this.formError[field] += msg;
    }
    addCustomValidationError(field, ruleId, msg, params) {
        this._message[field][ruleId] = {
            value: msg,
            params
        };
    }
    toggleShowPassword(event) {
        event.stopPropagation();
        this.isPasswordShow = !this.isPasswordShow;
    }
    isErrorStyle(field) {
        return !field.valid && field.dirty && !field.pristine;
    }
    trimUsername(event) {
        event.target.value = event.target.value.trim();
    }
    getBackgroundUrlImageUrl() {
        return this.sanitizer.bypassSecurityTrustStyle(`url(${this.backgroundImageUrl})`);
    }
    initFormError() {
        this.formError = {
            username: '',
            password: ''
        };
    }
    initFormFieldsMessages() {
        this._message = {
            username: {
                required: {
                    value: 'LOGIN.MESSAGES.USERNAME-REQUIRED'
                },
                minlength: {
                    value: 'LOGIN.MESSAGES.USERNAME-MIN',
                    params: {
                        minLength: this.minLength
                    }
                }
            },
            password: {
                required: {
                    value: 'LOGIN.MESSAGES.PASSWORD-REQUIRED'
                }
            }
        };
    }
    initFormFieldsDefault() {
        this.form = this._fb.group({
            username: ['', Validators.compose([Validators.required, Validators.minLength(this.minLength)])],
            password: ['', Validators.required]
        });
    }
    disableError() {
        this.isError = false;
        this.initFormError();
    }
}
LoginComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-login',
                template: "<div class=\"adf-login-content\" [style.background-image]=\"getBackgroundUrlImageUrl()\">\n    <div class=\"adf-ie11FixerParent\">\n        <div class=\"adf-ie11FixerChild\">\n\n            <mat-card class=\"adf-login-card-wide\">\n                <form id=\"adf-login-form\" [formGroup]=\"form\" (submit)=\"onSubmit(form.value)\" autocomplete=\"off\">\n                    <mat-card-header>\n                        <mat-card-title>\n                            <div class=\"adf-alfresco-logo\">\n                                <!--HEADER TEMPLATE-->\n                                <ng-template *ngIf=\"headerTemplate\"\n                                             ngFor [ngForOf]=\"[data]\"\n                                             [ngForTemplate]=\"headerTemplate\">\n                                </ng-template>\n                                <img *ngIf=\"!headerTemplate\" id=\"adf-login-img-logo\" class=\"adf-img-logo\" [src]=\"logoImageUrl\"\n                                     alt=\"{{'LOGIN.LOGO' | translate }}\">\n                            </div>\n                        </mat-card-title>\n                    </mat-card-header>\n\n                    <mat-card-content class=\"adf-login-controls\">\n\n                        <!--ERRORS AREA-->\n                        <div class=\"adf-error-container\">\n                            <div *ngIf=\"isError\" id=\"login-error\" data-automation-id=\"login-error\"\n                                 class=\"adf-error  adf-error-message\">\n                                <mat-icon class=\"adf-error-icon\">warning</mat-icon>\n                                <span class=\"adf-login-error-message\">{{errorMsg | translate }}</span>\n                            </div>\n                        </div>\n\n                        <div *ngIf=\"!implicitFlow\">\n\n                            <!--USERNAME FIELD-->\n                            <div class=\"adf-login__field\"\n                                 [ngClass]=\"{'adf-is-invalid': isErrorStyle(form.controls.username)}\">\n                                <mat-form-field class=\"adf-full-width\" floatPlaceholder=\"never\" color=\"primary\">\n                                    <input matInput placeholder=\"{{'LOGIN.LABEL.USERNAME' | translate }}\"\n                                           type=\"text\"\n                                           class=\"adf-full-width\"\n                                           formControlName=\"username\"\n                                           autocapitalize=\"none\"\n                                           id=\"username\"\n                                           data-automation-id=\"username\"\n                                           (blur)=\"trimUsername($event)\">\n                                </mat-form-field>\n\n                                <span class=\"adf-login-validation\" for=\"username\" *ngIf=\"formError['username']\">\n                                <span id=\"username-error\" class=\"adf-login-error\" data-automation-id=\"username-error\">{{formError['username'] | translate }}</span>\n                            </span>\n                            </div>\n\n                            <!--PASSWORD FIELD-->\n                            <div class=\"adf-login__field\">\n                                <mat-form-field class=\"adf-full-width\" floatPlaceholder=\"never\" color=\"primary\">\n                                    <input matInput placeholder=\"{{'LOGIN.LABEL.PASSWORD' | translate }}\"\n                                           [type]=\"isPasswordShow ? 'text' : 'password'\"\n                                           formControlName=\"password\"\n                                           id=\"password\"\n                                           data-automation-id=\"password\">\n                                        <button\n                                            matSuffix\n                                            mat-icon-button\n                                            type=\"button\"\n                                            [attr.aria-label]=\"(isPasswordShow ?\n                                                    'LOGIN.ARIA-LABEL.HIDE-PASSWORD':\n                                                    'LOGIN.ARIA-LABEL.SHOW-PASSWORD'\n                                                ) | translate\"\n                                            (click)=\"toggleShowPassword($event)\"\n                                            (keyup.enter)=\"toggleShowPassword($event)\"\n                                            [attr.data-automation-id]=\"isPasswordShow ? 'hide_password':'show_password'\">\n                                           <mat-icon class=\"adf-login-password-icon\">\n                                               {{ isPasswordShow ? 'visibility':'visibility_off' }}\n                                            </mat-icon>\n                                       </button>\n                                </mat-form-field>\n                                <span class=\"adf-login-validation\" for=\"password\" *ngIf=\"formError['password']\">\n                                <span id=\"password-required\" class=\"adf-login-error\"\n                                      data-automation-id=\"password-required\">{{formError['password'] | translate }}</span>\n                            </span>\n                            </div>\n\n                            <!--CUSTOM CONTENT-->\n                            <ng-content></ng-content>\n\n                            <br>\n                            <button type=\"submit\" id=\"login-button\"\n                                    class=\"adf-login-button\"\n                                    mat-raised-button color=\"accent\"\n                                    [class.adf-isChecking]=\"actualLoginStep === LoginSteps.Checking\"\n                                    [class.adf-isWelcome]=\"actualLoginStep === LoginSteps.Welcome\"\n                                    data-automation-id=\"login-button\" [disabled]=\"!form.valid\"\n                                    [attr.aria-label]=\"'LOGIN.BUTTON.LOGIN' | translate\">\n\n                                <span *ngIf=\"actualLoginStep === LoginSteps.Landing\" class=\"adf-login-button-label\">{{ 'LOGIN.BUTTON.LOGIN' | translate }}</span>\n\n                                <div *ngIf=\"actualLoginStep === LoginSteps.Checking\"\n                                     class=\"adf-interactive-login-label\">\n                                    <span\n                                        class=\"adf-login-button-label\">{{ 'LOGIN.BUTTON.CHECKING' | translate }}</span>\n                                    <div class=\"adf-login-spinner-container\">\n                                        <mat-spinner id=\"checking-spinner\" class=\"adf-login-checking-spinner\"\n                                                     [diameter]=\"25\"></mat-spinner>\n                                    </div>\n                                </div>\n\n\n                                <div *ngIf=\"actualLoginStep === LoginSteps.Welcome\" class=\"adf-interactive-login-label\">\n                                    <span class=\"adf-login-button-label\">{{ 'LOGIN.BUTTON.WELCOME' | translate }}</span>\n                                    <mat-icon class=\"adf-welcome-icon\">done</mat-icon>\n                                </div>\n\n                            </button>\n                            <div *ngIf=\"showRememberMe\" class=\"adf-login__remember-me\">\n                                <mat-checkbox id=\"adf-login-remember\" color=\"primary\" class=\"adf-login-remember-me\"\n                                              [checked]=\"rememberMe\"\n                                              (change)=\"rememberMe = !rememberMe\">{{ 'LOGIN.LABEL.REMEMBER' | translate }}\n                                </mat-checkbox>\n                            </div>\n                        </div>\n\n                        <div *ngIf=\"implicitFlow\">\n                            <button type=\"button\" (click)=\"implicitLogin()\" id=\"login-button-sso\"\n                                    [attr.aria-label]=\"'LOGIN.BUTTON.SSO' | translate\"\n                                    class=\"adf-login-button\"\n                                    mat-raised-button color=\"primary\"\n                                    data-automation-id=\"login-button-sso\">\n                                <span  class=\"adf-login-button-label\">{{ 'LOGIN.BUTTON.SSO' | translate }}</span>\n                            </button>\n                        </div>\n\n                    </mat-card-content>\n\n                    <mat-card-actions *ngIf=\"footerTemplate || showLoginActions\">\n\n                        <div class=\"adf-login-action-container\">\n                            <!--FOOTER TEMPLATE-->\n                            <ng-template *ngIf=\"footerTemplate\"\n                                         ngFor [ngForOf]=\"[data]\"\n                                         [ngForTemplate]=\"footerTemplate\">\n                            </ng-template>\n                            <div class=\"adf-login-action\" *ngIf=\"!footerTemplate && showLoginActions\">\n                                <div id=\"adf-login-action-left\" class=\"adf-login-action-left\">\n                                    <a href=\"{{needHelpLink}}\">{{'LOGIN.ACTION.HELP' | translate }}</a>\n                                </div>\n                                <div id=\"adf-login-action-right\" class=\"adf-login-action-right\">\n                                    <a href=\"{{registerLink}}\">{{'LOGIN.ACTION.REGISTER' | translate }}</a>\n                                </div>\n                            </div>\n                        </div>\n                    </mat-card-actions>\n\n                </form>\n            </mat-card>\n\n            <div class=\"adf-copyright\" data-automation-id=\"login-copyright\">\n                {{ copyrightText }}\n            </div>\n\n        </div>\n    </div>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-login' },
                styles: [".adf-login{display:flex;flex:1;flex-direction:column;height:100%;min-height:0;overflow:hidden}.adf-login-content{background-position:50%;background-size:cover;display:flex;flex-direction:column;justify-content:center;min-height:100%;min-width:320px}@media (-ms-high-contrast:active),(-ms-high-contrast:none){.adf-login-content{display:table;height:100%;width:100%}}.adf-login-content .adf-ie11FixerParent{margin-top:16px;min-width:320px}@media (-ms-high-contrast:active),(-ms-high-contrast:none){.adf-login-content .adf-ie11FixerParent{display:table-cell;padding-top:16px;vertical-align:middle;width:100%}}.adf-login-content .adf-ie11FixerChild{align-items:center;display:flex;flex-direction:column;justify-content:center;width:100%}.adf-login-content .adf-show{display:block!important}.adf-login-content .adf-hide{display:none!important}.adf-login-content .adf-icon-inline{display:block;left:82%;overflow:hidden;position:absolute;top:31%;width:30px}.adf-login-content .adf-login-card-wide{background-color:var(--theme-dialog-bg-color);border-radius:8px;box-shadow:0 2px 2px 0 rgba(0,0,0,.24),0 0 2px 0 rgba(0,0,0,.12);box-sizing:border-box;min-width:320px;padding:21px 64px 34px;width:450px}@media (max-width:482px){.adf-login-content .adf-login-card-wide{width:calc(100% - 32px)}}.adf-login-content .adf-error-container{height:45px}.adf-login-content .adf-error-message{box-orient:horizontal;color:var(--theme-warn-color);display:flex;flex-direction:row;font-size:13px;justify-content:flex-start;margin-bottom:4px;padding:0}.adf-login-content .adf-error-message .adf-error-icon{margin-right:10px}.adf-login-content .mat-card-header-text{margin:0 auto}.adf-login-content .adf-img-logo{display:block;margin-left:auto;margin-right:auto}.adf-login-content .adf-alfresco-logo{padding:24px 16px}.adf-login-content .adf-alfresco-logo img{max-height:58px}.adf-login-content .adf-login-button{box-shadow:none;height:36px;line-height:38px;width:100%}.adf-login-content .adf-login-button-label{color:var(--theme-accent-color-default-contrast)}.adf-login-content .adf-login-button.adf-isChecking{background-color:#e0f7fa}.adf-login-content .adf-login-button.adf-isChecking .adf-login-button-label{color:var(--theme-primary-color)}.adf-login-content .adf-login-button.adf-isWelcome{background-color:var(--theme-primary-color);color:var(--theme-primary-color-default-contrast)}.adf-login-content .adf-login-button.adf-isWelcome .adf-welcome-icon{margin:5px 0 0 10px}.adf-login-content .adf-interactive-login-label{box-orient:horizontal;box-pack:center;display:flex;flex-direction:row;justify-content:center}.adf-login-content .adf-login-spinner-container{margin-left:15px;margin-top:5px}.adf-login-content .adf-login-checking-spinner>svg>circle{stroke-width:16%!important}.adf-login-content .adf-login-controls{overflow:visible;padding:0 0 26px;width:100%}.adf-login-content .adf-login-action{box-orient:horizontal;box-pack:space-between;display:flex;flex-direction:row;justify-content:space-between;margin-top:20px}.adf-login-content .adf-login-action-left a,.adf-login-content .adf-login-action-right a{text-decoration:none}.adf-login-content .adf-is-active{background-color:transparent;color:var(--theme-warn-color);font-size:12px;font-weight:400;line-height:1.33}.adf-login-content .adf-copyright{font-size:12px;min-width:320px;opacity:.54;padding:16px 0;text-align:center}.adf-login-content .mat-form-field .adf-login-password-icon.mat-icon{color:var(--theme-text-fg-color)}.adf-login-content .adf-login__field .mat-form-field-wrapper{font-size:16px;margin:1em 0 0}.adf-login-content .adf-login__field input:-webkit-autofill{-webkit-box-shadow:0 0 0 1000px var(--theme-dialog-bg-color) inset;-webkit-text-fill-color:var(--theme-text-fg-color)!important}.adf-login-content .adf-login-validation{background-color:transparent;color:var(--theme-warn-color);font-size:12px}.adf-login-content .adf-login-error{color:var(--theme-warn-color);display:block;font-size:12px;margin-top:-12px;position:absolute}.adf-login-content .adf-full-width{width:100%}.adf-login-content .adf-login__remember-me{padding-top:22px}.adf-login-content .adf-login__remember-me .mat-checkbox-label{opacity:.87}.adf-login-content .adf-login__field{display:block;margin-left:auto;margin-right:auto;padding-bottom:18px}.adf-login-content .adf-login-remember-me{color:var(--theme-text-fg-color)!important}.adf-login-content .adf-login-action-container{border-top:1px solid rgba(0,0,0,.1);margin-top:23px}"]
            },] }
];
LoginComponent.ctorParameters = () => [
    { type: FormBuilder },
    { type: AuthenticationService },
    { type: TranslationService },
    { type: LogService },
    { type: Router },
    { type: AppConfigService },
    { type: UserPreferencesService },
    { type: ActivatedRoute },
    { type: DomSanitizer },
    { type: AlfrescoApiService }
];
LoginComponent.propDecorators = {
    showRememberMe: [{ type: Input }],
    showLoginActions: [{ type: Input }],
    needHelpLink: [{ type: Input }],
    registerLink: [{ type: Input }],
    logoImageUrl: [{ type: Input }],
    backgroundImageUrl: [{ type: Input }],
    copyrightText: [{ type: Input }],
    fieldsValidation: [{ type: Input }],
    successRoute: [{ type: Input }],
    success: [{ type: Output }],
    error: [{ type: Output }],
    executeSubmit: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class LoginHeaderDirective {
    constructor(alfrescoLoginComponent) {
        this.alfrescoLoginComponent = alfrescoLoginComponent;
    }
    ngAfterContentInit() {
        this.alfrescoLoginComponent.headerTemplate = this.template;
    }
}
LoginHeaderDirective.decorators = [
    { type: Directive, args: [{
                selector: 'adf-login-header, login-header'
            },] }
];
LoginHeaderDirective.ctorParameters = () => [
    { type: LoginComponent }
];
LoginHeaderDirective.propDecorators = {
    template: [{ type: ContentChild, args: [TemplateRef,] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class LoginFooterDirective {
    constructor(alfrescoLoginComponent) {
        this.alfrescoLoginComponent = alfrescoLoginComponent;
    }
    ngAfterContentInit() {
        this.alfrescoLoginComponent.footerTemplate = this.template;
    }
}
LoginFooterDirective.decorators = [
    { type: Directive, args: [{
                selector: 'adf-login-footer, login-footer'
            },] }
];
LoginFooterDirective.ctorParameters = () => [
    { type: LoginComponent }
];
LoginFooterDirective.propDecorators = {
    template: [{ type: ContentChild, args: [TemplateRef,] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class LoginDialogPanelComponent {
    constructor() {
        this.success = new EventEmitter();
    }
    submitForm() {
        this.login.submit();
    }
    onLoginSuccess(event) {
        this.success.emit(event);
    }
    isValid() {
        return this.login && this.login.form ? this.login.form.valid : false;
    }
}
LoginDialogPanelComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-login-dialog-panel',
                template: "<div>\n    <adf-login #adfLogin\n               class=\"adf-panel-login-dialog-component\"\n               [showRememberMe]=\"false\"\n               [showLoginActions]=\"false\"\n               [backgroundImageUrl]=\"''\"\n               (success)=\"onLoginSuccess($event)\">\n        <adf-login-header><ng-template></ng-template></adf-login-header>\n        <adf-login-footer><ng-template></ng-template></adf-login-footer>\n    </adf-login>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-panel-login-dialog-component .adf-login-content .adf-copyright,.adf-panel-login-dialog-component .adf-login-content .adf-login-button,.adf-panel-login-dialog-component .adf-login-content .adf-login__remember-me,.adf-panel-login-dialog-component .adf-login-content .mat-card-actions{display:none}"]
            },] }
];
LoginDialogPanelComponent.propDecorators = {
    success: [{ type: Output }],
    login: [{ type: ViewChild, args: ['adfLogin', { static: true },] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class LoginDialogComponent {
    constructor(data) {
        this.data = data;
        this.buttonActionName = '';
        this.buttonActionName = data.actionName ? `LOGIN.DIALOG.${data.actionName.toUpperCase()}` : 'LOGIN.DIALOG.CHOOSE';
    }
    close() {
        this.data.logged.complete();
    }
    submitForm() {
        this.loginPanel.submitForm();
    }
    onLoginSuccess(event) {
        this.data.logged.next(event);
        this.close();
    }
    isFormValid() {
        return this.loginPanel ? this.loginPanel.isValid() : false;
    }
}
LoginDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-login-dialog',
                template: "<header\n    mat-dialog-title\n    data-automation-id=\"login-dialog-title\">{{data?.title}}\n</header>\n\n<mat-dialog-content class=\"adf-login-dialog-content\">\n    <adf-login-dialog-panel #adfLoginPanel\n                            (success)=\"onLoginSuccess($event)\">\n    </adf-login-dialog-panel>\n</mat-dialog-content>\n\n<mat-dialog-actions align=\"end\">\n    <button\n        mat-button\n        (click)=\"close()\"\n        data-automation-id=\"login-dialog-actions-cancel\">{{ 'LOGIN.DIALOG.CANCEL' | translate }}\n    </button>\n\n    <button mat-button\n        class=\"choose-action\"\n        data-automation-id=\"login-dialog-actions-perform\"\n        [disabled]=\"!isFormValid()\"\n        (click)=\"submitForm()\">{{ buttonActionName | translate}}\n    </button>\n</mat-dialog-actions>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-login-dialog-content adf-login .adf-login-content .adf-login-card-wide{box-shadow:none;padding:0}"]
            },] }
];
LoginDialogComponent.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] }] }
];
LoginDialogComponent.propDecorators = {
    loginPanel: [{ type: ViewChild, args: ['adfLoginPanel', { static: true },] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class LoginModule {
}
LoginModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    RouterModule,
                    MaterialModule,
                    FormsModule,
                    ReactiveFormsModule,
                    CommonModule,
                    TranslateModule
                ],
                declarations: [
                    LoginComponent,
                    LoginFooterDirective,
                    LoginHeaderDirective,
                    LoginDialogComponent,
                    LoginDialogPanelComponent
                ],
                exports: [
                    LoginComponent,
                    LoginFooterDirective,
                    LoginHeaderDirective,
                    LoginDialogComponent,
                    LoginDialogPanelComponent
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class LanguageService {
    constructor(appConfigService, userPreferencesService) {
        this.userPreferencesService = userPreferencesService;
        this.languages = new BehaviorSubject([
            { 'key': 'de', 'label': 'Deutsch' },
            { 'key': 'en', 'label': 'English' },
            { 'key': 'es', 'label': 'Español' },
            { 'key': 'fr', 'label': 'Français' },
            { 'key': 'it', 'label': 'Italiano' },
            { 'key': 'ja', 'label': '日本語' },
            { 'key': 'nb', 'label': 'Bokmål' },
            { 'key': 'nl', 'label': 'Nederlands' },
            { 'key': 'pt-BR', 'label': 'Português (Brasil)' },
            { 'key': 'ru', 'label': 'Русский' },
            { 'key': 'zh-CN', 'label': '中文简体' },
            { 'key': 'cs', 'label': 'Čeština' },
            { 'key': 'da', 'label': 'Dansk' },
            { 'key': 'fi', 'label': 'Suomi' },
            { 'key': 'pl', 'label': 'Polski' },
            { 'key': 'sv', 'label': 'Svenska' },
            { 'key': 'ar', 'label': 'العربية', direction: 'rtl' }
        ]);
        this.languages$ = this.languages.asObservable();
        const customLanguages = appConfigService.get(AppConfigValues.APP_CONFIG_LANGUAGES_KEY);
        this.setLanguages(customLanguages);
    }
    changeLanguage(language) {
        this.userPreferencesService.locale = language.key;
        this.userPreferencesService.set('textOrientation', language.direction || 'ltr');
    }
    setLanguages(items) {
        if (items && items.length > 0) {
            this.languages.next(items);
        }
    }
}
LanguageService.ɵprov = ɵɵdefineInjectable({ factory: function LanguageService_Factory() { return new LanguageService(ɵɵinject(AppConfigService), ɵɵinject(UserPreferencesService)); }, token: LanguageService, providedIn: "root" });
LanguageService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
LanguageService.ctorParameters = () => [
    { type: AppConfigService },
    { type: UserPreferencesService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class LanguageMenuComponent {
    constructor(languageService) {
        this.languageService = languageService;
        this.languages$ = languageService.languages$;
    }
    changeLanguage(language) {
        this.languageService.changeLanguage(language);
    }
}
LanguageMenuComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-language-menu',
                template: `
        <button
            mat-menu-item
            *ngFor="let language of languages$ | async"
            (click)="changeLanguage(language)">{{language.label}}</button>
    `
            },] }
];
LanguageMenuComponent.ctorParameters = () => [
    { type: LanguageService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class LanguagePickerComponent {
}
LanguagePickerComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-picker-button',
                template: `
        <button mat-menu-item [matMenuTriggerFor]="langMenu">
            <mat-icon>language</mat-icon>
            {{ 'ADF.LANGUAGE' | translate }}
        </button>
        <mat-menu #langMenu="matMenu">
            <adf-language-menu></adf-language-menu>
        </mat-menu>
    `
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class LanguageMenuModule {
}
LanguageMenuModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    TranslateModule
                ],
                declarations: [
                    LanguageMenuComponent,
                    LanguagePickerComponent
                ],
                exports: [
                    LanguageMenuComponent,
                    LanguagePickerComponent
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class InfoDrawerLayoutComponent {
    constructor() {
        this.showHeader = true;
    }
}
InfoDrawerLayoutComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-info-drawer-layout',
                template: "<div *ngIf=\"showHeader\" class=\"adf-info-drawer-layout-header\">\n    <div class=\"adf-info-drawer-layout-header-title\">\n        <ng-content select=\"[info-drawer-title]\"></ng-content>\n    </div>\n    <div class=\"adf-info-drawer-layout-header-buttons\">\n        <ng-content select=\"[info-drawer-buttons]\"></ng-content>\n    </div>\n</div>\n<div class=\"adf-info-drawer-layout-content\">\n    <ng-content select=\"[info-drawer-content]\"></ng-content>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                host: { 'class': 'adf-info-drawer-layout' },
                styles: [".adf-info-drawer{overflow:hidden}.adf-info-drawer,.adf-info-drawer-layout{display:flex;flex:1;flex-direction:column;height:100%;min-height:0}.adf-info-drawer-layout{background-color:var(--theme-background-color);box-shadow:0 2px 4px 0 rgba(0,0,0,.27);overflow:hidden;overflow:auto;width:100%}.adf-info-drawer-layout .mat-tab-label{color:var(--theme-accent-color);font-weight:700;opacity:1;text-align:left;text-transform:uppercase}.adf-info-drawer-layout .mat-tab-label-active{color:var(--theme-primary-color)}.adf-info-drawer-layout-header{display:flex;justify-content:space-between;margin-bottom:40px;padding:13px 0 0 23px}.adf-info-drawer-layout-header-buttons{padding-right:18px}.adf-info-drawer-layout-header-buttons mat-icon{cursor:pointer}.adf-info-drawer-layout-header-title{color:var(--theme-text-color);font-size:20px;height:32px;letter-spacing:-.5px;line-height:1.6;text-align:left;width:197px}.adf-info-drawer-layout-header-title>div{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.adf-info-drawer-layout-content{padding:10px}.adf-info-drawer-layout-content>*{display:block;margin-bottom:20px}.adf-info-drawer-layout-content>:last-child{margin-bottom:0}.adf-info-drawer-layout-content .adf-info-drawer-tabs .mat-tab-body-content .adf-manage-versions-empty,.adf-info-drawer-layout-content .adf-info-drawer-tabs .mat-tab-body-content .adf-manage-versions-no-permission{color:var(--theme-text-color);display:flex;flex-direction:column;margin:0;padding:24px;text-align:center}.adf-info-drawer-layout-content .adf-info-drawer-tabs .mat-tab-body-content .adf-manage-versions-empty-icon,.adf-info-drawer-layout-content .adf-info-drawer-tabs .mat-tab-body-content .adf-manage-versions-no-permission-icon{display:block;font-size:48px;height:48px;margin:0 auto 24px;width:48px}"]
            },] }
];
InfoDrawerLayoutComponent.propDecorators = {
    showHeader: [{ type: Input }]
};
class InfoDrawerTitleDirective {
}
InfoDrawerTitleDirective.decorators = [
    { type: Directive, args: [{ selector: '[adf-info-drawer-title], [info-drawer-title]' },] }
];
class InfoDrawerButtonsDirective {
}
InfoDrawerButtonsDirective.decorators = [
    { type: Directive, args: [{ selector: '[adf-info-drawer-buttons], [info-drawer-buttons]' },] }
];
class InfoDrawerContentDirective {
}
InfoDrawerContentDirective.decorators = [
    { type: Directive, args: [{ selector: '[adf-info-drawer-content], [info-drawer-content]' },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class InfoDrawerTabComponent {
    constructor() {
        this.label = '';
        this.icon = null;
    }
}
InfoDrawerTabComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-info-drawer-tab',
                template: '<ng-template><ng-content></ng-content></ng-template>',
                encapsulation: ViewEncapsulation.None
            },] }
];
InfoDrawerTabComponent.propDecorators = {
    label: [{ type: Input }],
    icon: [{ type: Input }],
    content: [{ type: ViewChild, args: [TemplateRef, { static: true },] }]
};
class InfoDrawerComponent {
    constructor() {
        this.title = null;
        this.selectedIndex = 0;
        this.showHeader = true;
        this.currentTab = new EventEmitter();
    }
    onKeyDown(event) {
        event.cancelBubble = true;
    }
    onKeyUp(event) {
        event.cancelBubble = true;
    }
    showTabLayout() {
        return this.contentBlocks.length > 0;
    }
    onTabChange(event) {
        this.currentTab.emit(event.index);
    }
}
InfoDrawerComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-info-drawer',
                template: "<adf-info-drawer-layout [showHeader]=\"showHeader\">\n    <div role=\"heading\" aria-level=\"1\" *ngIf=\"title\" info-drawer-title>{{ title | translate }}</div>\n    <ng-content *ngIf=\"!title\" info-drawer-title select=\"[info-drawer-title]\"></ng-content>\n\n    <ng-content info-drawer-buttons select=\"[info-drawer-buttons]\"></ng-content>\n\n    <ng-container info-drawer-content *ngIf=\"showTabLayout(); then tabLayout else singleLayout\"></ng-container>\n\n    <ng-template #tabLayout>\n        <mat-tab-group [(selectedIndex)]=\"selectedIndex\" class=\"adf-info-drawer-tabs\" (selectedTabChange)=\"onTabChange($event)\">\n            <mat-tab *ngFor=\"let contentBlock of contentBlocks\"\n                [label]=\"contentBlock.label | translate\"\n                class=\"adf-info-drawer-tab\">\n\n                <ng-template mat-tab-label>\n                    <mat-icon *ngIf=\"contentBlock.icon\">{{ contentBlock.icon }}</mat-icon>\n                    <span *ngIf=\"contentBlock.label\">{{ contentBlock.label | translate }}</span>\n                </ng-template>\n\n                <ng-container *ngTemplateOutlet=\"contentBlock.content\"></ng-container>\n            </mat-tab>\n        </mat-tab-group>\n    </ng-template>\n\n    <ng-template #singleLayout>\n        <ng-content select=\"[info-drawer-content]\"></ng-content>\n    </ng-template>\n</adf-info-drawer-layout>\n",
                encapsulation: ViewEncapsulation.None,
                host: { 'class': 'adf-info-drawer' },
                styles: [".adf-info-drawer{display:block}.adf-info-drawer .mat-tab-label{min-width:0}.adf-info-drawer .adf-info-drawer-layout-content{padding:0}.adf-info-drawer .adf-info-drawer-layout-content>:not(.adf-info-drawer-tabs){padding:10px}.adf-info-drawer .adf-info-drawer-layout-content>:not(.adf-info-drawer-tabs)>*{display:block;margin-bottom:20px}.adf-info-drawer .adf-info-drawer-layout-content .adf-info-drawer-tabs .mat-tab-body-content>*{display:block;margin-bottom:20px}.adf-info-drawer .adf-info-drawer-layout-content .adf-info-drawer-tabs .mat-tab-body-content>:last-child{margin-bottom:0}.adf-info-drawer .adf-info-drawer-layout-content .adf-info-drawer-tabs .mat-tab-label{flex-grow:1}.adf-info-drawer .adf-info-drawer-layout-content .adf-info-drawer-tabs .mat-tab-label .mat-icon+span{padding-left:5px}.adf-info-drawer .adf-info-drawer-layout-content .adf-info-drawer-tabs .mat-ink-bar{height:4px}.adf-info-drawer .adf-info-drawer-layout-content .adf-info-drawer-tabs .mat-tab-body{padding:10px}.adf-info-drawer .adf-info-drawer-layout-content .adf-info-drawer-tabs .mat-tab-body-content{overflow:initial}"]
            },] }
];
InfoDrawerComponent.propDecorators = {
    title: [{ type: Input }],
    selectedIndex: [{ type: Input }],
    showHeader: [{ type: Input }],
    currentTab: [{ type: Output }],
    contentBlocks: [{ type: ContentChildren, args: [InfoDrawerTabComponent,] }],
    onKeyDown: [{ type: HostListener, args: ['keydown', ['$event'],] }],
    onKeyUp: [{ type: HostListener, args: ['keyup', ['$event'],] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class InfoDrawerModule {
}
InfoDrawerModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    TranslateModule
                ],
                declarations: [
                    InfoDrawerLayoutComponent,
                    InfoDrawerTabComponent,
                    InfoDrawerComponent,
                    InfoDrawerTitleDirective,
                    InfoDrawerButtonsDirective,
                    InfoDrawerContentDirective
                ],
                exports: [
                    InfoDrawerLayoutComponent,
                    InfoDrawerTabComponent,
                    InfoDrawerComponent,
                    InfoDrawerTitleDirective,
                    InfoDrawerButtonsDirective,
                    InfoDrawerContentDirective
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DataTableSchema {
    constructor(appConfigService, presetKey, presetsModel) {
        this.appConfigService = appConfigService;
        this.presetKey = presetKey;
        this.presetsModel = presetsModel;
        this.layoutPresets = {};
    }
    createDatatableSchema() {
        this.loadLayoutPresets();
        if (!this.columns || this.columns.length === 0) {
            this.columns = this.mergeJsonAndHtmlSchema();
        }
    }
    loadLayoutPresets() {
        const externalSettings = this.appConfigService.get(this.presetKey, null);
        if (externalSettings) {
            this.layoutPresets = Object.assign({}, this.presetsModel, externalSettings);
        }
        else {
            this.layoutPresets = this.presetsModel;
        }
    }
    mergeJsonAndHtmlSchema() {
        let customSchemaColumns = this.getSchemaFromConfig(this.presetColumn).concat(this.getSchemaFromHtml(this.columnList));
        if (customSchemaColumns.length === 0) {
            customSchemaColumns = this.getDefaultLayoutPreset();
        }
        return customSchemaColumns;
    }
    getSchemaFromHtml(columnList) {
        let schema = [];
        if (columnList && columnList.columns && columnList.columns.length > 0) {
            schema = columnList.columns.map((c) => c);
        }
        return schema;
    }
    getSchemaFromConfig(presetColumn) {
        return presetColumn ? (this.layoutPresets[presetColumn]).map((col) => new ObjectDataColumn(col)) : [];
    }
    getDefaultLayoutPreset() {
        return (this.layoutPresets['default']).map((col) => new ObjectDataColumn(col));
    }
    setPresetKey(presetKey) {
        this.presetKey = presetKey;
    }
    setPresetsModel(presetsModel) {
        this.presetsModel = presetsModel;
    }
}
DataTableSchema.decorators = [
    { type: Directive }
];
DataTableSchema.ctorParameters = () => [
    { type: AppConfigService },
    { type: String },
    { type: undefined }
];
DataTableSchema.propDecorators = {
    columnList: [{ type: ContentChild, args: [DataColumnListComponent,] }],
    presetColumn: [{ type: Input }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

function transformKeyToObject(key, value) {
    const objectLevels = key.split('.').reverse();
    return objectLevels.reduce((previousValue, currentValue) => {
        return { [currentValue]: previousValue };
    }, value);
}
class CardViewUpdateService {
    constructor() {
        this.itemUpdated$ = new Subject();
        this.itemClicked$ = new Subject();
        this.updateItem$ = new Subject();
        this.updatedAspect$ = new Subject();
    }
    update(property, newValue) {
        this.itemUpdated$.next({
            target: property,
            changed: transformKeyToObject(property.key, newValue)
        });
    }
    clicked(property) {
        this.itemClicked$.next({
            target: property
        });
    }
    updateElement(notification) {
        this.updateItem$.next(notification);
    }
    updateNodeAspect(node) {
        this.updatedAspect$.next(node);
    }
}
CardViewUpdateService.ɵprov = ɵɵdefineInjectable({ factory: function CardViewUpdateService_Factory() { return new CardViewUpdateService(); }, token: CardViewUpdateService, providedIn: "root" });
CardViewUpdateService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class BaseCardView {
    constructor(cardViewUpdateService) {
        this.cardViewUpdateService = cardViewUpdateService;
        this.destroy$ = new Subject();
        this.cardViewUpdateService.updateItem$
            .pipe(takeUntil(this.destroy$))
            .subscribe((itemModel) => {
            if (this.property.key === itemModel.key) {
                this.property.value = itemModel.value;
            }
        });
    }
    ngOnDestroy() {
        this.destroy$.next(true);
        this.destroy$.complete();
    }
}
BaseCardView.decorators = [
    { type: Directive }
];
BaseCardView.ctorParameters = () => [
    { type: CardViewUpdateService }
];
BaseCardView.propDecorators = {
    property: [{ type: Input }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DEFAULT_SEPARATOR = ', ';
const templateTypes = {
    clickableTemplate: 'clickableTemplate',
    multilineTemplate: 'multilineTemplate',
    chipsTemplate: 'chipsTemplate',
    emptyTemplate: 'emptyTemplate',
    defaultTemplate: 'defaultTemplate'
};
class CardViewTextItemComponent extends BaseCardView {
    constructor(cardViewUpdateService, clipboardService, translateService, cd) {
        super(cardViewUpdateService);
        this.clipboardService = clipboardService;
        this.translateService = translateService;
        this.cd = cd;
        this.editable = false;
        this.displayEmpty = true;
        this.copyToClipboardAction = true;
        this.useChipsForMultiValueProperty = true;
        this.multiValueSeparator = DEFAULT_SEPARATOR;
        this.textInput = new FormControl();
        this.onDestroy$ = new Subject();
    }
    ngOnChanges(changes) {
        if (changes.property && changes.property.firstChange) {
            this.textInput.valueChanges
                .pipe(filter(textInputValue => textInputValue !== this.editedValue && textInputValue !== null), debounceTime(50), takeUntil(this.onDestroy$))
                .subscribe(textInputValue => {
                this.editedValue = textInputValue;
                this.update();
            });
        }
        this.resetValue();
        this.setTemplateType();
        if (changes.editable) {
            this.isEditable ? this.textInput.enable() : this.textInput.disable();
        }
    }
    setTemplateType() {
        if (this.showProperty || this.isEditable) {
            if (this.isClickable) {
                this.templateType = templateTypes.clickableTemplate;
            }
            else if (this.isChipViewEnabled) {
                this.templateType = templateTypes.chipsTemplate;
            }
            else {
                this.templateType = templateTypes.defaultTemplate;
            }
        }
        else {
            this.templateType = templateTypes.emptyTemplate;
        }
    }
    resetValue() {
        if (this.isChipViewEnabled) {
            this.editedValue = this.property.value ? Array.from(this.property.value) : [];
        }
        else {
            this.editedValue = this.property.displayValue;
            this.textInput.setValue(this.editedValue);
        }
        this.resetErrorMessages();
    }
    resetErrorMessages() {
        this.errors = [];
    }
    update() {
        if (this.property.isValid(this.editedValue)) {
            this.property.value = this.prepareValueForUpload(this.property, this.editedValue);
            this.cardViewUpdateService.update(Object.assign({}, this.property), this.property.value);
            this.resetErrorMessages();
        }
        else {
            this.errors = this.property.getValidationErrors(this.editedValue);
        }
    }
    prepareValueForUpload(property, value) {
        if (property.multivalued && typeof value === 'string') {
            const listOfValues = value.split(this.multiValueSeparator.trim()).map((item) => item.trim());
            return listOfValues;
        }
        return value;
    }
    removeValueFromList(itemIndex) {
        if (Array.isArray(this.editedValue)) {
            this.editedValue.splice(itemIndex, 1);
            this.update();
            this.cd.detectChanges();
        }
    }
    addValueToList(newListItem) {
        const chipInput = newListItem.input;
        const chipValue = newListItem.value.trim() || '';
        if (typeof this.editedValue !== 'string') {
            if (chipValue) {
                this.editedValue.push(chipValue);
                this.update();
            }
            if (chipInput) {
                chipInput.value = '';
            }
        }
    }
    clicked() {
        if (typeof this.property.clickCallBack === 'function') {
            this.property.clickCallBack();
        }
        else {
            this.cardViewUpdateService.clicked(this.property);
        }
    }
    clearValue() {
        this.editedValue = '';
        this.textInput.setValue('');
        this.update();
    }
    copyToClipboard(valueToCopy) {
        if (this.copyToClipboard) {
            const clipboardMessage = this.translateService.instant('CORE.METADATA.ACCESSIBILITY.COPY_TO_CLIPBOARD_MESSAGE');
            this.clipboardService.copyContentToClipboard(valueToCopy, clipboardMessage);
        }
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
    get showProperty() {
        return this.displayEmpty || !this.property.isEmpty();
    }
    get showClickableIcon() {
        return this.hasIcon && this.editable;
    }
    get isEditable() {
        return this.editable && this.property.editable;
    }
    get isClickable() {
        return this.property.clickable;
    }
    get hasIcon() {
        return !!this.property.icon;
    }
    get hasErrors() {
        var _a, _b;
        return (_b = (!!((_a = this.errors) === null || _a === void 0 ? void 0 : _a.length))) !== null && _b !== void 0 ? _b : false;
    }
    get isChipViewEnabled() {
        return this.property.multivalued && this.useChipsForMultiValueProperty;
    }
}
CardViewTextItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-card-view-textitem',
                template: "<div [ngSwitch]=\"templateType\">\n    <div class=\"adf-property-label\"\n         [attr.data-automation-id]=\"'card-textitem-label-' + property.key\"\n         *ngIf=\"showProperty || isEditable\">\n        {{ property.label | translate }}\n    </div>\n\n    <div *ngSwitchDefault>\n        <mat-form-field class=\"adf-property-field adf-card-textitem-field\"\n                        [ngClass]=\"{ 'adf-property-read-only': !isEditable }\"\n                        [floatLabel]=\"'never'\">\n            <input matInput\n                   *ngIf=\"!property.multiline\"\n                   class=\"adf-property-value\"\n                   [placeholder]=\"property.default\"\n                   [formControl]=\"textInput\"\n                   (dblclick)=\"copyToClipboard(property.displayValue)\"\n                   matTooltipShowDelay=\"1000\"\n                   [matTooltip]=\"'CORE.METADATA.ACTIONS.COPY_TO_CLIPBOARD' | translate\"\n                   [matTooltipDisabled]=\"isEditable\"\n                   [attr.data-automation-id]=\"'card-textitem-value-' + property.key\">\n            <textarea matInput\n                      *ngIf=\"property.multiline\"\n                      [matTextareaAutosize]=\"true\"\n                      [matAutosizeMaxRows]=\"1\"\n                      [matAutosizeMaxRows]=\"5\"\n                      class=\"adf-property-value\"\n                      [placeholder]=\"property.default\"\n                      [formControl]=\"textInput\"\n                      [attr.data-automation-id]=\"'card-textitem-value-' + property.key\"></textarea>\n            <button mat-button\n                    matSuffix\n                    class=\"adf-property-clear-value\"\n                    *ngIf=\"isEditable\"\n                    mat-icon-button\n                    aria-label=\"Clear\"\n                    (click)=\"clearValue()\">\n                <mat-icon>cancel</mat-icon>\n            </button>\n            <mat-icon matSuffix\n                      *ngIf=\"isEditable\"\n                      [attr.title]=\"'CORE.METADATA.ACTIONS.EDIT' | translate\"\n                      class=\"adf-textitem-edit-icon\">mode_edit</mat-icon>\n\n        </mat-form-field>\n    </div>\n\n    <mat-error [attr.data-automation-id]=\"'card-textitem-error-' + property.key\"\n               class=\"adf-textitem-editable-error\"\n               *ngIf=\"isEditable && hasErrors\">\n        <ul>\n            <li *ngFor=\"let error of errors\">{{ error.message | translate: error }}</li>\n        </ul>\n    </mat-error>\n\n    <div *ngSwitchCase=\"'chipsTemplate'\"\n         class=\"adf-property-field adf-textitem-chip-list-container\">\n        <mat-chip-list #chipList\n                       class=\"adf-textitem-chip-list\">\n            <mat-chip *ngFor=\"let propertyValue of editedValue; let idx = index\"\n                      [removable]=\"isEditable\"\n                      (removed)=\"removeValueFromList(idx)\">\n                {{ propertyValue }}\n                <mat-icon *ngIf=\"isEditable\"\n                          matChipRemove>cancel</mat-icon>\n            </mat-chip>\n        </mat-chip-list>\n\n        <mat-form-field *ngIf=\"isEditable\"\n                        class=\"adf-property-field adf-textitem-chip-list-input\"\n                        [ngClass]=\"{ 'adf-property-read-only': !isEditable }\"\n                        [floatLabel]=\"'never'\">\n            <input matInput\n                   class=\"adf-property-value\"\n                   [placeholder]=\"editedValue ? '' : property.default | translate\"\n                   [matChipInputFor]=\"chipList\"\n                   [matChipInputAddOnBlur]=\"true\"\n                   (matChipInputTokenEnd)=\"addValueToList($event)\"\n                   [attr.data-automation-id]=\"'card-textitem-editchipinput-' + property.key\">\n            <mat-icon matSuffix\n                      class=\"adf-textitem-edit-icon\">mode_edit</mat-icon>\n        </mat-form-field>\n    </div>\n\n    <div *ngSwitchCase=\"'clickableTemplate'\"\n         role=\"button\"\n         class=\"adf-textitem-clickable\"\n         [ngClass]=\"{ 'adf-property-read-only': !isEditable }\"\n         [attr.data-automation-id]=\"'card-textitem-toggle-' + property.key\"\n         (click)=\"clicked()\"\n         fxLayout=\"row\"\n         fxLayoutAlign=\"space-between center\">\n        <mat-form-field class=\"adf-property-field adf-card-textitem-field\"\n                        [floatLabel]=\"'never'\">\n            <input matInput\n                   [type]=property.inputType\n                   class=\"adf-property-value\"\n                   [ngClass]=\"{ 'adf-textitem-clickable-value': !isEditable }\"\n                   [placeholder]=\"property.default\"\n                   [(ngModel)]=\"editedValue\"\n                   (blur)=\"update()\"\n                   (keydown.enter)=\"update()\"\n                   [disabled]=\"!isEditable\"\n                   [attr.data-automation-id]=\"'card-textitem-value-' + property.key\">\n            <button mat-icon-button\n                    matSuffix\n                    fxFlex=\"0 0 auto\"\n                    *ngIf=\"showClickableIcon\"\n                    class=\"adf-textitem-action\"\n                    [attr.title]=\"'CORE.METADATA.ACTIONS.EDIT' | translate\"\n                    [attr.data-automation-id]=\"'card-textitem-clickable-icon-' + property.key\">\n                <mat-icon class=\"adf-textitem-icon\">{{ property?.icon }}</mat-icon>\n            </button>\n        </mat-form-field>\n\n    </div>\n\n    <div *ngSwitchCase=\"'emptyTemplate'\">\n        <span class=\"adf-textitem-default-value\">{{ property.default | translate }}</span>\n    </div>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-textitem-edit-icon.mat-icon{color:var(--adf-card-view-text-color);font-size:16px;height:16px;width:16px}.adf-textitem-action.mat-icon-button{color:var(--adf-card-view-text-color);height:20px;line-height:20px;width:20px}.adf-textitem-action:focus,.adf-textitem-action:hover{color:var(--theme-text-fg-color)}.adf-update-icon{padding-left:13px}.adf-textitem-readonly{cursor:pointer!important}.adf-textitem-readonly:focus .adf-textitem-action,.adf-textitem-readonly:hover .adf-textitem-action{color:var(--theme-text-fg-color)}.adf-textitem-chip-list-container{margin-bottom:25px!important;margin-top:6px}.adf-textitem-chip-list-container .mat-form-field-label{margin-top:6px}.adf-textitem-clickable{cursor:pointer!important;padding-top:3px}.adf-textitem-clickable .adf-textitem-edit-icon.mat-icon{line-height:16px}.adf-textitem-clickable:hover .adf-textitem-action{color:var(--theme-text-fg-color)}.adf-textitem-clickable-value{color:var(--theme-primary-color)!important;cursor:pointer!important}.adf-textitem-editable-controls{align-items:center;display:flex}.adf-textitem-editable-controls mat-icon:not(.adf-button-disabled):hover{color:var(--theme-text-fg-color);cursor:pointer!important}.adf-textitem-editable-controls mat-form-field{width:100%}.adf-textitem-editable-controls input:focus,.adf-textitem-editable-controls textarea:focus{border:1px solid var(--theme-accent-color-a200)}.adf-textitem-editable-error{font-size:12px;padding-top:4px}.adf-textitem-editable-error ul{list-style-type:none;margin:0;padding:0}.adf-textitem-editable-error ul li{margin:0;padding:0}.adf-textitem-default-value{color:var(--theme-text-color)}.adf-textitem-editable .mat-form-field-wrapper{margin:0;padding-bottom:0}.adf-textitem-editable .mat-form-field-underline{display:none}.adf-textitem-editable .mat-form-field-infix{border-top:none;padding:0}.adf-textitem-editable .mat-form-field-label-wrapper{padding-top:2em;position:static}.adf-textitem-editable .mat-form-field-label{top:4px}.adf-textitem-editable .mat-input-element{font-family:inherit;padding-top:6px;position:relative}.adf-textitem-editable .mat-input-element:focus{left:-6px;padding:5px;top:0}.adf-textitem-editable input.mat-input-element{margin-bottom:2px}.adf-textitem-editable input.mat-input-element:focus{margin-bottom:-8px}.adf-textitem-scroll{display:block;overflow-x:auto;white-space:nowrap}.adf-textitem-scroll::-webkit-scrollbar{height:5px}.adf-textitem-scroll:hover::-webkit-scrollbar-thumb{background-color:var(--adf-card-view-text-color);border-radius:2px;display:block}.adf-textitem-multiline{display:block}.adf-property-field .adf-property-clear-value{display:none}.adf-property-field.adf-card-textitem-field:hover .adf-textitem-edit-icon{display:none}.adf-property-field.adf-card-textitem-field:hover .adf-property-clear-value{color:var(--adf-card-view-text-color);display:inline}.adf-property-field.adf-card-textitem-field:hover .adf-property-clear-value:hover{color:var(--theme-text-fg-color)}"]
            },] }
];
CardViewTextItemComponent.ctorParameters = () => [
    { type: CardViewUpdateService },
    { type: ClipboardService },
    { type: TranslationService },
    { type: ChangeDetectorRef }
];
CardViewTextItemComponent.propDecorators = {
    editable: [{ type: Input }],
    displayEmpty: [{ type: Input }],
    copyToClipboardAction: [{ type: Input }],
    useChipsForMultiValueProperty: [{ type: Input }],
    multiValueSeparator: [{ type: Input }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CardViewComponent {
    constructor() {
        this.displayEmpty = true;
        this.displayNoneOption = true;
        this.displayClearAction = true;
        this.copyToClipboardAction = true;
        this.useChipsForMultiValueProperty = true;
        this.multiValueSeparator = DEFAULT_SEPARATOR;
    }
}
CardViewComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-card-view',
                template: "<div class=\"adf-property-list\">\n    <div *ngFor=\"let property of properties\">\n        <div [attr.data-automation-id]=\"'header-'+property.key\" class=\"adf-property\">\n            <adf-card-view-item-dispatcher\n                [property]=\"property\"\n                [editable]=\"editable\"\n                [displayEmpty]=\"displayEmpty\"\n                [displayNoneOption]=\"property['displayNoneOption'] !== undefined ? property['displayNoneOption'] : displayNoneOption\"\n                [displayClearAction]=\"displayClearAction\"\n                [copyToClipboardAction]=\"copyToClipboardAction\"\n                [useChipsForMultiValueProperty]=\"useChipsForMultiValueProperty\"\n                [multiValueSeparator]=\"multiValueSeparator\">\n            </adf-card-view-item-dispatcher>\n        </div>\n    </div>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-property-list .adf-property{margin-bottom:20px}.adf-property-list .adf-property .adf-property-value-padding-top{margin-top:6px}.adf-property-list .adf-property .adf-property-field{margin-bottom:-25px;width:100%}.adf-property-list .adf-property .adf-property-field .mat-form-field-infix{border-top-width:0}.adf-property-list .adf-property .adf-property-field .mat-form-field-label{margin-top:6px}.adf-property-list .adf-property .adf-property-field .adf-property-read-only .mat-form-field-underline,.adf-property-list .adf-property .adf-property-read-only .mat-form-field-underline{display:none}.adf-property-list .adf-property .adf-property-label{color:var(--theme-text-color);font-size:12px;word-wrap:break-word}.adf-property-list .adf-property .adf-property-value,.adf-property-list .adf-property .mat-form-field-label{color:var(--theme-text-bold-color);font-size:14px}"]
            },] }
];
CardViewComponent.propDecorators = {
    properties: [{ type: Input }],
    editable: [{ type: Input }],
    displayEmpty: [{ type: Input }],
    displayNoneOption: [{ type: Input }],
    displayClearAction: [{ type: Input }],
    copyToClipboardAction: [{ type: Input }],
    useChipsForMultiValueProperty: [{ type: Input }],
    multiValueSeparator: [{ type: Input }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CardViewBoolItemComponent extends BaseCardView {
    constructor(cardViewUpdateService) {
        super(cardViewUpdateService);
    }
    isEditable() {
        return this.editable && this.property.editable;
    }
    changed(change) {
        this.cardViewUpdateService.update(Object.assign({}, this.property), change.checked);
        this.property.value = change.checked;
    }
}
CardViewBoolItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-card-view-boolitem',
                template: "<ng-container *ngIf=\"!property.isEmpty() || isEditable()\">\n    <div class=\"adf-property-value\">\n        <mat-checkbox [attr.data-automation-id]=\"'card-boolean-' + property.key\"\n                      [attr.title]=\"'CORE.METADATA.ACTIONS.TOGGLE' | translate\"\n                      [checked]=\"property.displayValue\"\n                      [disabled]=\"!isEditable()\"\n                      color=\"primary\"\n                      (change)=\"changed($event)\">\n            <div [attr.data-automation-id]=\"'card-boolean-label-' + property.key\"\n                 class=\"adf-property-label\">{{ property.label | translate }}</div>\n        </mat-checkbox>\n    </div>\n</ng-container>\n"
            },] }
];
CardViewBoolItemComponent.ctorParameters = () => [
    { type: CardViewUpdateService }
];
CardViewBoolItemComponent.propDecorators = {
    editable: [{ type: Input }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CardViewItemMatchValidator {
    constructor(expression, flags) {
        this.expression = expression;
        this.flags = flags;
        this.message = 'CORE.CARDVIEW.VALIDATORS.MATCH_VALIDATION_ERROR';
    }
    isValid(value) {
        const regex = new RegExp(this.expression, this.flags);
        return value === '' || regex.test(value);
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CardViewItemIntValidator {
    constructor() {
        this.message = 'CORE.CARDVIEW.VALIDATORS.INT_VALIDATION_ERROR';
    }
    isValid(value) {
        if (Array.isArray(value)) {
            return value.every(this.isIntegerNumber);
        }
        return value === '' || !isNaN(value) && this.isIntegerNumber(value);
    }
    isIntegerNumber(value) {
        const parsedNumber = Number(value);
        return (parsedNumber | 0) === parsedNumber;
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CardViewItemMinMaxValidator {
    constructor(minValue, maxValue) {
        this.minValue = minValue;
        this.maxValue = maxValue;
        this.message = 'CORE.CARDVIEW.VALIDATORS.MINMAX_VALIDATION_ERROR';
        this.intValidator = new CardViewItemIntValidator();
    }
    isValid(value) {
        return this.intValidator.isValid(value) && (value >= this.minValue && value <= this.maxValue);
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CardViewItemLengthValidator {
    constructor(minLength, maxLength) {
        this.minLength = minLength;
        this.maxLength = maxLength;
        this.message = 'CORE.CARDVIEW.VALIDATORS.LENGTH_VALIDATION_ERROR';
    }
    isValid(value = '') {
        const stringLength = value.length;
        return stringLength >= this.minLength && stringLength <= this.maxLength;
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ɵ0 = (parameters) => new CardViewItemMinMaxValidator(parameters.minValue, parameters.maxValue), ɵ1 = (parameters) => new CardViewItemMatchValidator(parameters.expression), ɵ2 = (parameters) => new CardViewItemLengthValidator(parameters.minLength, parameters.maxLength);
const validators = {
    minmax: ɵ0,
    regex: ɵ1,
    length: ɵ2
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CardViewBaseItemModel {
    constructor(cardViewItemProperties) {
        var _a, _b;
        this.label = cardViewItemProperties.label || '';
        this.value = cardViewItemProperties.value && cardViewItemProperties.value.displayName || cardViewItemProperties.value;
        this.key = cardViewItemProperties.key;
        this.default = cardViewItemProperties.default;
        this.editable = !!cardViewItemProperties.editable;
        this.clickable = !!cardViewItemProperties.clickable;
        this.icon = cardViewItemProperties.icon || '';
        this.hint = cardViewItemProperties.hint || '';
        this.validators = cardViewItemProperties.validators || [];
        this.data = cardViewItemProperties.data || null;
        this.multivalued = !!cardViewItemProperties.multivalued;
        if ((_b = (_a = cardViewItemProperties === null || cardViewItemProperties === void 0 ? void 0 : cardViewItemProperties.constraints) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0) {
            for (const constraint of cardViewItemProperties.constraints) {
                if (constraint.type !== 'LIST') {
                    this.validators.push(validators[constraint.type.toLowerCase()](constraint.parameters));
                }
            }
        }
    }
    isEmpty() {
        return this.value === undefined || this.value === null || this.value.length === 0;
    }
    isValid(newValue) {
        if (!this.validators.length) {
            return true;
        }
        return this.validators
            .map((validator) => validator.isValid(newValue))
            .reduce((isValidUntilNow, isValid) => isValidUntilNow && isValid, true);
    }
    getValidationErrors(value) {
        if (!this.validators.length) {
            return [];
        }
        return this.validators.filter((validator) => !validator.isValid(value)).map((validator) => validator);
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CardViewDateItemModel extends CardViewBaseItemModel {
    constructor(cardViewDateItemProperties) {
        super(cardViewDateItemProperties);
        this.type = 'date';
        if (cardViewDateItemProperties.format) {
            this.format = cardViewDateItemProperties.format;
        }
        if (cardViewDateItemProperties.locale) {
            this.locale = cardViewDateItemProperties.locale;
        }
    }
    get displayValue() {
        if (this.multivalued) {
            if (this.value) {
                return this.value.map((date) => this.transformDate(date));
            }
            else {
                return this.default ? [this.default] : [];
            }
        }
        else {
            return this.value ? this.transformDate(this.value) : this.default;
        }
    }
    transformDate(value) {
        this.localizedDatePipe = new LocalizedDatePipe();
        return this.localizedDatePipe.transform(value, this.format, this.locale);
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ɵ0$1 = MOMENT_DATE_FORMATS, ɵ1$1 = MAT_MOMENT_DATETIME_FORMATS;
class CardViewDateItemComponent extends BaseCardView {
    constructor(cardViewUpdateService, dateAdapter, userPreferencesService, appConfig, clipboardService, translateService) {
        super(cardViewUpdateService);
        this.dateAdapter = dateAdapter;
        this.userPreferencesService = userPreferencesService;
        this.appConfig = appConfig;
        this.clipboardService = clipboardService;
        this.translateService = translateService;
        this.editable = false;
        this.displayEmpty = true;
        this.displayClearAction = true;
        this.onDestroy$ = new Subject();
        this.dateFormat = this.appConfig.get('dateValues.defaultDateFormat');
    }
    ngOnInit() {
        this.userPreferencesService
            .select(UserPreferenceValues.Locale)
            .pipe(takeUntil(this.onDestroy$))
            .subscribe(locale => {
            this.dateAdapter.setLocale(locale);
            this.property.locale = locale;
        });
        this.dateAdapter.overrideDisplayFormat = 'MMM DD';
        if (this.property.value) {
            this.valueDate = moment(this.property.value, this.dateFormat);
        }
        else if (this.property.multivalued && !this.property.value) {
            this.property.value = [];
        }
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
    showProperty() {
        return this.displayEmpty || !this.property.isEmpty();
    }
    showClearAction() {
        return this.displayClearAction && (!this.property.isEmpty() || !!this.property.default);
    }
    isEditable() {
        return this.editable && this.property.editable;
    }
    showDatePicker() {
        this.datepicker.open();
    }
    onDateChanged(newDateValue) {
        if (newDateValue) {
            const momentDate = moment(newDateValue.value, this.dateFormat, true);
            if (momentDate.isValid()) {
                this.valueDate = momentDate;
                this.property.value = momentDate.toDate();
                this.update();
            }
        }
    }
    onDateClear() {
        this.valueDate = null;
        this.cardViewUpdateService.update(Object.assign({}, this.property), null);
        this.property.value = null;
        this.property.default = null;
    }
    copyToClipboard(valueToCopy) {
        const clipboardMessage = this.translateService.instant('CORE.METADATA.ACCESSIBILITY.COPY_TO_CLIPBOARD_MESSAGE');
        this.clipboardService.copyContentToClipboard(valueToCopy, clipboardMessage);
    }
    addDateToList(newDateValue) {
        if (newDateValue) {
            const momentDate = moment(newDateValue.value, this.dateFormat, true);
            if (momentDate.isValid()) {
                this.property.value.push(momentDate.toDate());
                this.update();
            }
        }
    }
    removeValueFromList(itemIndex) {
        this.property.value.splice(itemIndex, 1);
        this.update();
    }
    update() {
        this.cardViewUpdateService.update(Object.assign({}, this.property), this.property.value);
    }
}
CardViewDateItemComponent.decorators = [
    { type: Component, args: [{
                providers: [
                    { provide: DateAdapter, useClass: MomentDateAdapter },
                    { provide: MAT_DATE_FORMATS, useValue: ɵ0$1 },
                    { provide: DatetimeAdapter, useClass: MomentDatetimeAdapter },
                    { provide: MAT_DATETIME_FORMATS, useValue: ɵ1$1 }
                ],
                selector: 'adf-card-view-dateitem',
                template: "<div class=\"adf-property-label\"\n     [attr.data-automation-id]=\"'card-dateitem-label-' + property.key\"\n     *ngIf=\"showProperty() || isEditable()\">\n    {{ property.label | translate }}\n</div>\n\n<div class=\"adf-property-value adf-property-value-padding-top\">\n    <span *ngIf=\"!isEditable() && !property.multivalued\"\n          [attr.data-automation-id]=\"'card-' + property.type + '-value-' + property.key\">\n        <span *ngIf=\"showProperty()\"\n              [attr.data-automation-id]=\"'card-dateitem-' + property.key\"\n              (dblclick)=\"copyToClipboard(property.displayValue)\"\n              matTooltipShowDelay=\"1000\"\n              [matTooltip]=\"'CORE.METADATA.ACTIONS.COPY_TO_CLIPBOARD' | translate\">{{ property.displayValue}}</span>\n    </span>\n    <div *ngIf=\"isEditable() && !property.multivalued\"\n         class=\"adf-dateitem-editable\">\n        <div class=\"adf-dateitem-editable-controls\">\n            <span class=\"adf-datepicker-toggle\"\n                  [attr.data-automation-id]=\"'datepicker-label-toggle-' + property.key\"\n                  (click)=\"showDatePicker()\">\n                <span *ngIf=\"showProperty(); else elseEmptyValueBlock\"\n                      [attr.data-automation-id]=\"'card-' + property.type + '-value-' + property.key\">\n                    {{ property.displayValue }}</span>\n            </span>\n\n            <mat-icon *ngIf=\"showClearAction()\"\n                      class=\"adf-date-reset-icon\"\n                      (click)=\"onDateClear()\"\n                      [attr.title]=\"'CORE.METADATA.ACTIONS.CLEAR' | translate\"\n                      [attr.data-automation-id]=\"'datepicker-date-clear-' + property.key\">\n                clear\n            </mat-icon>\n\n            <mat-datetimepicker-toggle [attr.tabindex]=\"-1\"\n                                       [attr.title]=\"'CORE.METADATA.ACTIONS.EDIT' | translate\"\n                                       [attr.data-automation-id]=\"'datepickertoggle-' + property.key\"\n                                       [for]=\"datetimePicker\">\n            </mat-datetimepicker-toggle>\n        </div>\n\n        <input class=\"adf-invisible-date-input\"\n               [attr.tabIndex]=\"-1\"\n               [matDatetimepicker]=\"datetimePicker\"\n               [value]=\"valueDate\"\n               (dateChange)=\"onDateChanged($event)\">\n\n        <mat-datetimepicker #datetimePicker\n                            [type]=\"$any(property).type\"\n                            [timeInterval]=\"5\"\n                            [attr.data-automation-id]=\"'datepicker-' + property.key\"\n                            [startAt]=\"valueDate\">\n        </mat-datetimepicker>\n    </div>\n    <ng-template #elseEmptyValueBlock>\n        {{ property.default | translate }}\n    </ng-template>\n\n    <div *ngIf=\"property.multivalued\"\n         class=\"adf-property-field adf-dateitem-chip-list-container adf-dateitem-editable\">\n        <mat-chip-list #chipList\n                       class=\"adf-textitem-chip-list\">\n            <mat-chip *ngFor=\"let propertyValue of property.displayValue; let idx = index\"\n                      [removable]=\"isEditable()\"\n                      (removed)=\"removeValueFromList(idx)\">\n                {{ propertyValue }}\n                <mat-icon *ngIf=\"isEditable()\"\n                          matChipRemove>cancel</mat-icon>\n            </mat-chip>\n        </mat-chip-list>\n\n        <mat-form-field *ngIf=\"isEditable()\"\n                        class=\"adf-property-field adf-dateitem-editable-controls\"\n                        [floatLabel]=\"'never'\"\n                        (click)=\"showDatePicker()\">\n            <input matInput\n                   class=\"adf-invisible-date-input\"\n                   [attr.tabIndex]=\"-1\"\n                   [matDatetimepicker]=\"datetimePicker\"\n                   (dateChange)=\"addDateToList($event)\">\n            <mat-datetimepicker-toggle [attr.tabindex]=\"-1\"\n                                       matSuffix\n                                       [attr.title]=\"'CORE.METADATA.ACTIONS.EDIT' | translate\"\n                                       [attr.data-automation-id]=\"'datepickertoggle-' + property.key\"\n                                       [for]=\"datetimePicker\">\n            </mat-datetimepicker-toggle>\n\n            <mat-datetimepicker #datetimePicker\n                                [type]=\"$any(property).type\"\n                                [timeInterval]=\"5\"\n                                [attr.data-automation-id]=\"'datepicker-' + property.key\"\n                                [startAt]=\"valueDate\">\n            </mat-datetimepicker>\n        </mat-form-field>\n    </div>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-invisible-date-input{border:none;float:right;height:2px;margin:0;opacity:0;overflow:hidden;padding:0;width:0}.adf-dateitem-chip-list-container.adf-property-field{border-bottom:0;cursor:pointer;margin-bottom:-7px!important}.adf-dateitem-chip-list-container.adf-property-field .adf-dateitem-editable-controls{margin-top:15px}.adf-dateitem-chip-list-container.adf-property-field .mat-datetimepicker-toggle{position:absolute;right:0;top:-20px}.adf-dateitem-editable{border-bottom:1px solid var(--adf-card-view-datetime-border-color);cursor:pointer;padding-bottom:6px}.adf-dateitem-editable-controls{align-items:center;display:flex;justify-content:space-between}.adf-dateitem-editable-controls button.mat-icon-button{height:20px;line-height:20px;width:20px}.adf-dateitem-editable-controls mat-icon{height:16px;opacity:.5;width:16px}.adf-dateitem-editable-controls:hover mat-icon{opacity:1}.adf-dateitem-editable-controls .adf-datepicker-toggle{flex:1 0 auto}.adf-dateitem-editable-controls mat-icon.adf-date-reset-icon{font-size:16px;height:16px;line-height:10px;opacity:.3;padding-left:8px;position:relative;top:4px;width:16px}.adf-dateitem-editable-controls:hover mat-icon.adf-date-reset-icon{opacity:1}"]
            },] }
];
CardViewDateItemComponent.ctorParameters = () => [
    { type: CardViewUpdateService },
    { type: DateAdapter },
    { type: UserPreferencesService },
    { type: AppConfigService },
    { type: ClipboardService },
    { type: TranslationService }
];
CardViewDateItemComponent.propDecorators = {
    property: [{ type: Input }],
    editable: [{ type: Input }],
    displayEmpty: [{ type: Input }],
    displayClearAction: [{ type: Input }],
    datepicker: [{ type: ViewChild, args: ['datetimePicker',] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CardViewMapItemModel extends CardViewBaseItemModel {
    constructor() {
        super(...arguments);
        this.type = 'map';
    }
    get displayValue() {
        if (this.value && this.value.size > 0) {
            return this.value.values().next().value;
        }
        else {
            return this.default;
        }
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CardViewMapItemComponent extends BaseCardView {
    constructor(cardViewUpdateService) {
        super(cardViewUpdateService);
        this.displayEmpty = true;
    }
    showProperty() {
        return this.displayEmpty || !this.property.isEmpty();
    }
    isClickable() {
        return this.property.clickable;
    }
    clicked() {
        this.cardViewUpdateService.clicked(this.property);
    }
}
CardViewMapItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-card-view-mapitem',
                template: "<div [attr.data-automation-id]=\"'card-mapitem-label-' + property.key\"\n     class=\"adf-property-label\"\n     *ngIf=\"showProperty()\">{{ property.label | translate }}</div>\n<div class=\"adf-property-value adf-map-item-padding\">\n    <div>\n        <span *ngIf=\"!isClickable(); else clickableTemplate\"\n              [attr.data-automation-id]=\"'card-mapitem-value-' + property.key\">\n            <span *ngIf=\"showProperty();\">{{ property.displayValue }}</span>\n        </span>\n    </div>\n    <ng-template #clickableTemplate>\n        <span class=\"adf-mapitem-clickable-value\"\n              (click)=\"clicked()\"\n              [attr.data-automation-id]=\"'card-mapitem-value-' + property.key\">\n            <span *ngIf=\"showProperty(); else emptyValueTemplate\">{{ property.displayValue }}</span>\n        </span>\n    </ng-template>\n    <ng-template #emptyValueTemplate>\n        {{ property.default | translate }}\n    </ng-template>\n</div>\n",
                styles: [".adf-mapitem-clickable-value{cursor:pointer!important}.adf-map-item-padding{padding-top:6px}"]
            },] }
];
CardViewMapItemComponent.ctorParameters = () => [
    { type: CardViewUpdateService }
];
CardViewMapItemComponent.propDecorators = {
    property: [{ type: Input }],
    displayEmpty: [{ type: Input }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CardViewSelectItemComponent extends BaseCardView {
    constructor(cardViewUpdateService, appConfig) {
        super(cardViewUpdateService);
        this.appConfig = appConfig;
        this.editable = false;
        this.displayNoneOption = true;
        this.displayEmpty = true;
        this.filter$ = new BehaviorSubject('');
        this.showInputFilter = false;
        this.onDestroy$ = new Subject();
        this.list$ = null;
    }
    ngOnChanges() {
        this.value = this.property.value;
    }
    ngOnInit() {
        this.getOptions()
            .pipe(takeUntil(this.onDestroy$))
            .subscribe((options) => {
            this.showInputFilter = options.length > this.optionsLimit;
        });
        this.list$ = this.getList();
    }
    onFilterInputChange(value) {
        this.filter$.next(value.toString());
    }
    isEditable() {
        return this.editable && this.property.editable;
    }
    getOptions() {
        return this.options$ || this.property.options$;
    }
    getList() {
        return combineLatest([this.getOptions(), this.filter$])
            .pipe(map(([items, filter]) => items.filter((item) => filter ? item.label.toLowerCase().includes(filter.toLowerCase())
            : true)), takeUntil(this.onDestroy$));
    }
    onChange(event) {
        const selectedOption = event.value !== undefined ? event.value : null;
        this.cardViewUpdateService.update(Object.assign({}, this.property), selectedOption);
        this.property.value = selectedOption;
    }
    showNoneOption() {
        return this.displayNoneOption;
    }
    get showProperty() {
        return this.displayEmpty || !this.property.isEmpty();
    }
    ngOnDestroy() {
        this.onDestroy$.next();
        this.onDestroy$.complete();
    }
    get optionsLimit() {
        return this.appConfig.get('content-metadata.selectFilterLimit', CardViewSelectItemComponent.HIDE_FILTER_LIMIT);
    }
}
CardViewSelectItemComponent.HIDE_FILTER_LIMIT = 5;
CardViewSelectItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-card-view-selectitem',
                template: "<ng-container *ngIf=\"!property.isEmpty() || isEditable()\">\n    <div [attr.data-automation-id]=\"'card-select-label-' + property.key\"\n        class=\"adf-property-label\">{{ property.label | translate }}</div>\n    <div class=\"adf-property-field\">\n        <div *ngIf=\"!isEditable()\"\n            class=\"adf-select-item-padding adf-property-value\"\n            [attr.data-automation-id]=\"'select-readonly-value-' + property.key\"\n            data-automation-class=\"read-only-value\">{{ (property.displayValue | async) | translate }}</div>\n        <div *ngIf=\"isEditable()\">\n            <mat-form-field class=\"adf-select-item-padding-editable adf-property-value\">\n                <mat-select [(value)]=\"value\"\n                            panelClass=\"adf-select-filter\"\n                            (selectionChange)=\"onChange($event)\"\n                            data-automation-class=\"select-box\">\n\n                    <adf-select-filter-input *ngIf=\"showInputFilter\" (change)=\"onFilterInputChange($event)\"></adf-select-filter-input>\n\n                    <mat-option *ngIf=\"showNoneOption()\">{{ 'CORE.CARDVIEW.NONE' | translate }}</mat-option>\n                    <mat-option *ngFor=\"let option of list$ | async\"\n                                [value]=\"option.key\">\n                        {{ option.label | translate }}\n                    </mat-option>\n                </mat-select>\n            </mat-form-field>\n        </div>\n    </div>\n</ng-container>\n",
                styles: [".mat-form-field-type-mat-select{width:100%}.adf-select-item-padding{padding-bottom:20px;padding-top:6px}.adf-select-item-padding-editable{padding-bottom:6px;padding-top:6px}"]
            },] }
];
CardViewSelectItemComponent.ctorParameters = () => [
    { type: CardViewUpdateService },
    { type: AppConfigService }
];
CardViewSelectItemComponent.propDecorators = {
    editable: [{ type: Input }],
    options$: [{ type: Input }],
    displayNoneOption: [{ type: Input }],
    displayEmpty: [{ type: Input }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CardViewKeyValuePairsItemComponent extends BaseCardView {
    constructor(cardViewUpdateService) {
        super(cardViewUpdateService);
        this.editable = false;
    }
    ngOnChanges() {
        this.values = this.property.value || [];
        this.matTableValues = new MatTableDataSource(this.values);
    }
    isEditable() {
        return this.editable && this.property.editable;
    }
    add() {
        this.values.push({ name: '', value: '' });
    }
    remove(index) {
        this.values.splice(index, 1);
        this.save(true);
    }
    onBlur(value) {
        if (value.length) {
            this.save();
        }
    }
    save(remove) {
        const validValues = this.values.filter((i) => i.name.length && i.value.length);
        if (remove || validValues.length) {
            this.cardViewUpdateService.update(Object.assign({}, this.property), validValues);
            this.property.value = validValues;
        }
    }
}
CardViewKeyValuePairsItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-card-view-boolitem',
                template: "<div [attr.data-automation-id]=\"'card-key-value-pairs-label-' + property.key\"\n     class=\"adf-property-label\">{{ property.label | translate }}</div>\n<div class=\"adf-property-field\">\n\n    <div *ngIf=\"!isEditable()\"\n         class=\"adf-card-view__key-value-pairs__read-only adf-property-value\">\n        <mat-table #table\n                   [dataSource]=\"matTableValues\"\n                   class=\"mat-elevation-z8\">\n            <ng-container matColumnDef=\"name\">\n                <mat-header-cell *matHeaderCellDef>{{ 'CORE.CARDVIEW.KEYVALUEPAIRS.NAME' | translate }}\n                </mat-header-cell>\n                <mat-cell *matCellDef=\"let item\">{{item.name}}</mat-cell>\n            </ng-container>\n            <ng-container matColumnDef=\"value\">\n                <mat-header-cell *matHeaderCellDef>{{ 'CORE.CARDVIEW.KEYVALUEPAIRS.VALUE' | translate }}\n                </mat-header-cell>\n                <mat-cell *matCellDef=\"let item\">{{item.value}}</mat-cell>\n            </ng-container>\n\n            <mat-header-row *matHeaderRowDef=\"['name', 'value']\"></mat-header-row>\n            <mat-row *matRowDef=\"let row; columns: ['name', 'value'];\"></mat-row>\n        </mat-table>\n    </div>\n\n\n    <div class=\"adf-card-view__key-value-pairs adf-property-value\"\n         *ngIf=\"isEditable() && values && values.length\">\n        <div class=\"adf-card-view__key-value-pairs__row\">\n            <div class=\"adf-card-view__key-value-pairs__col\">{{ 'CORE.CARDVIEW.KEYVALUEPAIRS.NAME' | translate }}</div>\n            <div class=\"adf-card-view__key-value-pairs__col\">{{ 'CORE.CARDVIEW.KEYVALUEPAIRS.VALUE' | translate }}</div>\n        </div>\n\n        <div class=\"adf-card-view__key-value-pairs__row\"\n             *ngFor=\"let item of values; let i = index\">\n            <div class=\"adf-card-view__key-value-pairs__col\">\n                <mat-form-field>\n                    <input matInput\n                           placeholder=\"{{ 'CORE.CARDVIEW.KEYVALUEPAIRS.NAME' | translate }}\"\n                           (blur)=\"onBlur(item.value)\"\n                           [attr.data-automation-id]=\"'card-'+ property.key +'-name-input-' + i\"\n                           [(ngModel)]=\"values[i].name\">\n                </mat-form-field>\n            </div>\n            <div class=\"adf-card-view__key-value-pairs__col\">\n                <mat-form-field>\n                    <input matInput\n                           placeholder=\"{{ 'CORE.CARDVIEW.KEYVALUEPAIRS.VALUE' | translate }}\"\n                           (blur)=\"onBlur(item.value)\"\n                           [attr.data-automation-id]=\"'card-'+ property.key +'-value-input-' + i\"\n                           [(ngModel)]=\"values[i].value\">\n                    <button matSuffix\n                            mat-icon-button\n                            (click)=\"remove(i)\"\n                            class=\"adf-card-view__key-value-pairs__remove-btn\">\n                        <mat-icon>close</mat-icon>\n                    </button>\n                </mat-form-field>\n            </div>\n        </div>\n    </div>\n    <div *ngIf=\"isEditable()\"\n         class=\"adf-property-value adf-card-view__key-value-pairs__add-btn-container\">\n        <button (click)=\"add()\"\n                mat-button\n                class=\"adf-card-view__key-value-pairs__add-btn\"\n                [attr.data-automation-id]=\"'card-key-value-pairs-button-' + property.key\">\n            {{ 'CORE.CARDVIEW.KEYVALUEPAIRS.ADD' | translate }}\n            <mat-icon>add</mat-icon>\n        </button>\n    </div>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-card-view__key-value-pairs__row{display:flex;justify-content:center}.adf-card-view__key-value-pairs__col{width:50%}.adf-card-view__key-value-pairs__col .mat-form-field{font-size:14px;width:100%}.adf-card-view__key-value-pairs__col .mat-form-field-appearance-legacy .mat-form-field-label{color:var(--adf-card-view-label-color)!important}.adf-card-view__key-value-pairs__add-btn-container{display:flex;justify-content:center}.adf-card-view__key-value-pairs__add-btn.mat-button{margin-bottom:20px}.adf-card-view__key-value-pairs__read-only{padding-bottom:20px}.adf-card-view__key-value-pairs__read-only .mat-table{box-shadow:none}.adf-card-view__key-value-pairs__read-only .mat-header-row,.adf-card-view__key-value-pairs__read-only .mat-row{padding:0}"]
            },] }
];
CardViewKeyValuePairsItemComponent.ctorParameters = () => [
    { type: CardViewUpdateService }
];
CardViewKeyValuePairsItemComponent.propDecorators = {
    editable: [{ type: Input }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getType(type) {
    return () => type;
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DynamicComponentResolver {
    static fromType(type) {
        return getType(type);
    }
}
class DynamicComponentMapper {
    constructor() {
        this.defaultValue = undefined;
        this.types = {};
    }
    getComponentTypeResolver(type, defaultValue = this.defaultValue) {
        if (type) {
            return this.types[type] || DynamicComponentResolver.fromType(defaultValue);
        }
        return DynamicComponentResolver.fromType(defaultValue);
    }
    setComponentTypeResolver(type, resolver, override = true) {
        if (!type) {
            throw new Error(`type is null or not defined`);
        }
        if (!resolver) {
            throw new Error(`resolver is null or not defined`);
        }
        const existing = this.types[type];
        if (existing && !override) {
            throw new Error(`already mapped, use override option if you intend replacing existing mapping.`);
        }
        this.types[type] = resolver;
    }
    register(components, override = false) {
        if (components) {
            for (const type of Object.keys(components)) {
                this.setComponentTypeResolver(type, components[type], override);
            }
        }
    }
    resolveComponentType(model, defaultValue = this.defaultValue) {
        if (model) {
            const resolver = this.getComponentTypeResolver(model.type, defaultValue);
            return resolver(model);
        }
        return defaultValue;
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CardViewArrayItemComponent extends BaseCardView {
    constructor(cardViewUpdateService) {
        super(cardViewUpdateService);
    }
    clicked() {
        if (this.isClickable()) {
            this.cardViewUpdateService.clicked(this.property);
        }
    }
    showClickableIcon() {
        return this.hasIcon() && this.isClickable();
    }
    hasIcon() {
        return !!this.property.icon;
    }
    displayCount() {
        return this.property.noOfItemsToDisplay ? this.property.noOfItemsToDisplay : 0;
    }
    isClickable() {
        return !!this.property.clickable;
    }
}
CardViewArrayItemComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-card-view-arrayitem',
                template: "<div [attr.data-automation-id]=\"'card-array-label-' + property.key\" class=\"adf-property-label\">{{ property.label | translate }}</div>\n<div class=\"adf-property-value adf-card-view-array-item-container\" (click)=\"clicked()\">\n    <ng-container *ngIf=\"(property.displayValue | async) as items; else elseEmptyValueBlock\">\n        <mat-chip-list *ngIf=\"items.length > 0; else elseEmptyValueBlock\" data-automation-id=\"card-arrayitem-chip-list-container\">\n            <ng-container *ngIf=\"displayCount() > 0; else withOutDisplayCount\" >\n                <mat-chip\n                    *ngFor=\"let item of items.slice(0, displayCount())\"\n                    (click)=\"clicked()\"\n                    [attr.data-automation-id]=\"'card-arrayitem-chip-' + item.value\">\n                    <mat-icon *ngIf=\"item?.icon\" class=\"adf-array-item-icon\">{{item.icon}}</mat-icon>\n                    <span>{{item?.value}}</span>\n                </mat-chip>\n                <mat-chip\n                    *ngIf=\"items.length > displayCount()\"\n                    data-automation-id=\"card-arrayitem-more-chip\"\n                    [matMenuTriggerFor]=\"menu\">\n                    <span>{{items.length - displayCount()}} {{'CORE.CARDVIEW.MORE' | translate}}</span>\n                </mat-chip>\n            </ng-container>\n            <ng-template #withOutDisplayCount>\n                <mat-chip\n                    *ngFor=\"let item of items\"\n                    (click)=\"clicked()\"\n                    [attr.data-automation-id]=\"'card-arrayitem-chip-' + item.value\">\n                    <mat-icon *ngIf=\"item?.icon\" class=\"adf-array-item-icon\">{{item.icon}}</mat-icon>\n                    <span>{{item?.value}}</span>\n                </mat-chip>\n            </ng-template>\n        </mat-chip-list>\n        <mat-menu #menu=\"matMenu\">\n            <mat-card class=\"adf-array-item-more-chip-container\">\n                <mat-card-content>\n                    <mat-chip-list>\n                        <mat-chip (click)=\"clicked()\"\n                            *ngFor=\"let item of items.slice(displayCount(), items.length)\"\n                            [attr.data-automation-id]=\"'card-arrayitem-chip-' + item.value\">\n                        <mat-icon *ngIf=\"item?.icon\" class=\"adf-array-item-icon\">{{item.icon}}</mat-icon>\n                        <span>{{item?.value}}</span>\n                        </mat-chip>\n                    </mat-chip-list>\n                </mat-card-content>\n            </mat-card>\n        </mat-menu>\n    </ng-container>\n    <ng-template #elseEmptyValueBlock>\n        <span class=\"adf-card-array-item-default\" data-automation-id=\"card-arrayitem-default\">{{ property?.default | translate }}</span>\n    </ng-template>\n    <button mat-icon-button *ngIf=\"showClickableIcon()\"\n        class=\"adf-array-item-action\"\n        [attr.aria-label]=\"'CORE.METADATA.ACTIONS.EDIT' | translate\"\n        [attr.title]=\"'CORE.METADATA.ACTIONS.EDIT' | translate\"\n        [attr.data-automation-id]=\"'card-array-item-clickable-icon-' + property.key\">\n        <mat-icon class=\"adf-array-item-icon\">{{property.icon}}</mat-icon>\n    </button>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-array-item-icon{font-size:16px;padding-top:8px}.adf-array-item-action{color:var(--adf-card-view-text-color)}.adf-array-item-action:focus,.adf-array-item-action:hover{color:var(--theme-text-fg-color)}.adf-card-array-item-default{display:block;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.adf-array-item-more-chip-container.mat-card{box-shadow:none;max-height:300px;overflow-y:auto}.adf-array-item-more-chip-container .mat-chip{cursor:pointer}.adf-property-value .mat-chip-list{cursor:pointer;padding-top:6px;width:100%}.adf-property-value .mat-chip{cursor:pointer}.adf-card-view-array-item-container{align-items:center;box-sizing:border-box;display:flex;flex-direction:row;place-content:center space-between}"]
            },] }
];
CardViewArrayItemComponent.ctorParameters = () => [
    { type: CardViewUpdateService }
];

class CardItemTypeService extends DynamicComponentMapper {
    constructor() {
        super(...arguments);
        this.defaultValue = CardViewTextItemComponent;
        this.types = {
            'text': DynamicComponentResolver.fromType(CardViewTextItemComponent),
            'select': DynamicComponentResolver.fromType(CardViewSelectItemComponent),
            'int': DynamicComponentResolver.fromType(CardViewTextItemComponent),
            'float': DynamicComponentResolver.fromType(CardViewTextItemComponent),
            'date': DynamicComponentResolver.fromType(CardViewDateItemComponent),
            'datetime': DynamicComponentResolver.fromType(CardViewDateItemComponent),
            'bool': DynamicComponentResolver.fromType(CardViewBoolItemComponent),
            'map': DynamicComponentResolver.fromType(CardViewMapItemComponent),
            'keyvaluepairs': DynamicComponentResolver.fromType(CardViewKeyValuePairsItemComponent),
            'array': DynamicComponentResolver.fromType(CardViewArrayItemComponent)
        };
    }
}
CardItemTypeService.ɵprov = ɵɵdefineInjectable({ factory: function CardItemTypeService_Factory() { return new CardItemTypeService(); }, token: CardItemTypeService, providedIn: "root" });
CardItemTypeService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CardViewContentProxyDirective {
    constructor(viewContainerRef) {
        this.viewContainerRef = viewContainerRef;
    }
}
CardViewContentProxyDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-card-view-content-proxy]'
            },] }
];
CardViewContentProxyDirective.ctorParameters = () => [
    { type: ViewContainerRef }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CardViewItemDispatcherComponent {
    constructor(cardItemTypeService, resolver) {
        this.cardItemTypeService = cardItemTypeService;
        this.resolver = resolver;
        this.displayEmpty = true;
        this.displayNoneOption = true;
        this.displayClearAction = true;
        this.copyToClipboardAction = true;
        this.useChipsForMultiValueProperty = true;
        this.multiValueSeparator = DEFAULT_SEPARATOR;
        this.loaded = false;
        this.componentReference = null;
        const dynamicLifeCycleMethods = [
            'ngOnInit',
            'ngDoCheck',
            'ngAfterContentInit',
            'ngAfterContentChecked',
            'ngAfterViewInit',
            'ngAfterViewChecked',
            'ngOnDestroy'
        ];
        dynamicLifeCycleMethods.forEach((method) => {
            this[method] = this.proxy.bind(this, method);
        });
    }
    ngOnChanges(changes) {
        if (!this.loaded) {
            this.loadComponent();
            this.loaded = true;
        }
        Object.keys(changes)
            .map((changeName) => [changeName, changes[changeName]])
            .forEach(([inputParamName, simpleChange]) => {
            this.componentReference.instance[inputParamName] = simpleChange.currentValue;
        });
        this.proxy('ngOnChanges', changes);
    }
    loadComponent() {
        const factoryClass = this.cardItemTypeService.resolveComponentType(this.property);
        const factory = this.resolver.resolveComponentFactory(factoryClass);
        this.componentReference = this.content.viewContainerRef.createComponent(factory);
        this.componentReference.instance.editable = this.editable;
        this.componentReference.instance.property = this.property;
        this.componentReference.instance.displayEmpty = this.displayEmpty;
        this.componentReference.instance.displayNoneOption = this.displayNoneOption;
        this.componentReference.instance.displayClearAction = this.displayClearAction;
        this.componentReference.instance.copyToClipboardAction = this.copyToClipboardAction;
        this.componentReference.instance.useChipsForMultiValueProperty = this.useChipsForMultiValueProperty;
        this.componentReference.instance.multiValueSeparator = this.multiValueSeparator;
    }
    proxy(methodName, ...args) {
        if (this.componentReference.instance[methodName]) {
            this.componentReference.instance[methodName].apply(this.componentReference.instance, args);
        }
    }
}
CardViewItemDispatcherComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-card-view-item-dispatcher',
                template: '<ng-template adf-card-view-content-proxy></ng-template>'
            },] }
];
CardViewItemDispatcherComponent.ctorParameters = () => [
    { type: CardItemTypeService },
    { type: ComponentFactoryResolver }
];
CardViewItemDispatcherComponent.propDecorators = {
    property: [{ type: Input }],
    editable: [{ type: Input }],
    displayEmpty: [{ type: Input }],
    displayNoneOption: [{ type: Input }],
    displayClearAction: [{ type: Input }],
    copyToClipboardAction: [{ type: Input }],
    useChipsForMultiValueProperty: [{ type: Input }],
    multiValueSeparator: [{ type: Input }],
    content: [{ type: ViewChild, args: [CardViewContentProxyDirective, { static: true },] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class SelectFilterInputComponent {
    constructor(matSelect) {
        this.matSelect = matSelect;
        this.change = new EventEmitter();
        this.term = '';
        this.onDestroy$ = new Subject();
    }
    onModelChange(value) {
        this.change.next(value);
    }
    ngOnInit() {
        this.change
            .pipe(takeUntil(this.onDestroy$))
            .subscribe((val) => this.term = val);
        this.matSelect.openedChange
            .pipe(takeUntil(this.onDestroy$))
            .subscribe((isOpened) => {
            if (isOpened) {
                this.selectFilterInput.nativeElement.focus();
            }
            else {
                this.change.next('');
            }
        });
    }
    reset(event) {
        if (event) {
            event.stopPropagation();
        }
        this.change.next('');
        this.selectFilterInput.nativeElement.focus();
    }
    handleKeydown($event) {
        if (this.term) {
            if ($event.keyCode === ESCAPE) {
                event.stopPropagation();
                this.change.next('');
            }
            if ($event.target.tagName === 'INPUT' && $event.keyCode === TAB) {
                event.stopPropagation();
            }
        }
    }
    ngOnDestroy() {
        this.onDestroy$.next();
        this.onDestroy$.complete();
    }
}
SelectFilterInputComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-select-filter-input',
                template: "\n<div class=\"adf-select-filter-input-container\">\n    <mat-form-field>\n        <input matInput\n            autocomplete=\"off\"\n            (keydown)=\"handleKeydown($event)\"\n            [placeholder]=\"'SELECT_FILTER.INPUT.PLACEHOLDER' | translate\"\n            #selectFilterInput\n            [ngModel]=\"term\"\n            (ngModelChange)=\"onModelChange($event)\"\n            [attr.aria-label]=\"'SELECT_FILTER.INPUT.ARIA_LABEL' | translate\"\n            (change)=\"$event.stopPropagation()\"\n        />\n\n        <button mat-button\n            matSuffix\n            mat-icon-button\n            [attr.aria-label]=\"'SELECT_FILTER.BUTTON.ARIA_LABEL' | translate\"\n            *ngIf=\"term\"\n            (keydown.enter)=\"reset($event)\"\n            (click)=\"reset()\">\n            <mat-icon>close</mat-icon>\n        </button>\n    </mat-form-field>\n</div>\n",
                host: { 'class': 'adf-select-filter-input' },
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-select-filter-input{display:flex;height:4em}.adf-select-filter-input .adf-select-filter-input-container{background:var(--theme-card-bg-color);color:var(--theme-text-bold-color);display:flex;font-size:14px;height:4em;line-height:3em;padding:5px 16px 0;position:absolute;top:0;width:100%;z-index:100}.adf-select-filter-input .mat-form-field{width:100%}.mat-select-panel.adf-select-filter{max-height:calc(256px + 4em);overflow-x:hidden!important;transform:none!important}"]
            },] }
];
SelectFilterInputComponent.ctorParameters = () => [
    { type: MatSelect, decorators: [{ type: Inject, args: [MatSelect,] }] }
];
SelectFilterInputComponent.propDecorators = {
    selectFilterInput: [{ type: ViewChild, args: ['selectFilterInput', { read: ElementRef, static: false },] }],
    change: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CardViewItemFloatValidator {
    constructor() {
        this.message = 'CORE.CARDVIEW.VALIDATORS.FLOAT_VALIDATION_ERROR';
    }
    isValid(value) {
        if (Array.isArray(value)) {
            return value.every(this.isDecimalNumber);
        }
        return value === '' || this.isDecimalNumber(value);
    }
    isDecimalNumber(value) {
        return !isNaN(parseFloat(value)) && isFinite(value);
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CardViewBoolItemModel extends CardViewBaseItemModel {
    constructor(cardViewBoolItemProperties) {
        super(cardViewBoolItemProperties);
        this.type = 'bool';
        this.value = false;
        if (cardViewBoolItemProperties.value !== undefined) {
            this.value = !!JSON.parse(cardViewBoolItemProperties.value);
        }
    }
    get displayValue() {
        if (this.isEmpty()) {
            return this.default;
        }
        else {
            return this.value;
        }
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CardViewDatetimeItemModel extends CardViewDateItemModel {
    constructor(cardViewDateItemProperties) {
        super(cardViewDateItemProperties);
        this.type = 'datetime';
        this.format = 'MMM d, y, H:mm';
        if (cardViewDateItemProperties.format) {
            this.format = cardViewDateItemProperties.format;
        }
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CardViewTextItemModel extends CardViewBaseItemModel {
    constructor(cardViewTextItemProperties) {
        super(cardViewTextItemProperties);
        this.type = 'text';
        this.inputType = 'text';
        this.multiline = !!cardViewTextItemProperties.multiline;
        this.pipes = cardViewTextItemProperties.pipes || [];
        this.clickCallBack = cardViewTextItemProperties.clickCallBack ? cardViewTextItemProperties.clickCallBack : null;
        if (this.default && this.isEmpty()) {
            this.value = this.default;
        }
    }
    get displayValue() {
        return this.applyPipes(this.value);
    }
    applyPipes(displayValue) {
        if (this.pipes.length) {
            displayValue = this.pipes.reduce((accumulator, { pipe, params = [] }) => {
                return pipe.transform(accumulator, ...params);
            }, displayValue);
        }
        return displayValue;
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CardViewFloatItemModel extends CardViewTextItemModel {
    constructor(cardViewTextItemProperties) {
        super(cardViewTextItemProperties);
        this.type = 'float';
        this.inputType = 'number';
        this.validators.push(new CardViewItemFloatValidator());
        if (cardViewTextItemProperties.value && !cardViewTextItemProperties.multivalued) {
            this.value = parseFloat(cardViewTextItemProperties.value);
        }
    }
    get displayValue() {
        return this.applyPipes(this.value);
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CardViewIntItemModel extends CardViewTextItemModel {
    constructor(cardViewTextItemProperties) {
        super(cardViewTextItemProperties);
        this.type = 'int';
        this.inputType = 'number';
        this.validators.push(new CardViewItemIntValidator());
        if (cardViewTextItemProperties.value && !cardViewTextItemProperties.multivalued) {
            this.value = parseInt(cardViewTextItemProperties.value, 10);
        }
    }
    get displayValue() {
        return this.applyPipes(this.value);
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CardViewKeyValuePairsItemModel extends CardViewBaseItemModel {
    constructor(cardViewKeyValuePairsItemProperties) {
        super(cardViewKeyValuePairsItemProperties);
        this.type = 'keyvaluepairs';
    }
    get displayValue() {
        return this.value;
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CardViewSelectItemModel extends CardViewBaseItemModel {
    constructor(cardViewSelectItemProperties) {
        super(cardViewSelectItemProperties);
        this.type = 'select';
        this.valueFetch$ = null;
        this.displayNoneOption = cardViewSelectItemProperties.displayNoneOption !== undefined ? cardViewSelectItemProperties.displayNoneOption : true;
        this.options$ = cardViewSelectItemProperties.options$;
        this.valueFetch$ = this.options$.pipe(switchMap((options) => {
            const option = options.find((o) => { var _a; return o.key === ((_a = this.value) === null || _a === void 0 ? void 0 : _a.toString()); });
            return of(option ? option.label : '');
        }));
    }
    get displayValue() {
        return this.valueFetch$;
    }
    setValue(value) {
        this.value = value;
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CardViewArrayItemModel extends CardViewBaseItemModel {
    constructor(cardViewArrayItemProperties) {
        super(cardViewArrayItemProperties);
        this.type = 'array';
        this.noOfItemsToDisplay = cardViewArrayItemProperties.noOfItemsToDisplay;
    }
    get displayValue() {
        return this.value;
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CardViewModule {
}
CardViewModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    FlexLayoutModule,
                    TranslateModule,
                    MatDatepickerModule,
                    MatNativeDateModule,
                    MatCheckboxModule,
                    MatInputModule,
                    MatTableModule,
                    MatIconModule,
                    MatSelectModule,
                    MatButtonModule,
                    MatChipsModule,
                    MatMenuModule,
                    MatCardModule,
                    MatDatetimepickerModule,
                    MatNativeDatetimeModule,
                    MatSlideToggleModule,
                    MatTooltipModule
                ],
                declarations: [
                    CardViewComponent,
                    CardViewBoolItemComponent,
                    CardViewDateItemComponent,
                    CardViewMapItemComponent,
                    CardViewTextItemComponent,
                    CardViewKeyValuePairsItemComponent,
                    CardViewSelectItemComponent,
                    CardViewItemDispatcherComponent,
                    CardViewContentProxyDirective,
                    CardViewArrayItemComponent,
                    SelectFilterInputComponent
                ],
                exports: [
                    CardViewComponent,
                    CardViewBoolItemComponent,
                    CardViewDateItemComponent,
                    CardViewMapItemComponent,
                    CardViewTextItemComponent,
                    CardViewSelectItemComponent,
                    CardViewKeyValuePairsItemComponent,
                    CardViewArrayItemComponent,
                    SelectFilterInputComponent
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DebugAppConfigService extends AppConfigService {
    constructor(storage, http, extensionService) {
        super(http, extensionService);
        this.storage = storage;
    }
    get(key, defaultValue) {
        if (key === AppConfigValues.OAUTHCONFIG) {
            return (JSON.parse(this.storage.getItem(key)) || super.get(key, defaultValue));
        }
        else if (key === AppConfigValues.APPLICATION) {
            return undefined;
        }
        else {
            return (this.storage.getItem(key) || super.get(key, defaultValue));
        }
    }
}
DebugAppConfigService.decorators = [
    { type: Injectable }
];
DebugAppConfigService.ctorParameters = () => [
    { type: StorageService },
    { type: HttpClient },
    { type: ExtensionService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AppConfigPipe {
    constructor(config) {
        this.config = config;
    }
    transform(value, fallback) {
        return this.config.get(value, fallback);
    }
}
AppConfigPipe.decorators = [
    { type: Pipe, args: [{
                name: 'adfAppConfig'
            },] }
];
AppConfigPipe.ctorParameters = () => [
    { type: AppConfigService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AppConfigModule {
}
AppConfigModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    HttpClientModule
                ],
                declarations: [
                    AppConfigPipe
                ],
                exports: [
                    AppConfigPipe
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FormDefinitionModel extends FormSaveRepresentation {
    constructor(id, name, lastUpdatedByFullName, lastUpdated, metadata) {
        super();
        this.reusable = false;
        this.newVersion = false;
        this.formImageBase64 = '';
        this.formRepresentation = {
            id: id,
            name: name,
            description: '',
            version: 1,
            lastUpdatedBy: 1,
            lastUpdatedByFullName: lastUpdatedByFullName,
            lastUpdated: lastUpdated,
            stencilSetId: 0,
            referenceId: null,
            formDefinition: {
                fields: [{
                        name: 'Label',
                        type: 'container',
                        fieldType: 'ContainerRepresentation',
                        numberOfColumns: 2,
                        required: false,
                        readOnly: false,
                        sizeX: 2,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        fields: { '1': this.metadataToFields(metadata) }
                    }],
                gridsterForm: false,
                javascriptEvents: [],
                metadata: {},
                outcomes: [],
                className: '',
                style: '',
                tabs: [],
                variables: []
            }
        };
    }
    metadataToFields(metadata) {
        const fields = [];
        if (metadata) {
            metadata.forEach(function (property) {
                if (property) {
                    const field = {
                        type: 'text',
                        id: property.name,
                        name: property.name,
                        required: false,
                        readOnly: false,
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        colspan: 1,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        layout: {
                            colspan: 1,
                            row: -1,
                            column: -1
                        }
                    };
                    fields.push(field);
                }
            });
        }
        return fields;
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FormFieldTypes {
    static isReadOnlyType(type) {
        return FormFieldTypes.READONLY_TYPES.includes(type);
    }
    static isContainerType(type) {
        return type === FormFieldTypes.CONTAINER || type === FormFieldTypes.GROUP;
    }
}
FormFieldTypes.CONTAINER = 'container';
FormFieldTypes.GROUP = 'group';
FormFieldTypes.DYNAMIC_TABLE = 'dynamic-table';
FormFieldTypes.TEXT = 'text';
FormFieldTypes.MULTILINE_TEXT = 'multi-line-text';
FormFieldTypes.DROPDOWN = 'dropdown';
FormFieldTypes.HYPERLINK = 'hyperlink';
FormFieldTypes.RADIO_BUTTONS = 'radio-buttons';
FormFieldTypes.DISPLAY_VALUE = 'readonly';
FormFieldTypes.READONLY_TEXT = 'readonly-text';
FormFieldTypes.UPLOAD = 'upload';
FormFieldTypes.TYPEAHEAD = 'typeahead';
FormFieldTypes.FUNCTIONAL_GROUP = 'functional-group';
FormFieldTypes.PEOPLE = 'people';
FormFieldTypes.BOOLEAN = 'boolean';
FormFieldTypes.NUMBER = 'integer';
FormFieldTypes.DATE = 'date';
FormFieldTypes.AMOUNT = 'amount';
FormFieldTypes.DOCUMENT = 'document';
FormFieldTypes.DATETIME = 'datetime';
FormFieldTypes.ATTACH_FOLDER = 'select-folder';
FormFieldTypes.FILE_VIEWER = 'file-viewer';
FormFieldTypes.READONLY_TYPES = [
    FormFieldTypes.HYPERLINK,
    FormFieldTypes.DISPLAY_VALUE,
    FormFieldTypes.READONLY_TEXT,
    FormFieldTypes.GROUP
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FormWidgetModel {
    constructor(form, json) {
        this.form = form;
        this.json = json;
        if (json) {
            this.fieldType = json.fieldType;
            this.id = json.id;
            this.name = json.name;
            this.type = json.type;
            this.tab = json.tab;
            this.field = json.field;
        }
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class WidgetVisibilityModel {
    constructor(json) {
        this.json = json;
        if (json) {
            this.operator = json.operator;
            this.nextCondition = new WidgetVisibilityModel(json.nextCondition);
            this.nextConditionOperator = json.nextConditionOperator;
            this.rightRestResponseId = json.rightRestResponseId;
            this.rightFormFieldId = json.rightFormFieldId;
            this.leftFormFieldId = json.leftFormFieldId;
            this.leftRestResponseId = json.leftRestResponseId;
        }
        else {
            this.json = {};
        }
    }
    get leftType() {
        if (this.leftFormFieldId) {
            return WidgetTypeEnum.field;
        }
        else if (this.leftRestResponseId) {
            return WidgetTypeEnum.variable;
        }
        else if (!!this.json.leftType) {
            return this.json.leftType;
        }
        return null;
    }
    set leftType(leftType) {
        this.json.leftType = leftType;
    }
    get leftValue() {
        if (this.json.leftValue) {
            return this.json.leftValue;
        }
        else if (this.leftFormFieldId) {
            return this.leftFormFieldId;
        }
        else {
            return this.leftRestResponseId;
        }
    }
    set leftValue(leftValue) {
        this.json.leftValue = leftValue;
    }
    get rightType() {
        if (!!this.json.rightType) {
            return this.json.rightType;
        }
        else if (this.json.rightValue) {
            return WidgetTypeEnum.value;
        }
        else if (this.rightRestResponseId) {
            return WidgetTypeEnum.variable;
        }
        else if (this.rightFormFieldId) {
            return WidgetTypeEnum.field;
        }
        return null;
    }
    set rightType(rightType) {
        this.json.rightType = rightType;
    }
    get rightValue() {
        if (this.json.rightValue) {
            return this.json.rightValue;
        }
        else if (this.rightFormFieldId) {
            return this.rightFormFieldId;
        }
        else {
            return this.rightRestResponseId;
        }
    }
    set rightValue(rightValue) {
        this.json.rightValue = rightValue;
    }
}
var WidgetTypeEnum;
(function (WidgetTypeEnum) {
    WidgetTypeEnum["field"] = "field";
    WidgetTypeEnum["variable"] = "variable";
    WidgetTypeEnum["value"] = "value";
})(WidgetTypeEnum || (WidgetTypeEnum = {}));

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ContainerColumnModel {
    constructor() {
        this.size = 12;
        this.fields = [];
        this.colspan = 1;
        this.rowspan = 1;
    }
    hasFields() {
        return this.fields && this.fields.length > 0;
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ErrorMessageModel {
    constructor(obj) {
        this.message = '';
        this.attributes = null;
        this.message = obj && obj.message ? obj.message : '';
        this.attributes = new Map();
    }
    isActive() {
        return !!this.message;
    }
    getAttributesAsJsonObj() {
        let result = {};
        if (this.attributes.size > 0) {
            const obj = Object.create(null);
            this.attributes.forEach((value, key) => {
                obj[key] = value;
            });
            result = JSON.stringify(obj);
        }
        return result;
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RequiredFieldValidator {
    constructor() {
        this.supportedTypes = [
            FormFieldTypes.TEXT,
            FormFieldTypes.MULTILINE_TEXT,
            FormFieldTypes.NUMBER,
            FormFieldTypes.BOOLEAN,
            FormFieldTypes.TYPEAHEAD,
            FormFieldTypes.DROPDOWN,
            FormFieldTypes.PEOPLE,
            FormFieldTypes.FUNCTIONAL_GROUP,
            FormFieldTypes.RADIO_BUTTONS,
            FormFieldTypes.UPLOAD,
            FormFieldTypes.AMOUNT,
            FormFieldTypes.DYNAMIC_TABLE,
            FormFieldTypes.DATE,
            FormFieldTypes.DATETIME,
            FormFieldTypes.ATTACH_FOLDER
        ];
    }
    isSupported(field) {
        return field &&
            this.supportedTypes.indexOf(field.type) > -1 &&
            field.required;
    }
    validate(field) {
        if (this.isSupported(field) && field.isVisible) {
            if (field.type === FormFieldTypes.DROPDOWN) {
                if (field.hasMultipleValues) {
                    return Array.isArray(field.value) && !!field.value.length;
                }
                if (field.hasEmptyValue && field.emptyOption) {
                    if (field.value === field.emptyOption.id) {
                        return false;
                    }
                }
            }
            if (field.type === FormFieldTypes.RADIO_BUTTONS) {
                const option = field.options.find((opt) => opt.id === field.value);
                return !!option;
            }
            if (field.type === FormFieldTypes.UPLOAD) {
                return field.value && field.value.length > 0;
            }
            if (field.type === FormFieldTypes.DYNAMIC_TABLE) {
                return field.value && field.value instanceof Array && field.value.length > 0;
            }
            if (field.type === FormFieldTypes.BOOLEAN) {
                return !!field.value;
            }
            if (field.value === null || field.value === undefined || field.value === '') {
                return false;
            }
        }
        return true;
    }
}
class NumberFieldValidator {
    constructor() {
        this.supportedTypes = [
            FormFieldTypes.NUMBER,
            FormFieldTypes.AMOUNT
        ];
    }
    static isNumber(value) {
        if (value === null || value === undefined || value === '') {
            return false;
        }
        return !isNaN(+value);
    }
    isSupported(field) {
        return field && this.supportedTypes.indexOf(field.type) > -1;
    }
    validate(field) {
        if (this.isSupported(field) && field.isVisible) {
            if (field.value === null ||
                field.value === undefined ||
                field.value === '') {
                return true;
            }
            const valueStr = '' + field.value;
            let pattern = new RegExp(/^-?\d+$/);
            if (field.enableFractions) {
                pattern = new RegExp(/^-?[0-9]+(\.[0-9]{1,2})?$/);
            }
            if (valueStr.match(pattern)) {
                return true;
            }
            field.validationSummary.message = 'FORM.FIELD.VALIDATOR.INVALID_NUMBER';
            return false;
        }
        return true;
    }
}
class DateFieldValidator {
    constructor() {
        this.supportedTypes = [
            FormFieldTypes.DATE
        ];
    }
    static isValidDate(inputDate, dateFormat = 'D-M-YYYY') {
        if (inputDate) {
            const d = moment(inputDate, dateFormat, true);
            return d.isValid();
        }
        return false;
    }
    isSupported(field) {
        return field && this.supportedTypes.indexOf(field.type) > -1;
    }
    validate(field) {
        if (this.isSupported(field) && field.value && field.isVisible) {
            if (DateFieldValidator.isValidDate(field.value, field.dateDisplayFormat)) {
                return true;
            }
            field.validationSummary.message = field.dateDisplayFormat;
            return false;
        }
        return true;
    }
}
class DateTimeFieldValidator {
    constructor() {
        this.supportedTypes = [
            FormFieldTypes.DATETIME
        ];
    }
    static isValidDate(inputDate, dateFormat = 'YYYY-MM-DD HH:mm') {
        if (inputDate) {
            const d = moment(inputDate, dateFormat, true);
            return d.isValid();
        }
        return false;
    }
    isSupported(field) {
        return field && this.supportedTypes.indexOf(field.type) > -1;
    }
    validate(field) {
        if (this.isSupported(field) && field.value && field.isVisible) {
            if (DateFieldValidator.isValidDate(field.value, field.dateDisplayFormat)) {
                return true;
            }
            field.validationSummary.message = field.dateDisplayFormat;
            return false;
        }
        return true;
    }
}
class BoundaryDateFieldValidator {
    constructor() {
        this.DATE_FORMAT_CLOUD = 'YYYY-MM-DD';
        this.DATE_FORMAT = 'DD-MM-YYYY';
        this.supportedTypes = [
            FormFieldTypes.DATE
        ];
    }
    validate(field) {
        let isValid = true;
        if (this.isSupported(field) && field.value && field.isVisible) {
            const dateFormat = field.dateDisplayFormat;
            if (!DateFieldValidator.isValidDate(field.value, dateFormat)) {
                field.validationSummary.message = 'FORM.FIELD.VALIDATOR.INVALID_DATE';
                isValid = false;
            }
            else {
                isValid = this.checkDate(field, dateFormat);
            }
        }
        return isValid;
    }
    extractDateFormat(date) {
        const brokenDownDate = date.split('-');
        return brokenDownDate[0].length === 4 ? this.DATE_FORMAT_CLOUD : this.DATE_FORMAT;
    }
}
class MinDateFieldValidator extends BoundaryDateFieldValidator {
    checkDate(field, dateFormat) {
        let isValid = true;
        let fieldValueData;
        if (typeof field.value === 'string') {
            fieldValueData = moment(field.value.split('T')[0], dateFormat);
        }
        else {
            fieldValueData = field.value;
        }
        const minValueDateFormat = this.extractDateFormat(field.minValue);
        const min = moment(field.minValue, minValueDateFormat);
        if (fieldValueData.isBefore(min)) {
            field.validationSummary.message = `FORM.FIELD.VALIDATOR.NOT_LESS_THAN`;
            field.validationSummary.attributes.set('minValue', min.format(field.dateDisplayFormat).toLocaleUpperCase());
            isValid = false;
        }
        return isValid;
    }
    isSupported(field) {
        return field &&
            this.supportedTypes.indexOf(field.type) > -1 && !!field.minValue;
    }
}
class MaxDateFieldValidator extends BoundaryDateFieldValidator {
    checkDate(field, dateFormat) {
        let isValid = true;
        let fieldValueData;
        if (typeof field.value === 'string') {
            fieldValueData = moment(field.value.split('T')[0], dateFormat);
        }
        else {
            fieldValueData = field.value;
        }
        const maxValueDateFormat = this.extractDateFormat(field.maxValue);
        const max = moment(field.maxValue, maxValueDateFormat);
        if (fieldValueData.isAfter(max)) {
            field.validationSummary.message = `FORM.FIELD.VALIDATOR.NOT_GREATER_THAN`;
            field.validationSummary.attributes.set('maxValue', max.format(field.dateDisplayFormat).toLocaleUpperCase());
            isValid = false;
        }
        return isValid;
    }
    isSupported(field) {
        return field &&
            this.supportedTypes.indexOf(field.type) > -1 && !!field.maxValue;
    }
}
class MinDateTimeFieldValidator {
    constructor() {
        this.supportedTypes = [
            FormFieldTypes.DATETIME
        ];
        this.MIN_DATETIME_FORMAT = 'YYYY-MM-DD hh:mm AZ';
    }
    isSupported(field) {
        return field &&
            this.supportedTypes.indexOf(field.type) > -1 && !!field.minValue;
    }
    validate(field) {
        let isValid = true;
        if (this.isSupported(field) && field.value && field.isVisible) {
            const dateFormat = field.dateDisplayFormat;
            if (!DateFieldValidator.isValidDate(field.value, dateFormat)) {
                field.validationSummary.message = 'FORM.FIELD.VALIDATOR.INVALID_DATE';
                isValid = false;
            }
            else {
                isValid = this.checkDateTime(field, dateFormat);
            }
        }
        return isValid;
    }
    checkDateTime(field, dateFormat) {
        let isValid = true;
        let fieldValueDate;
        if (typeof field.value === 'string') {
            fieldValueDate = moment(field.value, dateFormat);
        }
        else {
            fieldValueDate = field.value;
        }
        const min = moment(field.minValue, this.MIN_DATETIME_FORMAT);
        if (fieldValueDate.isBefore(min)) {
            field.validationSummary.message = `FORM.FIELD.VALIDATOR.NOT_LESS_THAN`;
            field.validationSummary.attributes.set('minValue', min.format(field.dateDisplayFormat).replace(':', '-'));
            isValid = false;
        }
        return isValid;
    }
}
class MaxDateTimeFieldValidator {
    constructor() {
        this.supportedTypes = [
            FormFieldTypes.DATETIME
        ];
        this.MAX_DATETIME_FORMAT = 'YYYY-MM-DD hh:mm AZ';
    }
    isSupported(field) {
        return field &&
            this.supportedTypes.indexOf(field.type) > -1 && !!field.maxValue;
    }
    validate(field) {
        let isValid = true;
        if (this.isSupported(field) && field.value && field.isVisible) {
            const dateFormat = field.dateDisplayFormat;
            if (!DateFieldValidator.isValidDate(field.value, dateFormat)) {
                field.validationSummary.message = 'FORM.FIELD.VALIDATOR.INVALID_DATE';
                isValid = false;
            }
            else {
                isValid = this.checkDateTime(field, dateFormat);
            }
        }
        return isValid;
    }
    checkDateTime(field, dateFormat) {
        let isValid = true;
        let fieldValueDate;
        if (typeof field.value === 'string') {
            fieldValueDate = moment(field.value, dateFormat);
        }
        else {
            fieldValueDate = field.value;
        }
        const max = moment(field.maxValue, this.MAX_DATETIME_FORMAT);
        if (fieldValueDate.isAfter(max)) {
            field.validationSummary.message = `FORM.FIELD.VALIDATOR.NOT_GREATER_THAN`;
            field.validationSummary.attributes.set('maxValue', max.format(field.dateDisplayFormat).replace(':', '-'));
            isValid = false;
        }
        return isValid;
    }
}
class MinLengthFieldValidator {
    constructor() {
        this.supportedTypes = [
            FormFieldTypes.TEXT,
            FormFieldTypes.MULTILINE_TEXT
        ];
    }
    isSupported(field) {
        return field &&
            this.supportedTypes.indexOf(field.type) > -1 &&
            field.minLength > 0;
    }
    validate(field) {
        if (this.isSupported(field) && field.value && field.isVisible) {
            if (field.value.length >= field.minLength) {
                return true;
            }
            field.validationSummary.message = `FORM.FIELD.VALIDATOR.AT_LEAST_LONG`;
            field.validationSummary.attributes.set('minLength', field.minLength.toLocaleString());
            return false;
        }
        return true;
    }
}
class MaxLengthFieldValidator {
    constructor() {
        this.supportedTypes = [
            FormFieldTypes.TEXT,
            FormFieldTypes.MULTILINE_TEXT
        ];
    }
    isSupported(field) {
        return field &&
            this.supportedTypes.indexOf(field.type) > -1 &&
            field.maxLength > 0;
    }
    validate(field) {
        if (this.isSupported(field) && field.value && field.isVisible) {
            if (field.value.length <= field.maxLength) {
                return true;
            }
            field.validationSummary.message = `FORM.FIELD.VALIDATOR.NO_LONGER_THAN`;
            field.validationSummary.attributes.set('maxLength', field.maxLength.toLocaleString());
            return false;
        }
        return true;
    }
}
class MinValueFieldValidator {
    constructor() {
        this.supportedTypes = [
            FormFieldTypes.NUMBER,
            FormFieldTypes.AMOUNT
        ];
    }
    isSupported(field) {
        return field &&
            this.supportedTypes.indexOf(field.type) > -1 &&
            NumberFieldValidator.isNumber(field.minValue);
    }
    validate(field) {
        if (this.isSupported(field) && field.value && field.isVisible) {
            const value = +field.value;
            const minValue = +field.minValue;
            if (value >= minValue) {
                return true;
            }
            field.validationSummary.message = `FORM.FIELD.VALIDATOR.NOT_LESS_THAN`;
            field.validationSummary.attributes.set('minValue', field.minValue.toLocaleString());
            return false;
        }
        return true;
    }
}
class MaxValueFieldValidator {
    constructor() {
        this.supportedTypes = [
            FormFieldTypes.NUMBER,
            FormFieldTypes.AMOUNT
        ];
    }
    isSupported(field) {
        return field &&
            this.supportedTypes.indexOf(field.type) > -1 &&
            NumberFieldValidator.isNumber(field.maxValue);
    }
    validate(field) {
        if (this.isSupported(field) && field.value && field.isVisible) {
            const value = +field.value;
            const maxValue = +field.maxValue;
            if (value <= maxValue) {
                return true;
            }
            field.validationSummary.message = `FORM.FIELD.VALIDATOR.NOT_GREATER_THAN`;
            field.validationSummary.attributes.set('maxValue', field.maxValue.toLocaleString());
            return false;
        }
        return true;
    }
}
class RegExFieldValidator {
    constructor() {
        this.supportedTypes = [
            FormFieldTypes.TEXT,
            FormFieldTypes.MULTILINE_TEXT
        ];
    }
    isSupported(field) {
        return field &&
            this.supportedTypes.indexOf(field.type) > -1 && !!field.regexPattern;
    }
    validate(field) {
        if (this.isSupported(field) && field.value && field.isVisible) {
            if (field.value.length > 0 && field.value.match(new RegExp('^' + field.regexPattern + '$'))) {
                return true;
            }
            field.validationSummary.message = 'FORM.FIELD.VALIDATOR.INVALID_VALUE';
            return false;
        }
        return true;
    }
}
class FixedValueFieldValidator {
    constructor() {
        this.supportedTypes = [
            FormFieldTypes.TYPEAHEAD
        ];
    }
    isSupported(field) {
        return field && this.supportedTypes.indexOf(field.type) > -1;
    }
    hasValidNameOrValidId(field) {
        return this.hasValidName(field) || this.hasValidId(field);
    }
    hasValidName(field) {
        return field.options.find((item) => item.name && item.name.toLocaleLowerCase() === field.value.toLocaleLowerCase()) ? true : false;
    }
    hasValidId(field) {
        return field.options.find((item) => item.id === field.value) ? true : false;
    }
    hasStringValue(field) {
        return field.value && typeof field.value === 'string';
    }
    hasOptions(field) {
        return field.options && field.options.length > 0;
    }
    validate(field) {
        if (this.isSupported(field) && field.isVisible) {
            if (this.hasStringValue(field) && this.hasOptions(field) && !this.hasValidNameOrValidId(field)) {
                field.validationSummary.message = 'FORM.FIELD.VALIDATOR.INVALID_VALUE';
                return false;
            }
        }
        return true;
    }
}
const FORM_FIELD_VALIDATORS = [
    new RequiredFieldValidator(),
    new NumberFieldValidator(),
    new MinLengthFieldValidator(),
    new MaxLengthFieldValidator(),
    new MinValueFieldValidator(),
    new MaxValueFieldValidator(),
    new RegExFieldValidator(),
    new DateFieldValidator(),
    new DateTimeFieldValidator(),
    new MinDateFieldValidator(),
    new MaxDateFieldValidator(),
    new FixedValueFieldValidator(),
    new MinDateTimeFieldValidator(),
    new MaxDateTimeFieldValidator()
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FormFieldModel extends FormWidgetModel {
    constructor(form, json) {
        var _a;
        super(form, json);
        this._readOnly = false;
        this._isValid = true;
        this._required = false;
        this.defaultDateFormat = 'D-M-YYYY';
        this.defaultDateTimeFormat = 'D-M-YYYY hh:mm A';
        this.rowspan = 1;
        this.colspan = 1;
        this.placeholder = null;
        this.tooltip = null;
        this.minLength = 0;
        this.maxLength = 0;
        this.options = [];
        this.params = {};
        this.isVisible = true;
        this.visibilityCondition = null;
        this.enableFractions = false;
        this.currency = null;
        this.dateDisplayFormat = this.defaultDateFormat;
        this.selectionType = null;
        this.numberOfColumns = 1;
        this.fields = [];
        this.columns = [];
        if (json) {
            this.fieldType = json.fieldType;
            this.id = json.id;
            this.name = json.name;
            this.type = json.type;
            this.roles = json.roles;
            this._required = json.required;
            this._readOnly = json.readOnly || json.type === 'readonly';
            this.overrideId = json.overrideId;
            this.tab = json.tab;
            this.restUrl = json.restUrl;
            this.restResponsePath = json.restResponsePath;
            this.restIdProperty = json.restIdProperty;
            this.restLabelProperty = json.restLabelProperty;
            this.colspan = json.colspan;
            this.rowspan = json.rowspan;
            this.minLength = json.minLength || 0;
            this.maxLength = json.maxLength || 0;
            this.minValue = json.minValue;
            this.maxValue = json.maxValue;
            this.regexPattern = json.regexPattern;
            this.options = json.options || [];
            this.hasEmptyValue = json.hasEmptyValue;
            this.className = json.className;
            this.optionType = json.optionType;
            this.params = json.params || {};
            this.hyperlinkUrl = json.hyperlinkUrl;
            this.displayText = json.displayText;
            this.visibilityCondition = json.visibilityCondition ? new WidgetVisibilityModel(json.visibilityCondition) : undefined;
            this.enableFractions = json.enableFractions;
            this.currency = json.currency;
            this.dateDisplayFormat = json.dateDisplayFormat || this.getDefaultDateFormat(json);
            this._value = this.parseValue(json);
            this.validationSummary = new ErrorMessageModel();
            this.tooltip = json.tooltip;
            this.selectionType = json.selectionType;
            this.rule = json.rule;
            if (json.placeholder && json.placeholder !== '' && json.placeholder !== 'null') {
                this.placeholder = json.placeholder;
            }
            if (FormFieldTypes.isReadOnlyType(this.type)) {
                if (this.params && this.params.field) {
                    let valueFound = false;
                    if (form.processVariables) {
                        const processVariable = this.getProcessVariableValue(this.params.field, form);
                        if (processVariable) {
                            valueFound = true;
                            this.value = processVariable;
                        }
                    }
                    if (!valueFound && this.params.responseVariable) {
                        const defaultValue = form.getFormVariableValue(this.params.field.name);
                        if (defaultValue) {
                            valueFound = true;
                            this.value = defaultValue;
                        }
                    }
                }
            }
            if (FormFieldTypes.isContainerType(this.type)) {
                this.containerFactory(json, form);
            }
        }
        const emptyOption = Array.isArray(this.options) ? this.options.find(({ id }) => id === 'empty') : undefined;
        if (this.hasEmptyValue === undefined) {
            this.hasEmptyValue = (_a = json === null || json === void 0 ? void 0 : json.hasEmptyValue) !== null && _a !== void 0 ? _a : !!emptyOption;
        }
        if (this.options && this.options.length > 0 && this.hasEmptyValue) {
            this.emptyOption = emptyOption;
        }
        this.updateForm();
    }
    get value() {
        return this._value;
    }
    set value(v) {
        this._value = v;
        this.updateForm();
    }
    get readOnly() {
        if (this.form && this.form.readOnly) {
            return true;
        }
        return this._readOnly;
    }
    set readOnly(readOnly) {
        this._readOnly = readOnly;
        this.updateForm();
    }
    get required() {
        return this._required;
    }
    set required(value) {
        this._required = value;
        this.updateForm();
    }
    get isValid() {
        return this._isValid;
    }
    get hasMultipleValues() {
        return this.selectionType === 'multiple';
    }
    markAsInvalid() {
        this._isValid = false;
    }
    validate() {
        this.validationSummary = new ErrorMessageModel();
        if (!this.readOnly) {
            const validators = this.form.fieldValidators || [];
            for (const validator of validators) {
                if (!validator.validate(this)) {
                    this._isValid = false;
                    return this._isValid;
                }
            }
        }
        this._isValid = true;
        return this._isValid;
    }
    getDefaultDateFormat(jsonField) {
        let originalType = jsonField.type;
        if (FormFieldTypes.isReadOnlyType(jsonField.type) &&
            jsonField.params &&
            jsonField.params.field) {
            originalType = jsonField.params.field.type;
        }
        return originalType === FormFieldTypes.DATETIME ? this.defaultDateTimeFormat : this.defaultDateFormat;
    }
    isTypeaheadFieldType(type) {
        return type === 'typeahead';
    }
    getFieldNameWithLabel(name) {
        return name + '_LABEL';
    }
    getProcessVariableValue(field, form) {
        let fieldName = field.name;
        if (this.isTypeaheadFieldType(field.type)) {
            fieldName = this.getFieldNameWithLabel(field.id);
        }
        return form.getProcessVariableValue(fieldName);
    }
    containerFactory(json, form) {
        this.numberOfColumns = json.numberOfColumns || 1;
        this.fields = json.fields;
        this.rowspan = 1;
        this.colspan = 1;
        if (json.fields) {
            for (const currentField in json.fields) {
                if (json.fields.hasOwnProperty(currentField)) {
                    const col = new ContainerColumnModel();
                    const fields = (json.fields[currentField] || []).map((field) => new FormFieldModel(form, field));
                    col.fields = fields;
                    col.rowspan = json.fields[currentField].length;
                    col.fields.forEach((colFields) => {
                        this.colspan = colFields.colspan > this.colspan ? colFields.colspan : this.colspan;
                    });
                    this.rowspan = this.rowspan < col.rowspan ? col.rowspan : this.rowspan;
                    this.columns.push(col);
                }
            }
        }
    }
    parseValue(json) {
        let value = json.hasOwnProperty('value') && json.value !== undefined ? json.value : null;
        if (json.type === FormFieldTypes.DROPDOWN) {
            if (json.options) {
                const options = json.options || [];
                if (options.length > 0) {
                    if (json.hasEmptyValue) {
                        const emptyOption = json.options[0];
                        if (value === '' || value === emptyOption.id || value === emptyOption.name) {
                            value = emptyOption.id;
                        }
                    }
                    else {
                        if ((value === null || value === void 0 ? void 0 : value.id) && (value === null || value === void 0 ? void 0 : value.name)) {
                            value = value.id;
                        }
                    }
                }
            }
            if (this.hasMultipleValues) {
                value = Array.isArray(json.value) ? json.value : [];
            }
        }
        if (json.type === FormFieldTypes.RADIO_BUTTONS) {
            const entry = this.options.filter((opt) => opt.id === value || opt.name === value || (value && (opt.id === value.id || opt.name === value.name)));
            if (entry.length > 0) {
                value = entry[0].id;
            }
        }
        if (this.isDateField(json) || this.isDateTimeField(json)) {
            if (value) {
                let dateValue;
                if (NumberFieldValidator.isNumber(value)) {
                    dateValue = moment(value);
                }
                else {
                    dateValue = this.isDateTimeField(json) ? moment(value, 'YYYY-MM-DD hh:mm A') : moment(value.split('T')[0], 'YYYY-M-D');
                }
                if (dateValue && dateValue.isValid()) {
                    value = dateValue.format(this.dateDisplayFormat);
                }
            }
        }
        if (this.isCheckboxField(json)) {
            value = json.value === 'true' || json.value === true;
        }
        return value;
    }
    updateForm() {
        if (!this.form) {
            return;
        }
        switch (this.type) {
            case FormFieldTypes.DROPDOWN:
                if (Array.isArray(this.value)) {
                    this.form.values[this.id] = this.value;
                    break;
                }
                if (typeof this.value === 'string') {
                    if (this.value === 'empty' || this.value === '') {
                        this.form.values[this.id] = {};
                        break;
                    }
                    const entry = this.options.filter((opt) => opt.id === this.value);
                    if (entry.length > 0) {
                        this.setFormFieldValueOption(entry[0]);
                    }
                }
                break;
            case FormFieldTypes.RADIO_BUTTONS:
                const radioButton = this.options.filter((opt) => opt.id === this.value);
                if (radioButton.length > 0) {
                    this.setFormFieldValueOption(radioButton[0]);
                }
                break;
            case FormFieldTypes.UPLOAD:
                this.form.hasUpload = true;
                if (this.value && this.value.length > 0) {
                    this.form.values[this.id] = Array.isArray(this.value) ? this.value.map((elem) => elem.id).join(',') : [this.value];
                }
                else {
                    this.form.values[this.id] = null;
                }
                break;
            case FormFieldTypes.TYPEAHEAD:
                const typeAheadEntry = this.options.filter((opt) => opt.id === this.value || opt.name === this.value);
                if (typeAheadEntry.length > 0) {
                    this.form.values[this.id] = typeAheadEntry[0];
                }
                else if (this.options.length > 0) {
                    this.form.values[this.id] = null;
                }
                break;
            case FormFieldTypes.DATE:
                if (typeof this.value === 'string' && this.value === 'today') {
                    this.value = moment(new Date()).format(this.dateDisplayFormat);
                }
                const dateValue = moment(this.value, this.dateDisplayFormat, true);
                if (dateValue && dateValue.isValid()) {
                    this.form.values[this.id] = `${dateValue.format('YYYY-MM-DD')}T00:00:00.000Z`;
                }
                else {
                    this.form.values[this.id] = null;
                    this._value = this.value;
                }
                break;
            case FormFieldTypes.DATETIME:
                if (typeof this.value === 'string' && this.value === 'now') {
                    this.value = moment(new Date()).format(this.dateDisplayFormat);
                }
                const dateTimeValue = moment(this.value, this.dateDisplayFormat, true).utc();
                if (dateTimeValue && dateTimeValue.isValid()) {
                    this.form.values[this.id] = `${dateTimeValue.format('YYYY-MM-DDTHH:mm:ss')}.000Z`;
                }
                else {
                    this.form.values[this.id] = null;
                    this._value = this.value;
                }
                break;
            case FormFieldTypes.NUMBER:
                this.form.values[this.id] = this.enableFractions ? parseFloat(this.value) : parseInt(this.value, 10);
                break;
            case FormFieldTypes.AMOUNT:
                this.form.values[this.id] = this.enableFractions ? parseFloat(this.value) : parseInt(this.value, 10);
                break;
            case FormFieldTypes.BOOLEAN:
                this.form.values[this.id] = (this.value !== null && this.value !== undefined) ? this.value : false;
                break;
            case FormFieldTypes.PEOPLE:
                this.form.values[this.id] = this.value ? this.value : null;
                break;
            case FormFieldTypes.FUNCTIONAL_GROUP:
                this.form.values[this.id] = this.value ? this.value : null;
                break;
            default:
                if (!FormFieldTypes.isReadOnlyType(this.type) && !this.isInvalidFieldType(this.type)) {
                    this.form.values[this.id] = this.value;
                }
        }
        this.form.onFormFieldChanged(this);
    }
    isInvalidFieldType(type) {
        return type === 'container';
    }
    getOptionName() {
        const option = this.options.find((opt) => opt.id === this.value);
        return option ? option.name : null;
    }
    hasOptions() {
        return this.options && this.options.length > 0;
    }
    isDateField(json) {
        return (json.params &&
            json.params.field &&
            json.params.field.type === FormFieldTypes.DATE) ||
            json.type === FormFieldTypes.DATE;
    }
    isDateTimeField(json) {
        return (json.params &&
            json.params.field &&
            json.params.field.type === FormFieldTypes.DATETIME) ||
            json.type === FormFieldTypes.DATETIME;
    }
    isCheckboxField(json) {
        return (json.params &&
            json.params.field &&
            json.params.field.type === FormFieldTypes.BOOLEAN) ||
            json.type === FormFieldTypes.BOOLEAN;
    }
    setFormFieldValueOption(option) {
        if (this.optionType === 'rest' && !!this.restUrl) {
            const restEntry = {};
            const restIdProperty = this.restIdProperty || 'id';
            const restLabelProperty = this.restLabelProperty || 'name';
            restEntry[restIdProperty] = option.id;
            restEntry[restLabelProperty] = option.name;
            this.form.values[this.id] = restEntry;
        }
        else {
            this.form.values[this.id] = option;
        }
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FormEvent {
    constructor(form) {
        this.isDefaultPrevented = false;
        this.form = form;
    }
    get defaultPrevented() {
        return this.isDefaultPrevented;
    }
    preventDefault() {
        this.isDefaultPrevented = true;
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FormFieldEvent extends FormEvent {
    constructor(form, field) {
        super(form);
        this.field = field;
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ValidateFormFieldEvent extends FormFieldEvent {
    constructor(form, field) {
        super(form, field);
        this.isValid = true;
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ValidateFormEvent extends FormEvent {
    constructor(form) {
        super(form);
        this.isValid = true;
        this.errorsField = [];
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ContainerModel extends FormWidgetModel {
    constructor(field) {
        super(field.form, field.json);
        if (field) {
            this.field = field;
        }
    }
    get isVisible() {
        return this.field.isVisible;
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TabModel extends FormWidgetModel {
    constructor(form, json) {
        super(form, json);
        this.isVisible = true;
        this.fields = [];
        if (json) {
            this.title = json.title;
            this.visibilityCondition = new WidgetVisibilityModel(json.visibilityCondition);
        }
    }
    hasContent() {
        return this.fields && this.fields.length > 0;
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FormOutcomeModel extends FormWidgetModel {
    constructor(form, json) {
        super(form, json);
        this.isSystem = false;
        this.isSelected = false;
        this.isVisible = true;
        if (json) {
            this.isSystem = json.isSystem ? true : false;
            this.isSelected = form && json.name === form.selectedOutcome ? true : false;
            this.visibilityCondition = new WidgetVisibilityModel(json.visibilityCondition);
        }
    }
}
FormOutcomeModel.SAVE_ACTION = 'SAVE';
FormOutcomeModel.COMPLETE_ACTION = 'COMPLETE';
FormOutcomeModel.START_PROCESS_ACTION = 'START PROCESS';

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FormModel {
    constructor(json, formValues, readOnly = false, formService, enableFixedSpace) {
        this.formService = formService;
        this.taskName = FormModel.UNSET_TASK_NAME;
        this.values = {};
        this.tabs = [];
        this.fields = [];
        this.outcomes = [];
        this.fieldValidators = [...FORM_FIELD_VALIDATORS];
        this.customFieldTemplates = {};
        this.readOnly = false;
        this.isValid = true;
        this.processVariables = [];
        this.variables = [];
        this.readOnly = readOnly;
        this.json = json;
        if (json) {
            this.id = json.id;
            this.name = json.name;
            this.taskId = json.taskId;
            this.taskName = json.taskName || json.name || FormModel.UNSET_TASK_NAME;
            this.processDefinitionId = json.processDefinitionId;
            this.customFieldTemplates = json.customFieldTemplates || {};
            this.selectedOutcome = json.selectedOutcome;
            this.className = json.className || '';
            this.variables = json.variables || [];
            this.processVariables = json.processVariables || [];
            this.enableFixedSpace = enableFixedSpace ? true : false;
            const tabCache = {};
            this.tabs = (json.tabs || []).map((tabJson) => {
                const model = new TabModel(this, tabJson);
                tabCache[model.id] = model;
                return model;
            });
            this.fields = this.parseRootFields(json);
            if (formValues) {
                this.loadData(formValues);
            }
            for (let i = 0; i < this.fields.length; i++) {
                const field = this.fields[i];
                if (field.tab) {
                    const tab = tabCache[field.tab];
                    if (tab) {
                        tab.fields.push(field);
                    }
                }
            }
            this.parseOutcomes();
        }
        this.validateForm();
    }
    onFormFieldChanged(field) {
        this.validateField(field);
        if (this.formService) {
            this.formService.formFieldValueChanged.next(new FormFieldEvent(this, field));
        }
    }
    validateForm() {
        const validateFormEvent = new ValidateFormEvent(this);
        const errorsField = [];
        const fields = this.getFormFields();
        for (let i = 0; i < fields.length; i++) {
            if (!fields[i].validate()) {
                errorsField.push(fields[i]);
            }
        }
        this.isValid = errorsField.length <= 0;
        if (this.formService) {
            validateFormEvent.isValid = this.isValid;
            validateFormEvent.errorsField = errorsField;
            this.formService.validateForm.next(validateFormEvent);
        }
    }
    validateField(field) {
        if (!field) {
            return;
        }
        const validateFieldEvent = new ValidateFormFieldEvent(this, field);
        if (this.formService) {
            this.formService.validateFormField.next(validateFieldEvent);
        }
        if (!validateFieldEvent.isValid) {
            this.markAsInvalid();
            return;
        }
        if (validateFieldEvent.defaultPrevented) {
            return;
        }
        if (!field.validate()) {
            this.markAsInvalid();
        }
        this.validateForm();
    }
    parseRootFields(json) {
        let fields = [];
        if (json.fields) {
            fields = json.fields;
        }
        else if (json.formDefinition && json.formDefinition.fields) {
            fields = json.formDefinition.fields;
        }
        const formWidgetModel = [];
        for (const field of fields) {
            if (field.type === FormFieldTypes.DISPLAY_VALUE) {
                if (field.params) {
                    const originalField = field.params['field'];
                    if (originalField.type === FormFieldTypes.DYNAMIC_TABLE) {
                        formWidgetModel.push(new ContainerModel(new FormFieldModel(this, field)));
                    }
                }
            }
            else {
                formWidgetModel.push(new ContainerModel(new FormFieldModel(this, field)));
            }
        }
        return formWidgetModel;
    }
    loadData(formValues) {
        for (const field of this.getFormFields()) {
            const variableId = `variables.${field.name}`;
            if (this.isDefined(formValues[variableId]) || this.isDefined(formValues[field.id])) {
                field.json.value = formValues[variableId] || formValues[field.id];
                field.value = field.parseValue(field.json);
            }
        }
    }
    isDefined(value) {
        return value !== undefined && value !== null;
    }
    getFormVariable(identifier) {
        if (identifier) {
            return this.variables.find(variable => variable.name === identifier ||
                variable.id === identifier);
        }
        return undefined;
    }
    getFormVariableValue(identifier) {
        const variable = this.getFormVariable(identifier);
        if (variable && variable.hasOwnProperty('value')) {
            return this.parseValue(variable.type, variable.value);
        }
        return undefined;
    }
    getProcessVariableValue(name) {
        if (this.processVariables) {
            const names = [`variables.${name}`, name];
            const variable = this.processVariables.find(entry => names.includes(entry.name));
            if (variable) {
                return this.parseValue(variable.type, variable.value);
            }
        }
        return undefined;
    }
    parseValue(type, value) {
        if (type && value) {
            switch (type) {
                case 'date':
                    return value
                        ? `${value}T00:00:00.000Z`
                        : undefined;
                case 'boolean':
                    return typeof value === 'string'
                        ? JSON.parse(value)
                        : value;
                default:
                    return value;
            }
        }
        return value;
    }
    hasTabs() {
        return this.tabs && this.tabs.length > 0;
    }
    hasFields() {
        return this.fields && this.fields.length > 0;
    }
    hasOutcomes() {
        return this.outcomes && this.outcomes.length > 0;
    }
    getFieldById(fieldId) {
        return this.getFormFields().find((field) => field.id === fieldId);
    }
    getFormFields() {
        const formFieldModel = [];
        for (let i = 0; i < this.fields.length; i++) {
            const field = this.fields[i];
            if (field instanceof ContainerModel) {
                const container = field;
                formFieldModel.push(container.field);
                container.field.columns.forEach((column) => {
                    formFieldModel.push(...column.fields);
                });
            }
        }
        return formFieldModel;
    }
    markAsInvalid() {
        this.isValid = false;
    }
    parseOutcomes() {
        if (this.json.fields) {
            const saveOutcome = new FormOutcomeModel(this, {
                id: FormModel.SAVE_OUTCOME,
                name: 'SAVE',
                isSystem: true
            });
            const completeOutcome = new FormOutcomeModel(this, {
                id: FormModel.COMPLETE_OUTCOME,
                name: 'COMPLETE',
                isSystem: true
            });
            const startProcessOutcome = new FormOutcomeModel(this, {
                id: FormModel.START_PROCESS_OUTCOME,
                name: 'START PROCESS',
                isSystem: true
            });
            const customOutcomes = (this.json.outcomes || []).map((obj) => new FormOutcomeModel(this, obj));
            this.outcomes = [saveOutcome].concat(customOutcomes.length > 0
                ? customOutcomes
                : [completeOutcome, startProcessOutcome]);
        }
    }
    addValuesNotPresent(valuesToSetIfNotPresent) {
        this.getFormFields().forEach(field => {
            if (valuesToSetIfNotPresent[field.id] && (!this.values[field.id] || this.isValidDropDown(field.id))) {
                this.values[field.id] = valuesToSetIfNotPresent[field.id];
                field.json.value = this.values[field.id];
                field.value = field.parseValue(field.json);
            }
        });
    }
    isValidDropDown(key) {
        const field = this.getFieldById(key);
        if (field.type === FormFieldTypes.DROPDOWN) {
            if (field.hasMultipleValues) {
                return Array.isArray(this.values[key]);
            }
            return typeof this.values[key] === 'string' ? this.values[key] === 'empty' : Object.keys(this.values[key]).length === 0;
        }
        return false;
    }
    setNodeIdValueForViewersLinkedToUploadWidget(linkedUploadWidgetContentSelected) {
        const subscribedViewers = this.getFormFields().filter(field => linkedUploadWidgetContentSelected.uploadWidgetId === field.params['uploadWidget']);
        subscribedViewers.forEach(viewer => {
            this.values[viewer.id] = linkedUploadWidgetContentSelected.id;
            viewer.json.value = this.values[viewer.id];
            viewer.value = viewer.parseValue(viewer.json);
        });
    }
}
FormModel.UNSET_TASK_NAME = 'Nameless task';
FormModel.SAVE_OUTCOME = '$save';
FormModel.COMPLETE_OUTCOME = '$complete';
FormModel.START_PROCESS_OUTCOME = '$startProcess';

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FormOutcomeEvent {
    constructor(outcome) {
        this._defaultPrevented = false;
        this._outcome = outcome;
    }
    get outcome() {
        return this._outcome;
    }
    get defaultPrevented() {
        return this._defaultPrevented;
    }
    preventDefault() {
        this._defaultPrevented = true;
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ContentLinkModel {
    constructor(obj) {
        this.contentAvailable = obj && obj.contentAvailable;
        this.created = obj && obj.created;
        this.createdBy = obj && obj.createdBy || {};
        this.id = obj && obj.id;
        this.link = obj && obj.link;
        this.mimeType = obj && obj.mimeType;
        this.name = obj && obj.name;
        this.previewStatus = obj && obj.previewStatus;
        this.relatedContent = obj && obj.relatedContent;
        this.simpleType = obj && obj.simpleType;
        this.thumbnailStatus = obj && obj.thumbnailStatus;
        this.nodeId = obj && obj.nodeId;
    }
    hasPreviewStatus() {
        return this.previewStatus === 'supported';
    }
    isTypeImage() {
        return this.simpleType === 'image';
    }
    isTypePdf() {
        return this.simpleType === 'pdf';
    }
    isTypeDoc() {
        return this.simpleType === 'word' || this.simpleType === 'content';
    }
    isThumbnailReady() {
        return this.thumbnailStatus === 'created';
    }
    isThumbnailSupported() {
        return this.isTypeImage() || ((this.isTypePdf() || this.isTypeDoc()) && this.isThumbnailReady());
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class UploadWidgetContentLinkModel extends ContentLinkModel {
    constructor(obj, uploadWidgetId) {
        super(obj);
        this.uploadWidgetId = uploadWidgetId;
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class EcmModelService {
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
    }
    get customModelApi() {
        var _a;
        this._customModelApi = (_a = this._customModelApi) !== null && _a !== void 0 ? _a : new CustomModelApi(this.apiService.getInstance());
        return this._customModelApi;
    }
    createEcmTypeForActivitiForm(formName, form) {
        return new Observable((observer) => {
            this.searchActivitiEcmModel().subscribe((model) => {
                if (!model) {
                    this.createActivitiEcmModel(formName, form).subscribe((typeForm) => {
                        observer.next(typeForm);
                        observer.complete();
                    });
                }
                else {
                    this.saveFomType(formName, form).subscribe((typeForm) => {
                        observer.next(typeForm);
                        observer.complete();
                    });
                }
            }, (err) => this.handleError(err));
        });
    }
    searchActivitiEcmModel() {
        return this.getEcmModels().pipe(map(function (ecmModels) {
            return ecmModels.list.entries.find((model) => model.entry.name === EcmModelService.MODEL_NAME);
        }));
    }
    createActivitiEcmModel(formName, form) {
        return new Observable((observer) => {
            this.createEcmModel(EcmModelService.MODEL_NAME, EcmModelService.MODEL_NAMESPACE).subscribe((model) => {
                this.logService.info('model created', model);
                this.activeEcmModel(EcmModelService.MODEL_NAME).subscribe((modelActive) => {
                    this.logService.info('model active', modelActive);
                    this.createEcmTypeWithProperties(formName, form).subscribe((typeCreated) => {
                        observer.next(typeCreated);
                        observer.complete();
                    });
                }, (err) => this.handleError(err));
            }, (err) => this.handleError(err));
        });
    }
    saveFomType(formName, form) {
        return new Observable((observer) => {
            this.searchEcmType(formName, EcmModelService.MODEL_NAME).subscribe((ecmType) => {
                this.logService.info('custom types', ecmType);
                if (!ecmType) {
                    this.createEcmTypeWithProperties(formName, form).subscribe((typeCreated) => {
                        observer.next(typeCreated);
                        observer.complete();
                    });
                }
                else {
                    observer.next(ecmType);
                    observer.complete();
                }
            }, (err) => this.handleError(err));
        });
    }
    createEcmTypeWithProperties(formName, form) {
        return new Observable((observer) => {
            this.createEcmType(formName, EcmModelService.MODEL_NAME, EcmModelService.TYPE_MODEL).subscribe((typeCreated) => {
                this.logService.info('type Created', typeCreated);
                this.addPropertyToAType(EcmModelService.MODEL_NAME, formName, form).subscribe((propertyAdded) => {
                    this.logService.info('property Added', propertyAdded);
                    observer.next(typeCreated);
                    observer.complete();
                }, (err) => this.handleError(err));
            }, (err) => this.handleError(err));
        });
    }
    searchEcmType(typeName, modelName) {
        return this.getEcmType(modelName).pipe(map(function (customTypes) {
            return customTypes.list.entries.find((type) => type.entry.prefixedName === typeName || type.entry.title === typeName);
        }));
    }
    activeEcmModel(modelName) {
        return from(this.customModelApi.activateCustomModel(modelName))
            .pipe(map(this.toJson), catchError((err) => this.handleError(err)));
    }
    createEcmModel(modelName, nameSpace) {
        return from(this.customModelApi.createCustomModel('DRAFT', '', modelName, modelName, nameSpace))
            .pipe(map(this.toJson), catchError((err) => this.handleError(err)));
    }
    getEcmModels() {
        return from(this.customModelApi.getAllCustomModel())
            .pipe(map(this.toJson), catchError((err) => this.handleError(err)));
    }
    getEcmType(modelName) {
        return from(this.customModelApi.getAllCustomType(modelName))
            .pipe(map(this.toJson), catchError((err) => this.handleError(err)));
    }
    createEcmType(typeName, modelName, parentType) {
        const name = this.cleanNameType(typeName);
        return from(this.customModelApi.createCustomType(modelName, name, parentType, typeName, ''))
            .pipe(map(this.toJson), catchError((err) => this.handleError(err)));
    }
    addPropertyToAType(modelName, typeName, formFields) {
        const name = this.cleanNameType(typeName);
        const properties = [];
        if (formFields && formFields.values) {
            for (const key in formFields.values) {
                if (key) {
                    properties.push({
                        name: key,
                        title: key,
                        description: key,
                        dataType: 'd:text',
                        multiValued: false,
                        mandatory: false,
                        mandatoryEnforced: false
                    });
                }
            }
        }
        return from(this.customModelApi.addPropertyToType(modelName, name, properties))
            .pipe(map(this.toJson), catchError((err) => this.handleError(err)));
    }
    cleanNameType(name) {
        let cleanName = name;
        if (name.indexOf(':') !== -1) {
            cleanName = name.split(':')[1];
        }
        return cleanName.replace(/[^a-zA-Z ]/g, '');
    }
    toJson(res) {
        if (res) {
            return res || {};
        }
        return {};
    }
    handleError(err) {
        this.logService.error(err);
    }
}
EcmModelService.MODEL_NAMESPACE = 'activitiForms';
EcmModelService.MODEL_NAME = 'activitiFormsModel';
EcmModelService.TYPE_MODEL = 'cm:folder';
EcmModelService.ɵprov = ɵɵdefineInjectable({ factory: function EcmModelService_Factory() { return new EcmModelService(ɵɵinject(AlfrescoApiService), ɵɵinject(LogService)); }, token: EcmModelService, providedIn: "root" });
EcmModelService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
EcmModelService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: LogService }
];

class FormService {
    constructor(ecmModelService, apiService, logService) {
        this.ecmModelService = ecmModelService;
        this.apiService = apiService;
        this.logService = logService;
        this.formLoaded = new Subject();
        this.formDataRefreshed = new Subject();
        this.formFieldValueChanged = new Subject();
        this.formEvents = new Subject();
        this.taskCompleted = new Subject();
        this.taskCompletedError = new Subject();
        this.taskSaved = new Subject();
        this.taskSavedError = new Subject();
        this.formContentClicked = new Subject();
        this.validateForm = new Subject();
        this.validateFormField = new Subject();
        this.validateDynamicTableRow = new Subject();
        this.executeOutcome = new Subject();
        this.updateFormValuesRequested = new Subject();
    }
    get taskFormsApi() {
        var _a;
        this._taskFormsApi = (_a = this._taskFormsApi) !== null && _a !== void 0 ? _a : new TaskFormsApi(this.apiService.getInstance());
        return this._taskFormsApi;
    }
    get taskApi() {
        var _a;
        this._taskApi = (_a = this._taskApi) !== null && _a !== void 0 ? _a : new TasksApi(this.apiService.getInstance());
        return this._taskApi;
    }
    get modelsApi() {
        var _a;
        this._modelsApi = (_a = this._modelsApi) !== null && _a !== void 0 ? _a : new ModelsApi(this.apiService.getInstance());
        return this._modelsApi;
    }
    get editorApi() {
        var _a;
        this._editorApi = (_a = this._editorApi) !== null && _a !== void 0 ? _a : new FormModelsApi(this.apiService.getInstance());
        return this._editorApi;
    }
    get processDefinitionsApi() {
        var _a;
        this._processDefinitionsApi = (_a = this._processDefinitionsApi) !== null && _a !== void 0 ? _a : new ProcessDefinitionsApi(this.apiService.getInstance());
        return this._processDefinitionsApi;
    }
    get processInstanceVariablesApi() {
        var _a;
        this._processInstanceVariablesApi = (_a = this._processInstanceVariablesApi) !== null && _a !== void 0 ? _a : new ProcessInstanceVariablesApi(this.apiService.getInstance());
        return this._processInstanceVariablesApi;
    }
    get processInstancesApi() {
        var _a;
        this._processInstancesApi = (_a = this._processInstancesApi) !== null && _a !== void 0 ? _a : new ProcessInstancesApi(this.apiService.getInstance());
        return this._processInstancesApi;
    }
    get groupsApi() {
        var _a;
        this._groupsApi = (_a = this._groupsApi) !== null && _a !== void 0 ? _a : new ActivitiGroupsApi(this.apiService.getInstance());
        return this._groupsApi;
    }
    get usersApi() {
        var _a;
        this._usersApi = (_a = this._usersApi) !== null && _a !== void 0 ? _a : new UsersApi(this.apiService.getInstance());
        return this._usersApi;
    }
    parseForm(json, data, readOnly = false, fixedSpace) {
        if (json) {
            const form = new FormModel(json, data, readOnly, this, fixedSpace);
            if (!json.fields) {
                form.outcomes = [
                    new FormOutcomeModel(form, {
                        id: '$save',
                        name: FormOutcomeModel.SAVE_ACTION,
                        isSystem: true
                    })
                ];
            }
            return form;
        }
        return null;
    }
    createFormFromANode(formName) {
        return new Observable((observer) => {
            this.createForm(formName).subscribe((form) => {
                this.ecmModelService.searchEcmType(formName, EcmModelService.MODEL_NAME).subscribe((customType) => {
                    const formDefinitionModel = new FormDefinitionModel(form.id, form.name, form.lastUpdatedByFullName, form.lastUpdated, customType.entry.properties);
                    from(this.editorApi.saveForm(form.id, formDefinitionModel)).subscribe((formData) => {
                        observer.next(formData);
                        observer.complete();
                    }, (err) => this.handleError(err));
                }, (err) => this.handleError(err));
            }, (err) => this.handleError(err));
        });
    }
    createForm(formName) {
        const dataModel = {
            name: formName,
            description: '',
            modelType: 2,
            stencilSet: 0
        };
        return from(this.modelsApi.createModel(dataModel));
    }
    saveForm(formId, formModel) {
        return from(this.editorApi.saveForm(formId, formModel));
    }
    searchFrom(name) {
        const opts = {
            'modelType': 2
        };
        return from(this.modelsApi.getModels(opts))
            .pipe(map(function (forms) {
            return forms.data.find((formData) => formData.name === name);
        }), catchError((err) => this.handleError(err)));
    }
    getForms() {
        const opts = {
            'modelType': 2
        };
        return from(this.modelsApi.getModels(opts))
            .pipe(map(this.toJsonArray), catchError((err) => this.handleError(err)));
    }
    getProcessDefinitions() {
        return from(this.processDefinitionsApi.getProcessDefinitions({}))
            .pipe(map(this.toJsonArray), catchError((err) => this.handleError(err)));
    }
    getProcessVariablesById(processInstanceId) {
        return from(this.processInstanceVariablesApi.getProcessInstanceVariables(processInstanceId))
            .pipe(map(this.toJson), catchError((err) => this.handleError(err)));
    }
    getTasks() {
        return from(this.taskApi.listTasks({}))
            .pipe(map(this.toJsonArray), catchError((err) => this.handleError(err)));
    }
    getTask(taskId) {
        return from(this.taskApi.getTask(taskId))
            .pipe(map(this.toJson), catchError((err) => this.handleError(err)));
    }
    saveTaskForm(taskId, formValues) {
        const saveFormRepresentation = { values: formValues };
        return from(this.taskFormsApi.saveTaskForm(taskId, saveFormRepresentation))
            .pipe(catchError((err) => this.handleError(err)));
    }
    completeTaskForm(taskId, formValues, outcome) {
        const completeFormRepresentation = { values: formValues };
        if (outcome) {
            completeFormRepresentation.outcome = outcome;
        }
        return from(this.taskFormsApi.completeTaskForm(taskId, completeFormRepresentation))
            .pipe(catchError((err) => this.handleError(err)));
    }
    getTaskForm(taskId) {
        return from(this.taskFormsApi.getTaskForm(taskId))
            .pipe(map(this.toJson), catchError((err) => this.handleError(err)));
    }
    getFormDefinitionById(formId) {
        return from(this.editorApi.getForm(formId))
            .pipe(map(this.toJson), catchError((err) => this.handleError(err)));
    }
    getFormDefinitionByName(name) {
        const opts = {
            'filter': 'myReusableForms',
            'filterText': name,
            'modelType': 2
        };
        return from(this.modelsApi.getModels(opts))
            .pipe(map(this.getFormId), catchError((err) => this.handleError(err)));
    }
    getStartFormInstance(processId) {
        return from(this.processInstancesApi.getProcessInstanceStartForm(processId))
            .pipe(map(this.toJson), catchError((err) => this.handleError(err)));
    }
    getProcessInstance(processId) {
        return from(this.processInstancesApi.getProcessInstance(processId))
            .pipe(map(this.toJson), catchError((err) => this.handleError(err)));
    }
    getStartFormDefinition(processId) {
        return from(this.processDefinitionsApi.getProcessDefinitionStartForm(processId))
            .pipe(map(this.toJson), catchError((err) => this.handleError(err)));
    }
    getRestFieldValues(taskId, field) {
        return from(this.taskFormsApi.getRestFieldValues(taskId, field))
            .pipe(catchError((err) => this.handleError(err)));
    }
    getRestFieldValuesByProcessId(processDefinitionId, field) {
        return from(this.processDefinitionsApi.getRestFieldValues(processDefinitionId, field))
            .pipe(catchError((err) => this.handleError(err)));
    }
    getRestFieldValuesColumnByProcessId(processDefinitionId, field, column) {
        return from(this.processDefinitionsApi.getRestTableFieldValues(processDefinitionId, field, column))
            .pipe(catchError((err) => this.handleError(err)));
    }
    getRestFieldValuesColumn(taskId, field, column) {
        return from(this.taskFormsApi.getRestFieldColumnValues(taskId, field, column))
            .pipe(catchError((err) => this.handleError(err)));
    }
    getUserProfileImageApi(userId) {
        return this.usersApi.getUserProfilePictureUrl(userId);
    }
    getWorkflowUsers(filter, groupId) {
        const option = { filter: filter };
        if (groupId) {
            option.groupId = groupId;
        }
        return from(this.usersApi.getUsers(option))
            .pipe(switchMap(response => response.data || []), map((user) => {
            user.userImage = this.getUserProfileImageApi(user.id.toString());
            return of(user);
        }), combineAll(), defaultIfEmpty([]), catchError((err) => this.handleError(err)));
    }
    getWorkflowGroups(filter, groupId) {
        const option = { filter: filter };
        if (groupId) {
            option.groupId = groupId;
        }
        return from(this.groupsApi.getGroups(option))
            .pipe(map((response) => response.data || []), catchError((err) => this.handleError(err)));
    }
    getFormId(form) {
        let result = null;
        if (form && form.data && form.data.length > 0) {
            result = form.data[0].id;
        }
        return result;
    }
    toJson(res) {
        if (res) {
            return res || {};
        }
        return {};
    }
    toJsonArray(res) {
        if (res) {
            return res.data || [];
        }
        return [];
    }
    handleError(error) {
        let errMsg = FormService.UNKNOWN_ERROR_MESSAGE;
        if (error) {
            errMsg = (error.message) ? error.message :
                error.status ? `${error.status} - ${error.statusText}` : FormService.GENERIC_ERROR_MESSAGE;
        }
        this.logService.error(errMsg);
        return throwError(errMsg);
    }
}
FormService.UNKNOWN_ERROR_MESSAGE = 'Unknown error';
FormService.GENERIC_ERROR_MESSAGE = 'Server error';
FormService.ɵprov = ɵɵdefineInjectable({ factory: function FormService_Factory() { return new FormService(ɵɵinject(EcmModelService), ɵɵinject(AlfrescoApiService), ɵɵinject(LogService)); }, token: FormService, providedIn: "root" });
FormService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
FormService.ctorParameters = () => [
    { type: EcmModelService },
    { type: AlfrescoApiService },
    { type: LogService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class WidgetComponent {
    constructor(formService) {
        this.formService = formService;
        this.readOnly = false;
        this.fieldChanged = new EventEmitter();
    }
    hasField() {
        return !!this.field;
    }
    isRequired() {
        if (this.field && this.field.required) {
            return true;
        }
        return null;
    }
    isValid() {
        return !!this.field.validationSummary;
    }
    hasValue() {
        return this.field &&
            this.field.value !== null &&
            this.field.value !== undefined;
    }
    isInvalidFieldRequired() {
        return !this.field.isValid && !this.field.validationSummary && this.isRequired();
    }
    ngAfterViewInit() {
        this.fieldChanged.emit(this.field);
    }
    checkVisibility(field) {
        this.fieldChanged.emit(field);
    }
    onFieldChanged(field) {
        this.fieldChanged.emit(field);
    }
    event(event) {
        this.formService.formEvents.next(event);
    }
}
WidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'base-widget',
                template: '',
                host: {
                    '(click)': 'event($event)',
                    '(blur)': 'event($event)',
                    '(change)': 'event($event)',
                    '(focus)': 'event($event)',
                    '(focusin)': 'event($event)',
                    '(focusout)': 'event($event)',
                    '(input)': 'event($event)',
                    '(invalid)': 'event($event)',
                    '(select)': 'event($event)'
                },
                encapsulation: ViewEncapsulation.None
            },] }
];
WidgetComponent.ctorParameters = () => [
    { type: FormService }
];
WidgetComponent.propDecorators = {
    readOnly: [{ type: Input }],
    field: [{ type: Input }],
    fieldChanged: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ContainerWidgetComponentModel extends ContainerModel {
    constructor(field) {
        super(field);
        this.columns = [];
        this.isExpanded = true;
        this.rowspan = 1;
        this.colspan = 1;
        if (this.field) {
            this.columns = this.field.columns || [];
            this.isExpanded = !this.isCollapsedByDefault();
            this.colspan = field.colspan;
            this.rowspan = field.rowspan;
        }
    }
    isGroup() {
        return this.type === FormFieldTypes.GROUP;
    }
    isCollapsible() {
        let allowCollapse = false;
        if (this.isGroup() && this.field.params['allowCollapse']) {
            allowCollapse = this.field.params['allowCollapse'];
        }
        return allowCollapse;
    }
    isCollapsedByDefault() {
        let collapseByDefault = false;
        if (this.isCollapsible() && this.field.params['collapseByDefault']) {
            collapseByDefault = this.field.params['collapseByDefault'];
        }
        return collapseByDefault;
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ContainerWidgetComponent extends WidgetComponent {
    constructor(formService) {
        super(formService);
        this.formService = formService;
    }
    onExpanderClicked() {
        if (this.content && this.content.isCollapsible()) {
            this.content.isExpanded = !this.content.isExpanded;
        }
    }
    ngOnInit() {
        if (this.field) {
            this.content = new ContainerWidgetComponentModel(this.field);
            this.getNumberOfColumnsFromTheBiggestBetweenJsonAndColumnsLengthOrOne();
            this.fields = this.getFields();
        }
    }
    getNumberOfColumnsFromTheBiggestBetweenJsonAndColumnsLengthOrOne() {
        var _a, _b, _c, _d;
        this.numberOfColumns = (((_a = this.content.json) === null || _a === void 0 ? void 0 : _a.numberOfColumns) || 1) > (((_b = this.content.columns) === null || _b === void 0 ? void 0 : _b.length) || 1) ?
            (((_c = this.content.json) === null || _c === void 0 ? void 0 : _c.numberOfColumns) || 1) :
            (((_d = this.content.columns) === null || _d === void 0 ? void 0 : _d.length) || 1);
    }
    getFields() {
        var _a;
        const serialisedFormFields = [];
        const maxColumnFieldsSize = this.getMaxColumnFieldSize();
        for (let rowIndex = 0; rowIndex < maxColumnFieldsSize; rowIndex++) {
            (_a = this.content) === null || _a === void 0 ? void 0 : _a.columns.flatMap((currentColumn) => {
                var _a;
                if (!!(currentColumn === null || currentColumn === void 0 ? void 0 : currentColumn.fields[rowIndex])) {
                    serialisedFormFields.push(currentColumn === null || currentColumn === void 0 ? void 0 : currentColumn.fields[rowIndex]);
                }
                else {
                    const firstRowElementColSpan = (_a = currentColumn === null || currentColumn === void 0 ? void 0 : currentColumn.fields[0]) === null || _a === void 0 ? void 0 : _a.colspan;
                    if (!!firstRowElementColSpan && rowIndex > 0) {
                        for (let i = 0; i < firstRowElementColSpan; i++) {
                            serialisedFormFields.push(null);
                        }
                    }
                }
            });
        }
        return serialisedFormFields;
    }
    getMaxColumnFieldSize() {
        var _a, _b, _c, _d, _e, _f;
        let maxFieldSize = 0;
        if (((_b = (_a = this.content) === null || _a === void 0 ? void 0 : _a.columns) === null || _b === void 0 ? void 0 : _b.length) > 0) {
            maxFieldSize = (_f = (_e = (_d = (_c = this.content) === null || _c === void 0 ? void 0 : _c.columns) === null || _d === void 0 ? void 0 : _d.reduce((prevColumn, currentColumn) => {
                var _a;
                return currentColumn.fields.length > ((_a = prevColumn === null || prevColumn === void 0 ? void 0 : prevColumn.fields) === null || _a === void 0 ? void 0 : _a.length) ? currentColumn : prevColumn;
            })) === null || _e === void 0 ? void 0 : _e.fields) === null || _f === void 0 ? void 0 : _f.length;
        }
        return maxFieldSize;
    }
    getColumnWith(field) {
        const colspan = field ? field.colspan : 1;
        return (100 / this.content.json.numberOfColumns) * colspan + '';
    }
}
ContainerWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'container-widget',
                template: "<div [hidden]=\"!content?.isGroup()\" class=\"adf-container-widget__header\">\n    <h4 class=\"adf-container-widget__header-text\" id=\"container-header\"\n        [class.adf-collapsible]=\"content?.isCollapsible()\">\n        <button *ngIf=\"content?.isCollapsible()\"\n                mat-icon-button\n                class=\"mdl-button--icon\"\n                (click)=\"onExpanderClicked()\">\n            <mat-icon>{{ content?.isExpanded ? 'expand_more' : 'expand_less' }}</mat-icon>\n        </button>\n        <span (click)=\"onExpanderClicked()\" id=\"container-header-label\">{{content.name | translate }}</span>\n    </h4>\n</div>\n\n<div *ngIf=\"field?.form?.enableFixedSpace else fixingTemplate\">\n    <div class=\"adf-grid-list\" [ngStyle]=\"{ 'grid-template-columns': 'repeat('+numberOfColumns+', 1fr)'}\"\n        *ngIf=\"content?.isExpanded\">\n        <div class=\"adf-grid-list-item\" *ngFor=\"let field of fields\"\n            [ngStyle]=\"{'grid-area': 'auto / auto / span '+(field?.rowspan || 1)+' / span '+(field?.colspan || 1)}\">\n            <adf-form-field *ngIf=\"field\" [field]=\"field\"></adf-form-field>\n        </div>\n    </div>\n</div>\n\n<ng-template #fixingTemplate>\n    <section class=\"adf-grid-list-column-view\" *ngIf=\"content?.isExpanded\">\n        <div class=\"adf-grid-list-single-column\" *ngFor=\"let column of content?.columns\" [style.width.%]=\"getColumnWith(field)\">\n            <div class=\"adf-grid-list-column-view-item\" *ngFor=\"let field of column?.fields\">\n                <adf-form-field *ngIf=\"field\" [field]=\"field\"></adf-form-field>\n            </div>\n        </div>\n    </section>\n</ng-template>\n",
                host: {
                    '(click)': 'event($event)',
                    '(blur)': 'event($event)',
                    '(change)': 'event($event)',
                    '(focus)': 'event($event)',
                    '(focusin)': 'event($event)',
                    '(focusout)': 'event($event)',
                    '(input)': 'event($event)',
                    '(invalid)': 'event($event)',
                    '(select)': 'event($event)'
                },
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-hidden{display:none}.adf-container-widget__header-text{-moz-user-select:none;-ms-user-select:none;-webkit-touch-callout:none;-webkit-user-select:none;border-bottom:1px solid rgba(0,0,0,.87);cursor:default;padding-bottom:10px;user-select:none}.adf-container-widget__header-text.adf-collapsible{cursor:pointer}.adf-field-list{height:100%;list-style-type:none;padding:0;width:100%}container-widget .adf-grid-list-column-view{align-items:flex-start;display:flex;margin-right:-1%}container-widget .adf-grid-list-single-column{align-items:flex-start;display:flex;flex:1 1 auto;flex-direction:column}container-widget .adf-grid-list-column-view-item{box-sizing:border-box;flex-grow:1;padding-left:1%;padding-right:1%;width:100%}container-widget .adf-grid-list{display:grid}container-widget .adf-grid-list-item{box-sizing:border-box;padding-left:3px;padding-right:3px}@media screen and (max-width:959px){container-widget .adf-grid-list-item{flex:1 0 100%}container-widget .adf-grid-list--column-view{flex-direction:column}container-widget .adf-grid-list-single-column{width:90%!important}container-widget .adf-grid-list-column-view-item{flex:1 0 auto}}container-widget .mat-form-field,container-widget mat-form-field{width:100%}container-widget .mat-input-placeholder{top:1.8em!important}container-widget .mat-focused label{background-color:.3s cubic-bezier(.55,0,.55,.2);color:var(--theme-primary-color);transform:scaleX(1);transition:transform .15s linear}container-widget .mat-focused .mat-form-field-prefix{color:var(--theme-primary-color)}container-widget .mat-grid-tile{overflow:visible;width:80%}container-widget adf-form-field{width:100%}"]
            },] }
];
ContainerWidgetComponent.ctorParameters = () => [
    { type: FormService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TabsWidgetComponent {
    constructor() {
        this.tabs = [];
        this.formTabChanged = new EventEmitter();
        this.visibleTabs = [];
    }
    hasTabs() {
        return this.tabs && this.tabs.length > 0;
    }
    ngAfterContentChecked() {
        this.filterVisibleTabs();
    }
    filterVisibleTabs() {
        this.visibleTabs = this.tabs.filter((tab) => {
            return tab.isVisible;
        });
    }
    tabChanged(field) {
        this.formTabChanged.emit(field);
    }
}
TabsWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'tabs-widget',
                template: "<div *ngIf=\"hasTabs()\" class=\"alfresco-tabs-widget\">\n    <mat-tab-group>\n        <mat-tab *ngFor=\"let tab of visibleTabs\" [label]=\"tab.title | translate\">\n            <div *ngFor=\"let field of tab.fields\">\n                <adf-form-field [field]=\"field.field\"></adf-form-field>\n             </div>\n        </mat-tab>\n    </mat-tab-group>\n</div>\n",
                encapsulation: ViewEncapsulation.None
            },] }
];
TabsWidgetComponent.propDecorators = {
    tabs: [{ type: Input }],
    formTabChanged: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class UnknownWidgetComponent extends WidgetComponent {
    constructor(formService) {
        super(formService);
        this.formService = formService;
    }
}
UnknownWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'unknown-widget',
                template: `
            <mat-list class="adf-unknown-widget">
                <mat-list-item>
                     <mat-icon class="mat-24">error_outline</mat-icon>
                     <span class="adf-unknown-text">Unknown type: {{field.type}}</span>
                </mat-list-item>
            </mat-list>

    `,
                host: {
                    '(click)': 'event($event)',
                    '(blur)': 'event($event)',
                    '(change)': 'event($event)',
                    '(focus)': 'event($event)',
                    '(focusin)': 'event($event)',
                    '(focusout)': 'event($event)',
                    '(input)': 'event($event)',
                    '(invalid)': 'event($event)',
                    '(select)': 'event($event)'
                },
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-unknown-text{color:red;margin-left:10px}.adf-unknown-widget{margin:42px}"]
            },] }
];
UnknownWidgetComponent.ctorParameters = () => [
    { type: FormService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ADF_AMOUNT_SETTINGS = new InjectionToken('adf-amount-settings');
class AmountWidgetComponent extends WidgetComponent {
    constructor(formService, settings) {
        super(formService);
        this.formService = formService;
        this.settings = settings;
        this.showPlaceholder = true;
        this.currency = AmountWidgetComponent.DEFAULT_CURRENCY;
    }
    get placeholder() {
        return this.showPlaceholder ? this.field.placeholder : '';
    }
    ngOnInit() {
        if (this.field) {
            if (this.field.currency) {
                this.currency = this.field.currency;
            }
            if (this.field.readOnly) {
                this.showPlaceholder = this.settings && this.settings.showReadonlyPlaceholder;
            }
        }
    }
}
AmountWidgetComponent.DEFAULT_CURRENCY = '$';
AmountWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'amount-widget',
                template: "<div class=\"adf-amount-widget__container adf-amount-widget {{field.className}}\"\n     [class.adf-invalid]=\"!field.isValid\"\n     [class.adf-readonly]=\"field.readOnly\">\n    <label class=\"adf-label\"\n           [attr.for]=\"field.id\">{{field.name | translate }}<span *ngIf=\"isRequired()\">*</span></label>\n    <mat-form-field class=\"adf-amount-widget__input\">\n        <span matPrefix class=\"adf-amount-widget__prefix-spacing\">{{ currency }} &nbsp;</span>\n        <input matInput\n               [matTooltip]=\"field.tooltip\"\n               matTooltipPosition=\"above\"\n               matTooltipShowDelay=\"1000\"\n               class=\"adf-input\"\n               type=\"text\"\n               [id]=\"field.id\"\n               [required]=\"isRequired()\"\n               [placeholder]=\"placeholder\"\n               [value]=\"field.value\"\n               [(ngModel)]=\"field.value\"\n               (ngModelChange)=\"onFieldChanged(field)\"\n               [disabled]=\"field.readOnly\">\n    </mat-form-field>\n    <error-widget [error]=\"field.validationSummary\"></error-widget>\n    <error-widget *ngIf=\"isInvalidFieldRequired()\"\n                  required=\"{{ 'FORM.FIELD.REQUIRED' | translate }}\"></error-widget>\n</div>\n",
                host: {
                    '(click)': 'event($event)',
                    '(blur)': 'event($event)',
                    '(change)': 'event($event)',
                    '(focus)': 'event($event)',
                    '(focusin)': 'event($event)',
                    '(focusout)': 'event($event)',
                    '(input)': 'event($event)',
                    '(invalid)': 'event($event)',
                    '(select)': 'event($event)'
                },
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-amount-widget{margin-top:15px;width:100%}.adf-amount-widget__input{margin-top:-15px}.adf-amount-widget__input .mat-focused{transition:none}.adf-amount-widget__input:not(.mat-focused):not(.mat-form-field-invalid) .adf-amount-widget__prefix-spacing{color:var(--theme-secondary-text-color)}"]
            },] }
];
AmountWidgetComponent.ctorParameters = () => [
    { type: FormService },
    { type: undefined, decorators: [{ type: Inject, args: [ADF_AMOUNT_SETTINGS,] }, { type: Optional }] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CheckboxWidgetComponent extends WidgetComponent {
    constructor(formService) {
        super(formService);
        this.formService = formService;
    }
}
CheckboxWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'checkbox-widget',
                template: "<div [ngClass]=\"field.className\"\n     [class.adf-invalid]=\"!field.isValid\">\n    <mat-checkbox\n        [id]=\"field.id\"\n        color=\"primary\"\n        [required]=\"field.required\"\n        [disabled]=\"field.readOnly || readOnly\"\n        [(ngModel)]=\"field.value\"\n        (ngModelChange)=\"onFieldChanged(field)\"\n        [matTooltip]=\"field.tooltip\"\n        matTooltipPosition=\"right\"\n        matTooltipShowDelay=\"1000\">\n        {{field.name | translate }}\n        <span *ngIf=\"field.required\" >*</span>\n    </mat-checkbox>\n</div>\n",
                host: {
                    '(click)': 'event($event)',
                    '(blur)': 'event($event)',
                    '(change)': 'event($event)',
                    '(focus)': 'event($event)',
                    '(focusin)': 'event($event)',
                    '(focusout)': 'event($event)',
                    '(input)': 'event($event)',
                    '(invalid)': 'event($event)',
                    '(select)': 'event($event)'
                },
                encapsulation: ViewEncapsulation.None
            },] }
];
CheckboxWidgetComponent.ctorParameters = () => [
    { type: FormService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ɵ0$2 = MOMENT_DATE_FORMATS;
class DateWidgetComponent extends WidgetComponent {
    constructor(formService, dateAdapter, userPreferencesService) {
        super(formService);
        this.formService = formService;
        this.dateAdapter = dateAdapter;
        this.userPreferencesService = userPreferencesService;
        this.DATE_FORMAT = 'DD-MM-YYYY';
        this.onDestroy$ = new Subject();
    }
    ngOnInit() {
        this.userPreferencesService
            .select(UserPreferenceValues.Locale)
            .pipe(takeUntil(this.onDestroy$))
            .subscribe(locale => this.dateAdapter.setLocale(locale));
        const momentDateAdapter = this.dateAdapter;
        momentDateAdapter.overrideDisplayFormat = this.field.dateDisplayFormat;
        if (this.field) {
            if (this.field.minValue) {
                this.minDate = moment(this.field.minValue, this.DATE_FORMAT);
            }
            if (this.field.maxValue) {
                this.maxDate = moment(this.field.maxValue, this.DATE_FORMAT);
            }
        }
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
    onDateChanged(newDateValue) {
        const date = moment(newDateValue, this.field.dateDisplayFormat, true);
        if (date.isValid()) {
            this.field.value = date.format(this.field.dateDisplayFormat);
        }
        else {
            this.field.value = newDateValue;
        }
        this.onFieldChanged(this.field);
    }
}
DateWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'date-widget',
                providers: [
                    { provide: DateAdapter, useClass: MomentDateAdapter },
                    { provide: MAT_DATE_FORMATS, useValue: ɵ0$2 }
                ],
                template: "<div class=\"{{field.className}}\" id=\"data-widget\" [class.adf-invalid]=\"!field.isValid\">\n    <mat-form-field class=\"adf-date-widget\">\n        <label class=\"adf-label\" [attr.for]=\"field.id\">{{field.name | translate }} ({{field.dateDisplayFormat}})<span *ngIf=\"isRequired()\">*</span></label>\n        <input matInput\n               [id]=\"field.id\"\n               [value]=\"field.value\"\n               [required]=\"isRequired()\"\n               [disabled]=\"field.readOnly\"\n               (change)=\"onDateChanged($any($event).srcElement.value)\"\n               [placeholder]=\"field.placeholder\">\n        <mat-datepicker-toggle  matSuffix [for]=\"datePicker\" [disabled]=\"field.readOnly\" ></mat-datepicker-toggle>\n    </mat-form-field>\n    <error-widget [error]=\"field.validationSummary\"></error-widget>\n    <error-widget *ngIf=\"isInvalidFieldRequired()\" required=\"{{ 'FORM.FIELD.REQUIRED' | translate }}\"></error-widget>\n    <mat-datepicker #datePicker [touchUi]=\"true\" [startAt]=\"field.value | adfMomentDate: field.dateDisplayFormat\" [disabled]=\"field.readOnly\"></mat-datepicker>\n    <input\n        type=\"hidden\"\n        [matDatepicker]=\"datePicker\"\n        [value]=\"field.value | adfMomentDate: field.dateDisplayFormat\"\n        [min]=\"minDate\"\n        [max]=\"maxDate\"\n        [disabled]=\"field.readOnly\"\n        (dateInput)=\"onDateChanged($any($event).targetElement.value)\">\n</div>\n",
                host: {
                    '(click)': 'event($event)',
                    '(blur)': 'event($event)',
                    '(change)': 'event($event)',
                    '(focus)': 'event($event)',
                    '(focusin)': 'event($event)',
                    '(focusout)': 'event($event)',
                    '(input)': 'event($event)',
                    '(invalid)': 'event($event)',
                    '(select)': 'event($event)'
                },
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-date-widget .mat-form-field-suffix{top:26px}.adf-date-widget .mat-form-field-label-wrapper{top:20px}"]
            },] }
];
DateWidgetComponent.ctorParameters = () => [
    { type: FormService },
    { type: DateAdapter },
    { type: UserPreferencesService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DisplayTextWidgetComponent extends WidgetComponent {
    constructor(formService) {
        super(formService);
        this.formService = formService;
    }
}
DisplayTextWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'display-text-widget',
                template: "<div [matTooltip]=\"field.tooltip\" matTooltipPosition=\"above\" matTooltipShowDelay=\"1000\"\n    class=\"adf-display-text-widget {{field.className}}\">{{field.value | translate}}</div>\n",
                host: {
                    '(click)': 'event($event)',
                    '(blur)': 'event($event)',
                    '(change)': 'event($event)',
                    '(focus)': 'event($event)',
                    '(focusin)': 'event($event)',
                    '(focusout)': 'event($event)',
                    '(input)': 'event($event)',
                    '(invalid)': 'event($event)',
                    '(select)': 'event($event)'
                },
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-display-text-widget{white-space:pre-wrap}"]
            },] }
];
DisplayTextWidgetComponent.ctorParameters = () => [
    { type: FormService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DocumentWidgetComponent extends WidgetComponent {
    constructor(formService) {
        super(formService);
        this.formService = formService;
        this.fileId = null;
        this.hasFile = false;
    }
    ngOnInit() {
        if (this.field) {
            const file = this.field.value;
            if (file) {
                this.fileId = file.id;
                this.hasFile = true;
            }
            else {
                this.fileId = null;
                this.hasFile = false;
            }
        }
    }
}
DocumentWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-form-document-widget',
                template: "<div class=\"adf-form-document-widget {{field.className}}\">\n    <ng-container *ngIf=\"hasFile\">\n        <adf-content [id]=\"fileId\" [showDocumentContent]=\"true\"></adf-content>\n    </ng-container>\n</div>\n",
                host: {
                    '(click)': 'event($event)',
                    '(blur)': 'event($event)',
                    '(change)': 'event($event)',
                    '(focus)': 'event($event)',
                    '(focusin)': 'event($event)',
                    '(focusout)': 'event($event)',
                    '(input)': 'event($event)',
                    '(invalid)': 'event($event)',
                    '(select)': 'event($event)'
                },
                encapsulation: ViewEncapsulation.None
            },] }
];
DocumentWidgetComponent.ctorParameters = () => [
    { type: FormService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DropdownWidgetComponent extends WidgetComponent {
    constructor(formService, logService) {
        super(formService);
        this.formService = formService;
        this.logService = logService;
    }
    ngOnInit() {
        if (this.field && this.field.restUrl) {
            if (this.field.form.taskId) {
                this.getValuesByTaskId();
            }
            else {
                this.getValuesByProcessDefinitionId();
            }
        }
    }
    getValuesByTaskId() {
        this.formService
            .getRestFieldValues(this.field.form.taskId, this.field.id)
            .subscribe((formFieldOption) => {
            const options = [];
            if (this.field.emptyOption) {
                options.push(this.field.emptyOption);
            }
            this.field.options = options.concat((formFieldOption || []));
            this.field.updateForm();
        }, (err) => this.handleError(err));
    }
    getValuesByProcessDefinitionId() {
        this.formService
            .getRestFieldValuesByProcessId(this.field.form.processDefinitionId, this.field.id)
            .subscribe((formFieldOption) => {
            const options = [];
            if (this.field.emptyOption) {
                options.push(this.field.emptyOption);
            }
            this.field.options = options.concat((formFieldOption || []));
            this.field.updateForm();
        }, (err) => this.handleError(err));
    }
    getOptionValue(option, fieldValue) {
        let optionValue = '';
        if (option.id === 'empty' || option.name !== fieldValue) {
            optionValue = option.id;
        }
        else {
            optionValue = option.name;
        }
        return optionValue;
    }
    handleError(error) {
        this.logService.error(error);
    }
    isReadOnlyType() {
        return this.field.type === 'readonly';
    }
}
DropdownWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'dropdown-widget',
                template: "<div class=\"adf-dropdown-widget {{field.className}}\"\n     [class.adf-invalid]=\"!field.isValid\" [class.adf-readonly]=\"field.readOnly\">\n    <label class=\"adf-label\" [attr.for]=\"field.id\">{{field.name | translate }}<span *ngIf=\"isRequired()\">*</span></label>\n    <mat-form-field>\n        <mat-select class=\"adf-select\"\n                    [id]=\"field.id\"\n                    [(ngModel)]=\"field.value\"\n                    [disabled]=\"field.readOnly\"\n                    (ngModelChange)=\"onFieldChanged(field)\">\n            <mat-option *ngFor=\"let opt of field.options\"\n                        [value]=\"getOptionValue(opt, field.value)\"\n                        [id]=\"opt.id\">{{opt.name}}\n            </mat-option>\n            <mat-option id=\"readonlyOption\" *ngIf=\"isReadOnlyType()\" [value]=\"field.value\">{{field.value}}</mat-option>\n        </mat-select>\n    </mat-form-field>\n    <error-widget [error]=\"field.validationSummary\"></error-widget>\n    <error-widget class=\"adf-dropdown-required-message\" *ngIf=\"isInvalidFieldRequired()\"\n                  required=\"{{ 'FORM.FIELD.REQUIRED' | translate }}\"></error-widget>\n</div>\n",
                host: {
                    '(click)': 'event($event)',
                    '(blur)': 'event($event)',
                    '(change)': 'event($event)',
                    '(focus)': 'event($event)',
                    '(focusin)': 'event($event)',
                    '(focusout)': 'event($event)',
                    '(input)': 'event($event)',
                    '(invalid)': 'event($event)',
                    '(select)': 'event($event)'
                },
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-dropdown-widget{width:100%}.adf-dropdown-widget .adf-select{padding-top:0!important;width:100%}.adf-dropdown-widget .mat-select-value-text{font-size:14px}.adf-dropdown-widget-select{width:100%}"]
            },] }
];
DropdownWidgetComponent.ctorParameters = () => [
    { type: FormService },
    { type: LogService }
];

class WidgetVisibilityService {
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
    }
    get taskFormsApi() {
        var _a;
        this._taskFormsApi = (_a = this._taskFormsApi) !== null && _a !== void 0 ? _a : new TaskFormsApi(this.apiService.getInstance());
        return this._taskFormsApi;
    }
    refreshVisibility(form, processVarList) {
        this.form = form;
        if (processVarList) {
            this.processVarList = processVarList;
        }
        if (form && form.tabs && form.tabs.length > 0) {
            form.tabs.map((tabModel) => this.refreshEntityVisibility(tabModel));
        }
        if (form && form.outcomes && form.outcomes.length > 0) {
            form.outcomes.map((outcomeModel) => this.refreshOutcomeVisibility(outcomeModel));
        }
        if (form) {
            form.getFormFields().map((field) => this.refreshEntityVisibility(field));
        }
    }
    refreshEntityVisibility(element) {
        const visible = this.evaluateVisibility(element.form, element.visibilityCondition);
        element.isVisible = visible && this.isParentTabVisible(this.form, element);
    }
    refreshOutcomeVisibility(element) {
        element.isVisible = this.evaluateVisibility(element.form, element.visibilityCondition);
    }
    evaluateVisibility(form, visibilityObj) {
        const isLeftFieldPresent = visibilityObj && (visibilityObj.leftType || visibilityObj.leftValue);
        if (!isLeftFieldPresent || isLeftFieldPresent === 'null') {
            return true;
        }
        else {
            return this.isFieldVisible(form, visibilityObj);
        }
    }
    isFieldVisible(form, visibilityObj, accumulator = [], result = false) {
        const leftValue = this.getLeftValue(form, visibilityObj);
        const rightValue = this.getRightValue(form, visibilityObj);
        const actualResult = this.evaluateCondition(leftValue, rightValue, visibilityObj.operator);
        accumulator.push({ value: actualResult, operator: visibilityObj.nextConditionOperator });
        if (this.isValidCondition(visibilityObj.nextCondition)) {
            result = this.isFieldVisible(form, visibilityObj.nextCondition, accumulator);
        }
        else if (accumulator[0] !== undefined) {
            result = Function('"use strict";return (' +
                accumulator.map((expression) => this.transformToLiteralExpression(expression)).join('') +
                ')')();
        }
        else {
            result = actualResult;
        }
        return !!result;
    }
    transformToLiteralExpression(currentExpression) {
        const currentTransformedValue = !!currentExpression.value ? 'true' : 'false';
        return currentTransformedValue.concat(this.transformToLiteralOperator(currentExpression.operator));
    }
    transformToLiteralOperator(currentOperator) {
        switch (currentOperator) {
            case 'and':
                return '&&';
            case 'or':
                return '||';
            case 'and-not':
                return '&& !';
            case 'or-not':
                return '|| !';
            default:
                return '';
        }
    }
    getLeftValue(form, visibilityObj) {
        let leftValue = '';
        if (visibilityObj.leftType && visibilityObj.leftType === WidgetTypeEnum.variable) {
            leftValue = this.getVariableValue(form, visibilityObj.leftValue, this.processVarList);
        }
        else if (visibilityObj.leftType && visibilityObj.leftType === WidgetTypeEnum.field) {
            leftValue = this.getFormValue(form, visibilityObj.leftValue);
            if (leftValue === undefined || leftValue === '') {
                const variableValue = this.getVariableValue(form, visibilityObj.leftValue, this.processVarList);
                leftValue = !this.isInvalidValue(variableValue) ? variableValue : leftValue;
            }
        }
        return leftValue;
    }
    getRightValue(form, visibilityObj) {
        let valueFound = '';
        if (visibilityObj.rightType === WidgetTypeEnum.variable) {
            valueFound = this.getVariableValue(form, visibilityObj.rightValue, this.processVarList);
        }
        else if (visibilityObj.rightType === WidgetTypeEnum.field) {
            valueFound = this.getFormValue(form, visibilityObj.rightValue);
        }
        else {
            if (moment(visibilityObj.rightValue, 'YYYY-MM-DD', true).isValid()) {
                valueFound = visibilityObj.rightValue + 'T00:00:00.000Z';
            }
            else {
                valueFound = visibilityObj.rightValue;
            }
        }
        return valueFound;
    }
    getFormValue(form, fieldId) {
        const formField = this.getFormFieldById(form, fieldId);
        let value = undefined;
        if (this.isFormFieldValid(formField)) {
            value = this.getFieldValue(form.values, fieldId);
            if (this.isInvalidValue(value)) {
                value = this.searchValueInForm(formField, fieldId);
            }
        }
        return value;
    }
    isFormFieldValid(formField) {
        return formField && formField.isValid;
    }
    getFieldValue(valueList, fieldId) {
        let labelFilterByName, valueFound;
        if (fieldId && fieldId.indexOf('_LABEL') > 0) {
            labelFilterByName = fieldId.substring(0, fieldId.length - 6);
            if (valueList[labelFilterByName]) {
                if (Array.isArray(valueList[labelFilterByName])) {
                    valueFound = valueList[labelFilterByName].map(({ name }) => name);
                }
                else {
                    valueFound = valueList[labelFilterByName].name;
                }
            }
        }
        else if (valueList[fieldId] && valueList[fieldId].id) {
            valueFound = valueList[fieldId].id;
        }
        else if (valueList[fieldId] && Array.isArray(valueList[fieldId])) {
            valueFound = valueList[fieldId].map(({ id }) => id);
        }
        else {
            valueFound = valueList[fieldId];
        }
        return valueFound;
    }
    isInvalidValue(value) {
        return value === undefined || value === null;
    }
    getFormFieldById(form, fieldId) {
        return form.getFormFields().find((formField) => this.isSearchedField(formField, fieldId));
    }
    searchValueInForm(formField, fieldId) {
        let fieldValue = '';
        if (formField) {
            fieldValue = this.getObjectValue(formField, fieldId);
            if (!fieldValue) {
                if (formField.value && formField.value.id) {
                    fieldValue = formField.value.id;
                }
                else if (!this.isInvalidValue(formField.value)) {
                    fieldValue = formField.value;
                }
            }
        }
        return fieldValue;
    }
    isParentTabVisible(form, currentFormField) {
        const containers = this.getFormTabContainers(form);
        let isVisible = true;
        containers.map((container) => {
            if (!!this.getCurrentFieldFromTabById(container, currentFormField.id)) {
                const currentTab = form.tabs.find((tab) => tab.id === container.tab);
                if (!!currentTab) {
                    isVisible = currentTab.isVisible;
                }
            }
        });
        return isVisible;
    }
    getCurrentFieldFromTabById(container, fieldId) {
        const tabFields = Object.keys(container.field.fields).map(key => container.field.fields[key]);
        let currentField;
        for (const tabField of tabFields) {
            currentField = tabField.find((tab) => tab.id === fieldId);
            if (currentField) {
                return currentField;
            }
        }
        return null;
    }
    getFormTabContainers(form) {
        if (!!form) {
            return form.fields.filter(field => field.type === 'container' && field.tab);
        }
        return [];
    }
    getObjectValue(field, fieldId) {
        let value = '';
        if (field.value && field.value.name) {
            value = field.value.name;
        }
        else if (field.options) {
            const option = field.options.find((opt) => opt.id === field.value);
            if (option) {
                value = this.getValueFromOption(fieldId, option);
            }
        }
        return value;
    }
    getValueFromOption(fieldId, option) {
        let optionValue = '';
        if (fieldId && fieldId.indexOf('_LABEL') > 0) {
            optionValue = option.name;
        }
        else {
            optionValue = option.id;
        }
        return optionValue;
    }
    isSearchedField(field, fieldId) {
        const fieldToFind = (fieldId === null || fieldId === void 0 ? void 0 : fieldId.indexOf('_LABEL')) > 0 ? fieldId.replace('_LABEL', '') : fieldId;
        return (field.id && fieldToFind) ? field.id.toUpperCase() === fieldToFind.toUpperCase() : false;
    }
    getVariableValue(form, name, processVarList) {
        const processVariableValue = this.getProcessVariableValue(name, processVarList);
        const variableDefaultValue = form.getFormVariableValue(name);
        return (processVariableValue === undefined) ? variableDefaultValue : processVariableValue;
    }
    getProcessVariableValue(name, processVarList) {
        if (processVarList) {
            const processVariable = processVarList.find(variable => variable.id === name ||
                variable.id === `variables.${name}`);
            if (processVariable) {
                return processVariable.value;
            }
        }
        return undefined;
    }
    evaluateCondition(leftValue, rightValue, operator) {
        switch (operator) {
            case '==':
                return leftValue + '' === rightValue + '';
            case '<':
                return leftValue < rightValue;
            case '!=':
                return leftValue + '' !== rightValue + '';
            case '>':
                return leftValue > rightValue;
            case '>=':
                return leftValue >= rightValue;
            case '<=':
                return leftValue <= rightValue;
            case 'empty':
                return leftValue ? leftValue === '' : true;
            case '!empty':
                return leftValue ? leftValue !== '' : false;
            case 'contains':
                return this.contains(leftValue, rightValue);
            case '!contains':
                return !this.contains(leftValue, rightValue);
            default:
                this.logService.error(`Invalid operator: ${operator}`);
                return undefined;
        }
    }
    contains(leftValue, rightValue) {
        return Array.isArray(leftValue) && Array.isArray(rightValue) && rightValue.every((element) => leftValue.includes(element));
    }
    cleanProcessVariable() {
        this.processVarList = [];
    }
    getTaskProcessVariable(taskId) {
        return from(this.taskFormsApi.getTaskFormVariables(taskId))
            .pipe(map((res) => {
            const jsonRes = this.toJson(res);
            this.processVarList = jsonRes;
            return jsonRes;
        }), catchError(() => this.handleError()));
    }
    toJson(res) {
        return res || {};
    }
    isValidCondition(condition) {
        return !!(condition && condition.operator);
    }
    handleError() {
        this.logService.error('Error while performing a call');
        return throwError('Error while performing a call - Server error');
    }
}
WidgetVisibilityService.ɵprov = ɵɵdefineInjectable({ factory: function WidgetVisibilityService_Factory() { return new WidgetVisibilityService(ɵɵinject(AlfrescoApiService), ɵɵinject(LogService)); }, token: WidgetVisibilityService, providedIn: "root" });
WidgetVisibilityService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
WidgetVisibilityService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: LogService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ValidateDynamicTableRowEvent extends FormFieldEvent {
    constructor(form, field, row, summary) {
        super(form, field);
        this.row = row;
        this.summary = summary;
        this.isValid = true;
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DateCellValidator {
    constructor() {
        this.supportedTypes = [
            'Date'
        ];
    }
    isSupported(column) {
        return column && column.editable && this.supportedTypes.indexOf(column.type) > -1;
    }
    validate(row, column, summary) {
        if (this.isSupported(column)) {
            const value = row.value[column.id];
            if (!value && !column.required) {
                return true;
            }
            const dateValue = moment(value, 'YYYY-MM-DDTHH:mm:ss.SSSSZ', true);
            if (!dateValue.isValid()) {
                if (summary) {
                    summary.isValid = false;
                    summary.message = `Invalid '${column.name}' format.`;
                }
                return false;
            }
        }
        return true;
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DynamicRowValidationSummary extends ErrorMessageModel {
    constructor(json) {
        super(json);
        this.isValid = json.isValid;
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class NumberCellValidator {
    constructor() {
        this.supportedTypes = [
            'Number',
            'Amount'
        ];
    }
    isSupported(column) {
        return column && column.required && this.supportedTypes.indexOf(column.type) > -1;
    }
    isNumber(value) {
        if (value === null || value === undefined || value === '') {
            return false;
        }
        return !isNaN(+value);
    }
    validate(row, column, summary) {
        if (this.isSupported(column)) {
            const value = row.value[column.id];
            if (value === null ||
                value === undefined ||
                value === '' ||
                this.isNumber(value)) {
                return true;
            }
            if (summary) {
                summary.isValid = false;
                summary.message = `Field '${column.name}' must be a number.`;
            }
            return false;
        }
        return true;
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RequiredCellValidator {
    constructor() {
        this.supportedTypes = [
            'String',
            'Number',
            'Amount',
            'Date',
            'Dropdown'
        ];
    }
    isSupported(column) {
        return column && column.required && this.supportedTypes.indexOf(column.type) > -1;
    }
    validate(row, column, summary) {
        if (this.isSupported(column)) {
            const value = row.value[column.id];
            if (column.required) {
                if (value === null || value === undefined || value === '') {
                    if (summary) {
                        summary.isValid = false;
                        summary.message = `Field '${column.name}' is required.`;
                    }
                    return false;
                }
            }
        }
        return true;
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DynamicTableModel extends FormWidgetModel {
    constructor(field, formService) {
        super(field.form, field.json);
        this.formService = formService;
        this.columns = [];
        this.visibleColumns = [];
        this.rows = [];
        this._validators = [];
        this.field = field;
        if (field.json) {
            const columns = this.getColumns(field);
            if (columns) {
                this.columns = columns;
                this.visibleColumns = this.columns.filter((col) => col.visible);
            }
            if (field.json.value) {
                this.rows = field.json.value.map((obj) => ({ selected: false, value: obj }));
            }
        }
        this._validators = [
            new RequiredCellValidator(),
            new DateCellValidator(),
            new NumberCellValidator()
        ];
    }
    get selectedRow() {
        return this._selectedRow;
    }
    set selectedRow(value) {
        if (this._selectedRow && this._selectedRow === value) {
            this._selectedRow.selected = false;
            this._selectedRow = null;
            return;
        }
        this.rows.forEach((row) => row.selected = false);
        this._selectedRow = value;
        if (value) {
            this._selectedRow.selected = true;
        }
    }
    getColumns(field) {
        if (field && field.json) {
            let definitions = field.json.columnDefinitions;
            if (!definitions && field.json.params && field.json.params.field) {
                definitions = field.json.params.field.columnDefinitions;
            }
            if (definitions) {
                return definitions.map((obj) => obj);
            }
        }
        return null;
    }
    flushValue() {
        if (this.field) {
            this.field.value = this.rows.map((r) => r.value);
            this.field.updateForm();
        }
    }
    moveRow(row, offset) {
        const oldIndex = this.rows.indexOf(row);
        if (oldIndex > -1) {
            let newIndex = (oldIndex + offset);
            if (newIndex < 0) {
                newIndex = 0;
            }
            else if (newIndex >= this.rows.length) {
                newIndex = this.rows.length;
            }
            const arr = this.rows.slice();
            arr.splice(oldIndex, 1);
            arr.splice(newIndex, 0, row);
            this.rows = arr;
            this.flushValue();
        }
    }
    deleteRow(row) {
        if (row) {
            if (this.selectedRow === row) {
                this.selectedRow = null;
            }
            const idx = this.rows.indexOf(row);
            if (idx > -1) {
                this.rows.splice(idx, 1);
                this.flushValue();
            }
        }
    }
    addRow(row) {
        if (row) {
            this.rows.push(row);
        }
    }
    validateRow(row) {
        const summary = new DynamicRowValidationSummary({
            isValid: true,
            message: null
        });
        const event = new ValidateDynamicTableRowEvent(this.form, this.field, row, summary);
        this.formService.validateDynamicTableRow.next(event);
        if (event.defaultPrevented || !summary.isValid) {
            return summary;
        }
        if (row) {
            for (const col of this.columns) {
                for (const validator of this._validators) {
                    if (!validator.validate(row, col, summary)) {
                        return summary;
                    }
                }
            }
        }
        return summary;
    }
    getCellValue(row, column) {
        const rowValue = row.value[column.id];
        if (column.type === 'Dropdown') {
            if (rowValue) {
                return rowValue.name;
            }
        }
        if (column.type === 'Boolean') {
            return !!rowValue;
        }
        if (column.type === 'Date') {
            if (rowValue) {
                return moment(rowValue.split('T')[0], 'YYYY-MM-DD').format('DD-MM-YYYY');
            }
        }
        return rowValue || '';
    }
    getDisplayText(column) {
        let columnName = column.name;
        if (column.type === 'Amount') {
            const currency = column.amountCurrency || '$';
            columnName = `${column.name} (${currency})`;
        }
        return columnName;
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DynamicTableWidgetComponent extends WidgetComponent {
    constructor(formService, elementRef, visibilityService, logService, cd) {
        super(formService);
        this.formService = formService;
        this.elementRef = elementRef;
        this.visibilityService = visibilityService;
        this.logService = logService;
        this.cd = cd;
        this.ERROR_MODEL_NOT_FOUND = 'Table model not found';
        this.editMode = false;
        this.editRow = null;
        this.selectArrayCode = [32, 0, 13];
    }
    ngOnInit() {
        if (this.field) {
            this.content = new DynamicTableModel(this.field, this.formService);
            this.visibilityService.refreshVisibility(this.field.form);
        }
    }
    forceFocusOnAddButton() {
        if (this.content) {
            this.cd.detectChanges();
            const buttonAddRow = this.elementRef.nativeElement.querySelector('#' + this.content.id + '-add-row');
            if (this.isDynamicTableReady(buttonAddRow)) {
                buttonAddRow.focus();
            }
        }
    }
    isDynamicTableReady(buttonAddRow) {
        return this.field && !this.editMode && buttonAddRow;
    }
    isValid() {
        let valid = true;
        if (this.content && this.content.field) {
            valid = this.content.field.isValid;
        }
        return valid;
    }
    onRowClicked(row) {
        if (this.content) {
            this.content.selectedRow = row;
        }
    }
    onKeyPressed($event, row) {
        if (this.content && this.isEnterOrSpacePressed($event.keyCode)) {
            this.content.selectedRow = row;
        }
    }
    isEnterOrSpacePressed(keyCode) {
        return this.selectArrayCode.indexOf(keyCode) !== -1;
    }
    hasSelection() {
        return !!(this.content && this.content.selectedRow);
    }
    moveSelectionUp() {
        if (this.content && !this.readOnly) {
            this.content.moveRow(this.content.selectedRow, -1);
            return true;
        }
        return false;
    }
    moveSelectionDown() {
        if (this.content && !this.readOnly) {
            this.content.moveRow(this.content.selectedRow, 1);
            return true;
        }
        return false;
    }
    deleteSelection() {
        if (this.content && !this.readOnly) {
            this.content.deleteRow(this.content.selectedRow);
            return true;
        }
        return false;
    }
    addNewRow() {
        if (this.content && !this.readOnly) {
            this.editRow = {
                isNew: true,
                selected: false,
                value: {}
            };
            this.editMode = true;
            return true;
        }
        return false;
    }
    editSelection() {
        if (this.content && !this.readOnly) {
            this.editRow = this.copyRow(this.content.selectedRow);
            this.editMode = true;
            return true;
        }
        return false;
    }
    getCellValue(row, column) {
        if (this.content) {
            const cellValue = this.content.getCellValue(row, column);
            if (column.type === 'Amount') {
                return (column.amountCurrency || '$') + ' ' + (cellValue || 0);
            }
            return cellValue;
        }
        return null;
    }
    onSaveChanges() {
        if (this.content) {
            if (this.editRow.isNew) {
                const row = this.copyRow(this.editRow);
                this.content.selectedRow = null;
                this.content.addRow(row);
                this.editRow.isNew = false;
            }
            else {
                this.content.selectedRow.value = this.copyObject(this.editRow.value);
            }
            this.content.flushValue();
        }
        else {
            this.logService.error(this.ERROR_MODEL_NOT_FOUND);
        }
        this.editMode = false;
        this.forceFocusOnAddButton();
    }
    onCancelChanges() {
        this.editMode = false;
        this.editRow = null;
        this.forceFocusOnAddButton();
    }
    copyRow(row) {
        return {
            value: this.copyObject(row.value)
        };
    }
    copyObject(obj) {
        let result = obj;
        if (typeof obj === 'object' && obj !== null && obj !== undefined) {
            result = Object.assign({}, obj);
            Object.keys(obj).forEach((key) => {
                if (typeof obj[key] === 'object') {
                    result[key] = this.copyObject(obj[key]);
                }
            });
        }
        return result;
    }
}
DynamicTableWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'dynamic-table-widget',
                template: "<div class=\"adf-dynamic-table-scrolling {{field.className}}\"\n    [class.adf-invalid]=\"!isValid()\">\n    <div class=\"adf-label\">{{content.name | translate }}<span *ngIf=\"isRequired()\">*</span></div>\n\n    <div *ngIf=\"!editMode\">\n        <div class=\"adf-table-container\">\n            <table class=\"adf-full-width adf-dynamic-table\" id=\"dynamic-table-{{content.id}}\">\n                <thead>\n                    <tr>\n                        <th *ngFor=\"let column of content.visibleColumns\">\n                            {{column.name}}\n                        </th>\n                    </tr>\n                </thead>\n                <tbody>\n                    <tr *ngFor=\"let row of content.rows; let idx = index\" tabindex=\"0\" id=\"{{content.id}}-row-{{idx}}\"\n                        [class.adf-dynamic-table-widget__row-selected]=\"row.selected\" (keyup)=\"onKeyPressed($event, row)\">\n                        <td *ngFor=\"let column of content.visibleColumns\"\n                            (click)=\"onRowClicked(row)\">\n                            <span *ngIf=\"column.type !== 'Boolean' else checkbox\">\n                                {{ getCellValue(row, column) }}\n                            </span>\n                            <ng-template #checkbox>\n                                <mat-checkbox disabled [checked]=\"getCellValue(row, column)\">\n                                </mat-checkbox>\n                            </ng-template>\n                        </td>\n                    </tr>\n                </tbody>\n            </table>\n        </div>\n\n        <div *ngIf=\"!readOnly\">\n            <button mat-button\n                    [disabled]=\"!hasSelection()\"\n                    (click)=\"moveSelectionUp()\">\n                <mat-icon>arrow_upward</mat-icon>\n            </button>\n            <button mat-button\n                    [disabled]=\"!hasSelection()\"\n                    (click)=\"moveSelectionDown()\">\n                <mat-icon>arrow_downward</mat-icon>\n            </button>\n            <button mat-button\n                    [disabled]=\"field.readOnly\"\n                    id=\"{{content.id}}-add-row\"\n                    (click)=\"addNewRow()\">\n                <mat-icon>add_circle_outline</mat-icon>\n            </button>\n            <button mat-button\n                    [disabled]=\"!hasSelection()\"\n                    (click)=\"deleteSelection()\">\n                <mat-icon>remove_circle_outline</mat-icon>\n            </button>\n            <button mat-button\n                    [disabled]=\"!hasSelection()\"\n                    (click)=\"editSelection()\">\n                <mat-icon>edit</mat-icon>\n            </button>\n        </div>\n     </div>\n\n     <row-editor *ngIf=\"editMode\"\n        [table]=\"content\"\n        [row]=\"editRow\"\n        (save)=\"onSaveChanges()\"\n        (cancel)=\"onCancelChanges()\">\n     </row-editor>\n    <error-widget [error]=\"field.validationSummary\" ></error-widget>\n    <error-widget *ngIf=\"isInvalidFieldRequired()\" required=\"{{ 'FORM.FIELD.REQUIRED' | translate }}\"></error-widget>\n</div>\n",
                host: {
                    '(click)': 'event($event)',
                    '(blur)': 'event($event)',
                    '(change)': 'event($event)',
                    '(focus)': 'event($event)',
                    '(focusin)': 'event($event)',
                    '(focusout)': 'event($event)',
                    '(input)': 'event($event)',
                    '(invalid)': 'event($event)',
                    '(select)': 'event($event)'
                },
                encapsulation: ViewEncapsulation.None,
                styles: ["dynamic-table-widget .adf-label{height:auto;width:auto}.adf-dynamic-table-scrolling{overflow:auto}.adf-dynamic-table{border:1px solid var(--theme-border-color);border-collapse:unset;border-spacing:0;font-size:14px;position:relative;white-space:nowrap;width:100%}.adf-dynamic-table thead{padding-bottom:3px}.adf-dynamic-table tbody tr{height:56px;position:relative;transition-duration:.28s;transition-property:background-color;transition-timing-function:cubic-bezier(.4,0,.2,1)}.adf-dynamic-table tbody tr:hover{background-color:#eee}.adf-dynamic-table tbody tr.adf-is-selected,.adf-dynamic-table tbody tr.adf-is-selected:hover{background-color:#e0f7fa}.adf-dynamic-table tbody tr:focus{outline:1px solid #448aff;outline-offset:-1px}.adf-dynamic-table td,.adf-dynamic-table th{padding:0 18px 12px;text-align:center}.adf-dynamic-table td:first-of-type,.adf-dynamic-table th:first-of-type{padding-left:24px}.adf-dynamic-table td:last-of-type,.adf-dynamic-table th:last-of-type{padding-right:24px}.adf-dynamic-table td{border-bottom:1px solid var(--theme-border-color);border-top:1px solid var(--theme-border-color);cursor:default;padding-top:12px;vertical-align:middle}.adf-dynamic-table td,.adf-dynamic-table th{-webkit-touch-callout:none;-webkit-user-select:none;box-sizing:border-box;color:var(--theme-text-fg-color);height:56px;position:relative;user-select:none}.adf-dynamic-table th{cursor:pointer;font-size:12px;font-weight:700;letter-spacing:0;line-height:24px;padding-bottom:8px;text-overflow:ellipsis;vertical-align:bottom}.adf-dynamic-table th.adf-sortable{-webkit-touch-callout:none;-webkit-user-select:none;user-select:none}.adf-dynamic-table th.adf-sortable:hover{cursor:pointer}.adf-dynamic-table th.adf-dynamic-table__header--sorted-asc,.adf-dynamic-table th.adf-dynamic-table__header--sorted-desc{color:var(--theme-text-fg-color)}.adf-dynamic-table th.adf-dynamic-table__header--sorted-asc:before,.adf-dynamic-table th.adf-dynamic-table__header--sorted-desc:before{-webkit-font-feature-settings:\"liga\";-webkit-font-smoothing:antialiased;content:\"\\e5d8\";display:inline-block;font-family:Material Icons;font-feature-settings:\"liga\";font-size:24px;font-size:16px;font-style:normal;font-weight:400;letter-spacing:normal;line-height:1;margin-right:5px;text-transform:none;vertical-align:sub;word-wrap:normal}.adf-dynamic-table th.adf-dynamic-table__header--sorted-asc:hover,.adf-dynamic-table th.adf-dynamic-table__header--sorted-desc:hover{cursor:pointer}.adf-dynamic-table th.adf-dynamic-table__header--sorted-asc:hover:before,.adf-dynamic-table th.adf-dynamic-table__header--sorted-desc:hover:before{color:var(--theme-disabled-text-color)}.adf-dynamic-table th.adf-dynamic-table__header--sorted-desc:before{content:\"\\e5db\"}.adf-dynamic-table .adf-dynamic-table-cell{cursor:default;text-align:left}.adf-dynamic-table .adf-dynamic-table-cell--text{text-align:left}.adf-dynamic-table .adf-dynamic-table-cell--number{text-align:right}.adf-dynamic-table .adf-dynamic-table-cell--image{text-align:left}.adf-dynamic-table .adf-dynamic-table-cell--image img{height:24px;width:24px}.adf-dynamic-table .adf-full-width{width:100%}"]
            },] }
];
DynamicTableWidgetComponent.ctorParameters = () => [
    { type: FormService },
    { type: ElementRef },
    { type: WidgetVisibilityService },
    { type: LogService },
    { type: ChangeDetectorRef }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class BooleanEditorComponent {
    onValueChanged(row, column, event) {
        const value = event.checked;
        row.value[column.id] = value;
    }
}
BooleanEditorComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-boolean-editor',
                template: " <label [attr.for]=\"column.id\">\n    <mat-checkbox\n        color=\"primary\"\n        [id]=\"column.id\"\n        [checked]=\"table.getCellValue(row, column)\"\n        [required]=\"column.required\"\n        [disabled]=\"!column.editable\"\n        (change)=\"onValueChanged(row, column, $event)\">\n    <span class=\"adf-checkbox-label\">{{column.name}}</span>\n    </mat-checkbox>\n</label>\n",
                styles: [".adf-checkbox-label{cursor:pointer;font-size:16px;line-height:24px;margin:0;position:relative}"]
            },] }
];
BooleanEditorComponent.propDecorators = {
    table: [{ type: Input }],
    row: [{ type: Input }],
    column: [{ type: Input }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ɵ0$3 = MOMENT_DATE_FORMATS;
class DateEditorComponent {
    constructor(dateAdapter, userPreferencesService) {
        this.dateAdapter = dateAdapter;
        this.userPreferencesService = userPreferencesService;
        this.DATE_FORMAT = 'DD-MM-YYYY';
        this.onDestroy$ = new Subject();
    }
    ngOnInit() {
        this.userPreferencesService
            .select(UserPreferenceValues.Locale)
            .pipe(takeUntil(this.onDestroy$))
            .subscribe(locale => this.dateAdapter.setLocale(locale));
        const momentDateAdapter = this.dateAdapter;
        momentDateAdapter.overrideDisplayFormat = this.DATE_FORMAT;
        this.value = moment(this.table.getCellValue(this.row, this.column), this.DATE_FORMAT);
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
    onDateChanged(newDateValue) {
        if (newDateValue && newDateValue.value) {
            const momentDate = moment(newDateValue.value, this.DATE_FORMAT, true);
            if (!momentDate.isValid()) {
                this.row.value[this.column.id] = newDateValue.value;
            }
            else {
                this.row.value[this.column.id] = `${momentDate.format('YYYY-MM-DD')}T00:00:00.000Z`;
                this.table.flushValue();
            }
        }
        else {
            this.row.value[this.column.id] = '';
        }
    }
}
DateEditorComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-date-editor',
                template: "<div>\n    <mat-form-field class=\"adf-date-editor\">\n        <label [attr.for]=\"column.id\">{{column.name}} ({{DATE_FORMAT}})</label>\n        <input matInput\n            id=\"dateInput\"\n            type=\"text\"\n            [matDatepicker]=\"datePicker\"\n            [value]=\"value\"\n            [id]=\"column.id\"\n            [required]=\"column.required\"\n            [disabled]=\"!column.editable\"\n            (focusout)=\"onDateChanged($any($event).srcElement)\"\n            (dateChange)=\"onDateChanged($event)\">\n        <mat-datepicker-toggle  *ngIf=\"column.editable\" matSuffix [for]=\"datePicker\" class=\"adf-date-editor-button\" ></mat-datepicker-toggle>\n    </mat-form-field>\n    <mat-datepicker #datePicker [touchUi]=\"true\"></mat-datepicker>\n</div>\n",
                providers: [
                    { provide: DateAdapter, useClass: MomentDateAdapter },
                    { provide: MAT_DATE_FORMATS, useValue: ɵ0$3 }
                ],
                styles: [".adf-date-editor{width:100%}.adf-date-editor-button{position:relative;top:25px}"]
            },] }
];
DateEditorComponent.ctorParameters = () => [
    { type: DateAdapter },
    { type: UserPreferencesService }
];
DateEditorComponent.propDecorators = {
    table: [{ type: Input }],
    row: [{ type: Input }],
    column: [{ type: Input }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ɵ0$4 = MOMENT_DATE_FORMATS, ɵ1$2 = MAT_MOMENT_DATETIME_FORMATS;
class DateTimeEditorComponent {
    constructor(dateAdapter, userPreferencesService) {
        this.dateAdapter = dateAdapter;
        this.userPreferencesService = userPreferencesService;
        this.DATE_TIME_FORMAT = 'DD/MM/YYYY HH:mm';
        this.onDestroy$ = new Subject();
    }
    ngOnInit() {
        this.userPreferencesService
            .select(UserPreferenceValues.Locale)
            .pipe(takeUntil(this.onDestroy$))
            .subscribe(locale => this.dateAdapter.setLocale(locale));
        const momentDateAdapter = this.dateAdapter;
        momentDateAdapter.overrideDisplayFormat = this.DATE_TIME_FORMAT;
        this.value = moment(this.table.getCellValue(this.row, this.column), this.DATE_TIME_FORMAT);
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
    onDateChanged(newDateValue) {
        if (newDateValue && newDateValue.value) {
            const newValue = moment(newDateValue.value, this.DATE_TIME_FORMAT);
            this.row.value[this.column.id] = newDateValue.value.format(this.DATE_TIME_FORMAT);
            this.value = newValue;
            this.table.flushValue();
        }
        else if (newDateValue) {
            const newValue = moment(newDateValue, this.DATE_TIME_FORMAT);
            this.value = newValue;
            this.row.value[this.column.id] = newDateValue;
            this.table.flushValue();
        }
        else {
            this.row.value[this.column.id] = '';
        }
    }
}
DateTimeEditorComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-datetime-editor',
                template: "<div>\n    <mat-form-field class=\"adf-date-editor\">\n        <label [attr.for]=\"column.id\">{{column.name}} {{DATE_TIME_FORMAT}}</label>\n        <input matInput\n            [matDatetimepicker]=\"datetimePicker\"\n            [(ngModel)]=\"value\"\n            [id]=\"column.id\"\n            [required]=\"column.required\"\n            [disabled]=\"!column.editable\"\n            (focusout)=\"onDateChanged($any($event).srcElement.value)\"\n            (dateChange)=\"onDateChanged($event)\">\n            <mat-datetimepicker-toggle\n                matSuffix\n                [for]=\"datetimePicker\"\n                class=\"adf-date-editor-button\">\n            </mat-datetimepicker-toggle>\n    </mat-form-field>\n    <mat-datetimepicker\n        #datetimePicker\n        type=\"datetime\"\n        [openOnFocus]=\"true\"\n        [timeInterval]=\"5\">\n    </mat-datetimepicker>\n</div>\n",
                providers: [
                    { provide: DateAdapter, useClass: MomentDateAdapter },
                    { provide: MAT_DATE_FORMATS, useValue: ɵ0$4 },
                    { provide: DatetimeAdapter, useClass: MomentDatetimeAdapter },
                    { provide: MAT_DATETIME_FORMATS, useValue: ɵ1$2 }
                ],
                styles: [".adf-date-editor{width:100%}.adf-date-editor-button{position:relative;top:25px}"]
            },] }
];
DateTimeEditorComponent.ctorParameters = () => [
    { type: DateAdapter },
    { type: UserPreferencesService }
];
DateTimeEditorComponent.propDecorators = {
    table: [{ type: Input }],
    row: [{ type: Input }],
    column: [{ type: Input }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DropdownEditorComponent {
    constructor(formService, logService) {
        this.formService = formService;
        this.logService = logService;
        this.value = null;
        this.options = [];
    }
    ngOnInit() {
        const field = this.table.field;
        if (field) {
            if (this.column.optionType === 'rest') {
                if (this.table.form && this.table.form.taskId) {
                    this.getValuesByTaskId(field);
                }
                else {
                    this.getValuesByProcessDefinitionId(field);
                }
            }
            else {
                this.options = this.column.options || [];
                this.value = this.table.getCellValue(this.row, this.column);
            }
        }
    }
    getValuesByTaskId(field) {
        this.formService
            .getRestFieldValuesColumn(field.form.taskId, field.id, this.column.id)
            .subscribe((dynamicTableColumnOption) => {
            this.column.options = dynamicTableColumnOption || [];
            this.options = this.column.options;
            this.value = this.table.getCellValue(this.row, this.column);
        }, (err) => this.handleError(err));
    }
    getValuesByProcessDefinitionId(field) {
        this.formService
            .getRestFieldValuesColumnByProcessId(field.form.processDefinitionId, field.id, this.column.id)
            .subscribe((dynamicTableColumnOption) => {
            this.column.options = dynamicTableColumnOption || [];
            this.options = this.column.options;
            this.value = this.table.getCellValue(this.row, this.column);
        }, (err) => this.handleError(err));
    }
    onValueChanged(row, column, event) {
        let value = event.value;
        value = column.options.find((opt) => opt.name === value);
        row.value[column.id] = value;
    }
    handleError(error) {
        this.logService.error(error);
    }
}
DropdownEditorComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-dropdown-editor',
                template: "<div class=\"dropdown-editor\">\n    <label [attr.for]=\"column.id\">{{column.name}}</label>\n    <mat-form-field>\n        <mat-select\n            floatPlaceholder=\"never\"\n            class=\"adf-dropdown-editor-select\"\n            [id]=\"column.id\"\n            [(ngModel)]=\"value\"\n            [required]=\"column.required\"\n            [disabled]=\"!column.editable\"\n            (selectionChange)=\"onValueChanged(row, column, $event)\">\n            <mat-option></mat-option>\n            <mat-option *ngFor=\"let opt of options\" [value]=\"opt.name\" [id]=\"opt.id\">{{opt.name}}</mat-option>\n        </mat-select>\n    </mat-form-field>\n</div>\n",
                styles: [".adf-dropdown-editor-select{width:100%}"]
            },] }
];
DropdownEditorComponent.ctorParameters = () => [
    { type: FormService },
    { type: LogService }
];
DropdownEditorComponent.propDecorators = {
    table: [{ type: Input }],
    row: [{ type: Input }],
    column: [{ type: Input }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RowEditorComponent {
    constructor() {
        this.save = new EventEmitter();
        this.cancel = new EventEmitter();
        this.validationSummary = new DynamicRowValidationSummary({ isValid: true, message: '' });
    }
    onCancelChanges() {
        this.cancel.emit({
            table: this.table,
            row: this.row,
            column: this.column
        });
    }
    onSaveChanges() {
        this.validate();
        if (this.isValid()) {
            this.save.emit({
                table: this.table,
                row: this.row,
                column: this.column
            });
        }
    }
    isValid() {
        return this.validationSummary && this.validationSummary.isValid;
    }
    validate() {
        this.validationSummary = this.table.validateRow(this.row);
    }
}
RowEditorComponent.decorators = [
    { type: Component, args: [{
                selector: 'row-editor',
                template: "<div class=\"row-editor mdl-shadow--2dp\"\n     [class.row-editor__invalid]=\"!validationSummary.isValid\">\n    <div class=\"mdl-grid\" *ngFor=\"let column of table.columns\">\n        <div class=\"mdl-cell mdl-cell--6-col\" [ngSwitch]=\"column.type\">\n            <div *ngSwitchCase=\"'Dropdown'\">\n                <adf-dropdown-editor\n                    [table]=\"table\"\n                    [row]=\"row\"\n                    [column]=\"column\">\n                </adf-dropdown-editor>\n            </div>\n            <div *ngSwitchCase=\"'Date'\">\n                <adf-date-editor\n                    [table]=\"table\"\n                    [row]=\"row\"\n                    [column]=\"column\">\n                </adf-date-editor>\n            </div>\n            <div *ngSwitchCase=\"'Datetime'\">\n                <adf-datetime-editor\n                    [table]=\"table\"\n                    [row]=\"row\"\n                    [column]=\"column\">\n                </adf-datetime-editor>\n            </div>\n            <div *ngSwitchCase=\"'Boolean'\">\n                <adf-boolean-editor\n                    [table]=\"table\"\n                    [row]=\"row\"\n                    [column]=\"column\">\n                </adf-boolean-editor>\n            </div>\n            <div *ngSwitchCase=\"'Amount'\">\n                <adf-amount-editor\n                    [table]=\"table\"\n                    [row]=\"row\"\n                    [column]=\"column\">\n                </adf-amount-editor>\n            </div>\n            <div *ngSwitchDefault>\n                <adf-text-editor\n                    [table]=\"table\"\n                    [row]=\"row\"\n                    [column]=\"column\">\n                </adf-text-editor>\n            </div>\n        </div>\n    </div>\n    <error-widget [error]=\"validationSummary\"></error-widget>\n    <div>\n        <button mat-button (click)=\"onCancelChanges()\">Cancel</button>\n        <button mat-button (click)=\"onSaveChanges()\">Save</button>\n    </div>\n</div>\n",
                styles: [".row-editor{padding:8px}.row-editor__validation-summary{visibility:hidden}.row-editor__invalid .row-editor__validation-summary{color:#d50000;padding:8px 16px;visibility:visible}"]
            },] }
];
RowEditorComponent.ctorParameters = () => [];
RowEditorComponent.propDecorators = {
    table: [{ type: Input }],
    row: [{ type: Input }],
    column: [{ type: Input }],
    save: [{ type: Output }],
    cancel: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TextEditorComponent {
    ngOnInit() {
        this.displayName = this.table.getDisplayText(this.column);
    }
    onValueChanged(row, column, event) {
        const value = event.target.value;
        row.value[column.id] = value;
    }
}
TextEditorComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-text-editor',
                template: "<div class=\"adf-text-editor\">\n    <mat-form-field>\n    <label [attr.for]=\"column.id\">{{displayName}}</label>\n    <input matInput\n        type=\"text\"\n        [value]=\"table.getCellValue(row, column)\"\n        (keyup)=\"onValueChanged(row, column, $event)\"\n        [required]=\"column.required\"\n        [disabled]=\"!column.editable\"\n        [id]=\"column.id\">\n    </mat-form-field>\n</div>\n",
                styles: [".adf-text-editor{width:100%}"]
            },] }
];
TextEditorComponent.propDecorators = {
    table: [{ type: Input }],
    row: [{ type: Input }],
    column: [{ type: Input }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AmountEditorComponent {
    ngOnInit() {
        this.displayName = this.table.getDisplayText(this.column);
    }
    onValueChanged(row, column, event) {
        const value = Number(event.target.value);
        row.value[column.id] = value;
    }
}
AmountEditorComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-amount-editor',
                template: "<div class=\"adf-amount-editor\">\n    <mat-form-field>\n    <label [attr.for]=\"column.id\">{{displayName}}</label>\n    <input matInput\n        type=\"number\"\n        [value]=\"table.getCellValue(row, column)\"\n        (keyup)=\"onValueChanged(row, column, $event)\"\n        [required]=\"column.required\"\n        [disabled]=\"!column.editable\"\n        [id]=\"column.id\">\n    </mat-form-field>\n</div>\n",
                styles: [".adf-text-editor{width:100%}"]
            },] }
];
AmountEditorComponent.propDecorators = {
    table: [{ type: Input }],
    row: [{ type: Input }],
    column: [{ type: Input }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ErrorWidgetComponent extends WidgetComponent {
    constructor(formService) {
        super(formService);
        this.formService = formService;
        this.translateParameters = null;
        this._subscriptAnimationState = '';
    }
    ngOnChanges(changes) {
        if (changes['required']) {
            this.required = changes.required.currentValue;
            this._subscriptAnimationState = 'enter';
        }
        if (changes['error'] && changes['error'].currentValue) {
            if (changes.error.currentValue.isActive()) {
                this.error = changes.error.currentValue;
                this.translateParameters = this.error.getAttributesAsJsonObj();
                this._subscriptAnimationState = 'enter';
            }
        }
    }
}
ErrorWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'error-widget',
                template: "<div class=\"adf-error-text-container\">\n    <div *ngIf=\"error?.isActive()\" [@transitionMessages]=\"_subscriptAnimationState\">\n        <div class=\"adf-error-text\">{{error.message | translate:translateParameters}}</div>\n        <mat-icon class=\"adf-error-icon\">warning</mat-icon>\n    </div>\n    <div *ngIf=\"required\" [@transitionMessages]=\"_subscriptAnimationState\">\n            <div class=\"adf-error-text\">{{required}}</div>\n    </div>\n</div>\n",
                animations: [
                    trigger('transitionMessages', [
                        state('enter', style({ opacity: 1, transform: 'translateY(0%)' })),
                        transition('void => enter', [
                            style({ opacity: 0, transform: 'translateY(-100%)' }),
                            animate('300ms cubic-bezier(0.55, 0, 0.55, 0.2)')
                        ])
                    ])
                ],
                host: {
                    '(click)': 'event($event)',
                    '(blur)': 'event($event)',
                    '(change)': 'event($event)',
                    '(focus)': 'event($event)',
                    '(focusin)': 'event($event)',
                    '(focusout)': 'event($event)',
                    '(input)': 'event($event)',
                    '(invalid)': 'event($event)',
                    '(select)': 'event($event)'
                },
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-error-text{width:85%}"]
            },] }
];
ErrorWidgetComponent.ctorParameters = () => [
    { type: FormService }
];
ErrorWidgetComponent.propDecorators = {
    error: [{ type: Input }],
    required: [{ type: Input }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FunctionalGroupWidgetComponent extends WidgetComponent {
    constructor(formService, elementRef) {
        super(formService);
        this.formService = formService;
        this.elementRef = elementRef;
        this.minTermLength = 1;
        this.searchTerm = new FormControl();
        this.groups$ = merge(this.searchTerm.valueChanges).pipe(tap((search) => {
            const isValid = typeof search !== 'string';
            const empty = search === '';
            this.updateOption(isValid ? search : null);
            this.validateGroup(isValid, empty);
        }), filter((group) => typeof group === 'string' && group.length >= this.minTermLength), debounceTime(300), switchMap((searchTerm) => this.formService.getWorkflowGroups(searchTerm, this.groupId)
            .pipe(catchError(() => of([])))));
    }
    ngOnInit() {
        var _a;
        if (this.field) {
            if (this.field.readOnly) {
                this.searchTerm.disable();
            }
            const params = this.field.params;
            if (params && params.restrictWithGroup) {
                const restrictWithGroup = params.restrictWithGroup;
                this.groupId = restrictWithGroup.id;
            }
            if ((_a = this.field.value) === null || _a === void 0 ? void 0 : _a.name) {
                this.searchTerm.setValue(this.field.value.name);
            }
        }
    }
    updateOption(option) {
        if (option) {
            this.field.value = option;
        }
        else {
            this.field.value = null;
        }
        this.field.updateForm();
    }
    validateGroup(valid, empty) {
        const isEmpty = !this.field.required && (empty || valid);
        const hasValue = this.field.required && valid;
        if (hasValue || isEmpty) {
            this.field.validationSummary.message = '';
            this.field.validate();
            this.field.form.validateForm();
        }
        else {
            this.field.validationSummary.message = 'FORM.FIELD.VALIDATOR.INVALID_VALUE';
            this.field.markAsInvalid();
            this.field.form.markAsInvalid();
        }
    }
    getDisplayName(model) {
        if (model) {
            return typeof model === 'string' ? model : model.name;
        }
        return '';
    }
}
FunctionalGroupWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'functional-group-widget',
                template: "<div class=\"adf-group-widget {{field.className}}\"\n     [class.is-dirty]=\"!!field.value\"\n     [class.adf-invalid]=\"!field.isValid\"\n     [class.adf-readonly]=\"field.readOnly\"\n     id=\"functional-group-div\">\n\n    <mat-form-field>\n        <label class=\"adf-label\" [attr.for]=\"field.id\">{{field.name | translate }}<span *ngIf=\"isRequired()\">*</span></label>\n        <input matInput\n               class=\"adf-input\"\n               type=\"text\"\n               data-automation-id=\"adf-group-search-input\"\n               [id]=\"field.id\"\n               [formControl]=\"searchTerm\"\n               [placeholder]=\"field.placeholder\"\n               [matAutocomplete]=\"auto\">\n        <mat-autocomplete #auto=\"matAutocomplete\" (optionSelected)=\"updateOption($event.option.value)\" [displayWith]=\"getDisplayName\">\n            <mat-option *ngFor=\"let item of groups$ | async; let i = index\"\n                        id=\"adf-group-widget-user-{{i}}\"\n                       [id]=\"field.id +'-'+item.id\"\n                       [value]=\"item\">\n                <span id=\"adf-group-label-name\">{{item.name}}</span>\n            </mat-option>\n        </mat-autocomplete>\n\n    </mat-form-field>\n    <error-widget [error]=\"field.validationSummary\"></error-widget>\n    <error-widget *ngIf=\"isInvalidFieldRequired()\" required=\"{{ 'FORM.FIELD.REQUIRED' | translate }}\"></error-widget>\n</div>\n",
                host: {
                    '(click)': 'event($event)',
                    '(blur)': 'event($event)',
                    '(change)': 'event($event)',
                    '(focus)': 'event($event)',
                    '(focusin)': 'event($event)',
                    '(focusout)': 'event($event)',
                    '(input)': 'event($event)',
                    '(invalid)': 'event($event)',
                    '(select)': 'event($event)'
                },
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-group-widget{width:100%}"]
            },] }
];
FunctionalGroupWidgetComponent.ctorParameters = () => [
    { type: FormService },
    { type: ElementRef }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class HyperlinkWidgetComponent extends WidgetComponent {
    constructor(formService) {
        super(formService);
        this.formService = formService;
        this.linkUrl = '#';
        this.linkText = null;
    }
    ngOnInit() {
        if (this.field) {
            this.linkUrl = this.getHyperlinkUrl(this.field);
            this.linkText = this.getHyperlinkText(this.field);
        }
    }
    getHyperlinkUrl(field) {
        let value = field.value || field.hyperlinkUrl;
        if (value && !/^https?:\/\//i.test(value)) {
            value = `${HyperlinkWidgetComponent.DEFAULT_HYPERLINK_SCHEME}${value}`;
        }
        return value || HyperlinkWidgetComponent.DEFAULT_HYPERLINK_URL;
    }
    getHyperlinkText(field) {
        if (field) {
            return field.displayText || field.hyperlinkUrl || field.value;
        }
        return null;
    }
}
HyperlinkWidgetComponent.DEFAULT_HYPERLINK_URL = '#';
HyperlinkWidgetComponent.DEFAULT_HYPERLINK_SCHEME = 'http://';
HyperlinkWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'hyperlink-widget',
                template: "<div class=\"adf-hyperlink-widget {{field.className}}\">\n    <label class=\"adf-label\" [attr.for]=\"field.id\">{{field.name | translate }}<span\n            *ngIf=\"isRequired()\">*</span></label>\n    <div [matTooltip]=\"field.tooltip\" matTooltipPosition=\"above\" matTooltipShowDelay=\"1000\">\n        <a [href]=\"linkUrl\" target=\"_blank\" rel=\"nofollow\">{{linkText}}</a>\n    </div>\n</div>\n",
                host: {
                    '(click)': 'event($event)',
                    '(blur)': 'event($event)',
                    '(change)': 'event($event)',
                    '(focus)': 'event($event)',
                    '(focusin)': 'event($event)',
                    '(focusout)': 'event($event)',
                    '(input)': 'event($event)',
                    '(invalid)': 'event($event)',
                    '(select)': 'event($event)'
                },
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-hyperlink-widget{border-top:.84375em solid transparent;padding:.4375em 0}.adf-hyperlink-widget a{color:var(--theme-primary-color)}"]
            },] }
];
HyperlinkWidgetComponent.ctorParameters = () => [
    { type: FormService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class MultilineTextWidgetComponentComponent extends WidgetComponent {
    constructor(formService) {
        super(formService);
        this.formService = formService;
    }
}
MultilineTextWidgetComponentComponent.decorators = [
    { type: Component, args: [{
                selector: 'multiline-text-widget',
                template: "<div class=\"adf-multiline-text-widget {{field.className}}\"\n     [class.adf-invalid]=\"!field.isValid\" [class.adf-readonly]=\"field.readOnly\">\n    <mat-form-field floatPlaceholder=\"never\">\n        <label class=\"adf-label\" [attr.for]=\"field.id\">{{field.name | translate }}<span *ngIf=\"isRequired()\">*</span></label>\n        <textarea matInput class=\"adf-input\"\n                  [matTextareaAutosize]=\"true\"\n                  type=\"text\"\n                  rows=\"3\"\n                  [id]=\"field.id\"\n                  [required]=\"isRequired()\"\n                  [(ngModel)]=\"field.value\"\n                  (ngModelChange)=\"onFieldChanged(field)\"\n                  [disabled]=\"field.readOnly || readOnly\"\n                  [placeholder]=\"field.placeholder\"\n                  [matTooltip]=\"field.tooltip\"\n                  matTooltipPosition=\"above\"\n                  matTooltipShowDelay=\"1000\">\n        </textarea>\n    </mat-form-field>\n    <div *ngIf=\"field.maxLength > 0\" class=\"adf-multiline-word-counter\">\n        <span>{{field?.value?.length || 0}}/{{field.maxLength}}</span>\n    </div>\n    <error-widget [error]=\"field.validationSummary\"></error-widget>\n    <error-widget class=\"adf-multiline-required-message\" *ngIf=\"isInvalidFieldRequired()\" required=\"{{ 'FORM.FIELD.REQUIRED' | translate }}\"></error-widget>\n</div>\n\n",
                host: {
                    '(click)': 'event($event)',
                    '(blur)': 'event($event)',
                    '(change)': 'event($event)',
                    '(focus)': 'event($event)',
                    '(focusin)': 'event($event)',
                    '(focusout)': 'event($event)',
                    '(input)': 'event($event)',
                    '(invalid)': 'event($event)',
                    '(select)': 'event($event)'
                },
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-multiline-text-widget{width:100%}.adf-multiline-text-widget .mat-form-field-label-wrapper{top:20px}.adf-multiline-word-counter{float:right;font-size:12px;line-height:14px;margin-top:-20px!important;min-height:24px;min-width:1px;opacity:1;overflow:hidden;padding-left:0;padding-right:2px;padding-top:5px;text-align:right;transition:all .3s cubic-bezier(.55,0,.55,.2)}.adf-multiline-required-message{display:flex}"]
            },] }
];
MultilineTextWidgetComponentComponent.ctorParameters = () => [
    { type: FormService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class NumberWidgetComponent extends WidgetComponent {
    constructor(formService, decimalNumberPipe) {
        super(formService);
        this.formService = formService;
        this.decimalNumberPipe = decimalNumberPipe;
    }
    ngOnInit() {
        if (this.field.readOnly) {
            this.displayValue = this.decimalNumberPipe.transform(this.field.value);
        }
        else {
            this.displayValue = this.field.value;
        }
    }
}
NumberWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'number-widget',
                template: "<div class=\"adf-textfield adf-number-widget {{field.className}}\"\n     [class.adf-invalid]=\"!field.isValid\" [class.adf-readonly]=\"field.readOnly\">\n    <mat-form-field>\n        <label class=\"adf-label\" [attr.for]=\"field.id\">{{field.name | translate }}<span *ngIf=\"isRequired()\">*</span></label>\n        <input matInput\n               class=\"adf-input\"\n               type=\"text\"\n               pattern=\"-?[0-9]*(\\.[0-9]+)?\"\n               [id]=\"field.id\"\n               [required]=\"isRequired()\"\n               [value]=\"displayValue\"\n               [(ngModel)]=\"field.value\"\n               (ngModelChange)=\"onFieldChanged(field)\"\n               [disabled]=\"field.readOnly\"\n               [placeholder]=\"field.placeholder\"\n               [matTooltip]=\"field.tooltip\"\n               matTooltipPosition=\"above\"\n               matTooltipShowDelay=\"1000\">\n    </mat-form-field>\n    <error-widget [error]=\"field.validationSummary\" ></error-widget>\n    <error-widget *ngIf=\"isInvalidFieldRequired()\" required=\"{{ 'FORM.FIELD.REQUIRED' | translate }}\"></error-widget>\n</div>\n",
                host: {
                    '(click)': 'event($event)',
                    '(blur)': 'event($event)',
                    '(change)': 'event($event)',
                    '(focus)': 'event($event)',
                    '(focusin)': 'event($event)',
                    '(focusout)': 'event($event)',
                    '(input)': 'event($event)',
                    '(invalid)': 'event($event)',
                    '(select)': 'event($event)'
                },
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-number-widget{width:100%}.adf-number-widget .mat-form-field-label-wrapper{top:20px}"]
            },] }
];
NumberWidgetComponent.ctorParameters = () => [
    { type: FormService },
    { type: DecimalNumberPipe }
];

class PeopleProcessService {
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
    }
    get taskActionsApi() {
        var _a;
        this._taskActionsApi = (_a = this._taskActionsApi) !== null && _a !== void 0 ? _a : new TaskActionsApi(this.apiService.getInstance());
        return this._taskActionsApi;
    }
    get userApi() {
        var _a;
        this._userApi = (_a = this._userApi) !== null && _a !== void 0 ? _a : new UsersApi(this.apiService.getInstance());
        return this._userApi;
    }
    getWorkflowUsers(taskId, searchWord) {
        const option = { excludeTaskId: taskId, filter: searchWord };
        return from(this.getWorkflowUserApi(option))
            .pipe(map((response) => response.data || []), catchError((err) => this.handleError(err)));
    }
    getUserImage(user) {
        return this.getUserProfileImageApi(user.id.toString());
    }
    involveUserWithTask(taskId, idToInvolve) {
        const node = { userId: idToInvolve };
        return from(this.involveUserToTaskApi(taskId, node))
            .pipe(catchError((err) => this.handleError(err)));
    }
    removeInvolvedUser(taskId, idToRemove) {
        const node = { userId: idToRemove };
        return from(this.removeInvolvedUserFromTaskApi(taskId, node))
            .pipe(catchError((err) => this.handleError(err)));
    }
    getWorkflowUserApi(options) {
        return this.userApi.getUsers(options);
    }
    involveUserToTaskApi(taskId, node) {
        return this.taskActionsApi.involveUser(taskId, node);
    }
    removeInvolvedUserFromTaskApi(taskId, node) {
        return this.taskActionsApi.removeInvolvedUser(taskId, node);
    }
    getUserProfileImageApi(userId) {
        return this.userApi.getUserProfilePictureUrl(userId);
    }
    handleError(error) {
        this.logService.error(error);
        return throwError(error || 'Server error');
    }
}
PeopleProcessService.ɵprov = ɵɵdefineInjectable({ factory: function PeopleProcessService_Factory() { return new PeopleProcessService(ɵɵinject(AlfrescoApiService), ɵɵinject(LogService)); }, token: PeopleProcessService, providedIn: "root" });
PeopleProcessService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
PeopleProcessService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: LogService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PeopleWidgetComponent extends WidgetComponent {
    constructor(formService, peopleProcessService) {
        super(formService);
        this.formService = formService;
        this.peopleProcessService = peopleProcessService;
        this.peopleSelected = new EventEmitter();
        this.searchTerm = new FormControl();
        this.searchTerms$ = this.searchTerm.valueChanges;
        this.users$ = this.searchTerms$.pipe(tap((searchInput) => {
            if (typeof searchInput === 'string') {
                this.onItemSelect();
            }
        }), distinctUntilChanged(), switchMap((searchTerm) => {
            const value = searchTerm.email ? this.getDisplayName(searchTerm) : searchTerm;
            return this.formService.getWorkflowUsers(value, this.groupId)
                .pipe(catchError(() => of([])));
        }), map((list) => {
            const value = this.searchTerm.value.email ? this.getDisplayName(this.searchTerm.value) : this.searchTerm.value;
            this.checkUserAndValidateForm(list, value);
            return list;
        }));
    }
    ngOnInit() {
        if (this.field) {
            if (this.field.value) {
                this.searchTerm.setValue(this.field.value);
            }
            if (this.field.readOnly) {
                this.searchTerm.disable();
            }
            const params = this.field.params;
            if (params && params.restrictWithGroup) {
                const restrictWithGroup = params.restrictWithGroup;
                this.groupId = restrictWithGroup.id;
            }
        }
    }
    checkUserAndValidateForm(list, value) {
        const isValidUser = this.isValidUser(list, value);
        if (isValidUser || value === '') {
            this.field.validationSummary.message = '';
            this.field.validate();
            this.field.form.validateForm();
        }
        else {
            this.field.validationSummary.message = 'FORM.FIELD.VALIDATOR.INVALID_VALUE';
            this.field.markAsInvalid();
            this.field.form.markAsInvalid();
        }
    }
    isValidUser(users, name) {
        if (users) {
            return !!users.find((user) => {
                const selectedUser = this.getDisplayName(user).toLocaleLowerCase() === name.toLocaleLowerCase();
                if (selectedUser) {
                    this.peopleSelected.emit(user && user.id || undefined);
                }
                return selectedUser;
            });
        }
        return false;
    }
    getDisplayName(model) {
        if (model) {
            const displayName = `${model.firstName || ''} ${model.lastName || ''}`;
            return displayName.trim();
        }
        return '';
    }
    onItemSelect(item) {
        if (item) {
            this.field.value = item;
        }
        else {
            this.field.value = null;
        }
    }
}
PeopleWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'people-widget',
                template: "<div class=\"adf-people-widget {{field.className}}\"\n     [class.adf-invalid]=\"!field.isValid\"\n     [class.adf-readonly]=\"field.readOnly\"\n     id=\"people-widget-content\">\n    <mat-form-field>\n        <label class=\"adf-label\" [attr.for]=\"field.id\">{{field.name | translate }}<span *ngIf=\"isRequired()\">*</span></label>\n        <input #inputValue\n               matInput\n               class=\"adf-input\"\n               data-automation-id=\"adf-people-search-input\"\n               type=\"text\"\n               [id]=\"field.id\"\n               [formControl]=\"searchTerm\"\n               [placeholder]=\"field.placeholder\"\n               [matAutocomplete]=\"auto\"\n               [matTooltip]=\"field.tooltip\"\n               matTooltipPosition=\"above\"\n               matTooltipShowDelay=\"1000\">\n        <mat-autocomplete class=\"adf-people-widget-list\"\n                          #auto=\"matAutocomplete\"\n                          (optionSelected)=\"onItemSelect($event.option.value)\"\n                          [displayWith]=\"getDisplayName\">\n            <mat-option *ngFor=\"let user of users$ | async; let i = index\" [value]=\"user\">\n                <div class=\"adf-people-widget-row\" id=\"adf-people-widget-user-{{i}}\">\n                    <div [outerHTML]=\"user | usernameInitials:'adf-people-widget-pic'\"></div>\n                    <div *ngIf=\"user.pictureId\" class=\"adf-people-widget-image-row\">\n                        <img id=\"adf-people-widget-pic-{{i}}\" class=\"adf-people-widget-image\"\n                             [alt]=\"getDisplayName(user)\" [src]=\"peopleProcessService.getUserImage(user)\"/>\n                    </div>\n                    <span class=\"adf-people-label-name\">{{getDisplayName(user)}}</span>\n                </div>\n            </mat-option>\n        </mat-autocomplete>\n    </mat-form-field>\n    <error-widget [error]=\"field.validationSummary\"></error-widget>\n    <error-widget *ngIf=\"isInvalidFieldRequired()\" required=\"{{ 'FORM.FIELD.REQUIRED' | translate }}\"></error-widget>\n</div>\n",
                host: {
                    '(click)': 'event($event)',
                    '(blur)': 'event($event)',
                    '(change)': 'event($event)',
                    '(focus)': 'event($event)',
                    '(focusin)': 'event($event)',
                    '(focusout)': 'event($event)',
                    '(input)': 'event($event)',
                    '(invalid)': 'event($event)',
                    '(select)': 'event($event)'
                },
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-people-widget{width:100%}.adf-people-widget .mat-form-field-label-wrapper{top:10px}.adf-people-widget-list{margin:5px 0;padding:10px 0}.adf-people-widget-row{align-items:center;display:flex}.adf-people-widget-pic{align-items:center;background:var(--theme-primary-color);border-radius:100px;color:var(--theme-text-fg-color);display:flex;font-size:18px;font-weight:bolder;height:40px;justify-content:center;text-transform:uppercase;width:40px}.adf-people-widget-image{background:var(--theme-dialog-bg-color);border-radius:100px;display:inline-block;height:40px;left:21px;margin-left:-44px;padding:0;vertical-align:middle;width:40px}.adf-people-widget-image-row{display:inline-block}.adf-people-label-name{padding-left:10px}"]
            },] }
];
PeopleWidgetComponent.ctorParameters = () => [
    { type: FormService },
    { type: PeopleProcessService }
];
PeopleWidgetComponent.propDecorators = {
    input: [{ type: ViewChild, args: ['inputValue', { static: true },] }],
    peopleSelected: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class RadioButtonsWidgetComponent extends WidgetComponent {
    constructor(formService, logService) {
        super(formService);
        this.formService = formService;
        this.logService = logService;
    }
    ngOnInit() {
        if (this.field && this.field.restUrl) {
            if (this.field.form.taskId) {
                this.getOptionsByTaskId();
            }
            else {
                this.getOptionsByProcessDefinitionId();
            }
        }
    }
    getOptionsByTaskId() {
        this.formService
            .getRestFieldValues(this.field.form.taskId, this.field.id)
            .subscribe((formFieldOption) => {
            this.field.options = formFieldOption || [];
            this.field.updateForm();
        }, (err) => this.handleError(err));
    }
    getOptionsByProcessDefinitionId() {
        this.formService
            .getRestFieldValuesByProcessId(this.field.form.processDefinitionId, this.field.id)
            .subscribe((formFieldOption) => {
            this.field.options = formFieldOption || [];
            this.field.updateForm();
        }, (err) => this.handleError(err));
    }
    onOptionClick(optionSelected) {
        this.field.value = optionSelected;
        this.fieldChanged.emit(this.field);
    }
    handleError(error) {
        this.logService.error(error);
    }
}
RadioButtonsWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'radio-buttons-widget',
                template: "<div class=\"adf-radio-buttons-widget {{field.className}}\"\n     [class.adf-invalid]=\"!field.isValid\" [class.adf-readonly]=\"field.readOnly\" [id]=\"field.id\">\n    <div class=\"adf-radio-button-container\">\n        <label class=\"adf-label\" [attr.for]=\"field.id\">{{field.name | translate }}<span *ngIf=\"isRequired()\">*</span></label>\n        <mat-radio-group class=\"adf-radio-group\" [(ngModel)]=\"field.value\" [disabled]=\"field.readOnly\">\n            <mat-radio-button\n                [matTooltip]=\"field.tooltip\"\n                matTooltipPosition=\"above\"\n                matTooltipShowDelay=\"1000\"\n                [id]=\"field.id + '-' + opt.id\"\n                [name]=\"field.id\"\n                [value]=\"opt.id\"\n                [checked]=\"field.value === opt.id\"\n                (change)=\"onOptionClick(opt.id)\"\n                color=\"primary\"\n                class=\"adf-radio-button\" *ngFor=\"let opt of field.options\" >\n                {{opt.name}}\n            </mat-radio-button>\n        </mat-radio-group>\n    </div>\n    <error-widget [error]=\"field.validationSummary\" ></error-widget>\n    <error-widget *ngIf=\"isInvalidFieldRequired()\" required=\"{{ 'FORM.FIELD.REQUIRED' | translate }}\"></error-widget>\n</div>\n",
                host: {
                    '(click)': 'event($event)',
                    '(blur)': 'event($event)',
                    '(change)': 'event($event)',
                    '(focus)': 'event($event)',
                    '(focusin)': 'event($event)',
                    '(focusout)': 'event($event)',
                    '(input)': 'event($event)',
                    '(invalid)': 'event($event)',
                    '(select)': 'event($event)'
                },
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-radio-button-container{display:flex;flex-direction:column;margin-bottom:15px}.adf-radio-group{display:inline-flex;flex-direction:column;margin-left:5px;margin-top:15px}.adf-radio-button{margin:5px}"]
            },] }
];
RadioButtonsWidgetComponent.ctorParameters = () => [
    { type: FormService },
    { type: LogService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const CUSTOM_INPUT_CONTROL_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => InputMaskDirective),
    multi: true
};
class InputMaskDirective {
    constructor(el, render) {
        this.el = el;
        this.render = render;
        this.translationMask = {
            '0': { pattern: /\d/ },
            '9': { pattern: /\d/, optional: true },
            '#': { pattern: /\d/, recursive: true },
            'A': { pattern: /[a-zA-Z0-9]/ },
            'S': { pattern: /[a-zA-Z]/ }
        };
        this.byPassKeys = [9, 16, 17, 18, 36, 37, 38, 39, 40, 91];
        this.invalidCharacters = [];
        this._onChange = (_) => {
        };
        this._onTouched = () => {
        };
    }
    onTextInput(event) {
        if (this.inputMask && this.inputMask.mask) {
            this.maskValue(this.el.nativeElement.value, this.el.nativeElement.selectionStart, this.inputMask.mask, this.inputMask.isReversed, event.keyCode);
        }
        else {
            this._onChange(this.el.nativeElement.value);
        }
    }
    ngOnChanges(changes) {
        if (changes['inputMask'] && changes['inputMask'].currentValue['mask']) {
            this.inputMask = changes['inputMask'].currentValue;
        }
    }
    writeValue(value) {
        this.el.nativeElement.value = value;
    }
    registerOnChange(fn) {
        this._onChange = fn;
    }
    registerOnTouched(fn) {
        this._onTouched = fn;
    }
    maskValue(actualValue, startCaret, maskToApply, isMaskReversed, keyCode) {
        if (this.byPassKeys.indexOf(keyCode) === -1) {
            const value = this.getMasked(false, actualValue, maskToApply, isMaskReversed);
            const calculatedCaret = this.calculateCaretPosition(startCaret, actualValue, keyCode);
            this.render.setAttribute(this.el.nativeElement, 'value', value);
            this.el.nativeElement.value = value;
            this.setValue(value);
            this._onChange(value);
            this.setCaretPosition(calculatedCaret);
        }
    }
    setCaretPosition(caretPosition) {
        this.el.nativeElement.moveStart = caretPosition;
        this.el.nativeElement.moveEnd = caretPosition;
    }
    calculateCaretPosition(caretPosition, newValue, keyCode) {
        const newValueLength = newValue.length;
        const oldValue = this.getValue() || '';
        const oldValueLength = oldValue.length;
        if (keyCode === 8 && oldValue !== newValue) {
            caretPosition = caretPosition - (newValue.slice(0, caretPosition).length - oldValue.slice(0, caretPosition).length);
        }
        else if (oldValue !== newValue) {
            if (caretPosition >= oldValueLength) {
                caretPosition = newValueLength;
            }
            else {
                caretPosition = caretPosition + (newValue.slice(0, caretPosition).length - oldValue.slice(0, caretPosition).length);
            }
        }
        return caretPosition;
    }
    getMasked(skipMaskChars, val, mask, isReversed = false) {
        const buf = [];
        const value = val;
        let maskIndex = 0;
        const maskLen = mask.length;
        let valueIndex = 0;
        const valueLength = value.length;
        let offset = 1;
        let addMethod = 'push';
        let resetPos = -1;
        let lastMaskChar;
        let lastUntranslatedMaskChar;
        let check;
        if (isReversed) {
            addMethod = 'unshift';
            offset = -1;
            lastMaskChar = 0;
            maskIndex = maskLen - 1;
            valueIndex = valueLength - 1;
        }
        else {
            lastMaskChar = maskLen - 1;
        }
        check = this.isToCheck(isReversed, maskIndex, maskLen, valueIndex, valueLength);
        while (check) {
            const maskDigit = mask.charAt(maskIndex), valDigit = value.charAt(valueIndex), translation = this.translationMask[maskDigit];
            if (translation) {
                if (valDigit.match(translation.pattern)) {
                    buf[addMethod](valDigit);
                    if (translation.recursive) {
                        if (resetPos === -1) {
                            resetPos = maskIndex;
                        }
                        else if (maskIndex === lastMaskChar) {
                            maskIndex = resetPos - offset;
                        }
                        if (lastMaskChar === resetPos) {
                            maskIndex -= offset;
                        }
                    }
                    maskIndex += offset;
                }
                else if (valDigit === lastUntranslatedMaskChar) {
                    lastUntranslatedMaskChar = undefined;
                }
                else if (translation.optional) {
                    maskIndex += offset;
                    valueIndex -= offset;
                }
                else {
                    this.invalidCharacters.push({
                        index: valueIndex,
                        digit: valDigit,
                        translated: translation.pattern
                    });
                }
                valueIndex += offset;
            }
            else {
                if (!skipMaskChars) {
                    buf[addMethod](maskDigit);
                }
                if (valDigit === maskDigit) {
                    valueIndex += offset;
                }
                else {
                    lastUntranslatedMaskChar = maskDigit;
                }
                maskIndex += offset;
            }
            check = this.isToCheck(isReversed, maskIndex, maskLen, valueIndex, valueLength);
        }
        const lastMaskCharDigit = mask.charAt(lastMaskChar);
        if (maskLen === valueLength + 1 && !this.translationMask[lastMaskCharDigit]) {
            buf.push(lastMaskCharDigit);
        }
        return buf.join('');
    }
    isToCheck(isReversed, maskIndex, maskLen, valueIndex, valueLength) {
        let check = false;
        if (isReversed) {
            check = (maskIndex > -1) && (valueIndex > -1);
        }
        else {
            check = (maskIndex < maskLen) && (valueIndex < valueLength);
        }
        return check;
    }
    setValue(value) {
        this.value = value;
    }
    getValue() {
        return this.value;
    }
}
InputMaskDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-text-mask], [textMask]',
                providers: [CUSTOM_INPUT_CONTROL_VALUE_ACCESSOR]
            },] }
];
InputMaskDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: Renderer2 }
];
InputMaskDirective.propDecorators = {
    inputMask: [{ type: Input, args: ['textMask',] }],
    onTextInput: [{ type: HostListener, args: ['input', ['$event'],] }, { type: HostListener, args: ['keyup', ['$event'],] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TextWidgetComponent extends WidgetComponent {
    constructor(formService) {
        super(formService);
        this.formService = formService;
    }
    ngOnInit() {
        if (this.field.params) {
            this.mask = this.field.params['inputMask'];
            this.placeholder = this.field.params['inputMask'] && this.field.params['inputMaskPlaceholder'] ? this.field.params['inputMaskPlaceholder'] : this.field.placeholder;
            this.isMaskReversed = this.field.params['inputMaskReversed'] ? this.field.params['inputMaskReversed'] : false;
        }
    }
}
TextWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'text-widget',
                template: "<div class=\"adf-textfield adf-text-widget {{field.className}}\"\n     [class.adf-invalid]=\"!field.isValid\" [class.adf-readonly]=\"field.readOnly\">\n    <mat-form-field>\n        <label class=\"adf-label\" [attr.for]=\"field.id\">{{field.name | translate }}<span *ngIf=\"isRequired()\">*</span></label>\n        <input matInput\n               class=\"adf-input\"\n               type=\"text\"\n               [id]=\"field.id\"\n               [required]=\"isRequired()\"\n               [value]=\"field.value\"\n               [(ngModel)]=\"field.value\"\n               (ngModelChange)=\"onFieldChanged(field)\"\n               [disabled]=\"field.readOnly || readOnly\"\n               [textMask]=\"{mask: mask, isReversed: isMaskReversed}\"\n               [placeholder]=\"placeholder\"\n               [matTooltip]=\"field.tooltip\"\n                matTooltipPosition=\"above\"\n                matTooltipShowDelay=\"1000\">\n    </mat-form-field>\n    <error-widget [error]=\"field.validationSummary\"></error-widget>\n    <error-widget *ngIf=\"isInvalidFieldRequired()\" required=\"{{ 'FORM.FIELD.REQUIRED' | translate }}\"></error-widget>\n</div>\n",
                host: {
                    '(click)': 'event($event)',
                    '(blur)': 'event($event)',
                    '(change)': 'event($event)',
                    '(focus)': 'event($event)',
                    '(focusin)': 'event($event)',
                    '(focusout)': 'event($event)',
                    '(input)': 'event($event)',
                    '(invalid)': 'event($event)',
                    '(select)': 'event($event)'
                },
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-text-widget{width:100%}.adf-text-widget .mat-form-field-label-wrapper{top:20px}"]
            },] }
];
TextWidgetComponent.ctorParameters = () => [
    { type: FormService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TypeaheadWidgetComponent extends WidgetComponent {
    constructor(formService, logService) {
        super(formService);
        this.formService = formService;
        this.logService = logService;
        this.minTermLength = 1;
        this.options = [];
    }
    ngOnInit() {
        if (this.field.form.taskId && this.field.restUrl) {
            this.getValuesByTaskId();
        }
        else if (this.field.form.processDefinitionId && this.field.restUrl) {
            this.getValuesByProcessDefinitionId();
        }
        if (this.isReadOnlyType()) {
            this.value = this.field.value;
        }
    }
    getValuesByTaskId() {
        this.formService
            .getRestFieldValues(this.field.form.taskId, this.field.id)
            .subscribe((formFieldOption) => {
            const options = formFieldOption || [];
            this.field.options = options;
            const fieldValue = this.field.value;
            if (fieldValue) {
                const toSelect = options.find((item) => item.id === fieldValue || item.name.toLocaleLowerCase() === fieldValue.toLocaleLowerCase());
                if (toSelect) {
                    this.value = toSelect.name;
                }
            }
            this.onFieldChanged(this.field);
            this.field.updateForm();
        }, (err) => this.handleError(err));
    }
    getValuesByProcessDefinitionId() {
        this.formService
            .getRestFieldValuesByProcessId(this.field.form.processDefinitionId, this.field.id)
            .subscribe((formFieldOption) => {
            const options = formFieldOption || [];
            this.field.options = options;
            const fieldValue = this.field.value;
            if (fieldValue) {
                const toSelect = options.find((item) => item.id === fieldValue);
                if (toSelect) {
                    this.value = toSelect.name;
                }
            }
            this.onFieldChanged(this.field);
            this.field.updateForm();
        }, (err) => this.handleError(err));
    }
    getOptions() {
        const val = this.value.trim().toLocaleLowerCase();
        return this.field.options.filter((item) => {
            const name = item.name.toLocaleLowerCase();
            return name.indexOf(val) > -1;
        });
    }
    isValidOptionName(optionName) {
        const option = this.field.options.find((item) => item.name && item.name.toLocaleLowerCase() === optionName.toLocaleLowerCase());
        return option ? true : false;
    }
    onKeyUp(event) {
        if (this.value && this.value.trim().length >= this.minTermLength && this.oldValue !== this.value) {
            if (event.keyCode !== ESCAPE && event.keyCode !== ENTER) {
                if (this.value.length >= this.minTermLength) {
                    this.options = this.getOptions();
                    this.oldValue = this.value;
                    if (this.isValidOptionName(this.value)) {
                        this.field.value = this.options[0].id;
                    }
                }
            }
        }
        if (this.isValueDefined() && this.value.trim().length === 0) {
            this.oldValue = this.value;
            this.options = [];
        }
    }
    onItemSelect(item) {
        if (item) {
            this.field.value = item.id;
            this.value = item.name;
            this.onFieldChanged(this.field);
        }
    }
    validate() {
        this.field.value = this.value;
    }
    isValueDefined() {
        return this.value !== null && this.value !== undefined;
    }
    handleError(error) {
        this.logService.error(error);
    }
    isReadOnlyType() {
        return this.field.type === 'readonly' ? true : false;
    }
}
TypeaheadWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'typeahead-widget',
                template: "<div class=\"adf-typeahead-widget-container\">\n    <div class=\"adf-typeahead-widget {{field.className}}\"\n        [class.is-dirty]=\"value\"\n        [class.adf-invalid]=\"!field.isValid\"\n        [class.adf-readonly]=\"field.readOnly\"\n        id=\"typehead-div\">\n        <mat-form-field>\n            <label class=\"adf-label\" [attr.for]=\"field.id\">{{field.name | translate }}</label>\n            <input matInput class=\"adf-input\"\n                   type=\"text\"\n                   [id]=\"field.id\"\n                   [(ngModel)]=\"value\"\n                   (ngModelChange)=\"validate()\"\n                   (keyup)=\"onKeyUp($event)\"\n                   [disabled]=\"field.readOnly\"\n                   data-automation-id=\"adf-typeahed-search-input\"\n                   placeholder=\"{{field.placeholder}}\"\n                   [matAutocomplete]=\"auto\">\n            <mat-autocomplete #auto=\"matAutocomplete\" (optionSelected)=\"onItemSelect($event.option.value)\">\n                <mat-option *ngFor=\"let item of options; let i = index\" id=\"adf-typeahed-widget-user-{{i}}\" [value]=\"item\">\n                    <span id=\"adf-typeahed-label-name\">{{item.name}}</span>\n                </mat-option>\n            </mat-autocomplete>\n        </mat-form-field>\n\n        <error-widget [error]=\"field.validationSummary\"></error-widget>\n        <error-widget *ngIf=\"isInvalidFieldRequired()\" required=\"{{ 'FORM.FIELD.REQUIRED' | translate }}\"></error-widget>\n    </div>\n</div>\n",
                host: {
                    '(click)': 'event($event)',
                    '(blur)': 'event($event)',
                    '(change)': 'event($event)',
                    '(focus)': 'event($event)',
                    '(focusin)': 'event($event)',
                    '(focusout)': 'event($event)',
                    '(input)': 'event($event)',
                    '(invalid)': 'event($event)',
                    '(select)': 'event($event)'
                },
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-typeahead-widget-container{display:block;position:relative}.adf-typeahead-widget{width:100%}"]
            },] }
];
TypeaheadWidgetComponent.ctorParameters = () => [
    { type: FormService },
    { type: LogService }
];

class ProcessContentService {
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
    }
    get contentApi() {
        var _a;
        this._contentApi = (_a = this._contentApi) !== null && _a !== void 0 ? _a : new ActivitiContentApi(this.apiService.getInstance());
        return this._contentApi;
    }
    createTemporaryRawRelatedContent(file) {
        return from(this.contentApi.createTemporaryRawRelatedContent(file))
            .pipe(catchError((err) => this.handleError(err)));
    }
    getFileContent(contentId) {
        return from(this.contentApi.getContent(contentId))
            .pipe(catchError((err) => this.handleError(err)));
    }
    getFileRawContent(contentId) {
        return from(this.contentApi.getRawContent(contentId))
            .pipe(catchError((err) => this.handleError(err)));
    }
    getContentPreview(contentId) {
        return new Observable((observer) => {
            this.contentApi.getRawContent(contentId).then((result) => {
                observer.next(result);
                observer.complete();
            }, () => {
                this.contentApi.getRawContent(contentId).then((data) => {
                    observer.next(data);
                    observer.complete();
                }, (err) => {
                    observer.error(err);
                    observer.complete();
                });
            });
        });
    }
    getFileRawContentUrl(contentId) {
        return this.contentApi.getRawContentUrl(contentId);
    }
    getContentThumbnail(contentId) {
        return from(this.contentApi.getRawContent(contentId, 'thumbnail'))
            .pipe(catchError((err) => this.handleError(err)));
    }
    getTaskRelatedContent(taskId, opts) {
        return from(this.contentApi.getRelatedContentForTask(taskId, opts))
            .pipe(catchError((err) => this.handleError(err)));
    }
    getProcessRelatedContent(processId, opts) {
        return from(this.contentApi.getRelatedContentForProcessInstance(processId, opts))
            .pipe(catchError((err) => this.handleError(err)));
    }
    deleteRelatedContent(contentId) {
        return from(this.contentApi.deleteContent(contentId))
            .pipe(catchError((err) => this.handleError(err)));
    }
    createProcessRelatedContent(processInstanceId, content, opts) {
        return from(this.contentApi.createRelatedContentOnProcessInstance(processInstanceId, content, opts))
            .pipe(catchError((err) => this.handleError(err)));
    }
    createTaskRelatedContent(taskId, file, opts) {
        return from(this.contentApi.createRelatedContentOnTask(taskId, file, opts))
            .pipe(catchError((err) => this.handleError(err)));
    }
    toJson(res) {
        if (res) {
            return res || {};
        }
        return {};
    }
    toJsonArray(res) {
        if (res) {
            return res.data || [];
        }
        return [];
    }
    handleError(error) {
        let errMsg = ProcessContentService.UNKNOWN_ERROR_MESSAGE;
        if (error) {
            errMsg = (error.message) ? error.message :
                error.status ? `${error.status} - ${error.statusText}` : ProcessContentService.GENERIC_ERROR_MESSAGE;
        }
        this.logService.error(errMsg);
        return throwError(errMsg);
    }
}
ProcessContentService.UNKNOWN_ERROR_MESSAGE = 'Unknown error';
ProcessContentService.GENERIC_ERROR_MESSAGE = 'Server error';
ProcessContentService.ɵprov = ɵɵdefineInjectable({ factory: function ProcessContentService_Factory() { return new ProcessContentService(ɵɵinject(AlfrescoApiService), ɵɵinject(LogService)); }, token: ProcessContentService, providedIn: "root" });
ProcessContentService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
ProcessContentService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: LogService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class UploadWidgetComponent extends WidgetComponent {
    constructor(formService, logService, thumbnailService, processContentService) {
        super(formService);
        this.formService = formService;
        this.logService = logService;
        this.thumbnailService = thumbnailService;
        this.processContentService = processContentService;
        this.multipleOption = '';
    }
    ngOnInit() {
        if (this.field &&
            this.field.value &&
            this.field.value.length > 0) {
            this.hasFile = true;
        }
        this.getMultipleFileParam();
    }
    removeFile(file) {
        if (this.field) {
            this.removeElementFromList(file);
        }
    }
    onFileChanged(event) {
        const files = event.target.files;
        let filesSaved = [];
        if (this.field.json.value) {
            filesSaved = [...this.field.json.value];
        }
        if (files && files.length > 0) {
            from(files)
                .pipe(mergeMap((file) => this.uploadRawContent(file)))
                .subscribe((res) => filesSaved.push(res), () => this.logService.error('Error uploading file. See console output for more details.'), () => {
                this.field.value = filesSaved;
                this.field.json.value = filesSaved;
                this.hasFile = true;
            });
        }
    }
    uploadRawContent(file) {
        return this.processContentService.createTemporaryRawRelatedContent(file)
            .pipe(map((response) => {
            this.logService.info(response);
            response.contentBlob = file;
            return response;
        }));
    }
    getMultipleFileParam() {
        if (this.field &&
            this.field.params &&
            this.field.params.multiple) {
            this.multipleOption = this.field.params.multiple ? 'multiple' : '';
        }
    }
    removeElementFromList(file) {
        const index = this.field.value.indexOf(file);
        if (index !== -1) {
            this.field.value.splice(index, 1);
            this.field.json.value = this.field.value;
            this.field.updateForm();
        }
        this.hasFile = this.field.value.length > 0;
        if (!this.hasFile) {
            this.field.value = null;
            this.field.json.value = null;
        }
    }
    getIcon(mimeType) {
        return this.thumbnailService.getMimeTypeIcon(mimeType);
    }
    fileClicked(contentLinkModel) {
        const file = new ContentLinkModel(contentLinkModel);
        let fetch = this.processContentService.getContentPreview(file.id);
        if (file.isTypeImage() || file.isTypePdf()) {
            fetch = this.processContentService.getFileRawContent(file.id);
        }
        fetch.subscribe((blob) => {
            file.contentBlob = blob;
            this.formService.formContentClicked.next(file);
        }, () => {
            this.logService.error('Unable to send event for file ' + file.name);
        });
    }
}
UploadWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'upload-widget',
                template: "<div class=\"adf-upload-widget {{field.className}}\"\n     [class.adf-invalid]=\"!field.isValid\"\n     [class.adf-readonly]=\"field.readOnly\">\n    <label class=\"adf-label\" [attr.for]=\"field.id\">{{field.name | translate }}<span *ngIf=\"isRequired()\">*</span></label>\n    <div class=\"adf-upload-widget-container\">\n        <div>\n            <mat-list *ngIf=\"hasFile\">\n                <mat-list-item class=\"adf-upload-files-row\" *ngFor=\"let file of field.value\">\n                    <img mat-list-icon class=\"adf-upload-widget__icon\"\n                         [id]=\"'file-'+file.id+'-icon'\"\n                         [src]=\"getIcon(file.mimeType)\"\n                         [alt]=\"mimeTypeIcon\"\n                         (click)=\"fileClicked(file)\"\n                         (keyup.enter)=\"fileClicked(file)\"\n                         role=\"button\"\n                         tabindex=\"0\"/>\n                    <span matLine id=\"{{'file-'+file.id}}\" (click)=\"fileClicked(file)\" (keyup.enter)=\"fileClicked(file)\"\n                          role=\"button\" tabindex=\"0\" class=\"adf-file\">{{file.name}}</span>\n                    <button *ngIf=\"!field.readOnly\" mat-icon-button [id]=\"'file-'+file.id+'-remove'\"\n                            (click)=\"removeFile(file);\" (keyup.enter)=\"removeFile(file);\">\n                        <mat-icon class=\"mat-24\">highlight_off</mat-icon>\n                    </button>\n                </mat-list-item>\n            </mat-list>\n        </div>\n\n        <div *ngIf=\"(!hasFile || multipleOption) && !field.readOnly\">\n            <button mat-raised-button color=\"primary\" (click)=\"uploadFiles.click()\">\n                {{ 'FORM.FIELD.UPLOAD' | translate }}<mat-icon>file_upload</mat-icon>\n                <input #uploadFiles\n                       [multiple]=\"multipleOption\"\n                       type=\"file\"\n                       [id]=\"field.id\"\n                       (change)=\"onFileChanged($event)\"/>\n            </button>\n        </div>\n    </div>\n    <error-widget [error]=\"field.validationSummary\"></error-widget>\n    <error-widget *ngIf=\"isInvalidFieldRequired()\" required=\"{{ 'FORM.FIELD.REQUIRED' | translate }}\"></error-widget>\n</div>\n",
                host: {
                    '(click)': 'event($event)',
                    '(blur)': 'event($event)',
                    '(change)': 'event($event)',
                    '(focus)': 'event($event)',
                    '(focusin)': 'event($event)',
                    '(focusout)': 'event($event)',
                    '(input)': 'event($event)',
                    '(invalid)': 'event($event)',
                    '(select)': 'event($event)'
                },
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-upload-widget-container{margin-bottom:15px}.adf-upload-widget-container input{display:none}.adf-upload-widget{border-top:.84375em solid transparent;padding:.4375em 0;width:100%;word-break:break-all}.adf-upload-widget__icon{cursor:pointer;float:left;padding:6px}.adf-upload-widget__reset{margin-top:-2px}.adf-upload-files-row .mat-line{margin-bottom:0}"]
            },] }
];
UploadWidgetComponent.ctorParameters = () => [
    { type: FormService },
    { type: LogService },
    { type: ThumbnailService },
    { type: ProcessContentService }
];
UploadWidgetComponent.propDecorators = {
    fileInput: [{ type: ViewChild, args: ['uploadFiles',] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ɵ0$5 = MOMENT_DATE_FORMATS, ɵ1$3 = MAT_MOMENT_DATETIME_FORMATS;
class DateTimeWidgetComponent extends WidgetComponent {
    constructor(formService, dateAdapter, userPreferencesService) {
        super(formService);
        this.formService = formService;
        this.dateAdapter = dateAdapter;
        this.userPreferencesService = userPreferencesService;
        this.onDestroy$ = new Subject();
    }
    ngOnInit() {
        this.userPreferencesService
            .select(UserPreferenceValues.Locale)
            .pipe(takeUntil(this.onDestroy$))
            .subscribe(locale => this.dateAdapter.setLocale(locale));
        const momentDateAdapter = this.dateAdapter;
        momentDateAdapter.overrideDisplayFormat = this.field.dateDisplayFormat;
        if (this.field) {
            if (this.field.minValue) {
                this.minDate = moment(this.field.minValue, 'YYYY-MM-DDTHH:mm:ssZ');
            }
            if (this.field.maxValue) {
                this.maxDate = moment(this.field.maxValue, 'YYYY-MM-DDTHH:mm:ssZ');
            }
        }
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
    onDateChanged(newDateValue) {
        const date = moment(newDateValue, this.field.dateDisplayFormat, true);
        if (date.isValid()) {
            this.field.value = date.format(this.field.dateDisplayFormat);
        }
        else {
            this.field.value = newDateValue;
        }
        this.onFieldChanged(this.field);
    }
}
DateTimeWidgetComponent.decorators = [
    { type: Component, args: [{
                providers: [
                    { provide: DateAdapter, useClass: MomentDateAdapter },
                    { provide: MAT_DATE_FORMATS, useValue: ɵ0$5 },
                    { provide: DatetimeAdapter, useClass: MomentDatetimeAdapter },
                    { provide: MAT_DATETIME_FORMATS, useValue: ɵ1$3 }
                ],
                selector: 'date-time-widget',
                template: "<div class=\"{{field.className}}\" id=\"data-time-widget\" [class.adf-invalid]=\"!field.isValid\">\n    <mat-form-field class=\"adf-date-time-widget\">\n        <label class=\"adf-label\" [attr.for]=\"field.id\">{{field.name | translate }} ({{field.dateDisplayFormat}})<span *ngIf=\"isRequired()\">*</span></label>\n        <input matInput\n               [id]=\"field.id\"\n               [value]=\"field.value\"\n               [required]=\"isRequired()\"\n               [disabled]=\"field.readOnly\"\n               (change)=\"onDateChanged($any($event).srcElement.value)\"\n               [placeholder]=\"field.placeholder\"\n               [matTooltip]=\"field.tooltip\"\n               matTooltipPosition=\"above\"\n               matTooltipShowDelay=\"1000\"\n               (focus)=\"datetimePicker.open()\">\n        <mat-datetimepicker-toggle matSuffix [for]=\"datetimePicker\" [disabled]=\"field.readOnly\"></mat-datetimepicker-toggle>\n    </mat-form-field>\n    <error-widget [error]=\"field.validationSummary\"></error-widget>\n    <error-widget *ngIf=\"isInvalidFieldRequired()\" required=\"{{ 'FORM.FIELD.REQUIRED' | translate }}\"></error-widget>\n    <mat-datetimepicker #datetimePicker type=\"datetime\" [touchUi]=\"true\" [timeInterval]=\"5\" [disabled]=\"field.readOnly\"></mat-datetimepicker>\n        <input\n            type=\"hidden\"\n            [matDatetimepicker]=\"datetimePicker\"\n            [value]=\"field.value | adfMomentDate: field.dateDisplayFormat\"\n            [min]=\"minDate\"\n            [max]=\"maxDate\"\n            [disabled]=\"field.readOnly\"\n            (dateInput)=\"onDateChanged($any($event).targetElement.value)\">\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-date-time-widget .mat-form-field-suffix{top:26px}.adf-date-time-widget .mat-form-field-label-wrapper{top:20px}"]
            },] }
];
DateTimeWidgetComponent.ctorParameters = () => [
    { type: FormService },
    { type: DateAdapter },
    { type: UserPreferencesService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class JsonWidgetComponent extends WidgetComponent {
    constructor(formService, dialog) {
        super(formService);
        this.formService = formService;
        this.dialog = dialog;
    }
    view() {
        const rawValue = this.field.value;
        const value = typeof rawValue === 'object'
            ? JSON.stringify(rawValue || {}, null, 2)
            : rawValue;
        const settings = {
            title: this.field.name,
            editable: false,
            value
        };
        this.dialog
            .open(EditJsonDialogComponent, {
            data: settings,
            minWidth: '50%',
            minHeight: '50%'
        });
    }
}
JsonWidgetComponent.decorators = [
    { type: Component, args: [{
                template: `
        <button mat-raised-button color="primary" (click)="view()">json</button>
    `,
                host: {
                    '(click)': 'event($event)',
                    '(blur)': 'event($event)',
                    '(change)': 'event($event)',
                    '(focus)': 'event($event)',
                    '(focusin)': 'event($event)',
                    '(focusout)': 'event($event)',
                    '(input)': 'event($event)',
                    '(invalid)': 'event($event)',
                    '(select)': 'event($event)'
                },
                encapsulation: ViewEncapsulation.None
            },] }
];
JsonWidgetComponent.ctorParameters = () => [
    { type: FormService },
    { type: MatDialog }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class UploadFolderWidgetComponent extends WidgetComponent {
    constructor(formService, logService, thumbnailService, processContentService) {
        super(formService);
        this.formService = formService;
        this.logService = logService;
        this.thumbnailService = thumbnailService;
        this.processContentService = processContentService;
        this.multipleOption = '';
    }
    ngOnInit() {
        if (this.field &&
            this.field.value &&
            this.field.value.length > 0) {
            this.hasFile = true;
        }
        this.getMultipleFileParam();
    }
    removeFile(file) {
        if (this.field) {
            this.removeElementFromList(file);
        }
    }
    onFileChanged(event) {
        const files = event.target.files;
        let filesSaved = [];
        if (this.field.json.value) {
            filesSaved = [...this.field.json.value];
        }
        if (files && files.length > 0) {
            from(files)
                .pipe(mergeMap((file) => this.uploadRawContent(file)))
                .subscribe((res) => {
                filesSaved.push(res);
            }, () => {
                this.logService.error('Error uploading file. See console output for more details.');
            }, () => {
                this.field.value = filesSaved;
                this.field.json.value = filesSaved;
            });
            this.hasFile = true;
        }
    }
    uploadRawContent(file) {
        return this.processContentService.createTemporaryRawRelatedContent(file).pipe(map((response) => {
            this.logService.info(response);
            return response;
        }));
    }
    getMultipleFileParam() {
        if (this.field &&
            this.field.params &&
            this.field.params.multiple) {
            this.multipleOption = this.field.params.multiple ? 'multiple' : '';
        }
    }
    removeElementFromList(file) {
        const index = this.field.value.indexOf(file);
        if (index !== -1) {
            this.field.value.splice(index, 1);
            this.field.json.value = this.field.value;
            this.field.updateForm();
        }
        this.hasFile = this.field.value.length > 0;
        this.resetFormValueWithNoFiles();
    }
    resetFormValueWithNoFiles() {
        if (this.field.value.length === 0) {
            this.field.value = [];
            this.field.json.value = [];
        }
    }
    getIcon(mimeType) {
        return this.thumbnailService.getMimeTypeIcon(mimeType);
    }
    fileClicked(contentLinkModel) {
        const file = new ContentLinkModel(contentLinkModel);
        let fetch = this.processContentService.getContentPreview(file.id);
        if (file.isTypeImage() || file.isTypePdf()) {
            fetch = this.processContentService.getFileRawContent(file.id);
        }
        fetch.subscribe((blob) => {
            file.contentBlob = blob;
            this.formService.formContentClicked.next(file);
        }, () => {
            this.logService.error('Unable to send event for file ' + file.name);
        });
    }
}
UploadFolderWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'upload-folder-widget',
                template: "<div class=\"adf-upload-folder-widget {{field.className}}\"\n    [class.adf-invalid]=\"!field.isValid\"\n    [class.adf-readonly]=\"field.readOnly\">\n<label class=\"adf-label\" [attr.for]=\"field.id\">{{field.name | translate }}<span *ngIf=\"isRequired()\">*</span></label>\n    <div class=\"adf-upload-widget-container\">\n    </div>\n</div>\n",
                host: {
                    '(click)': 'event($event)',
                    '(blur)': 'event($event)',
                    '(change)': 'event($event)',
                    '(focus)': 'event($event)',
                    '(focusin)': 'event($event)',
                    '(focusout)': 'event($event)',
                    '(input)': 'event($event)',
                    '(invalid)': 'event($event)',
                    '(select)': 'event($event)'
                },
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-upload-folder-widget{border-top:.84375em solid transparent;padding:.4375em 0;width:100%;word-break:break-all}"]
            },] }
];
UploadFolderWidgetComponent.ctorParameters = () => [
    { type: FormService },
    { type: LogService },
    { type: ThumbnailService },
    { type: ProcessContentService }
];
UploadFolderWidgetComponent.propDecorators = {
    fileInput: [{ type: ViewChild, args: ['uploadFiles',] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FileViewerWidgetComponent extends WidgetComponent {
    constructor(formService) {
        super(formService);
    }
}
FileViewerWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'file-viewer-widget',
                template: "<div class=\"adf-file-viewer-widget {{field.className}}\" [class.adf-invalid]=\"!field.isValid\"\n    [class.adf-readonly]=\"field.readOnly\">\n    <label class=\"adf-label\" [attr.for]=\"field.id\">{{field.name | translate }}<span\n            *ngIf=\"isRequired()\">*</span></label>\n    <adf-viewer [overlayMode]=\"false\" [nodeId]=\"field.value\" [showViewer]=\"field.value\" [allowGoBack]=\"false\"></adf-viewer>\n    <error-widget [error]=\"field.validationSummary\"></error-widget>\n</div>\n",
                host: {
                    '(click)': 'event($event)',
                    '(blur)': 'event($event)',
                    '(change)': 'event($event)',
                    '(focus)': 'event($event)',
                    '(focusin)': 'event($event)',
                    '(focusout)': 'event($event)',
                    '(input)': 'event($event)',
                    '(invalid)': 'event($event)',
                    '(select)': 'event($event)'
                },
                encapsulation: ViewEncapsulation.None,
                styles: ["file-viewer-widget,file-viewer-widget .adf-file-viewer-widget{height:100%;width:100%}file-viewer-widget .adf-file-viewer-widget adf-viewer.adf-viewer{position:relative}file-viewer-widget .adf-file-viewer-widget adf-viewer.adf-viewer .adf-viewer-container .adf-viewer-content>div{height:90vh}"]
            },] }
];
FileViewerWidgetComponent.ctorParameters = () => [
    { type: FormService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const WIDGET_DIRECTIVES = [
    UnknownWidgetComponent,
    TabsWidgetComponent,
    ContainerWidgetComponent,
    TextWidgetComponent,
    NumberWidgetComponent,
    CheckboxWidgetComponent,
    MultilineTextWidgetComponentComponent,
    DropdownWidgetComponent,
    HyperlinkWidgetComponent,
    RadioButtonsWidgetComponent,
    DisplayTextWidgetComponent,
    UploadWidgetComponent,
    TypeaheadWidgetComponent,
    FunctionalGroupWidgetComponent,
    PeopleWidgetComponent,
    DateWidgetComponent,
    AmountWidgetComponent,
    DynamicTableWidgetComponent,
    DateEditorComponent,
    DropdownEditorComponent,
    BooleanEditorComponent,
    TextEditorComponent,
    RowEditorComponent,
    ErrorWidgetComponent,
    DocumentWidgetComponent,
    DateTimeWidgetComponent,
    DateTimeEditorComponent,
    JsonWidgetComponent,
    AmountEditorComponent,
    UploadFolderWidgetComponent,
    FileViewerWidgetComponent
];
const MASK_DIRECTIVE = [
    InputMaskDirective
];

class FormRenderingService extends DynamicComponentMapper {
    constructor() {
        super(...arguments);
        this.defaultValue = UnknownWidgetComponent;
        this.types = {
            'text': DynamicComponentResolver.fromType(TextWidgetComponent),
            'string': DynamicComponentResolver.fromType(TextWidgetComponent),
            'integer': DynamicComponentResolver.fromType(NumberWidgetComponent),
            'multi-line-text': DynamicComponentResolver.fromType(MultilineTextWidgetComponentComponent),
            'boolean': DynamicComponentResolver.fromType(CheckboxWidgetComponent),
            'dropdown': DynamicComponentResolver.fromType(DropdownWidgetComponent),
            'date': DynamicComponentResolver.fromType(DateWidgetComponent),
            'amount': DynamicComponentResolver.fromType(AmountWidgetComponent),
            'radio-buttons': DynamicComponentResolver.fromType(RadioButtonsWidgetComponent),
            'hyperlink': DynamicComponentResolver.fromType(HyperlinkWidgetComponent),
            'readonly-text': DynamicComponentResolver.fromType(DisplayTextWidgetComponent),
            'json': DynamicComponentResolver.fromType(JsonWidgetComponent),
            'readonly': DynamicComponentResolver.fromType(TextWidgetComponent),
            'typeahead': DynamicComponentResolver.fromType(TypeaheadWidgetComponent),
            'people': DynamicComponentResolver.fromType(PeopleWidgetComponent),
            'functional-group': DynamicComponentResolver.fromType(FunctionalGroupWidgetComponent),
            'dynamic-table': DynamicComponentResolver.fromType(DynamicTableWidgetComponent),
            'container': DynamicComponentResolver.fromType(ContainerWidgetComponent),
            'group': DynamicComponentResolver.fromType(ContainerWidgetComponent),
            'document': DynamicComponentResolver.fromType(DocumentWidgetComponent),
            'upload': DynamicComponentResolver.fromType(UploadWidgetComponent),
            'datetime': DynamicComponentResolver.fromType(DateTimeWidgetComponent),
            'file-viewer': DynamicComponentResolver.fromType(FileViewerWidgetComponent)
        };
    }
}
FormRenderingService.ɵprov = ɵɵdefineInjectable({ factory: function FormRenderingService_Factory() { return new FormRenderingService(); }, token: FormRenderingService, providedIn: "root" });
FormRenderingService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FormFieldComponent {
    constructor(formRenderingService, componentFactoryResolver, visibilityService, compiler) {
        this.formRenderingService = formRenderingService;
        this.componentFactoryResolver = componentFactoryResolver;
        this.visibilityService = visibilityService;
        this.compiler = compiler;
        this.field = null;
        this.focus = false;
    }
    ngOnInit() {
        const w = window;
        if (w.adf === undefined) {
            w.adf = {};
        }
        const originalField = this.getField();
        if (originalField) {
            const customTemplate = this.field.form.customFieldTemplates[originalField.type];
            if (customTemplate && this.hasController(originalField.type)) {
                const factory = this.getComponentFactorySync(originalField.type, customTemplate);
                this.componentRef = this.container.createComponent(factory);
                const instance = this.componentRef.instance;
                if (instance) {
                    instance.field = originalField;
                }
            }
            else {
                const componentType = this.formRenderingService.resolveComponentType(originalField);
                if (componentType) {
                    const factory = this.componentFactoryResolver.resolveComponentFactory(componentType);
                    this.componentRef = this.container.createComponent(factory);
                    const instance = this.componentRef.instance;
                    instance.field = this.field;
                    instance.fieldChanged.subscribe((field) => {
                        if (field && this.field.form) {
                            this.visibilityService.refreshVisibility(field.form);
                            field.form.onFormFieldChanged(field);
                        }
                    });
                }
            }
        }
    }
    ngOnDestroy() {
        if (this.componentRef) {
            this.componentRef.destroy();
            this.componentRef = null;
        }
    }
    getField() {
        if (this.field && this.field.params) {
            const wrappedField = this.field.params.field;
            if (wrappedField && wrappedField.type) {
                return wrappedField;
            }
        }
        return this.field;
    }
    hasController(type) {
        return (adf && adf.components && adf.components[type]);
    }
    getComponentFactorySync(type, template) {
        const componentInfo = adf.components[type];
        if (componentInfo.factory) {
            return componentInfo.factory;
        }
        const metadata = {
            selector: `runtime-component-${type}`,
            template: template
        };
        const factory = this.createComponentFactorySync(this.compiler, metadata, componentInfo.class);
        componentInfo.factory = factory;
        return factory;
    }
    createComponentFactorySync(compiler, metadata, componentClass) {
        const cmpClass = componentClass || class RuntimeComponent {
        };
        const decoratedCmp = Component(metadata)(cmpClass);
        const moduleClass = class RuntimeComponentModule {
        };
        const decoratedNgModule = NgModule({ imports: [], declarations: [decoratedCmp] })(moduleClass);
        const module = compiler.compileModuleAndAllComponentsSync(decoratedNgModule);
        return module.componentFactories.find((x) => x.componentType === decoratedCmp);
    }
    focusToggle() {
        setTimeout(() => {
            this.focus = !this.focus;
        });
    }
}
FormFieldComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-form-field',
                template: `
        <div [id]="'field-'+field?.id+'-container'"
            [hidden]="!field?.isVisible"
            [class.adf-focus]="focus"
            (focusin)="focusToggle()"
            (focusout)="focusToggle()">
            <div #container></div>
        </div>
    `,
                encapsulation: ViewEncapsulation.None
            },] }
];
FormFieldComponent.ctorParameters = () => [
    { type: FormRenderingService },
    { type: ComponentFactoryResolver },
    { type: WidgetVisibilityService },
    { type: Compiler }
];
FormFieldComponent.propDecorators = {
    container: [{ type: ViewChild, args: ['container', { read: ViewContainerRef, static: true },] }],
    field: [{ type: Input }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FormBaseComponent {
    constructor() {
        this.showTitle = true;
        this.showCompleteButton = true;
        this.disableCompleteButton = false;
        this.disableSaveButton = false;
        this.disableStartProcessButton = false;
        this.showSaveButton = true;
        this.readOnly = false;
        this.showRefreshButton = true;
        this.showValidationIcon = true;
        this.formError = new EventEmitter();
        this.executeOutcome = new EventEmitter();
        this.error = new EventEmitter();
    }
    getParsedFormDefinition() {
        return this;
    }
    hasForm() {
        return !!this.form;
    }
    isTitleEnabled() {
        let titleEnabled = false;
        if (this.showTitle && this.form) {
            titleEnabled = true;
        }
        return titleEnabled;
    }
    getColorForOutcome(outcomeName) {
        return outcomeName === FormBaseComponent.COMPLETE_OUTCOME_NAME ? FormBaseComponent.COMPLETE_BUTTON_COLOR : null;
    }
    isOutcomeButtonEnabled(outcome) {
        if (this.form.readOnly) {
            return false;
        }
        if (outcome) {
            if (outcome.name === FormOutcomeModel.SAVE_ACTION) {
                return !this.disableSaveButton;
            }
            if (outcome.name === FormOutcomeModel.COMPLETE_ACTION) {
                return this.disableCompleteButton ? false : this.form.isValid;
            }
            if (outcome.name === FormOutcomeModel.START_PROCESS_ACTION) {
                return this.disableStartProcessButton ? false : this.form.isValid;
            }
            return this.form.isValid;
        }
        return false;
    }
    isOutcomeButtonVisible(outcome, isFormReadOnly) {
        if (outcome && outcome.name) {
            if (outcome.name === FormOutcomeModel.COMPLETE_ACTION) {
                return this.showCompleteButton;
            }
            if (isFormReadOnly) {
                return outcome.isSelected;
            }
            if (outcome.name === FormOutcomeModel.SAVE_ACTION) {
                return this.showSaveButton;
            }
            if (outcome.name === FormOutcomeModel.START_PROCESS_ACTION) {
                return false;
            }
            return true;
        }
        return false;
    }
    onOutcomeClicked(outcome) {
        if (!this.readOnly && outcome && this.form) {
            if (!this.onExecuteOutcome(outcome)) {
                return false;
            }
            if (outcome.isSystem) {
                if (outcome.id === FormBaseComponent.SAVE_OUTCOME_ID) {
                    this.saveTaskForm();
                    return true;
                }
                if (outcome.id === FormBaseComponent.COMPLETE_OUTCOME_ID) {
                    this.completeTaskForm();
                    return true;
                }
                if (outcome.id === FormBaseComponent.START_PROCESS_OUTCOME_ID) {
                    this.completeTaskForm();
                    return true;
                }
                if (outcome.id === FormBaseComponent.CUSTOM_OUTCOME_ID) {
                    this.onTaskSaved(this.form);
                    this.storeFormAsMetadata();
                    return true;
                }
            }
            else {
                if (outcome.name) {
                    this.onTaskSaved(this.form);
                    this.completeTaskForm(outcome.name);
                    return true;
                }
            }
        }
        return false;
    }
    handleError(err) {
        this.error.emit(err);
    }
}
FormBaseComponent.SAVE_OUTCOME_ID = '$save';
FormBaseComponent.COMPLETE_OUTCOME_ID = '$complete';
FormBaseComponent.START_PROCESS_OUTCOME_ID = '$startProcess';
FormBaseComponent.CUSTOM_OUTCOME_ID = '$custom';
FormBaseComponent.COMPLETE_BUTTON_COLOR = 'primary';
FormBaseComponent.COMPLETE_OUTCOME_NAME = 'COMPLETE';
FormBaseComponent.decorators = [
    { type: Directive }
];
FormBaseComponent.propDecorators = {
    path: [{ type: Input }],
    nameNode: [{ type: Input }],
    showTitle: [{ type: Input }],
    showCompleteButton: [{ type: Input }],
    disableCompleteButton: [{ type: Input }],
    disableSaveButton: [{ type: Input }],
    disableStartProcessButton: [{ type: Input }],
    showSaveButton: [{ type: Input }],
    readOnly: [{ type: Input }],
    showRefreshButton: [{ type: Input }],
    showValidationIcon: [{ type: Input }],
    fieldValidators: [{ type: Input }],
    formError: [{ type: Output }],
    executeOutcome: [{ type: Output }],
    error: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FormListComponent {
    constructor(formService) {
        this.formService = formService;
        this.forms = [];
    }
    ngOnChanges() {
        this.getForms();
    }
    isEmpty() {
        return this.forms && this.forms.length === 0;
    }
    getForms() {
        this.formService.getForms().subscribe((forms) => {
            this.forms.push(...forms);
        });
    }
}
FormListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-form-list',
                template: "<adf-datatable *ngIf=\"!isEmpty()\"\n    [rows]=\"forms\">\n    <data-columns>\n        <data-column key=\"name\" type=\"text\" title=\"Name\" class=\"adf-ellipsis-cell\" [sortable]=\"true\"></data-column>\n        <data-column key=\"lastUpdatedByFullName\" type=\"text\" title=\"User\" class=\"adf-ellipsis-cell\" [sortable]=\"true\"></data-column>\n        <data-column key=\"lastUpdated\" type=\"date\" format=\"shortDate\" title=\"Date\"></data-column>\n    </data-columns>\n</adf-datatable>\n",
                encapsulation: ViewEncapsulation.None
            },] }
];
FormListComponent.ctorParameters = () => [
    { type: FormService }
];
FormListComponent.propDecorators = {
    forms: [{ type: Input }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ContentWidgetComponent {
    constructor(formService, logService, contentService, processContentService) {
        this.formService = formService;
        this.logService = logService;
        this.contentService = contentService;
        this.processContentService = processContentService;
        this.showDocumentContent = true;
        this.contentClick = new EventEmitter();
        this.thumbnailLoaded = new EventEmitter();
        this.contentLoaded = new EventEmitter();
        this.error = new EventEmitter();
    }
    ngOnChanges(changes) {
        const contentId = changes['id'];
        if (contentId && contentId.currentValue) {
            this.loadContent(contentId.currentValue);
        }
    }
    loadContent(id) {
        this.processContentService
            .getFileContent(id)
            .subscribe((response) => {
            this.content = new ContentLinkModel(response);
            this.contentLoaded.emit(this.content);
            this.loadThumbnailUrl(this.content);
        }, (error) => {
            this.error.emit(error);
        });
    }
    loadThumbnailUrl(content) {
        if (this.content.isThumbnailSupported()) {
            let observable;
            if (this.content.isTypeImage()) {
                observable = this.processContentService.getFileRawContent(content.id);
            }
            else {
                observable = this.processContentService.getContentThumbnail(content.id);
            }
            if (observable) {
                observable.subscribe((response) => {
                    this.content.thumbnailUrl = this.contentService.createTrustedUrl(response);
                    this.thumbnailLoaded.emit(this.content.thumbnailUrl);
                }, (error) => {
                    this.error.emit(error);
                });
            }
        }
    }
    openViewer(content) {
        let fetch = this.processContentService.getContentPreview(content.id);
        if (content.isTypeImage() || content.isTypePdf()) {
            fetch = this.processContentService.getFileRawContent(content.id);
        }
        fetch.subscribe((blob) => {
            content.contentBlob = blob;
            this.contentClick.emit(content);
            this.logService.info('Content clicked' + content.id);
            this.formService.formContentClicked.next(content);
        }, (error) => {
            this.error.emit(error);
        });
    }
    download(content) {
        this.processContentService.getFileRawContent(content.id).subscribe((blob) => this.contentService.downloadBlob(blob, content.name), (error) => {
            this.error.emit(error);
        });
    }
}
ContentWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-content',
                template: "<mat-card class=\"adf-content-container\" *ngIf=\"content\">\n    <mat-card-content *ngIf=\"showDocumentContent\">\n        <div *ngIf=\"content.isThumbnailSupported()\" >\n            <img id=\"thumbnailPreview\" class=\"adf-img-upload-widget\" [src]=\"content.thumbnailUrl\" alt=\"{{content.name}}\">\n        </div>\n        <div *ngIf=\"!content.isThumbnailSupported()\">\n            <mat-icon>image</mat-icon>\n            <div id=\"unsupported-thumbnail\" class=\"adf-content-widget-preview-text\">{{ 'FORM.PREVIEW.IMAGE_NOT_AVAILABLE' | translate }}\n            </div>\n        </div>\n        <div class=\"mdl-card__supporting-text upload-widget__content-text\">{{content.name | translate }}</div>\n    </mat-card-content>\n\n    <mat-card-actions>\n        <button mat-icon-button id=\"view\" (click)=\"openViewer(content)\">\n            <mat-icon class=\"mat-24\">zoom_in</mat-icon>\n        </button>\n        <button mat-icon-button id=\"download\" (click)=\"download(content)\">\n            <mat-icon class=\"mat-24\">file_download</mat-icon>\n        </button>\n    </mat-card-actions>\n</mat-card>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-img-upload-widget{background-color:#fff;border:1px solid hsla(0,0%,45.9%,.57);box-shadow:1px 1px 2px #ddd;height:100%;width:100%}.adf-content-widget-preview-text{text-align:center;word-break:break-all;word-wrap:break-word}"]
            },] }
];
ContentWidgetComponent.ctorParameters = () => [
    { type: FormService },
    { type: LogService },
    { type: ContentService },
    { type: ProcessContentService }
];
ContentWidgetComponent.propDecorators = {
    id: [{ type: Input }],
    showDocumentContent: [{ type: Input }],
    contentClick: [{ type: Output }],
    thumbnailLoaded: [{ type: Output }],
    contentLoaded: [{ type: Output }],
    error: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class StartFormCustomButtonDirective {
}
StartFormCustomButtonDirective.decorators = [
    { type: Directive, args: [{ selector: '[adf-form-custom-button], [form-custom-button]' },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FormRendererComponent {
    constructor() {
        this.showDebugButton = false;
    }
}
FormRendererComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-form-renderer',
                template: "<div class=\"{{formDefinition.className}}\" [ngClass]=\"{'adf-readonly-form': formDefinition.readOnly }\">\n    <div *ngIf=\"formDefinition.hasTabs()\">\n        <tabs-widget [tabs]=\"formDefinition.tabs\"></tabs-widget>\n    </div>\n\n    <div *ngIf=\"!formDefinition.hasTabs() && formDefinition.hasFields()\">\n        <div *ngFor=\"let field of formDefinition.fields\">\n            <adf-form-field [field]=\"field.field\"></adf-form-field>\n        </div>\n    </div>\n</div>\n<!--\nFor debugging and data visualisation purposes,\nwill be removed during future revisions\n-->\n<div *ngIf=\"showDebugButton\" class=\"adf-form-debug-container\">\n    <mat-slide-toggle [(ngModel)]=\"debugMode\">Debug mode</mat-slide-toggle>\n    <div *ngIf=\"debugMode\">\n        <h4>Values</h4>\n        <pre>{{formDefinition.values | json}}</pre>\n\n        <h4>Form</h4>\n        <pre>{{formDefinition.json | json}}</pre>\n    </div>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-form-container{max-height:100%!important;max-width:100%!important}.adf-form-container .mat-card{overflow:hidden;padding:16px 24px}.adf-form-container .mat-card-header-text{margin:0!important}.adf-form-container .mat-tab-body-content{overflow:hidden}.adf-form-container .mat-tab-label{color:rgba(0,0,0,.54);font-size:var(--theme-subheading-2-font-size);letter-spacing:-.4px;line-height:var(--theme-headline-line-height);text-align:left;text-transform:uppercase}.adf-form-container .mat-ink-bar{height:4px}.adf-form-container .mat-form-field-wrapper{margin:0 12px 0 0}.adf-form-title{font-size:var(--theme-title-font-size);overflow:hidden;text-overflow:ellipsis;white-space:nowrap}.adf-form-debug-container{padding:10px}.adf-form-debug-container .adf-debug-toggle-text{cursor:pointer;padding-left:15px}.adf-form-debug-container .adf-debug-toggle-text:hover{font-weight:700}.adf-form-reload-button{position:absolute;right:12px;top:30px}.adf-form-validation-button{color:var(--theme-accent-color);position:absolute;right:50px;top:39px}.adf-form-validation-button .adf-invalid-color{color:var(--theme-warn-color)}.adf-form-hide-button{display:none!important}.adf-task-title{text-align:center}.adf-label{font-size:var(--theme-caption-font-size);height:16px;line-height:var(--theme-headline-line-height);text-align:left;white-space:nowrap;width:32px}.adf-form-mat-card-actions{float:right;padding-bottom:25px!important;padding-right:25px!important}.adf-form-mat-card-actions .mat-button{border-radius:5px;height:36px}.adf-form-mat-card-actions .mat-button-wrapper{font-size:var(--theme-body-2-font-size);font-weight:700;height:20px;opacity:.54;width:58px}form-field{width:100%}form-field .mat-input-element{font-size:var(--theme-body-2-font-size);line-height:normal;padding-top:8px}"]
            },] }
];
FormRendererComponent.propDecorators = {
    showDebugButton: [{ type: Input }],
    formDefinition: [{ type: Input }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

class ActivitiContentService {
    constructor(apiService, logService, sitesService) {
        this.apiService = apiService;
        this.logService = logService;
        this.sitesService = sitesService;
    }
    get integrationAlfrescoOnPremiseApi() {
        var _a;
        this._integrationAlfrescoOnPremiseApi = (_a = this._integrationAlfrescoOnPremiseApi) !== null && _a !== void 0 ? _a : new IntegrationAlfrescoOnPremiseApi(this.apiService.getInstance());
        return this._integrationAlfrescoOnPremiseApi;
    }
    get contentApi() {
        var _a;
        this._contentApi = (_a = this._contentApi) !== null && _a !== void 0 ? _a : new ActivitiContentApi(this.apiService.getInstance());
        return this._contentApi;
    }
    getAlfrescoNodes(accountId, folderId) {
        const accountShortId = accountId.replace('alfresco-', '');
        return from(this.integrationAlfrescoOnPremiseApi.getContentInFolder(accountShortId, folderId))
            .pipe(map(this.toJsonArray), catchError((err) => this.handleError(err)));
    }
    getAlfrescoRepositories(tenantId, includeAccount) {
        const opts = {
            tenantId,
            includeAccounts: includeAccount ? includeAccount : true
        };
        return from(this.integrationAlfrescoOnPremiseApi.getRepositories(opts))
            .pipe(map(this.toJsonArray), catchError((err) => this.handleError(err)));
    }
    linkAlfrescoNode(accountId, node, siteId) {
        return from(this.contentApi.createTemporaryRelatedContent({
            link: true,
            name: node.title,
            simpleType: node.simpleType,
            source: accountId,
            sourceId: node.id + '@' + siteId
        }))
            .pipe(map(this.toJson), catchError((err) => this.handleError(err)));
    }
    applyAlfrescoNode(node, siteId, accountId) {
        var _a;
        const currentSideId = siteId ? siteId : this.sitesService.getSiteNameFromNodePath(node);
        const params = {
            source: accountId,
            mimeType: (_a = node === null || node === void 0 ? void 0 : node.content) === null || _a === void 0 ? void 0 : _a.mimeType,
            sourceId: node.id + ';' + node.properties['cm:versionLabel'] + '@' + currentSideId,
            name: node.name,
            link: node.isLink
        };
        return from(this.contentApi.createTemporaryRelatedContent(params))
            .pipe(map(this.toJson), catchError((err) => this.handleError(err)));
    }
    toJson(res) {
        if (res) {
            return res || {};
        }
        return {};
    }
    toJsonArray(res) {
        if (res) {
            return res.data || [];
        }
        return [];
    }
    handleError(error) {
        let errMsg = ActivitiContentService.UNKNOWN_ERROR_MESSAGE;
        if (error) {
            errMsg = (error.message) ? error.message :
                error.status ? `${error.status} - ${error.statusText}` : ActivitiContentService.GENERIC_ERROR_MESSAGE;
        }
        this.logService.error(errMsg);
        return throwError(errMsg);
    }
}
ActivitiContentService.UNKNOWN_ERROR_MESSAGE = 'Unknown error';
ActivitiContentService.GENERIC_ERROR_MESSAGE = 'Server error';
ActivitiContentService.ɵprov = ɵɵdefineInjectable({ factory: function ActivitiContentService_Factory() { return new ActivitiContentService(ɵɵinject(AlfrescoApiService), ɵɵinject(LogService), ɵɵinject(SitesService)); }, token: ActivitiContentService, providedIn: "root" });
ActivitiContentService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
ActivitiContentService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: LogService },
    { type: SitesService }
];

class NodeService {
    constructor(nodesApiService) {
        this.nodesApiService = nodesApiService;
    }
    getNodeMetadata(nodeId) {
        return this.nodesApiService.getNodeMetadata(nodeId);
    }
    createNodeMetadata(nodeType, nameSpace, data, path, name) {
        return this.nodesApiService.createNodeMetadata(nodeType, nameSpace, data, path, name);
    }
    createNode(name, nodeType, properties, path) {
        return this.nodesApiService.createNodeInsideRoot(name, nodeType, properties, path);
    }
}
NodeService.ɵprov = ɵɵdefineInjectable({ factory: function NodeService_Factory() { return new NodeService(ɵɵinject(NodesApiService)); }, token: NodeService, providedIn: "root" });
NodeService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
NodeService.ctorParameters = () => [
    { type: NodesApiService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FormErrorEvent extends FormEvent {
    constructor(form, error) {
        super(form);
        this.error = error;
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class EditJsonDialogModule {
}
EditJsonDialogModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FormsModule,
                    ReactiveFormsModule,
                    TranslateModule,
                    MatDialogModule,
                    MatButtonModule
                ],
                declarations: [
                    EditJsonDialogComponent
                ],
                exports: [
                    EditJsonDialogComponent
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FormBaseModule {
}
FormBaseModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    A11yModule,
                    FlexLayoutModule,
                    DataTableModule,
                    HttpClientModule,
                    MaterialModule,
                    TranslateModule,
                    FormsModule,
                    ReactiveFormsModule,
                    DataColumnModule,
                    PipeModule,
                    MatDatetimepickerModule,
                    MatNativeDatetimeModule,
                    EditJsonDialogModule,
                    ViewerModule
                ],
                declarations: [
                    ContentWidgetComponent,
                    FormFieldComponent,
                    FormListComponent,
                    FormRendererComponent,
                    StartFormCustomButtonDirective,
                    ...WIDGET_DIRECTIVES,
                    ...MASK_DIRECTIVE,
                    WidgetComponent
                ],
                exports: [
                    ContentWidgetComponent,
                    FormFieldComponent,
                    FormListComponent,
                    FormRendererComponent,
                    StartFormCustomButtonDirective,
                    ...WIDGET_DIRECTIVES
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class HeaderLayoutComponent {
    constructor() {
        this.redirectUrl = '/';
        this.showSidenavToggle = true;
        this.clicked = new EventEmitter();
        this.expandedSidenav = true;
        this.position = 'start';
    }
    toggleMenu() {
        this.clicked.emit(true);
        this.expandedSidenav = !this.expandedSidenav;
    }
    ngOnInit() {
        if (!this.logo) {
            this.logo = './assets/images/logo.png';
        }
    }
}
HeaderLayoutComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-layout-header',
                template: "<mat-toolbar\n    [color]=\"color\"\n    [style.background-color]=\"color\"\n    role=\"heading\"\n    aria-level=\"1\">\n    <button\n        *ngIf=\"showSidenavToggle && position === 'start'\"\n        id=\"adf-sidebar-toggle-start\"\n        data-automation-id=\"adf-menu-icon\"\n        class=\"mat-icon-button adf-menu-icon\"\n        mat-icon-button\n        (click)=\"toggleMenu()\"\n        [attr.aria-expanded]=\"expandedSidenav\"\n        [attr.aria-label]=\"'CORE.HEADER.ACCESSIBILITY.SIDEBAR_TOGGLE_BUTTON_ARIA_LABEL' | translate\">\n        <mat-icon\n            class=\"mat-icon material-icon\"\n            role=\"img\"\n            aria-hidden=\"true\">menu</mat-icon>\n    </button>\n\n    <a [routerLink]=\"redirectUrl\" title=\"{{ tooltip }}\">\n        <img\n            src=\"{{ logo }}\"\n            class=\"adf-app-logo\"\n            alt=\"{{ 'CORE.HEADER.LOGO_ARIA' | translate }}\"\n        />\n    </a>\n\n    <span\n        role=\"link\"\n        [attr.aria-label]=\"title | translate\"\n        [routerLink]=\"redirectUrl\"\n        fxFlex=\"1 1 auto\"\n        fxShow\n        fxHide.lt-sm=\"true\"\n        class=\"adf-app-title\"\n        >{{ title }}</span>\n    <ng-content></ng-content>\n\n    <button\n        *ngIf=\"showSidenavToggle && position === 'end'\"\n        id=\"adf-sidebar-toggle-end\"\n        data-automation-id=\"adf-menu-icon\"\n        class=\"mat-icon-button adf-menu-icon\"\n        mat-icon-button\n        (click)=\"toggleMenu()\"\n        [attr.aria-expanded]=\"expandedSidenav\"\n        [attr.aria-label]=\"'CORE.HEADER.ACCESSIBILITY.SIDEBAR_TOGGLE_BUTTON_ARIA_LABEL' | translate\">\n    >\n        <mat-icon\n            class=\"mat-icon material-icon\"\n            role=\"img\"\n            aria-hidden=\"true\">menu</mat-icon>\n    </button>\n</mat-toolbar>\n",
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-layout-header' },
                styles: ["adf-layout-header .mat-toolbar-single-row{background-color:var(--adf-header-background-color);color:var(--adf-header-text-color)!important;padding:0 24px;position:relative}adf-layout-header .mat-toolbar-single-row .adf-menu-icon{margin-right:0;position:relative}adf-layout-header .mat-toolbar-single-row .adf-menu-icon .mat-icon{font-size:29px;padding:0 5px 0 0}adf-layout-header .mat-toolbar-single-row .adf-app-logo{height:28px;margin-top:-3px;position:relative;vertical-align:middle}adf-layout-header .mat-toolbar-single-row .adf-app-title{cursor:pointer;font-weight:100;letter-spacing:-.3px}adf-layout-header .mat-toolbar-single-row .adf-toolbar--spacer{flex:1 1 auto}adf-layout-header .mat-toolbar-single-row .adf-toolbar-divider{margin:0 5px}adf-layout-header .mat-toolbar-single-row .adf-toolbar-divider>div{background-color:var(--theme-card-bg-color)}adf-layout-header .mat-toolbar-single-row .adf-header-delimiter{background-color:var(--theme-primary-color-default-contrast);height:24px;width:2px}adf-layout-header .mat-toolbar-single-row .adf-userinfo-container{flex-direction:row;padding:0}@media screen and (max-width:599px){adf-layout-header .mat-toolbar-single-row .adf-app-logo,adf-layout-header .mat-toolbar-single-row .adf-app-title{display:none}}[dir=rtl] adf-layout-header .mat-toolbar-single-row .adf-menu-icon{margin-right:-11px}[dir=rtl] adf-layout-header .mat-toolbar-single-row .adf-app-logo{margin-right:6px}[dir=rtl] adf-layout-header .mat-toolbar-single-row .adf-app-title{margin-right:6px}[dir=rtl] adf-layout-header .mat-toolbar-single-row .adf-header-delimiter{margin-left:16px}[dir=rtl] adf-layout-header .mat-toolbar-single-row .adf-userinfo-container{margin-left:16px}[dir=rtl] adf-layout-header .mat-toolbar-single-row .adf-userinfo-name{padding-left:8px}[dir=ltr] adf-layout-header .mat-toolbar-single-row .adf-menu-icon{margin-left:-11px}[dir=ltr] adf-layout-header .mat-toolbar-single-row .adf-app-logo{margin-left:6px}[dir=ltr] adf-layout-header .mat-toolbar-single-row .adf-app-title{margin-left:6px}[dir=ltr] adf-layout-header .mat-toolbar-single-row .adf-header-delimiter{margin-right:16px}[dir=ltr] adf-layout-header .mat-toolbar-single-row .adf-userinfo-container{margin-right:16px}[dir=ltr] adf-layout-header .mat-toolbar-single-row .adf-userinfo-name{padding-right:8px}"]
            },] }
];
HeaderLayoutComponent.propDecorators = {
    title: [{ type: Input }],
    logo: [{ type: Input }],
    redirectUrl: [{ type: Input }],
    tooltip: [{ type: Input }],
    color: [{ type: Input }],
    showSidenavToggle: [{ type: Input }],
    clicked: [{ type: Output }],
    expandedSidenav: [{ type: Input }],
    position: [{ type: Input }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const sidenavAnimation = trigger('sidenavAnimation', [
    state('expanded', style({ width: '{{ width }}px' }), { params: { width: 0 } }),
    state('compact', style({ width: '{{ width }}px' }), { params: { width: 0 } }),
    transition('compact <=> expanded', animate('0.4s cubic-bezier(0.25, 0.8, 0.25, 1)'))
]);
const contentAnimation = trigger('contentAnimationLeft', [
    state('expanded', style({
        'margin-left': '{{ margin-left }}px',
        'margin-right': '{{ margin-right }}px'
    }), { params: { 'margin-left': 0, 'margin-right': 0 } }),
    state('compact', style({
        'margin-left': '{{ margin-left }}px',
        'margin-right': '{{ margin-right }}px'
    }), { params: { 'margin-left': 0, 'margin-right': 0 } }),
    transition('expanded <=> compact', animate('400ms cubic-bezier(0.25, 0.8, 0.25, 1)'))
]);

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class LayoutContainerComponent {
    constructor() {
        this.hideSidenav = false;
        this.expandedSidenav = true;
        this.position = 'start';
        this.direction = 'ltr';
        this.SIDENAV_STATES = { MOBILE: {}, EXPANDED: {}, COMPACT: {} };
        this.CONTENT_STATES = { MOBILE: {}, EXPANDED: {}, COMPACT: {} };
        this.onMediaQueryChange = this.onMediaQueryChange.bind(this);
    }
    ngOnInit() {
        this.SIDENAV_STATES.MOBILE = { value: 'expanded', params: { width: this.sidenavMax } };
        this.SIDENAV_STATES.EXPANDED = { value: 'expanded', params: { width: this.sidenavMax } };
        this.SIDENAV_STATES.COMPACT = { value: 'compact', params: { width: this.sidenavMin } };
        this.CONTENT_STATES.MOBILE = { value: 'expanded' };
        this.mediaQueryList.addListener(this.onMediaQueryChange);
        if (this.isMobileScreenSize) {
            this.sidenavAnimationState = this.SIDENAV_STATES.MOBILE;
            this.contentAnimationState = this.CONTENT_STATES.MOBILE;
        }
        else if (this.expandedSidenav) {
            this.sidenavAnimationState = this.SIDENAV_STATES.EXPANDED;
            this.contentAnimationState = this.toggledContentAnimation;
        }
        else {
            this.sidenavAnimationState = this.SIDENAV_STATES.COMPACT;
            this.contentAnimationState = this.toggledContentAnimation;
        }
    }
    ngOnDestroy() {
        this.mediaQueryList.removeListener(this.onMediaQueryChange);
    }
    ngOnChanges(changes) {
        if (changes && changes.direction) {
            this.contentAnimationState = this.toggledContentAnimation;
        }
    }
    toggleMenu() {
        if (this.isMobileScreenSize) {
            this.sidenav.toggle();
        }
        else {
            this.sidenavAnimationState = this.toggledSidenavAnimation;
            this.contentAnimationState = this.toggledContentAnimation;
        }
    }
    get isMobileScreenSize() {
        return this.mediaQueryList.matches;
    }
    getContentAnimationState() {
        return this.contentAnimationState;
    }
    get toggledSidenavAnimation() {
        return this.sidenavAnimationState === this.SIDENAV_STATES.EXPANDED
            ? this.SIDENAV_STATES.COMPACT
            : this.SIDENAV_STATES.EXPANDED;
    }
    get toggledContentAnimation() {
        if (this.isMobileScreenSize) {
            return this.CONTENT_STATES.MOBILE;
        }
        if (this.sidenavAnimationState === this.SIDENAV_STATES.EXPANDED) {
            if (this.position === 'start' && this.direction === 'ltr') {
                return { value: 'compact', params: { 'margin-left': this.sidenavMax } };
            }
            if (this.position === 'start' && this.direction === 'rtl') {
                return { value: 'compact', params: { 'margin-right': this.sidenavMax } };
            }
            if (this.position === 'end' && this.direction === 'ltr') {
                return { value: 'compact', params: { 'margin-right': this.sidenavMax } };
            }
            if (this.position === 'end' && this.direction === 'rtl') {
                return { value: 'compact', params: { 'margin-left': this.sidenavMax } };
            }
        }
        else {
            if (this.position === 'start' && this.direction === 'ltr') {
                return { value: 'expanded', params: { 'margin-left': this.sidenavMin } };
            }
            if (this.position === 'start' && this.direction === 'rtl') {
                return { value: 'expanded', params: { 'margin-right': this.sidenavMin } };
            }
            if (this.position === 'end' && this.direction === 'ltr') {
                return { value: 'expanded', params: { 'margin-right': this.sidenavMin } };
            }
            if (this.position === 'end' && this.direction === 'rtl') {
                return { value: 'expanded', params: { 'margin-left': this.sidenavMin } };
            }
        }
    }
    onMediaQueryChange() {
        this.sidenavAnimationState = this.SIDENAV_STATES.EXPANDED;
        this.contentAnimationState = this.toggledContentAnimation;
    }
}
LayoutContainerComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-layout-container',
                template: "<mat-sidenav-container>\n    <mat-sidenav\n        [position]=\"position\"\n        [disableClose]=\"!isMobileScreenSize\"\n        [ngClass]=\"{ 'adf-sidenav--hidden': hideSidenav }\"\n        [@sidenavAnimation]=\"sidenavAnimationState\"\n        [opened]=\"!isMobileScreenSize\"\n        [mode]=\"isMobileScreenSize ? 'over' : 'side'\">\n        <ng-content sidenav select=\"[app-layout-navigation]\"></ng-content>\n    </mat-sidenav>\n\n    <div>\n        <div class=\"adf-container-full-width\" [@contentAnimationLeft]=\"getContentAnimationState()\">\n            <ng-content select=\"[app-layout-content]\"></ng-content>\n        </div>\n    </div>\n</mat-sidenav-container>\n",
                encapsulation: ViewEncapsulation.None,
                animations: [sidenavAnimation, contentAnimation],
                styles: ["adf-layout-container{display:block;height:100%;overflow:hidden;width:100%}.adf-container-full-width{width:inherit}@media screen and (-ms-high-contrast:active),screen and (-ms-high-contrast:none){.adf-container-full-width{width:100%}}.adf-sidenav--hidden{opacity:0!important;transform:unset!important;visibility:hidden!important;width:0!important}.mat-sidenav-container{display:block;height:100%;overflow:hidden;width:100%}.mat-sidenav{background-color:var(--theme-background-color);border-right:1px solid var(--theme-border-color);overflow:hidden}.mat-drawer-transition .mat-drawer-content,mat-sidenav-content.mat-sidenav-content{margin-left:0!important;transform:unset!important;transition-duration:unset!important;transition-property:unset!important;transition-timing-function:unset!important}mat-sidenav-content>div{display:flex;height:100%}mat-sidenav-content>div>div{flex:auto}"]
            },] }
];
LayoutContainerComponent.ctorParameters = () => [];
LayoutContainerComponent.propDecorators = {
    sidenavMin: [{ type: Input }],
    sidenavMax: [{ type: Input }],
    mediaQueryList: [{ type: Input }],
    hideSidenav: [{ type: Input }],
    expandedSidenav: [{ type: Input }],
    position: [{ type: Input }],
    direction: [{ type: Input }],
    sidenav: [{ type: ViewChild, args: [MatSidenav, { static: true },] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class SidebarActionMenuComponent {
    constructor() {
        this.width = 272;
    }
    isExpanded() {
        return this.expanded;
    }
}
SidebarActionMenuComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-sidebar-action-menu',
                template: "<div class=\"adf-sidebar-action-menu\">\n    <button *ngIf=\"isExpanded()\" mat-raised-button class=\"adf-sidebar-action-menu-button\" data-automation-id=\"create-button\" [matMenuTriggerFor]=\"adfSidebarMenu\">\n        <span *ngIf=\"title\" class=\"adf-sidebar-action-menu-text\">{{ title }}</span>\n        <ng-content select=\"[adf-sidebar-menu-title-icon], [sidebar-menu-title-icon]\"></ng-content>\n    </button>\n\n    <div *ngIf=\"!isExpanded()\" class=\"adf-sidebar-action-menu-icon\" [matMenuTriggerFor]=\"adfSidebarMenu\">\n        <ng-content select=\"[adf-sidebar-menu-expand-icon], [sidebar-menu-expand-icon]\"></ng-content>\n    </div>\n\n    <mat-menu #adfSidebarMenu=\"matMenu\" class=\"adf-sidebar-action-menu-panel\" [overlapTrigger]=\"false\" yPosition=\"below\">\n        <div class=\"adf-sidebar-action-menu-options\" [style.width.px]=\"width\">\n            <ng-content select=\"[adf-sidebar-menu-options], [sidebar-menu-options]\"></ng-content>\n        </div>\n    </mat-menu>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                host: { 'class': 'adf-sidebar-action-menu' },
                styles: [".adf-sidebar-action-menu .mat-raised-button{background-color:var(--theme-primary-color);border-radius:4px;box-shadow:none!important;color:var(--theme-primary-color-default-contrast)!important;display:block;font-weight:700;height:37.5px;width:100%}.adf-sidebar-action-menu .mat-raised-button mat-icon{color:var(--theme-primary-color-default-contrast)!important;height:25px;width:24px}.adf-sidebar-action-menu-text{height:20px;text-align:left;width:100%}.adf-sidebar-action-menu-icon{color:var(--theme-text-color);cursor:pointer;margin:18px 0 0 20px}.adf-sidebar-action-menu-icon:hover{color:var(--theme-primary-color)}.adf-sidebar-action-menu-options{letter-spacing:-.4px;text-align:left}.adf-sidebar-action-menu-options .mat-menu-item{color:var(--theme-text-bold-color);font-size:14px;letter-spacing:-.4px;line-height:1.5;text-align:left}.adf-sidebar-action-menu-options .mat-menu-item:hover{color:var(--theme-primary-color);opacity:inherit}.adf-sidebar-action-menu-panel{border-radius:2px;box-shadow:0 3px 1px -2px rgba(0,0,0,.2),0 2px 2px 0 rgba(0,0,0,.14),0 1px 5px 0 rgba(0,0,0,.12);margin-top:7.5px}"]
            },] }
];
SidebarActionMenuComponent.propDecorators = {
    title: [{ type: Input }],
    expanded: [{ type: Input }],
    width: [{ type: Input }]
};
class SidebarMenuDirective {
}
SidebarMenuDirective.decorators = [
    { type: Directive, args: [{ selector: '[adf-sidebar-menu-options], [sidebar-menu-options]' },] }
];
class SidebarMenuTitleIconDirective {
}
SidebarMenuTitleIconDirective.decorators = [
    { type: Directive, args: [{ selector: '[adf-sidebar-menu-title-icon], [sidebar-menu-title-icon]' },] }
];
class SidebarMenuExpandIconDirective {
}
SidebarMenuExpandIconDirective.decorators = [
    { type: Directive, args: [{ selector: '[adf-sidebar-menu-expand-icon], [sidebar-menu-expand-icon]' },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class SidenavLayoutContentDirective {
}
SidenavLayoutContentDirective.decorators = [
    { type: Directive, args: [{
                selector: 'adf-sidenav-layout-content'
            },] }
];
SidenavLayoutContentDirective.propDecorators = {
    template: [{ type: ContentChild, args: [TemplateRef,] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class SidenavLayoutHeaderDirective {
}
SidenavLayoutHeaderDirective.decorators = [
    { type: Directive, args: [{
                selector: 'adf-sidenav-layout-header'
            },] }
];
SidenavLayoutHeaderDirective.propDecorators = {
    template: [{ type: ContentChild, args: [TemplateRef,] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class SidenavLayoutNavigationDirective {
}
SidenavLayoutNavigationDirective.decorators = [
    { type: Directive, args: [{
                selector: 'adf-sidenav-layout-navigation'
            },] }
];
SidenavLayoutNavigationDirective.propDecorators = {
    template: [{ type: ContentChild, args: [TemplateRef,] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class SidenavLayoutComponent {
    constructor(mediaMatcher, userPreferencesService) {
        this.mediaMatcher = mediaMatcher;
        this.userPreferencesService = userPreferencesService;
        this.dir = 'ltr';
        this.position = 'start';
        this.hideSidenav = false;
        this.expandedSidenav = true;
        this.expanded = new EventEmitter();
        this.templateContext = {
            toggleMenu: () => { },
            isMenuMinimized: () => this.isMenuMinimized
        };
        this.onDestroy$ = new Subject();
        this.onMediaQueryChange = this.onMediaQueryChange.bind(this);
    }
    ngOnInit() {
        const initialMenuState = !this.expandedSidenav;
        this.menuOpenStateSubject = new BehaviorSubject(initialMenuState);
        this.menuOpenState$ = this.menuOpenStateSubject.asObservable();
        const stepOver = this.stepOver || SidenavLayoutComponent.STEP_OVER;
        this.isMenuMinimized = initialMenuState;
        this.mediaQueryList = this.mediaMatcher.matchMedia(`(max-width: ${stepOver}px)`);
        this.mediaQueryList.addListener(this.onMediaQueryChange);
        this.userPreferencesService
            .select('textOrientation')
            .pipe(takeUntil(this.onDestroy$))
            .subscribe((direction) => {
            this.dir = direction;
        });
    }
    ngAfterViewInit() {
        this.templateContext.toggleMenu = this.toggleMenu.bind(this);
    }
    ngOnDestroy() {
        this.mediaQueryList.removeListener(this.onMediaQueryChange);
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
    toggleMenu() {
        if (!this.mediaQueryList.matches) {
            this.isMenuMinimized = !this.isMenuMinimized;
        }
        else {
            this.isMenuMinimized = false;
        }
        this.container.toggleMenu();
        this.expanded.emit(!this.isMenuMinimized);
    }
    get isMenuMinimized() {
        return this._isMenuMinimized;
    }
    set isMenuMinimized(menuState) {
        this._isMenuMinimized = menuState;
        this.menuOpenStateSubject.next(!menuState);
    }
    get isHeaderInside() {
        return this.mediaQueryList.matches;
    }
    get headerTemplate() {
        return this.headerDirective && this.headerDirective.template || this.emptyTemplate;
    }
    get navigationTemplate() {
        return this.navigationDirective && this.navigationDirective.template || this.emptyTemplate;
    }
    get contentTemplate() {
        return this.contentDirective && this.contentDirective.template || this.emptyTemplate;
    }
    onMediaQueryChange() {
        this.isMenuMinimized = false;
        this.expanded.emit(!this.isMenuMinimized);
    }
}
SidenavLayoutComponent.STEP_OVER = 600;
SidenavLayoutComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-sidenav-layout',
                template: "<div class=\"adf-sidenav-layout-full-space\">\n    <ng-container *ngIf=\"!isHeaderInside\">\n        <ng-container class=\"adf-sidenav-layout-outer-header\"\n                      *ngTemplateOutlet=\"headerTemplate; context:templateContext\"></ng-container>\n    </ng-container>\n\n    <adf-layout-container #container\n                          [direction]=\"dir\"\n                          [position]=\"position\"\n                          [sidenavMin]=\"sidenavMin\"\n                          [sidenavMax]=\"sidenavMax\"\n                          [mediaQueryList]=\"mediaQueryList\"\n                          [hideSidenav]=\"hideSidenav\"\n                          [expandedSidenav]=\"expandedSidenav\"\n                          data-automation-id=\"adf-layout-container\"\n                          class=\"adf-layout__content\">\n\n        <ng-container app-layout-navigation\n                      *ngTemplateOutlet=\"navigationTemplate; context:templateContext\"></ng-container>\n\n        <ng-container app-layout-content>\n            <ng-container *ngIf=\"isHeaderInside\">\n                <ng-container *ngTemplateOutlet=\"headerTemplate; context:templateContext\"></ng-container>\n            </ng-container>\n            <ng-container *ngTemplateOutlet=\"contentTemplate; context:templateContext\"></ng-container>\n        </ng-container>\n    </adf-layout-container>\n\n    <ng-template #emptyTemplate></ng-template>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-sidenav-layout' },
                styles: [".adf-sidenav-layout,.adf-sidenav-layout-full-space{display:flex;flex:1;flex-direction:column;height:100%;min-height:0;overflow:hidden;width:100%}.adf-sidenav-layout .adf-layout__content{flex:1 1 auto}.adf-sidenav-layout router-outlet{flex:0 0}@media (max-width:599.9px){.adf-sidenav-layout .mat-drawer{max-width:300px!important;width:calc(-50px + 100vw)!important}}.adf-sidenav-layout .mat-drawer-content{display:flex;flex:1;flex-direction:column;height:100%;min-height:0;overflow:hidden;overflow:auto;position:unset}"]
            },] }
];
SidenavLayoutComponent.ctorParameters = () => [
    { type: MediaMatcher },
    { type: UserPreferencesService }
];
SidenavLayoutComponent.propDecorators = {
    position: [{ type: Input }],
    sidenavMin: [{ type: Input }],
    sidenavMax: [{ type: Input }],
    stepOver: [{ type: Input }],
    hideSidenav: [{ type: Input }],
    expandedSidenav: [{ type: Input }],
    expanded: [{ type: Output }],
    headerDirective: [{ type: ContentChild, args: [SidenavLayoutHeaderDirective,] }],
    navigationDirective: [{ type: ContentChild, args: [SidenavLayoutNavigationDirective,] }],
    contentDirective: [{ type: ContentChild, args: [SidenavLayoutContentDirective,] }],
    container: [{ type: ViewChild, args: ['container', { static: true },] }],
    emptyTemplate: [{ type: ViewChild, args: ['emptyTemplate', { static: true },] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class SidenavLayoutModule {
}
SidenavLayoutModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    RouterModule,
                    TranslateModule
                ],
                exports: [
                    SidenavLayoutHeaderDirective,
                    SidenavLayoutContentDirective,
                    SidenavLayoutNavigationDirective,
                    SidenavLayoutComponent,
                    LayoutContainerComponent,
                    SidebarActionMenuComponent,
                    SidebarMenuDirective,
                    SidebarMenuExpandIconDirective,
                    SidebarMenuTitleIconDirective,
                    HeaderLayoutComponent
                ],
                declarations: [
                    SidenavLayoutHeaderDirective,
                    SidenavLayoutContentDirective,
                    SidenavLayoutNavigationDirective,
                    SidenavLayoutComponent,
                    LayoutContainerComponent,
                    SidebarActionMenuComponent,
                    SidebarMenuDirective,
                    SidebarMenuExpandIconDirective,
                    SidebarMenuTitleIconDirective,
                    HeaderLayoutComponent
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CommentListComponent {
    constructor(peopleProcessService, ecmUserService, userPreferenceService) {
        this.peopleProcessService = peopleProcessService;
        this.ecmUserService = ecmUserService;
        this.userPreferenceService = userPreferenceService;
        this.clickRow = new EventEmitter();
        this.onDestroy$ = new Subject();
    }
    ngOnInit() {
        this.userPreferenceService
            .select(UserPreferenceValues.Locale)
            .pipe(takeUntil(this.onDestroy$))
            .subscribe(locale => this.currentLocale = locale);
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
    selectComment(comment) {
        if (this.selectedComment) {
            this.selectedComment.isSelected = false;
        }
        comment.isSelected = true;
        this.selectedComment = comment;
        this.clickRow.emit(this.selectedComment);
    }
    getUserShortName(user) {
        let shortName = '';
        if (user) {
            if (user.firstName) {
                shortName = user.firstName[0].toUpperCase();
            }
            if (user.lastName) {
                shortName += user.lastName[0].toUpperCase();
            }
        }
        return shortName;
    }
    isPictureDefined(user) {
        return user.pictureId || user.avatarId;
    }
    getUserImage(user) {
        if (this.isAContentUsers(user)) {
            return this.ecmUserService.getUserProfileImage(user.avatarId);
        }
        else {
            return this.peopleProcessService.getUserImage(user);
        }
    }
    isAContentUsers(user) {
        return user.avatarId;
    }
}
CommentListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-comment-list',
                template: " <mat-list class=\"adf-comment-list\">\n    <mat-list-item *ngFor=\"let comment of comments\"\n                  (click)=\"selectComment(comment)\"\n                  class=\"adf-comment-list-item\"\n                  [class.adf-is-selected]=\"comment.isSelected\"\n                  id=\"adf-comment-{{comment?.id}}\">\n        <div id=\"comment-user-icon\" class=\"adf-comment-img-container\">\n            <div\n                *ngIf=\"!isPictureDefined(comment.createdBy)\"\n                class=\"adf-comment-user-icon\">\n                {{getUserShortName(comment.createdBy)}}\n            </div>\n            <div>\n                <img [alt]=\"comment.createdBy\" *ngIf=\"isPictureDefined(comment.createdBy)\"\n                      class=\"adf-people-img\"\n                     [src]=\"getUserImage(comment.createdBy)\" />\n            </div>\n        </div>\n        <div class=\"adf-comment-contents\">\n            <div matLine id=\"comment-user\" class=\"adf-comment-user-name\">\n                {{comment.createdBy?.firstName}} {{comment.createdBy?.lastName}}\n            </div>\n            <div matLine id=\"comment-message\" class=\"adf-comment-message\" [innerHTML]=\"comment.message\"></div>\n            <div matLine id=\"comment-time\" class=\"adf-comment-message-time\">\n                {{ comment.created | adfTimeAgo: currentLocale }}\n            </div>\n        </div>\n    </mat-list-item>\n</mat-list>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-is-selected{background:var(--adf-comment-list-primary-color)}.adf-comment-img-container{align-self:flex-start;display:flex;float:left;height:100%;padding-top:18px;width:40px}.adf-comment-list-item{background-position:50%;display:table-row-group;height:100%!important;overflow:hidden;padding-top:12px;transition:background .8s;white-space:normal}.adf-comment-list-item:hover{background:var(--adf-comment-list-primary-color) radial-gradient(circle,transparent 1%,var(--adf-comment-list-primary-color) 0) 50%/15000%}.adf-comment-list-item:active{background-color:var(--adf-comment-list-ripple-color);background-size:100%;transition:background 0s}.adf-comment-user-icon{background-color:var(--theme-primary-color);background-size:cover;border-radius:50%;color:var(--theme-primary-color-default-contrast);font-size:16px;height:20px;padding:10px 5px;text-align:center;width:30px}.adf-comment-user-name{float:left;font-size:14px;font-weight:600;padding:2px 10px;width:90%}.adf-comment-message{font-size:14px;font-style:italic;letter-spacing:-.2px;line-height:1.43;white-space:normal!important;width:calc(100% - 10px)}.adf-comment-message,.adf-comment-message-time{color:var(--theme-foreground-text-color);float:left;padding:2px 10px}.adf-comment-message-time{font-size:12px!important;width:90%}.adf-comment-contents{padding-bottom:12px;padding-left:5px;padding-top:12px;width:calc(100% - 10px)}.adf-people-img{border-radius:90%;height:40px;vertical-align:middle;width:40px}"]
            },] }
];
CommentListComponent.ctorParameters = () => [
    { type: PeopleProcessService },
    { type: EcmUserService },
    { type: UserPreferencesService }
];
CommentListComponent.propDecorators = {
    comments: [{ type: Input }],
    clickRow: [{ type: Output }]
};

class CommentProcessService {
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
    }
    get commentsApi() {
        var _a;
        this._commentsApi = (_a = this._commentsApi) !== null && _a !== void 0 ? _a : new ActivitiCommentsApi(this.apiService.getInstance());
        return this._commentsApi;
    }
    addTaskComment(taskId, message) {
        return from(this.commentsApi.addTaskComment({ message: message }, taskId))
            .pipe(map((response) => {
            return new CommentModel({
                id: response.id,
                message: response.message,
                created: response.created,
                createdBy: response.createdBy
            });
        }), catchError((err) => this.handleError(err)));
    }
    getTaskComments(taskId) {
        return from(this.commentsApi.getTaskComments(taskId))
            .pipe(map((response) => {
            const comments = [];
            response.data.forEach((comment) => {
                const user = new UserProcessModel(comment.createdBy);
                comments.push(new CommentModel({
                    id: comment.id,
                    message: comment.message,
                    created: comment.created,
                    createdBy: user
                }));
            });
            return comments;
        }), catchError((err) => this.handleError(err)));
    }
    getProcessInstanceComments(processInstanceId) {
        return from(this.commentsApi.getProcessInstanceComments(processInstanceId))
            .pipe(map((response) => {
            const comments = [];
            response.data.forEach((comment) => {
                const user = new UserProcessModel(comment.createdBy);
                comments.push(new CommentModel({
                    id: comment.id,
                    message: comment.message,
                    created: comment.created,
                    createdBy: user
                }));
            });
            return comments;
        }), catchError((err) => this.handleError(err)));
    }
    addProcessInstanceComment(processInstanceId, message) {
        return from(this.commentsApi.addProcessInstanceComment({ message: message }, processInstanceId)).pipe(map((response) => {
            return new CommentModel({
                id: response.id,
                message: response.message,
                created: response.created,
                createdBy: response.createdBy
            });
        }), catchError((err) => this.handleError(err)));
    }
    handleError(error) {
        this.logService.error(error);
        return throwError(error || 'Server error');
    }
}
CommentProcessService.ɵprov = ɵɵdefineInjectable({ factory: function CommentProcessService_Factory() { return new CommentProcessService(ɵɵinject(AlfrescoApiService), ɵɵinject(LogService)); }, token: CommentProcessService, providedIn: "root" });
CommentProcessService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
CommentProcessService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: LogService }
];

class CommentContentService {
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
    }
    get commentsApi() {
        var _a;
        this._commentsApi = (_a = this._commentsApi) !== null && _a !== void 0 ? _a : new CommentsApi(this.apiService.getInstance());
        return this._commentsApi;
    }
    addNodeComment(nodeId, message) {
        return from(this.commentsApi.createComment(nodeId, { content: message }))
            .pipe(map((response) => {
            return new CommentModel({
                id: response.entry.id,
                message: response.entry.content,
                created: response.entry.createdAt,
                createdBy: response.entry.createdBy
            });
        }), catchError((err) => this.handleError(err)));
    }
    getNodeComments(nodeId) {
        return from(this.commentsApi.listComments(nodeId))
            .pipe(map((response) => {
            const comments = [];
            response.list.entries.forEach((comment) => {
                comments.push(new CommentModel({
                    id: comment.entry.id,
                    message: comment.entry.content,
                    created: comment.entry.createdAt,
                    createdBy: comment.entry.createdBy
                }));
            });
            return comments;
        }), catchError((err) => this.handleError(err)));
    }
    handleError(error) {
        this.logService.error(error);
        return throwError(error || 'Server error');
    }
}
CommentContentService.ɵprov = ɵɵdefineInjectable({ factory: function CommentContentService_Factory() { return new CommentContentService(ɵɵinject(AlfrescoApiService), ɵɵinject(LogService)); }, token: CommentContentService, providedIn: "root" });
CommentContentService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
CommentContentService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: LogService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CommentsComponent {
    constructor(commentProcessService, commentContentService) {
        this.commentProcessService = commentProcessService;
        this.commentContentService = commentContentService;
        this.readOnly = false;
        this.error = new EventEmitter();
        this.comments = [];
        this.beingAdded = false;
        this.comment$ = new Observable((observer) => this.commentObserver = observer)
            .pipe(share());
        this.comment$.subscribe((comment) => {
            this.comments.push(comment);
        });
    }
    ngOnChanges(changes) {
        this.taskId = null;
        this.nodeId = null;
        this.taskId = changes['taskId'] ? changes['taskId'].currentValue : null;
        this.nodeId = changes['nodeId'] ? changes['nodeId'].currentValue : null;
        if (this.taskId || this.nodeId) {
            this.getComments();
        }
        else {
            this.resetComments();
        }
    }
    getComments() {
        this.resetComments();
        if (this.isATask()) {
            this.commentProcessService.getTaskComments(this.taskId).subscribe((comments) => {
                if (comments && comments instanceof Array) {
                    comments = comments.sort((comment1, comment2) => {
                        const date1 = new Date(comment1.created);
                        const date2 = new Date(comment2.created);
                        return date1 > date2 ? -1 : date1 < date2 ? 1 : 0;
                    });
                    comments.forEach((currentComment) => {
                        this.commentObserver.next(currentComment);
                    });
                }
            }, (err) => {
                this.error.emit(err);
            });
        }
        if (this.isANode()) {
            this.commentContentService.getNodeComments(this.nodeId).subscribe((comments) => {
                if (comments && comments instanceof Array) {
                    comments = comments.sort((comment1, comment2) => {
                        const date1 = new Date(comment1.created);
                        const date2 = new Date(comment2.created);
                        return date1 > date2 ? -1 : date1 < date2 ? 1 : 0;
                    });
                    comments.forEach((comment) => {
                        this.commentObserver.next(comment);
                    });
                }
            }, (err) => {
                this.error.emit(err);
            });
        }
    }
    resetComments() {
        this.comments = [];
    }
    add() {
        if (this.message && this.message.trim() && !this.beingAdded) {
            const comment = this.sanitize(this.message);
            this.beingAdded = true;
            if (this.isATask()) {
                this.commentProcessService.addTaskComment(this.taskId, comment)
                    .subscribe((res) => {
                    this.comments.unshift(res);
                    this.message = '';
                    this.beingAdded = false;
                }, (err) => {
                    this.error.emit(err);
                    this.beingAdded = false;
                });
            }
            if (this.isANode()) {
                this.commentContentService.addNodeComment(this.nodeId, comment)
                    .subscribe((res) => {
                    this.comments.unshift(res);
                    this.message = '';
                    this.beingAdded = false;
                }, (err) => {
                    this.error.emit(err);
                    this.beingAdded = false;
                });
            }
        }
    }
    clear(event) {
        event.stopPropagation();
        this.message = '';
    }
    isReadOnly() {
        return this.readOnly;
    }
    isATask() {
        return !!this.taskId;
    }
    isANode() {
        return !!this.nodeId;
    }
    sanitize(input) {
        return input.replace(/<[^>]+>/g, '')
            .replace(/^\s+|\s+$|\s+(?=\s)/g, '')
            .replace(/\r?\n/g, '<br/>');
    }
}
CommentsComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-comments',
                template: "<div class=\"adf-comments-container\">\n    <div id=\"comment-header\" class=\"adf-comments-header\" role=\"heading\">\n        {{'COMMENTS.HEADER' | translate: { count: comments?.length} }}\n    </div>\n    <div class=\"adf-comments-input-container\" *ngIf=\"!isReadOnly()\">\n            <mat-form-field class=\"adf-full-width\">\n                <textarea (keydown.escape)=\"clear($event)\" matInput id=\"comment-input\" placeholder=\"{{'COMMENTS.ADD' | translate}}\" [(ngModel)]=\"message\"></textarea>\n            </mat-form-field>\n\n            <div class=\"adf-comments-input-actions\">\n                <button mat-button\n                    class=\"adf-comments-input-add\"\n                    data-automation-id=\"comments-input-add\"\n                    color=\"primary\"\n                    (click)=\"add()\"\n                    [disabled]=\"!message\">\n                    {{ 'COMMENTS.ADD' | translate }}\n                </button>\n            </div>\n    </div>\n\n    <div *ngIf=\"comments.length > 0\">\n        <adf-comment-list [comments]=\"comments\">\n        </adf-comment-list>\n    </div>\n</div>",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-comments-container{height:100%;overflow:auto;width:100%}.adf-comments-header{border-bottom:1px solid var(--theme-fg-divider);font-size:14px;font-weight:600;padding:10px 20px}.adf-comments-input-container{border-bottom:1px solid var(--theme-fg-divider);padding:8px 15px 0;width:calc(100% - 30px)}.adf-comments-input-container textarea{resize:vertical}.adf-comments-input-actions{display:flex;justify-content:flex-end;margin-bottom:10px}.adf-full-width{width:100%}adf-comment-list{float:left;height:calc(100% - 101px);overflow:auto;width:100%}"]
            },] }
];
CommentsComponent.ctorParameters = () => [
    { type: CommentProcessService },
    { type: CommentContentService }
];
CommentsComponent.propDecorators = {
    taskId: [{ type: Input }],
    nodeId: [{ type: Input }],
    readOnly: [{ type: Input }],
    error: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CommentsModule {
}
CommentsModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    PipeModule,
                    DataColumnModule,
                    DataTableModule,
                    FormsModule,
                    ReactiveFormsModule,
                    MaterialModule,
                    CommonModule,
                    TranslateModule
                ],
                declarations: [
                    CommentListComponent,
                    CommentsComponent
                ],
                exports: [
                    CommentListComponent,
                    CommentsComponent
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ButtonsMenuComponent {
    ngAfterContentInit() {
        this.isMenuEmpty = this.buttons.length <= 0;
    }
    isMobile() {
        return !!/Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
    }
}
ButtonsMenuComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-buttons-action-menu',
                template: "<div id=\"adf-buttons-menu\" class=\"adf-buttons-menu\" *ngIf=\"!isMenuEmpty\">\n    <div *ngIf=\"isMobile()\">\n        <button mat-icon-button [matMenuTriggerFor]=\"editReportMenu\">\n            <mat-icon>more_vert</mat-icon>\n        </button>\n        <mat-menu #editReportMenu=\"matMenu\" class=\"adf-buttons-menu-mobile\">\n            <ng-content *ngTemplateOutlet=\"desktop\">\n            </ng-content>\n        </mat-menu>\n    </div>\n\n    <div *ngIf=\"!isMobile()\" class=\"adf-buttons-menu-desktop\">\n        <ng-content *ngTemplateOutlet=\"desktop\">\n        </ng-content>\n    </div>\n</div>\n\n<ng-template #desktop>\n    <ng-content></ng-content>\n</ng-template>",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-buttons-menu{margin-right:10px}.adf-buttons-menu div{display:flex}.adf-buttons-menu-mobile{margin-right:10px}.adf-buttons-menu-desktop{display:flex}.adf-buttons-menu-desktop button{color:#000;padding:0}.adf-buttons-menu-desktop button>span{display:none}.adf-buttons-menu-desktop button>mat-icon.mat-icon.material-icons{color:#000;margin:0 10px}"]
            },] }
];
ButtonsMenuComponent.propDecorators = {
    buttons: [{ type: ContentChildren, args: [MatMenuItem,] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ButtonsMenuModule {
}
ButtonsMenuModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    TranslateModule,
                    FlexLayoutModule
                ],
                declarations: [
                    ButtonsMenuComponent
                ],
                exports: [
                    ButtonsMenuComponent
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class SortingPickerComponent {
    constructor() {
        this.options = [];
        this.ascending = true;
        this.valueChange = new EventEmitter();
        this.sortingChange = new EventEmitter();
    }
    onOptionChanged(event) {
        this.selected = event.value;
        this.valueChange.emit(this.selected);
    }
    toggleSortDirection() {
        this.ascending = !this.ascending;
        this.sortingChange.emit(this.ascending);
    }
}
SortingPickerComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-sorting-picker',
                template: "<mat-form-field floatLabel=\"always\">\n    <mat-label>{{'CORE.SEARCH.SORT_BY' | translate}}</mat-label>\n    <mat-select [(value)]=\"selected\" (selectionChange)=\"onOptionChanged($event)\">\n        <mat-option *ngFor=\"let option of options\" [value]=\"option.key\">\n            {{ option.label | translate }}\n        </mat-option>\n    </mat-select>\n</mat-form-field>\n\n<button *ngIf=\"selected\" mat-icon-button (click)=\"toggleSortDirection()\" aria-label=\"'CORE.SEARCH.TOGGLE_ASC_DESC_ORDER' | translate\">\n    <mat-icon *ngIf=\"ascending\">arrow_upward</mat-icon>\n    <mat-icon *ngIf=\"!ascending\">arrow_downward</mat-icon>\n</button>\n",
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-sorting-picker' }
            },] }
];
SortingPickerComponent.propDecorators = {
    options: [{ type: Input }],
    selected: [{ type: Input }],
    ascending: [{ type: Input }],
    valueChange: [{ type: Output }],
    sortingChange: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class SortingPickerModule {
}
SortingPickerModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    TranslateModule
                ],
                declarations: [
                    SortingPickerComponent
                ],
                exports: [
                    SortingPickerComponent
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ErrorContentComponent {
    constructor(route, translateService) {
        this.route = route;
        this.translateService = translateService;
        this.errorCode = ErrorContentComponent.UNKNOWN_ERROR;
    }
    ngOnInit() {
        if (this.route) {
            this.route.params.subscribe(params => {
                const code = params['id'] || this.errorCode;
                const errorHasTranslation = this.checkErrorExists(code);
                this.errorCodeTranslated = errorHasTranslation ? code : ErrorContentComponent.UNKNOWN_ERROR;
            });
        }
    }
    checkErrorExists(errorCode) {
        const errorMessage = this.translateService.instant('ERROR_CONTENT.' + errorCode);
        return errorMessage !== ('ERROR_CONTENT.' + errorCode);
    }
}
ErrorContentComponent.UNKNOWN_ERROR = 'UNKNOWN';
ErrorContentComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-error-content',
                template: "<div class=\"adf-error-content\">\n    <p class=\"adf-error-content-code\">\n        {{ errorCodeTranslated }}\n    </p>\n    <div class=\"adf-error-content-shadow\"></div>\n    <p class=\"adf-error-content-title\">\n        {{ 'ERROR_CONTENT.' + errorCodeTranslated + '.TITLE' | translate }}\n    </p>\n    <p class=\"adf-error-content-description\">\n        {{ 'ERROR_CONTENT.' + errorCodeTranslated + '.DESCRIPTION' | translate }}\n    </p>\n    <ng-content select=\"[adf-error-content-actions]\"></ng-content>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-error-content' },
                styles: [".adf-error-content{align-items:center;color:var(--theme-text-color);display:flex;flex-direction:column}.adf-error-content-code{font-size:110px;font-weight:300;margin-bottom:45px;margin-top:200px}.adf-error-content-shadow{box-shadow:0 10px 15px 0 rgba(0,0,0,.39);height:3px;opacity:.54;width:170px}.adf-error-content-title{font-size:46px;font-weight:400;margin-bottom:10px;margin-top:40px}.adf-error-content-description{font-size:24px;font-weight:400;line-height:30px;margin-bottom:60px;min-width:250px;text-align:center;width:50%}@media screen and (max-width:959px){.adf-error-content-code{font-size:50px;margin-bottom:25px;margin-top:100px}.adf-error-content-shadow{width:100px}.adf-error-content-title{font-size:24px}.adf-error-content-description{font-size:17px}}"]
            },] }
];
ErrorContentComponent.ctorParameters = () => [
    { type: ActivatedRoute },
    { type: TranslationService }
];
ErrorContentComponent.propDecorators = {
    errorCode: [{ type: Input }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class EmptyContentComponent {
    constructor() {
        this.icon = 'cake';
        this.title = '';
        this.subtitle = '';
    }
}
EmptyContentComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-empty-content',
                template: "<div class=\"adf-empty-content\" [title]=\"title | translate\">\n    <adf-icon class=\"adf-empty-content__icon\" [value]=\"icon\"></adf-icon>\n    <div class=\"adf-empty-content__title\">{{ title | translate }}</div>\n    <div class=\"adf-empty-content__subtitle\">{{ subtitle | translate }}</div>\n    <ng-content></ng-content>\n</div>\n",
                changeDetection: ChangeDetectionStrategy.OnPush,
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-empty-content' },
                styles: [".adf-empty-content{align-items:center;color:var(--theme-text-color);display:flex;flex-direction:column;height:100%;justify-content:center;width:100%}.adf-empty-content__icon .mat-icon{font-size:var(--theme-display-3-font-size);height:var(--theme-display-3-font-size)!important;width:var(--theme-display-3-font-size)!important}.adf-empty-content__title{font-size:18px;font-weight:600;line-height:0;margin:10px 0;text-align:center;white-space:normal}.adf-empty-content__subtitle,.adf-empty-content__text{font-size:14px;font-weight:300;line-height:inherit;text-align:center;white-space:normal}.adf-empty-content .adf-icon{opacity:.6}"]
            },] }
];
EmptyContentComponent.propDecorators = {
    icon: [{ type: Input }],
    title: [{ type: Input }],
    subtitle: [{ type: Input }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class IconComponent {
    constructor() {
        this._value = '';
        this._isCustom = false;
    }
    get value() {
        return this._value;
    }
    set value(value) {
        this._value = value || 'settings';
        this._isCustom = this._value.includes(':');
    }
    get isCustom() {
        return this._isCustom;
    }
}
IconComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-icon',
                template: "<ng-container *ngIf=\"isCustom; else: default\">\n  <mat-icon [color]=\"color\" [svgIcon]=\"value\"></mat-icon>\n</ng-container>\n\n<ng-template #default>\n  <mat-icon [color]=\"color\">{{ value }}</mat-icon>\n</ng-template>\n",
                encapsulation: ViewEncapsulation.None,
                changeDetection: ChangeDetectionStrategy.OnPush,
                host: { class: 'adf-icon' },
                styles: [".adf-icon{display:inline-flex;vertical-align:middle}"]
            },] }
];
IconComponent.propDecorators = {
    color: [{ type: Input }],
    value: [{ type: Input }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class IconModule {
}
IconModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MatIconModule
                ],
                declarations: [
                    IconComponent
                ],
                exports: [
                    IconComponent
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TemplateModule {
}
TemplateModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    TranslateModule,
                    IconModule
                ],
                declarations: [
                    ErrorContentComponent,
                    EmptyContentComponent
                ],
                exports: [
                    ErrorContentComponent,
                    EmptyContentComponent
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AuthGuardBase {
    constructor(authenticationService, router, appConfigService, dialog, storageService) {
        this.authenticationService = authenticationService;
        this.router = router;
        this.appConfigService = appConfigService;
        this.dialog = dialog;
        this.storageService = storageService;
    }
    get withCredentials() {
        return this.appConfigService.get('auth.withCredentials', false);
    }
    canActivate(route, state) {
        if (this.authenticationService.isLoggedIn() && this.authenticationService.isOauth() && this.isLoginFragmentPresent()) {
            return this.redirectSSOSuccessURL();
        }
        return this.checkLogin(route, state.url);
    }
    canActivateChild(route, state) {
        return this.canActivate(route, state);
    }
    redirectSSOSuccessURL() {
        return __awaiter(this, void 0, void 0, function* () {
            const redirectFragment = this.storageService.getItem('loginFragment');
            if (redirectFragment && this.getLoginRoute() !== redirectFragment) {
                yield this.navigate(redirectFragment);
                this.storageService.removeItem('loginFragment');
                return false;
            }
            return true;
        });
    }
    isLoginFragmentPresent() {
        return !!this.storageService.getItem('loginFragment');
    }
    redirectToUrl(url) {
        return __awaiter(this, void 0, void 0, function* () {
            let urlToRedirect = `/${this.getLoginRoute()}`;
            if (!this.authenticationService.isOauth()) {
                this.authenticationService.setRedirect({
                    provider: this.getProvider(),
                    url
                });
                urlToRedirect = `${urlToRedirect}?redirectUrl=${url}`;
                return this.navigate(urlToRedirect);
            }
            else if (this.getOauthConfig().silentLogin && !this.authenticationService.isPublicUrl()) {
                this.authenticationService.ssoImplicitLogin();
            }
            else {
                return this.navigate(urlToRedirect);
            }
            return false;
        });
    }
    navigate(url) {
        return __awaiter(this, void 0, void 0, function* () {
            this.dialog.closeAll();
            yield this.router.navigateByUrl(this.router.parseUrl(url));
            return false;
        });
    }
    getOauthConfig() {
        return (this.appConfigService &&
            this.appConfigService.get(AppConfigValues.OAUTHCONFIG, null));
    }
    getLoginRoute() {
        return (this.appConfigService &&
            this.appConfigService.get(AppConfigValues.LOGIN_ROUTE, 'login'));
    }
    getProvider() {
        return (this.appConfigService &&
            this.appConfigService.get(AppConfigValues.PROVIDERS, 'ALL'));
    }
    isOAuthWithoutSilentLogin() {
        const oauth = this.appConfigService.get(AppConfigValues.OAUTHCONFIG, null);
        return (this.authenticationService.isOauth() && !!oauth && !oauth.silentLogin);
    }
    isSilentLogin() {
        const oauth = this.appConfigService.get(AppConfigValues.OAUTHCONFIG, null);
        return this.authenticationService.isOauth() && oauth && oauth.silentLogin;
    }
}

class AuthGuard extends AuthGuardBase {
    constructor(jwtHelperService, authenticationService, router, appConfigService, dialog, storageService) {
        super(authenticationService, router, appConfigService, dialog, storageService);
        this.jwtHelperService = jwtHelperService;
        this.ticketChangeBind = this.ticketChange.bind(this);
        window.addEventListener('storage', this.ticketChangeBind);
    }
    ticketChange(event) {
        if (event.key.includes('ticket-ECM') && event.newValue !== event.oldValue) {
            this.ticketChangeRedirect(event);
        }
        if (event.key.includes('ticket-BPM') && event.newValue !== event.oldValue) {
            this.ticketChangeRedirect(event);
        }
        if (event.key.endsWith(JwtHelperService.USER_ACCESS_TOKEN) &&
            this.jwtHelperService.getValueFromToken(event.newValue, JwtHelperService.USER_PREFERRED_USERNAME) !==
                this.jwtHelperService.getValueFromToken(event.oldValue, JwtHelperService.USER_PREFERRED_USERNAME)) {
            this.ticketChangeRedirect(event);
        }
    }
    ticketChangeRedirect(event) {
        if (event.newValue) {
            this.navigate(this.router.url);
        }
        else {
            window.location.reload();
        }
    }
    checkLogin(_, redirectUrl) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.authenticationService.isLoggedIn() || this.withCredentials) {
                return true;
            }
            return this.redirectToUrl(redirectUrl);
        });
    }
}
AuthGuard.ɵprov = ɵɵdefineInjectable({ factory: function AuthGuard_Factory() { return new AuthGuard(ɵɵinject(JwtHelperService), ɵɵinject(AuthenticationService), ɵɵinject(Router), ɵɵinject(AppConfigService), ɵɵinject(MatDialog), ɵɵinject(StorageService)); }, token: AuthGuard, providedIn: "root" });
AuthGuard.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
AuthGuard.ctorParameters = () => [
    { type: JwtHelperService },
    { type: AuthenticationService },
    { type: Router },
    { type: AppConfigService },
    { type: MatDialog },
    { type: StorageService }
];

class AuthGuardEcm extends AuthGuardBase {
    constructor(authenticationService, router, appConfigService, dialog, storageService) {
        super(authenticationService, router, appConfigService, dialog, storageService);
    }
    checkLogin(_, redirectUrl) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.authenticationService.isEcmLoggedIn() || this.withCredentials) {
                return true;
            }
            return this.redirectToUrl(redirectUrl);
        });
    }
}
AuthGuardEcm.ɵprov = ɵɵdefineInjectable({ factory: function AuthGuardEcm_Factory() { return new AuthGuardEcm(ɵɵinject(AuthenticationService), ɵɵinject(Router), ɵɵinject(AppConfigService), ɵɵinject(MatDialog), ɵɵinject(StorageService)); }, token: AuthGuardEcm, providedIn: "root" });
AuthGuardEcm.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
AuthGuardEcm.ctorParameters = () => [
    { type: AuthenticationService },
    { type: Router },
    { type: AppConfigService },
    { type: MatDialog },
    { type: StorageService }
];

class AuthGuardBpm extends AuthGuardBase {
    constructor(authenticationService, router, appConfigService, dialog, storageService) {
        super(authenticationService, router, appConfigService, dialog, storageService);
    }
    checkLogin(_, redirectUrl) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this.authenticationService.isBpmLoggedIn() || this.withCredentials) {
                return true;
            }
            return this.redirectToUrl(redirectUrl);
        });
    }
}
AuthGuardBpm.ɵprov = ɵɵdefineInjectable({ factory: function AuthGuardBpm_Factory() { return new AuthGuardBpm(ɵɵinject(AuthenticationService), ɵɵinject(Router), ɵɵinject(AppConfigService), ɵɵinject(MatDialog), ɵɵinject(StorageService)); }, token: AuthGuardBpm, providedIn: "root" });
AuthGuardBpm.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
AuthGuardBpm.ctorParameters = () => [
    { type: AuthenticationService },
    { type: Router },
    { type: AppConfigService },
    { type: MatDialog },
    { type: StorageService }
];

var ContentGroups;
(function (ContentGroups) {
    ContentGroups["ALFRESCO_ADMINISTRATORS"] = "ALFRESCO_ADMINISTRATORS";
})(ContentGroups || (ContentGroups = {}));
class PeopleContentService {
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
        this.hasContentAdminRole = false;
        this.hasCheckedIsContentAdmin = false;
    }
    get peopleApi() {
        var _a;
        this._peopleApi = (_a = this._peopleApi) !== null && _a !== void 0 ? _a : new PeopleApi(this.apiService.getInstance());
        return this._peopleApi;
    }
    getPerson(personId) {
        const promise = this.peopleApi.getPerson(personId);
        return from(promise).pipe(catchError((error) => this.handleError(error)));
    }
    getCurrentPerson() {
        return this.getPerson('-me-');
    }
    listPeople(requestQuery) {
        const requestQueryParams = { skipCount: requestQuery === null || requestQuery === void 0 ? void 0 : requestQuery.skipCount, maxItems: requestQuery === null || requestQuery === void 0 ? void 0 : requestQuery.maxItems };
        const orderBy = this.buildOrderArray(requestQuery === null || requestQuery === void 0 ? void 0 : requestQuery.sorting);
        if (orderBy.length) {
            requestQueryParams['orderBy'] = orderBy;
        }
        const promise = this.peopleApi.listPeople(requestQueryParams);
        return from(promise).pipe(map(response => {
            return {
                pagination: response.list.pagination,
                entries: response.list.entries.map((person) => person.entry)
            };
        }), catchError((err) => this.handleError(err)));
    }
    createPerson(newPerson, opts) {
        return from(this.peopleApi.createPerson(newPerson, opts)).pipe(map((res) => res === null || res === void 0 ? void 0 : res.entry), catchError((error) => this.handleError(error)));
    }
    isContentAdmin() {
        var _a, _b;
        return __awaiter(this, void 0, void 0, function* () {
            if (!this.hasCheckedIsContentAdmin) {
                const user = yield this.getCurrentPerson().toPromise();
                this.hasContentAdminRole = (_b = (_a = user === null || user === void 0 ? void 0 : user.entry) === null || _a === void 0 ? void 0 : _a.capabilities) === null || _b === void 0 ? void 0 : _b.isAdmin;
                this.hasCheckedIsContentAdmin = true;
            }
            return this.hasContentAdminRole;
        });
    }
    buildOrderArray(sorting) {
        return (sorting === null || sorting === void 0 ? void 0 : sorting.orderBy) && (sorting === null || sorting === void 0 ? void 0 : sorting.direction) ? [`${sorting.orderBy} ${sorting.direction.toUpperCase()}`] : [];
    }
    handleError(error) {
        this.logService.error(error);
        return throwError(error || 'Server error');
    }
}
PeopleContentService.ɵprov = ɵɵdefineInjectable({ factory: function PeopleContentService_Factory() { return new PeopleContentService(ɵɵinject(AlfrescoApiService), ɵɵinject(LogService)); }, token: PeopleContentService, providedIn: "root" });
PeopleContentService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
PeopleContentService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: LogService }
];

class AuthGuardSsoRoleService {
    constructor(jwtHelperService, router, dialog, peopleContentService) {
        this.jwtHelperService = jwtHelperService;
        this.router = router;
        this.dialog = dialog;
        this.peopleContentService = peopleContentService;
    }
    canActivate(route) {
        return __awaiter(this, void 0, void 0, function* () {
            let hasRole;
            let hasRealmRole = false;
            let hasClientRole = true;
            if (route.data) {
                if (route.data['roles']) {
                    const rolesToCheck = route.data['roles'];
                    const excludedRoles = route.data['excludedRoles'] || [];
                    const isContentAdmin = rolesToCheck.includes(ContentGroups.ALFRESCO_ADMINISTRATORS) || excludedRoles.includes(ContentGroups.ALFRESCO_ADMINISTRATORS) ? yield this.peopleContentService.isContentAdmin() : false;
                    hasRealmRole = excludedRoles.length ? this.checkAccessWithExcludedRoles(rolesToCheck, excludedRoles, isContentAdmin) : this.hasRoles(rolesToCheck, isContentAdmin);
                }
                if (route.data['clientRoles']) {
                    const clientRoleName = route.params[route.data['clientRoles']];
                    const rolesToCheck = route.data['roles'];
                    hasClientRole = this.jwtHelperService.hasRealmRolesForClientRole(clientRoleName, rolesToCheck);
                }
            }
            hasRole = hasRealmRole && hasClientRole;
            if (!hasRole && route.data && route.data['redirectUrl']) {
                this.router.navigate(['/' + route.data['redirectUrl']]);
            }
            if (!hasRole) {
                this.dialog.closeAll();
            }
            return hasRole;
        });
    }
    checkAccessWithExcludedRoles(rolesToCheck, excludedRoles, isContentAdmin) {
        return this.hasRoles(rolesToCheck, isContentAdmin) && !this.hasRoles(excludedRoles, isContentAdmin);
    }
    hasRoles(rolesToCheck, isContentAdmin) {
        return rolesToCheck.includes(ContentGroups.ALFRESCO_ADMINISTRATORS) ? this.jwtHelperService.hasRealmRoles(rolesToCheck) || isContentAdmin : this.jwtHelperService.hasRealmRoles(rolesToCheck);
    }
}
AuthGuardSsoRoleService.ɵprov = ɵɵdefineInjectable({ factory: function AuthGuardSsoRoleService_Factory() { return new AuthGuardSsoRoleService(ɵɵinject(JwtHelperService), ɵɵinject(Router), ɵɵinject(MatDialog), ɵɵinject(PeopleContentService)); }, token: AuthGuardSsoRoleService, providedIn: "root" });
AuthGuardSsoRoleService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
AuthGuardSsoRoleService.ctorParameters = () => [
    { type: JwtHelperService },
    { type: Router },
    { type: MatDialog },
    { type: PeopleContentService }
];

class AppsProcessService {
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
    }
    get appsApi() {
        var _a;
        this._appsApi = (_a = this._appsApi) !== null && _a !== void 0 ? _a : new RuntimeAppDefinitionsApi(this.apiService.getInstance());
        return this._appsApi;
    }
    getDeployedApplications() {
        return from(this.appsApi.getAppDefinitions())
            .pipe(map((response) => response.data), catchError((err) => this.handleError(err)));
    }
    getDeployedApplicationsByName(name) {
        return from(this.appsApi.getAppDefinitions())
            .pipe(map((response) => response.data.find((app) => app.name === name)), catchError((err) => this.handleError(err)));
    }
    getApplicationDetailsById(appId) {
        return from(this.appsApi.getAppDefinitions())
            .pipe(map((response) => response.data.find((app) => app.id === appId)), catchError((err) => this.handleError(err)));
    }
    handleError(error) {
        this.logService.error(error);
        return throwError(error || 'Server error');
    }
}
AppsProcessService.ɵprov = ɵɵdefineInjectable({ factory: function AppsProcessService_Factory() { return new AppsProcessService(ɵɵinject(AlfrescoApiService), ɵɵinject(LogService)); }, token: AppsProcessService, providedIn: "root" });
AppsProcessService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
AppsProcessService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: LogService }
];

class PageTitleService {
    constructor(titleService, appConfig, translationService) {
        this.titleService = titleService;
        this.appConfig = appConfig;
        this.translationService = translationService;
        this.originalTitle = '';
        this.translatedTitle = '';
        translationService.translate.onLangChange.subscribe(() => this.onLanguageChanged());
        translationService.translate.onTranslationChange.subscribe(() => this.onLanguageChanged());
    }
    setTitle(value = '') {
        this.originalTitle = value;
        this.translatedTitle = this.translationService.instant(value);
        this.updateTitle();
    }
    onLanguageChanged() {
        this.translatedTitle = this.translationService.instant(this.originalTitle);
        this.updateTitle();
    }
    updateTitle() {
        const name = this.appConfig.get('application.name') || 'Alfresco ADF Application';
        const title = this.translatedTitle ? `${this.translatedTitle} - ${name}` : `${name}`;
        this.titleService.setTitle(title);
    }
}
PageTitleService.ɵprov = ɵɵdefineInjectable({ factory: function PageTitleService_Factory() { return new PageTitleService(ɵɵinject(Title), ɵɵinject(AppConfigService), ɵɵinject(TranslationService)); }, token: PageTitleService, providedIn: "root" });
PageTitleService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
PageTitleService.ctorParameters = () => [
    { type: Title },
    { type: AppConfigService },
    { type: TranslationService }
];

class RenditionsService {
    constructor(apiService) {
        this.apiService = apiService;
    }
    get renditionsApi() {
        var _a;
        this._renditionsApi = (_a = this._renditionsApi) !== null && _a !== void 0 ? _a : new RenditionsApi(this.apiService.getInstance());
        return this._renditionsApi;
    }
    get contentApi() {
        var _a;
        this._contentApi = (_a = this._contentApi) !== null && _a !== void 0 ? _a : new ContentApi(this.apiService.getInstance());
        return this._contentApi;
    }
    getAvailableRenditionForNode(nodeId) {
        return from(this.renditionsApi.listRenditions(nodeId)).pipe(map((availableRenditions) => {
            const renditionsAvailable = availableRenditions.list.entries.filter((rendition) => (rendition.entry.id === 'pdf' || rendition.entry.id === 'imgpreview'));
            const existingRendition = renditionsAvailable.find((rend) => rend.entry.status === 'CREATED');
            return existingRendition ? existingRendition : renditionsAvailable[0];
        }));
    }
    generateRenditionForNode(nodeId) {
        return this.getAvailableRenditionForNode(nodeId).pipe(map((rendition) => {
            if (rendition.entry.status !== 'CREATED') {
                return from(this.renditionsApi.createRendition(nodeId, { id: rendition.entry.id }));
            }
            else {
                return empty();
            }
        }));
    }
    isRenditionAvailable(nodeId, encoding) {
        return new Observable((observer) => {
            this.getRendition(nodeId, encoding).subscribe((res) => {
                let isAvailable = true;
                if (res.entry.status.toString() === 'NOT_CREATED') {
                    isAvailable = false;
                }
                observer.next(isAvailable);
                observer.complete();
            }, () => {
                observer.next(false);
                observer.complete();
            });
        });
    }
    isConversionPossible(nodeId, encoding) {
        return new Observable((observer) => {
            this.getRendition(nodeId, encoding).subscribe(() => {
                observer.next(true);
                observer.complete();
            }, () => {
                observer.next(false);
                observer.complete();
            });
        });
    }
    getRenditionUrl(nodeId, encoding) {
        return this.contentApi.getRenditionUrl(nodeId, encoding);
    }
    getRendition(nodeId, encoding) {
        return from(this.renditionsApi.getRendition(nodeId, encoding));
    }
    getRenditionsListByNodeId(nodeId) {
        return from(this.renditionsApi.listRenditions(nodeId));
    }
    createRendition(nodeId, encoding) {
        return from(this.renditionsApi.createRendition(nodeId, { id: encoding }));
    }
    convert(nodeId, encoding, pollingInterval = 1000, retries = 5) {
        return this.createRendition(nodeId, encoding)
            .pipe(concatMap(() => this.pollRendition(nodeId, encoding, pollingInterval, retries)));
    }
    pollRendition(nodeId, encoding, intervalSize = 1000, retries = 5) {
        let attempts = 0;
        return interval(intervalSize)
            .pipe(switchMap(() => this.getRendition(nodeId, encoding)), takeWhile((renditionEntry) => {
            attempts += 1;
            if (attempts > retries) {
                return false;
            }
            return (renditionEntry.entry.status.toString() !== 'CREATED');
        }));
    }
}
RenditionsService.ɵprov = ɵɵdefineInjectable({ factory: function RenditionsService_Factory() { return new RenditionsService(ɵɵinject(AlfrescoApiService)); }, token: RenditionsService, providedIn: "root" });
RenditionsService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
RenditionsService.ctorParameters = () => [
    { type: AlfrescoApiService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ComponentTranslationModel {
    constructor(obj) {
        this.name = obj && obj.name;
        this.path = obj && obj.path;
        this.json = obj && obj.json || [];
    }
}

class TranslateLoaderService {
    constructor(http) {
        this.http = http;
        this.prefix = 'i18n';
        this.suffix = '.json';
        this.providers = [];
        this.queue = [];
        this.defaultLang = 'en';
    }
    setDefaultLang(value) {
        this.defaultLang = value || 'en';
    }
    registerProvider(name, path) {
        const registered = this.providers.find((provider) => provider.name === name);
        if (registered) {
            registered.path = path;
        }
        else {
            this.providers.push(new ComponentTranslationModel({ name: name, path: path }));
        }
    }
    providerRegistered(name) {
        return this.providers.find((x) => x.name === name) ? true : false;
    }
    fetchLanguageFile(lang, component, fallbackUrl) {
        const translationUrl = fallbackUrl || `${component.path}/${this.prefix}/${lang}${this.suffix}?v=${Date.now()}`;
        return this.http.get(translationUrl).pipe(map((res) => {
            component.json[lang] = res;
        }), retry(3), catchError(() => {
            if (!fallbackUrl && lang.includes('-')) {
                const [langId] = lang.split('-');
                if (langId && langId !== this.defaultLang) {
                    const url = `${component.path}/${this.prefix}/${langId}${this.suffix}?v=${Date.now()}`;
                    return this.fetchLanguageFile(lang, component, url);
                }
            }
            return throwError(`Failed to load ${translationUrl}`);
        }));
    }
    getComponentToFetch(lang) {
        const observableBatch = [];
        if (!this.queue[lang]) {
            this.queue[lang] = [];
        }
        this.providers.forEach((component) => {
            if (!this.isComponentInQueue(lang, component.name)) {
                this.queue[lang].push(component.name);
                observableBatch.push(this.fetchLanguageFile(lang, component));
            }
        });
        return observableBatch;
    }
    init(lang) {
        if (this.queue[lang] === undefined) {
            this.queue[lang] = [];
        }
    }
    isComponentInQueue(lang, name) {
        return (this.queue[lang] || []).find((x) => x === name) ? true : false;
    }
    getFullTranslationJSON(lang) {
        let result = {};
        this.providers
            .slice(0)
            .sort((a, b) => {
            if (a.name === 'app') {
                return 1;
            }
            if (b.name === 'app') {
                return -1;
            }
            return a.name.localeCompare(b.name);
        })
            .forEach((model) => {
            if (model.json && model.json[lang]) {
                result = ObjectUtils.merge(result, model.json[lang]);
            }
        });
        return result;
    }
    getTranslation(lang) {
        let hasFailures = false;
        const batch = [
            ...this.getComponentToFetch(lang).map((observable) => {
                return observable.pipe(catchError((error) => {
                    hasFailures = true;
                    return of(error);
                }));
            })
        ];
        return new Observable((observer) => {
            if (batch.length > 0) {
                forkJoin(batch).subscribe(() => {
                    const fullTranslation = this.getFullTranslationJSON(lang);
                    if (fullTranslation) {
                        observer.next(fullTranslation);
                    }
                    if (hasFailures) {
                        observer.error('Failed to load some resources');
                    }
                    else {
                        observer.complete();
                    }
                }, () => {
                    observer.error('Failed to load some resources');
                });
            }
            else {
                const fullTranslation = this.getFullTranslationJSON(lang);
                if (fullTranslation) {
                    observer.next(fullTranslation);
                    observer.complete();
                }
            }
        });
    }
}
TranslateLoaderService.ɵprov = ɵɵdefineInjectable({ factory: function TranslateLoaderService_Factory() { return new TranslateLoaderService(ɵɵinject(HttpClient)); }, token: TranslateLoaderService, providedIn: "root" });
TranslateLoaderService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
TranslateLoaderService.ctorParameters = () => [
    { type: HttpClient }
];

class DeletedNodesApiService {
    constructor(apiService, preferences) {
        this.apiService = apiService;
        this.preferences = preferences;
    }
    get nodesApi() {
        var _a;
        this._nodesApi = (_a = this._nodesApi) !== null && _a !== void 0 ? _a : new NodesApi(this.apiService.getInstance());
        return this._nodesApi;
    }
    get trashcanApi() {
        var _a;
        this._trashcanApi = (_a = this._trashcanApi) !== null && _a !== void 0 ? _a : new TrashcanApi(this.apiService.getInstance());
        return this._trashcanApi;
    }
    getDeletedNodes(options) {
        const defaultOptions = {
            include: ['path', 'properties'],
            maxItems: this.preferences.paginationSize,
            skipCount: 0
        };
        const queryOptions = Object.assign(defaultOptions, options);
        const promise = this.trashcanApi.listDeletedNodes(queryOptions);
        return from(promise).pipe(catchError((err) => of(err)));
    }
}
DeletedNodesApiService.ɵprov = ɵɵdefineInjectable({ factory: function DeletedNodesApiService_Factory() { return new DeletedNodesApiService(ɵɵinject(AlfrescoApiService), ɵɵinject(UserPreferencesService)); }, token: DeletedNodesApiService, providedIn: "root" });
DeletedNodesApiService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
DeletedNodesApiService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: UserPreferencesService }
];

class FavoritesApiService {
    constructor(apiService, preferences) {
        this.apiService = apiService;
        this.preferences = preferences;
    }
    get favoritesApi() {
        var _a;
        this._favoritesApi = (_a = this._favoritesApi) !== null && _a !== void 0 ? _a : new FavoritesApi(this.apiService.getInstance());
        return this._favoritesApi;
    }
    static remapEntry({ entry }) {
        entry.properties = {
            'cm:title': entry.title,
            'cm:description': entry.description
        };
        return { entry };
    }
    remapFavoritesData(data = {}) {
        var _a, _b;
        const pagination = (((_a = data === null || data === void 0 ? void 0 : data.list) === null || _a === void 0 ? void 0 : _a.pagination) || {});
        const entries = this
            .remapFavoriteEntries(((_b = data === null || data === void 0 ? void 0 : data.list) === null || _b === void 0 ? void 0 : _b.entries) || []);
        return {
            list: { entries, pagination }
        };
    }
    remapFavoriteEntries(entries) {
        return entries
            .map(({ entry: { target } }) => ({
            entry: target.file || target.folder
        }))
            .filter(({ entry }) => (!!entry))
            .map(FavoritesApiService.remapEntry);
    }
    getFavorites(personId, options) {
        const defaultOptions = {
            maxItems: this.preferences.paginationSize,
            skipCount: 0,
            where: '(EXISTS(target/file) OR EXISTS(target/folder))',
            include: ['properties', 'allowableOperations']
        };
        const queryOptions = Object.assign(defaultOptions, options);
        const promise = this.favoritesApi
            .listFavorites(personId, queryOptions)
            .then(this.remapFavoritesData);
        return from(promise).pipe(catchError((err) => of(err)));
    }
}
FavoritesApiService.ɵprov = ɵɵdefineInjectable({ factory: function FavoritesApiService_Factory() { return new FavoritesApiService(ɵɵinject(AlfrescoApiService), ɵɵinject(UserPreferencesService)); }, token: FavoritesApiService, providedIn: "root" });
FavoritesApiService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
FavoritesApiService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: UserPreferencesService }
];

class SearchConfigurationService {
    constructor() {
    }
    generateQueryBody(searchTerm, maxResults, skipCount) {
        const defaultQueryBody = {
            query: {
                query: searchTerm ? `'${searchTerm}*' OR name:'${searchTerm}*'` : searchTerm
            },
            include: ['path', 'allowableOperations'],
            paging: {
                maxItems: maxResults,
                skipCount: skipCount
            },
            filterQueries: [
                { query: "TYPE:'cm:folder' OR TYPE:'cm:content'" },
                { query: 'NOT cm:creator:System' }
            ]
        };
        return defaultQueryBody;
    }
}
SearchConfigurationService.ɵprov = ɵɵdefineInjectable({ factory: function SearchConfigurationService_Factory() { return new SearchConfigurationService(); }, token: SearchConfigurationService, providedIn: "root" });
SearchConfigurationService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
SearchConfigurationService.ctorParameters = () => [];

class SearchService {
    constructor(apiService, searchConfigurationService) {
        this.apiService = apiService;
        this.searchConfigurationService = searchConfigurationService;
        this.dataLoaded = new Subject();
    }
    get queriesApi() {
        var _a;
        this._queriesApi = (_a = this._queriesApi) !== null && _a !== void 0 ? _a : new QueriesApi(this.apiService.getInstance());
        return this._queriesApi;
    }
    get searchApi() {
        var _a;
        this._searchApi = (_a = this._searchApi) !== null && _a !== void 0 ? _a : new SearchApi(this.apiService.getInstance());
        return this._searchApi;
    }
    getNodeQueryResults(term, options) {
        const promise = this.queriesApi.findNodes(term, options);
        promise.then((nodePaging) => {
            this.dataLoaded.next(nodePaging);
        }).catch((err) => this.handleError(err));
        return from(promise);
    }
    search(searchTerm, maxResults, skipCount) {
        const searchQuery = Object.assign(this.searchConfigurationService.generateQueryBody(searchTerm, maxResults, skipCount));
        const promise = this.searchApi.search(searchQuery);
        promise.then((nodePaging) => {
            this.dataLoaded.next(nodePaging);
        }).catch((err) => this.handleError(err));
        return from(promise);
    }
    searchByQueryBody(queryBody) {
        const promise = this.searchApi.search(queryBody);
        promise.then((nodePaging) => {
            this.dataLoaded.next(nodePaging);
        }).catch((err) => this.handleError(err));
        return from(promise);
    }
    handleError(error) {
        return throwError(error || 'Server error');
    }
}
SearchService.ɵprov = ɵɵdefineInjectable({ factory: function SearchService_Factory() { return new SearchService(ɵɵinject(AlfrescoApiService), ɵɵinject(SearchConfigurationService)); }, token: SearchService, providedIn: "root" });
SearchService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
SearchService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: SearchConfigurationService }
];

class SharedLinksApiService {
    constructor(apiService, preferences) {
        this.apiService = apiService;
        this.preferences = preferences;
        this.error = new Subject();
    }
    get sharedLinksApi() {
        var _a;
        this._sharedLinksApi = (_a = this._sharedLinksApi) !== null && _a !== void 0 ? _a : new SharedlinksApi(this.apiService.getInstance());
        return this._sharedLinksApi;
    }
    getSharedLinks(options = {}) {
        const defaultOptions = {
            maxItems: this.preferences.paginationSize,
            skipCount: 0,
            include: ['properties', 'allowableOperations']
        };
        const queryOptions = Object.assign({}, defaultOptions, options);
        const promise = this.sharedLinksApi.listSharedLinks(queryOptions);
        return from(promise).pipe(catchError((err) => of(err)));
    }
    createSharedLinks(nodeId, options = {}) {
        const promise = this.sharedLinksApi.createSharedLink({ nodeId: nodeId }, options);
        return from(promise).pipe(catchError((err) => of(err)));
    }
    deleteSharedLink(sharedId) {
        const promise = this.sharedLinksApi.deleteSharedLink(sharedId);
        return from(promise).pipe(catchError((err) => of(err)));
    }
}
SharedLinksApiService.ɵprov = ɵɵdefineInjectable({ factory: function SharedLinksApiService_Factory() { return new SharedLinksApiService(ɵɵinject(AlfrescoApiService), ɵɵinject(UserPreferencesService)); }, token: SharedLinksApiService, providedIn: "root" });
SharedLinksApiService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
SharedLinksApiService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: UserPreferencesService }
];

class LoginDialogService {
    constructor(dialog) {
        this.dialog = dialog;
    }
    openLogin(actionName, title) {
        const logged = new Subject();
        logged.subscribe({
            complete: this.close.bind(this)
        });
        const data = {
            title,
            actionName,
            logged
        };
        this.openLoginDialog(data, 'adf-login-dialog', '630px');
        return logged;
    }
    openLoginDialog(data, currentPanelClass, chosenWidth) {
        this.dialog.open(LoginDialogComponent, { data, panelClass: currentPanelClass, width: chosenWidth });
    }
    close() {
        this.dialog.closeAll();
    }
}
LoginDialogService.ɵprov = ɵɵdefineInjectable({ factory: function LoginDialogService_Factory() { return new LoginDialogService(ɵɵinject(MatDialog)); }, token: LoginDialogService, providedIn: "root" });
LoginDialogService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
LoginDialogService.ctorParameters = () => [
    { type: MatDialog }
];

class ExternalAlfrescoApiService {
    constructor() {
        this.nodeUpdated = new Subject();
        this.alfrescoApiInitialized = new ReplaySubject(1);
    }
    getInstance() {
        return this.alfrescoApi;
    }
    get contentApi() {
        return this.getInstance().content;
    }
    get nodesApi() {
        var _a;
        this._nodesApi = (_a = this._nodesApi) !== null && _a !== void 0 ? _a : new NodesApi(this.getInstance());
        return this._nodesApi;
    }
    init(ecmHost, contextRoot) {
        const domainPrefix = this.createPrefixFromHost(ecmHost);
        const config = {
            provider: 'ECM',
            hostEcm: ecmHost,
            authType: 'BASIC',
            contextRoot: contextRoot,
            domainPrefix
        };
        this.initAlfrescoApi(config);
        this.alfrescoApiInitialized.next(true);
    }
    initAlfrescoApi(config) {
        if (this.alfrescoApi) {
            this.alfrescoApi.configureJsApi(config);
        }
        else {
            this.alfrescoApi = new AlfrescoApiCompatibility(config);
        }
    }
    createPrefixFromHost(url) {
        const match = url.match(/:\/\/(www[0-9]?\.)?(.[^/:]+)/i);
        let result = null;
        if (match != null && match.length > 2 && typeof match[2] === 'string' && match[2].length > 0) {
            result = match[2];
        }
        return result;
    }
}
ExternalAlfrescoApiService.ɵprov = ɵɵdefineInjectable({ factory: function ExternalAlfrescoApiService_Factory() { return new ExternalAlfrescoApiService(); }, token: ExternalAlfrescoApiService, providedIn: "root" });
ExternalAlfrescoApiService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];

class LockService {
    constructor(alfrescoApiService) {
        this.alfrescoApiService = alfrescoApiService;
    }
    isLocked(node) {
        let isLocked = false;
        if (this.hasLockConfigured(node)) {
            if (this.isReadOnlyLock(node)) {
                isLocked = !this.isLockExpired(node);
            }
            else if (this.isLockOwnerAllowed(node)) {
                isLocked = this.alfrescoApiService.getInstance().getEcmUsername() !== node.properties['cm:lockOwner'].id;
                if (this.isLockExpired(node)) {
                    isLocked = false;
                }
            }
        }
        return isLocked;
    }
    hasLockConfigured(node) {
        return node.isFile && node.isLocked && node.properties['cm:lockType'];
    }
    isReadOnlyLock(node) {
        return node.properties['cm:lockType'] === 'READ_ONLY_LOCK' && node.properties['cm:lockLifetime'] === 'PERSISTENT';
    }
    isLockOwnerAllowed(node) {
        return node.properties['cm:lockType'] === 'WRITE_LOCK' && node.properties['cm:lockLifetime'] === 'PERSISTENT';
    }
    getLockExpiryTime(node) {
        if (node.properties['cm:expiryDate']) {
            return moment(node.properties['cm:expiryDate'], 'yyyy-MM-ddThh:mm:ssZ');
        }
        return undefined;
    }
    isLockExpired(node) {
        const expiryLockTime = this.getLockExpiryTime(node);
        if (expiryLockTime) {
            return moment().isAfter(expiryLockTime);
        }
        return false;
    }
}
LockService.ɵprov = ɵɵdefineInjectable({ factory: function LockService_Factory() { return new LockService(ɵɵinject(AlfrescoApiService)); }, token: LockService, providedIn: "root" });
LockService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
LockService.ctorParameters = () => [
    { type: AlfrescoApiService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DemoForm {
    constructor() {
        this.easyForm = {
            'formRepresentation': {
                'id': 1001,
                'name': 'ISSUE_FORM',
                'tabs': [],
                'fields': [
                    {
                        'fieldType': 'ContainerRepresentation',
                        'id': '1498212398417',
                        'name': 'Label',
                        'type': 'container',
                        'value': null,
                        'required': false,
                        'readOnly': false,
                        'overrideId': false,
                        'colspan': 1,
                        'placeholder': null,
                        'minLength': 0,
                        'maxLength': 0,
                        'minValue': null,
                        'maxValue': null,
                        'regexPattern': null,
                        'optionType': null,
                        'hasEmptyValue': false,
                        'options': null,
                        'restUrl': null,
                        'restResponsePath': null,
                        'restIdProperty': null,
                        'restLabelProperty': null,
                        'tab': null,
                        'className': null,
                        'dateDisplayFormat': null,
                        'sizeX': 2,
                        'sizeY': 1,
                        'row': -1,
                        'col': -1,
                        'numberOfColumns': 2,
                        'fields': {
                            '1': [
                                {
                                    'fieldType': 'RestFieldRepresentation',
                                    'id': 'label',
                                    'name': 'Label',
                                    'type': 'dropdown',
                                    'value': 'Choose one...',
                                    'required': false,
                                    'readOnly': false,
                                    'overrideId': false,
                                    'colspan': 1,
                                    'placeholder': null,
                                    'minLength': 0,
                                    'maxLength': 0,
                                    'minValue': null,
                                    'maxValue': null,
                                    'regexPattern': null,
                                    'optionType': null,
                                    'hasEmptyValue': true,
                                    'options': [
                                        {
                                            'id': 'empty',
                                            'name': 'Choose one...'
                                        },
                                        {
                                            'id': 'option_1',
                                            'name': 'test1'
                                        },
                                        {
                                            'id': 'option_2',
                                            'name': 'test2'
                                        },
                                        {
                                            'id': 'option_3',
                                            'name': 'test3'
                                        }
                                    ],
                                    'restUrl': null,
                                    'restResponsePath': null,
                                    'restIdProperty': null,
                                    'restLabelProperty': null,
                                    'tab': null,
                                    'className': null,
                                    'params': {
                                        'existingColspan': 1,
                                        'maxColspan': 2
                                    },
                                    'dateDisplayFormat': null,
                                    'layout': {
                                        'row': -1,
                                        'column': -1,
                                        'colspan': 1
                                    },
                                    'sizeX': 1,
                                    'sizeY': 1,
                                    'row': -1,
                                    'col': -1,
                                    'visibilityCondition': null,
                                    'endpoint': null,
                                    'requestHeaders': null
                                },
                                {
                                    'fieldType': 'FormFieldRepresentation',
                                    'id': 'Date',
                                    'name': 'Date',
                                    'type': 'date',
                                    'value': null,
                                    'required': false,
                                    'readOnly': false,
                                    'overrideId': false,
                                    'colspan': 1,
                                    'placeholder': null,
                                    'minLength': 0,
                                    'maxLength': 0,
                                    'minValue': null,
                                    'maxValue': null,
                                    'regexPattern': null,
                                    'optionType': null,
                                    'hasEmptyValue': null,
                                    'options': null,
                                    'restUrl': null,
                                    'restResponsePath': null,
                                    'restIdProperty': null,
                                    'restLabelProperty': null,
                                    'tab': 'tab1',
                                    'className': null,
                                    'params': {
                                        'existingColspan': 1,
                                        'maxColspan': 2
                                    },
                                    'dateDisplayFormat': null,
                                    'layout': {
                                        'row': -1,
                                        'column': -1,
                                        'colspan': 1
                                    },
                                    'sizeX': 1,
                                    'sizeY': 1,
                                    'row': -1,
                                    'col': -1,
                                    'visibilityCondition': null
                                },
                                {
                                    'fieldType': 'FormFieldRepresentation',
                                    'id': 'label5',
                                    'name': 'Label5',
                                    'type': 'boolean',
                                    'value': null,
                                    'required': false,
                                    'readOnly': false,
                                    'overrideId': false,
                                    'colspan': 1,
                                    'placeholder': null,
                                    'minLength': 0,
                                    'maxLength': 0,
                                    'minValue': null,
                                    'maxValue': null,
                                    'regexPattern': null,
                                    'optionType': null,
                                    'hasEmptyValue': null,
                                    'options': null,
                                    'restUrl': null,
                                    'restResponsePath': null,
                                    'restIdProperty': null,
                                    'restLabelProperty': null,
                                    'tab': 'tab1',
                                    'className': null,
                                    'params': {
                                        'existingColspan': 1,
                                        'maxColspan': 1
                                    },
                                    'dateDisplayFormat': null,
                                    'layout': {
                                        'row': -1,
                                        'column': -1,
                                        'colspan': 1
                                    },
                                    'sizeX': 1,
                                    'sizeY': 1,
                                    'row': -1,
                                    'col': -1,
                                    'visibilityCondition': null
                                },
                                {
                                    'fieldType': 'FormFieldRepresentation',
                                    'id': 'label6',
                                    'name': 'Label6',
                                    'type': 'boolean',
                                    'value': null,
                                    'required': false,
                                    'readOnly': false,
                                    'overrideId': false,
                                    'colspan': 1,
                                    'placeholder': null,
                                    'minLength': 0,
                                    'maxLength': 0,
                                    'minValue': null,
                                    'maxValue': null,
                                    'regexPattern': null,
                                    'optionType': null,
                                    'hasEmptyValue': null,
                                    'options': null,
                                    'restUrl': null,
                                    'restResponsePath': null,
                                    'restIdProperty': null,
                                    'restLabelProperty': null,
                                    'tab': 'tab1',
                                    'className': null,
                                    'params': {
                                        'existingColspan': 1,
                                        'maxColspan': 1
                                    },
                                    'dateDisplayFormat': null,
                                    'layout': {
                                        'row': -1,
                                        'column': -1,
                                        'colspan': 1
                                    },
                                    'sizeX': 1,
                                    'sizeY': 1,
                                    'row': -1,
                                    'col': -1,
                                    'visibilityCondition': null
                                },
                                {
                                    'fieldType': 'FormFieldRepresentation',
                                    'id': 'label4',
                                    'name': 'Label4',
                                    'type': 'integer',
                                    'value': null,
                                    'required': false,
                                    'readOnly': false,
                                    'overrideId': false,
                                    'colspan': 1,
                                    'placeholder': null,
                                    'minLength': 0,
                                    'maxLength': 0,
                                    'minValue': null,
                                    'maxValue': null,
                                    'regexPattern': null,
                                    'optionType': null,
                                    'hasEmptyValue': null,
                                    'options': null,
                                    'restUrl': null,
                                    'restResponsePath': null,
                                    'restIdProperty': null,
                                    'restLabelProperty': null,
                                    'tab': 'tab1',
                                    'className': null,
                                    'params': {
                                        'existingColspan': 1,
                                        'maxColspan': 2
                                    },
                                    'dateDisplayFormat': null,
                                    'layout': {
                                        'row': -1,
                                        'column': -1,
                                        'colspan': 1
                                    },
                                    'sizeX': 1,
                                    'sizeY': 1,
                                    'row': -1,
                                    'col': -1,
                                    'visibilityCondition': null
                                },
                                {
                                    'fieldType': 'RestFieldRepresentation',
                                    'id': 'label12',
                                    'name': 'Label12',
                                    'type': 'radio-buttons',
                                    'value': null,
                                    'required': false,
                                    'readOnly': false,
                                    'overrideId': false,
                                    'colspan': 1,
                                    'placeholder': null,
                                    'minLength': 0,
                                    'maxLength': 0,
                                    'minValue': null,
                                    'maxValue': null,
                                    'regexPattern': null,
                                    'optionType': null,
                                    'hasEmptyValue': null,
                                    'options': [
                                        {
                                            'id': 'option_1',
                                            'name': 'Option 1'
                                        },
                                        {
                                            'id': 'option_2',
                                            'name': 'Option 2'
                                        }
                                    ],
                                    'restUrl': null,
                                    'restResponsePath': null,
                                    'restIdProperty': null,
                                    'restLabelProperty': null,
                                    'tab': 'tab1',
                                    'className': null,
                                    'params': {
                                        'existingColspan': 1,
                                        'maxColspan': 2
                                    },
                                    'dateDisplayFormat': null,
                                    'layout': {
                                        'row': -1,
                                        'column': -1,
                                        'colspan': 1
                                    },
                                    'sizeX': 1,
                                    'sizeY': 1,
                                    'row': -1,
                                    'col': -1,
                                    'visibilityCondition': null,
                                    'endpoint': null,
                                    'requestHeaders': null
                                }
                            ]
                        }
                    }
                ],
                'outcomes': [],
                'javascriptEvents': [],
                'className': '',
                'style': '',
                'customFieldTemplates': {},
                'metadata': {},
                'variables': [
                    {
                        'id': 'bfca9766-7bc1-45cc-8ecf-cdad551e36e2',
                        'name': 'name1',
                        'type': 'string',
                        'value': ''
                    },
                    {
                        'id': '3ed9f28a-dbae-463f-b991-47ef06658bb6',
                        'name': 'name2',
                        'type': 'string',
                        'value': ''
                    },
                    {
                        'id': 'a7710978-1e9c-4b54-a19c-c6267d2b19a2',
                        'name': 'input02',
                        'type': 'integer'
                    }
                ],
                'customFieldsValueInfo': {},
                'gridsterForm': false,
                'globalDateFormat': 'D-M-YYYY'
            }
        };
        this.formDefinition = {
            'formRepresentation': {
                'id': 3003,
                'name': 'demo-01',
                'taskId': '7501',
                'taskName': 'Demo Form 01',
                'tabs': [
                    {
                        'id': 'tab1',
                        'title': 'Text',
                        'visibilityCondition': null
                    },
                    {
                        'id': 'tab2',
                        'title': 'Misc',
                        'visibilityCondition': null
                    }
                ],
                'fields': [
                    {
                        'fieldType': 'ContainerRepresentation',
                        'id': '1488274019966',
                        'name': 'Label',
                        'type': 'container',
                        'value': null,
                        'required': false,
                        'readOnly': false,
                        'overrideId': false,
                        'colspan': 1,
                        'placeholder': null,
                        'minLength': 0,
                        'maxLength': 0,
                        'minValue': null,
                        'maxValue': null,
                        'regexPattern': null,
                        'optionType': null,
                        'hasEmptyValue': null,
                        'options': null,
                        'restUrl': null,
                        'restResponsePath': null,
                        'restIdProperty': null,
                        'restLabelProperty': null,
                        'tab': null,
                        'className': null,
                        'dateDisplayFormat': null,
                        'layout': null,
                        'sizeX': 2,
                        'sizeY': 1,
                        'row': -1,
                        'col': -1,
                        'visibilityCondition': null,
                        'numberOfColumns': 2,
                        'fields': {
                            '1': [],
                            '2': []
                        }
                    },
                    {
                        'fieldType': 'ContainerRepresentation',
                        'id': 'section4',
                        'name': 'Section 4',
                        'type': 'group',
                        'value': null,
                        'required': false,
                        'readOnly': false,
                        'overrideId': false,
                        'colspan': 1,
                        'placeholder': null,
                        'minLength': 0,
                        'maxLength': 0,
                        'minValue': null,
                        'maxValue': null,
                        'regexPattern': null,
                        'optionType': null,
                        'hasEmptyValue': null,
                        'options': null,
                        'restUrl': null,
                        'restResponsePath': null,
                        'restIdProperty': null,
                        'restLabelProperty': null,
                        'tab': 'tab2',
                        'className': null,
                        'dateDisplayFormat': null,
                        'layout': {
                            'row': -1,
                            'column': -1,
                            'colspan': 2
                        },
                        'sizeX': 2,
                        'sizeY': 1,
                        'row': -1,
                        'col': -1,
                        'visibilityCondition': null,
                        'numberOfColumns': 2,
                        'fields': {
                            '1': [
                                {
                                    'fieldType': 'FormFieldRepresentation',
                                    'id': 'label8',
                                    'name': 'Label8',
                                    'type': 'people',
                                    'value': null,
                                    'required': false,
                                    'readOnly': false,
                                    'overrideId': false,
                                    'colspan': 1,
                                    'placeholder': null,
                                    'minLength': 0,
                                    'maxLength': 0,
                                    'minValue': null,
                                    'maxValue': null,
                                    'regexPattern': null,
                                    'optionType': null,
                                    'hasEmptyValue': null,
                                    'options': null,
                                    'restUrl': null,
                                    'restResponsePath': null,
                                    'restIdProperty': null,
                                    'restLabelProperty': null,
                                    'tab': 'tab2',
                                    'className': null,
                                    'params': {
                                        'existingColspan': 1,
                                        'maxColspan': 2
                                    },
                                    'dateDisplayFormat': null,
                                    'layout': {
                                        'row': -1,
                                        'column': -1,
                                        'colspan': 1
                                    },
                                    'sizeX': 1,
                                    'sizeY': 1,
                                    'row': -1,
                                    'col': -1,
                                    'visibilityCondition': null
                                },
                                {
                                    'fieldType': 'FormFieldRepresentation',
                                    'id': 'label13',
                                    'name': 'Label13',
                                    'type': 'functional-group',
                                    'value': null,
                                    'required': false,
                                    'readOnly': false,
                                    'overrideId': false,
                                    'colspan': 1,
                                    'placeholder': null,
                                    'minLength': 0,
                                    'maxLength': 0,
                                    'minValue': null,
                                    'maxValue': null,
                                    'regexPattern': null,
                                    'optionType': null,
                                    'hasEmptyValue': null,
                                    'options': null,
                                    'restUrl': null,
                                    'restResponsePath': null,
                                    'restIdProperty': null,
                                    'restLabelProperty': null,
                                    'tab': 'tab2',
                                    'className': null,
                                    'params': {
                                        'existingColspan': 1,
                                        'maxColspan': 2
                                    },
                                    'dateDisplayFormat': null,
                                    'layout': {
                                        'row': -1,
                                        'column': -1,
                                        'colspan': 1
                                    },
                                    'sizeX': 1,
                                    'sizeY': 1,
                                    'row': -1,
                                    'col': -1,
                                    'visibilityCondition': null
                                },
                                {
                                    'fieldType': 'FormFieldRepresentation',
                                    'id': 'label18',
                                    'name': 'Label18',
                                    'type': 'readonly',
                                    'value': null,
                                    'required': false,
                                    'readOnly': false,
                                    'overrideId': false,
                                    'colspan': 1,
                                    'placeholder': null,
                                    'minLength': 0,
                                    'maxLength': 0,
                                    'minValue': null,
                                    'maxValue': null,
                                    'regexPattern': null,
                                    'optionType': null,
                                    'hasEmptyValue': null,
                                    'options': null,
                                    'restUrl': null,
                                    'restResponsePath': null,
                                    'restIdProperty': null,
                                    'restLabelProperty': null,
                                    'tab': 'tab2',
                                    'className': null,
                                    'params': {
                                        'existingColspan': 1,
                                        'maxColspan': 2
                                    },
                                    'dateDisplayFormat': null,
                                    'layout': {
                                        'row': -1,
                                        'column': -1,
                                        'colspan': 1
                                    },
                                    'sizeX': 1,
                                    'sizeY': 1,
                                    'row': -1,
                                    'col': -1,
                                    'visibilityCondition': null
                                },
                                {
                                    'fieldType': 'FormFieldRepresentation',
                                    'id': 'label19',
                                    'name': 'Label19',
                                    'type': 'readonly-text',
                                    'value': 'Display text as part of the form',
                                    'required': false,
                                    'readOnly': false,
                                    'overrideId': false,
                                    'colspan': 1,
                                    'placeholder': null,
                                    'minLength': 0,
                                    'maxLength': 0,
                                    'minValue': null,
                                    'maxValue': null,
                                    'regexPattern': null,
                                    'optionType': null,
                                    'hasEmptyValue': null,
                                    'options': null,
                                    'restUrl': null,
                                    'restResponsePath': null,
                                    'restIdProperty': null,
                                    'restLabelProperty': null,
                                    'tab': 'tab2',
                                    'className': null,
                                    'params': {
                                        'existingColspan': 1,
                                        'maxColspan': 2
                                    },
                                    'dateDisplayFormat': null,
                                    'layout': {
                                        'row': -1,
                                        'column': -1,
                                        'colspan': 1
                                    },
                                    'sizeX': 1,
                                    'sizeY': 1,
                                    'row': -1,
                                    'col': -1,
                                    'visibilityCondition': null
                                }
                            ],
                            '2': [
                                {
                                    'fieldType': 'HyperlinkRepresentation',
                                    'id': 'label15',
                                    'name': 'Label15',
                                    'type': 'hyperlink',
                                    'value': null,
                                    'required': false,
                                    'readOnly': false,
                                    'overrideId': false,
                                    'colspan': 1,
                                    'placeholder': null,
                                    'minLength': 0,
                                    'maxLength': 0,
                                    'minValue': null,
                                    'maxValue': null,
                                    'regexPattern': null,
                                    'optionType': null,
                                    'hasEmptyValue': null,
                                    'options': null,
                                    'restUrl': null,
                                    'restResponsePath': null,
                                    'restIdProperty': null,
                                    'restLabelProperty': null,
                                    'tab': 'tab2',
                                    'className': null,
                                    'params': {
                                        'existingColspan': 1,
                                        'maxColspan': 1
                                    },
                                    'dateDisplayFormat': null,
                                    'layout': {
                                        'row': -1,
                                        'column': -1,
                                        'colspan': 1
                                    },
                                    'sizeX': 1,
                                    'sizeY': 1,
                                    'row': -1,
                                    'col': -1,
                                    'visibilityCondition': null,
                                    'hyperlinkUrl': 'www.google.com',
                                    'displayText': null
                                },
                                {
                                    'fieldType': 'AttachFileFieldRepresentation',
                                    'id': 'label16',
                                    'name': 'Label16',
                                    'type': 'upload',
                                    'value': [],
                                    'required': false,
                                    'readOnly': false,
                                    'overrideId': false,
                                    'colspan': 1,
                                    'placeholder': null,
                                    'minLength': 0,
                                    'maxLength': 0,
                                    'minValue': null,
                                    'maxValue': null,
                                    'regexPattern': null,
                                    'optionType': null,
                                    'hasEmptyValue': null,
                                    'options': null,
                                    'restUrl': null,
                                    'restResponsePath': null,
                                    'restIdProperty': null,
                                    'restLabelProperty': null,
                                    'tab': 'tab2',
                                    'className': null,
                                    'params': {
                                        'existingColspan': 1,
                                        'maxColspan': 1,
                                        'fileSource': {
                                            'serviceId': 'all-file-sources',
                                            'name': 'All file sources'
                                        }
                                    },
                                    'dateDisplayFormat': null,
                                    'layout': {
                                        'row': -1,
                                        'column': -1,
                                        'colspan': 1
                                    },
                                    'sizeX': 1,
                                    'sizeY': 1,
                                    'row': -1,
                                    'col': -1,
                                    'visibilityCondition': null,
                                    'metaDataColumnDefinitions': null
                                },
                                {
                                    'fieldType': 'FormFieldRepresentation',
                                    'id': 'label17',
                                    'name': 'Label17',
                                    'type': 'select-folder',
                                    'value': null,
                                    'required': false,
                                    'readOnly': false,
                                    'overrideId': false,
                                    'colspan': 1,
                                    'placeholder': null,
                                    'minLength': 0,
                                    'maxLength': 0,
                                    'minValue': null,
                                    'maxValue': null,
                                    'regexPattern': null,
                                    'optionType': null,
                                    'hasEmptyValue': null,
                                    'options': null,
                                    'restUrl': null,
                                    'restResponsePath': null,
                                    'restIdProperty': null,
                                    'restLabelProperty': null,
                                    'tab': 'tab2',
                                    'className': null,
                                    'params': {
                                        'existingColspan': 1,
                                        'maxColspan': 1,
                                        'folderSource': {
                                            'serviceId': 'alfresco-1',
                                            'name': 'Alfresco 5.2 Local',
                                            'metaDataAllowed': true
                                        }
                                    },
                                    'dateDisplayFormat': null,
                                    'layout': {
                                        'row': -1,
                                        'column': -1,
                                        'colspan': 1
                                    },
                                    'sizeX': 1,
                                    'sizeY': 1,
                                    'row': -1,
                                    'col': -1,
                                    'visibilityCondition': null
                                }
                            ]
                        }
                    },
                    {
                        'fieldType': 'DynamicTableRepresentation',
                        'id': 'label14',
                        'name': 'Label14',
                        'type': 'dynamic-table',
                        'value': null,
                        'required': false,
                        'readOnly': false,
                        'overrideId': false,
                        'colspan': 1,
                        'placeholder': null,
                        'minLength': 0,
                        'maxLength': 0,
                        'minValue': null,
                        'maxValue': null,
                        'regexPattern': null,
                        'optionType': null,
                        'hasEmptyValue': null,
                        'options': null,
                        'restUrl': null,
                        'restResponsePath': null,
                        'restIdProperty': null,
                        'restLabelProperty': null,
                        'tab': 'tab2',
                        'className': null,
                        'params': {
                            'existingColspan': 1,
                            'maxColspan': 1
                        },
                        'dateDisplayFormat': null,
                        'layout': {
                            'row': -1,
                            'column': -1,
                            'colspan': 2
                        },
                        'sizeX': 2,
                        'sizeY': 2,
                        'row': -1,
                        'col': -1,
                        'visibilityCondition': null,
                        'columnDefinitions': [
                            {
                                'id': 'id',
                                'name': 'id',
                                'type': 'String',
                                'value': null,
                                'optionType': null,
                                'options': null,
                                'restResponsePath': null,
                                'restUrl': null,
                                'restIdProperty': null,
                                'restLabelProperty': null,
                                'amountCurrency': null,
                                'amountEnableFractions': false,
                                'required': true,
                                'editable': true,
                                'sortable': true,
                                'visible': true,
                                'endpoint': null,
                                'requestHeaders': null
                            },
                            {
                                'id': 'name',
                                'name': 'name',
                                'type': 'String',
                                'value': null,
                                'optionType': null,
                                'options': null,
                                'restResponsePath': null,
                                'restUrl': null,
                                'restIdProperty': null,
                                'restLabelProperty': null,
                                'amountCurrency': null,
                                'amountEnableFractions': false,
                                'required': true,
                                'editable': true,
                                'sortable': true,
                                'visible': true,
                                'endpoint': null,
                                'requestHeaders': null
                            }
                        ]
                    },
                    {
                        'fieldType': 'ContainerRepresentation',
                        'id': 'section1',
                        'name': 'Section 1',
                        'type': 'group',
                        'value': null,
                        'required': false,
                        'readOnly': false,
                        'overrideId': false,
                        'colspan': 1,
                        'placeholder': null,
                        'minLength': 0,
                        'maxLength': 0,
                        'minValue': null,
                        'maxValue': null,
                        'regexPattern': null,
                        'optionType': null,
                        'hasEmptyValue': null,
                        'options': null,
                        'restUrl': null,
                        'restResponsePath': null,
                        'restIdProperty': null,
                        'restLabelProperty': null,
                        'tab': 'tab1',
                        'className': null,
                        'dateDisplayFormat': null,
                        'layout': {
                            'row': -1,
                            'column': -1,
                            'colspan': 2
                        },
                        'sizeX': 2,
                        'sizeY': 1,
                        'row': -1,
                        'col': -1,
                        'visibilityCondition': null,
                        'numberOfColumns': 2,
                        'fields': {
                            '1': [
                                {
                                    'fieldType': 'FormFieldRepresentation',
                                    'id': 'label1',
                                    'name': 'Label1',
                                    'type': 'text',
                                    'value': null,
                                    'required': false,
                                    'readOnly': false,
                                    'overrideId': false,
                                    'colspan': 1,
                                    'placeholder': null,
                                    'minLength': 0,
                                    'maxLength': 0,
                                    'minValue': null,
                                    'maxValue': null,
                                    'regexPattern': null,
                                    'optionType': null,
                                    'hasEmptyValue': null,
                                    'options': null,
                                    'restUrl': null,
                                    'restResponsePath': null,
                                    'restIdProperty': null,
                                    'restLabelProperty': null,
                                    'tab': 'tab1',
                                    'className': null,
                                    'params': {
                                        'existingColspan': 1,
                                        'maxColspan': 2
                                    },
                                    'dateDisplayFormat': null,
                                    'layout': {
                                        'row': -1,
                                        'column': -1,
                                        'colspan': 1
                                    },
                                    'sizeX': 1,
                                    'sizeY': 1,
                                    'row': -1,
                                    'col': -1,
                                    'visibilityCondition': null
                                },
                                {
                                    'fieldType': 'FormFieldRepresentation',
                                    'id': 'label3',
                                    'name': 'Label3',
                                    'type': 'text',
                                    'value': null,
                                    'required': false,
                                    'readOnly': false,
                                    'overrideId': false,
                                    'colspan': 1,
                                    'placeholder': null,
                                    'minLength': 0,
                                    'maxLength': 0,
                                    'minValue': null,
                                    'maxValue': null,
                                    'regexPattern': null,
                                    'optionType': null,
                                    'hasEmptyValue': null,
                                    'options': null,
                                    'restUrl': null,
                                    'restResponsePath': null,
                                    'restIdProperty': null,
                                    'restLabelProperty': null,
                                    'tab': 'tab1',
                                    'className': null,
                                    'params': {
                                        'existingColspan': 1,
                                        'maxColspan': 2
                                    },
                                    'dateDisplayFormat': null,
                                    'layout': {
                                        'row': -1,
                                        'column': -1,
                                        'colspan': 1
                                    },
                                    'sizeX': 1,
                                    'sizeY': 1,
                                    'row': -1,
                                    'col': -1,
                                    'visibilityCondition': null
                                }
                            ],
                            '2': [
                                {
                                    'fieldType': 'FormFieldRepresentation',
                                    'id': 'label2',
                                    'name': 'Label2',
                                    'type': 'multi-line-text',
                                    'value': null,
                                    'required': false,
                                    'readOnly': false,
                                    'overrideId': false,
                                    'colspan': 1,
                                    'placeholder': null,
                                    'minLength': 0,
                                    'maxLength': 0,
                                    'minValue': null,
                                    'maxValue': null,
                                    'regexPattern': null,
                                    'optionType': null,
                                    'hasEmptyValue': null,
                                    'options': null,
                                    'restUrl': null,
                                    'restResponsePath': null,
                                    'restIdProperty': null,
                                    'restLabelProperty': null,
                                    'tab': 'tab1',
                                    'className': null,
                                    'params': {
                                        'existingColspan': 1,
                                        'maxColspan': 1
                                    },
                                    'dateDisplayFormat': null,
                                    'layout': {
                                        'row': -1,
                                        'column': -1,
                                        'colspan': 1
                                    },
                                    'sizeX': 1,
                                    'sizeY': 2,
                                    'row': -1,
                                    'col': -1,
                                    'visibilityCondition': null
                                }
                            ]
                        }
                    },
                    {
                        'fieldType': 'ContainerRepresentation',
                        'id': 'section2',
                        'name': 'Section 2',
                        'type': 'group',
                        'value': null,
                        'required': false,
                        'readOnly': false,
                        'overrideId': false,
                        'colspan': 1,
                        'placeholder': null,
                        'minLength': 0,
                        'maxLength': 0,
                        'minValue': null,
                        'maxValue': null,
                        'regexPattern': null,
                        'optionType': null,
                        'hasEmptyValue': null,
                        'options': null,
                        'restUrl': null,
                        'restResponsePath': null,
                        'restIdProperty': null,
                        'restLabelProperty': null,
                        'tab': 'tab1',
                        'className': null,
                        'dateDisplayFormat': null,
                        'layout': {
                            'row': -1,
                            'column': -1,
                            'colspan': 2
                        },
                        'sizeX': 2,
                        'sizeY': 1,
                        'row': -1,
                        'col': -1,
                        'visibilityCondition': null,
                        'numberOfColumns': 2,
                        'fields': {
                            '1': [
                                {
                                    'fieldType': 'FormFieldRepresentation',
                                    'id': 'label4',
                                    'name': 'Label4',
                                    'type': 'integer',
                                    'value': null,
                                    'required': false,
                                    'readOnly': false,
                                    'overrideId': false,
                                    'colspan': 1,
                                    'placeholder': null,
                                    'minLength': 0,
                                    'maxLength': 0,
                                    'minValue': null,
                                    'maxValue': null,
                                    'regexPattern': null,
                                    'optionType': null,
                                    'hasEmptyValue': null,
                                    'options': null,
                                    'restUrl': null,
                                    'restResponsePath': null,
                                    'restIdProperty': null,
                                    'restLabelProperty': null,
                                    'tab': 'tab1',
                                    'className': null,
                                    'params': {
                                        'existingColspan': 1,
                                        'maxColspan': 2
                                    },
                                    'dateDisplayFormat': null,
                                    'layout': {
                                        'row': -1,
                                        'column': -1,
                                        'colspan': 1
                                    },
                                    'sizeX': 1,
                                    'sizeY': 1,
                                    'row': -1,
                                    'col': -1,
                                    'visibilityCondition': null
                                },
                                {
                                    'fieldType': 'FormFieldRepresentation',
                                    'id': 'label7',
                                    'name': 'Label7',
                                    'type': 'date',
                                    'value': null,
                                    'required': false,
                                    'readOnly': false,
                                    'overrideId': false,
                                    'colspan': 1,
                                    'placeholder': null,
                                    'minLength': 0,
                                    'maxLength': 0,
                                    'minValue': null,
                                    'maxValue': null,
                                    'regexPattern': null,
                                    'optionType': null,
                                    'hasEmptyValue': null,
                                    'options': null,
                                    'restUrl': null,
                                    'restResponsePath': null,
                                    'restIdProperty': null,
                                    'restLabelProperty': null,
                                    'tab': 'tab1',
                                    'className': null,
                                    'params': {
                                        'existingColspan': 1,
                                        'maxColspan': 2
                                    },
                                    'dateDisplayFormat': null,
                                    'layout': {
                                        'row': -1,
                                        'column': -1,
                                        'colspan': 1
                                    },
                                    'sizeX': 1,
                                    'sizeY': 1,
                                    'row': -1,
                                    'col': -1,
                                    'visibilityCondition': null
                                }
                            ],
                            '2': [
                                {
                                    'fieldType': 'FormFieldRepresentation',
                                    'id': 'label5',
                                    'name': 'Label5',
                                    'type': 'boolean',
                                    'value': null,
                                    'required': false,
                                    'readOnly': false,
                                    'overrideId': false,
                                    'colspan': 1,
                                    'placeholder': null,
                                    'minLength': 0,
                                    'maxLength': 0,
                                    'minValue': null,
                                    'maxValue': null,
                                    'regexPattern': null,
                                    'optionType': null,
                                    'hasEmptyValue': null,
                                    'options': null,
                                    'restUrl': null,
                                    'restResponsePath': null,
                                    'restIdProperty': null,
                                    'restLabelProperty': null,
                                    'tab': 'tab1',
                                    'className': null,
                                    'params': {
                                        'existingColspan': 1,
                                        'maxColspan': 1
                                    },
                                    'dateDisplayFormat': null,
                                    'layout': {
                                        'row': -1,
                                        'column': -1,
                                        'colspan': 1
                                    },
                                    'sizeX': 1,
                                    'sizeY': 1,
                                    'row': -1,
                                    'col': -1,
                                    'visibilityCondition': null
                                },
                                {
                                    'fieldType': 'FormFieldRepresentation',
                                    'id': 'label6',
                                    'name': 'Label6',
                                    'type': 'boolean',
                                    'value': null,
                                    'required': false,
                                    'readOnly': false,
                                    'overrideId': false,
                                    'colspan': 1,
                                    'placeholder': null,
                                    'minLength': 0,
                                    'maxLength': 0,
                                    'minValue': null,
                                    'maxValue': null,
                                    'regexPattern': null,
                                    'optionType': null,
                                    'hasEmptyValue': null,
                                    'options': null,
                                    'restUrl': null,
                                    'restResponsePath': null,
                                    'restIdProperty': null,
                                    'restLabelProperty': null,
                                    'tab': 'tab1',
                                    'className': null,
                                    'params': {
                                        'existingColspan': 1,
                                        'maxColspan': 1
                                    },
                                    'dateDisplayFormat': null,
                                    'layout': {
                                        'row': -1,
                                        'column': -1,
                                        'colspan': 1
                                    },
                                    'sizeX': 1,
                                    'sizeY': 1,
                                    'row': -1,
                                    'col': -1,
                                    'visibilityCondition': null
                                },
                                {
                                    'fieldType': 'AmountFieldRepresentation',
                                    'id': 'label11',
                                    'name': 'Label11',
                                    'type': 'amount',
                                    'value': null,
                                    'required': false,
                                    'readOnly': false,
                                    'overrideId': false,
                                    'colspan': 1,
                                    'placeholder': '10',
                                    'minLength': 0,
                                    'maxLength': 0,
                                    'minValue': null,
                                    'maxValue': null,
                                    'regexPattern': null,
                                    'optionType': null,
                                    'hasEmptyValue': null,
                                    'options': null,
                                    'restUrl': null,
                                    'restResponsePath': null,
                                    'restIdProperty': null,
                                    'restLabelProperty': null,
                                    'tab': 'tab1',
                                    'className': null,
                                    'params': {
                                        'existingColspan': 1,
                                        'maxColspan': 1
                                    },
                                    'dateDisplayFormat': null,
                                    'layout': {
                                        'row': -1,
                                        'column': -1,
                                        'colspan': 1
                                    },
                                    'sizeX': 1,
                                    'sizeY': 1,
                                    'row': -1,
                                    'col': -1,
                                    'visibilityCondition': null,
                                    'enableFractions': false,
                                    'currency': null
                                }
                            ]
                        }
                    },
                    {
                        'fieldType': 'ContainerRepresentation',
                        'id': 'section3',
                        'name': 'Section 3',
                        'type': 'group',
                        'value': null,
                        'required': false,
                        'readOnly': false,
                        'overrideId': false,
                        'colspan': 1,
                        'placeholder': null,
                        'minLength': 0,
                        'maxLength': 0,
                        'minValue': null,
                        'maxValue': null,
                        'regexPattern': null,
                        'optionType': null,
                        'hasEmptyValue': null,
                        'options': null,
                        'restUrl': null,
                        'restResponsePath': null,
                        'restIdProperty': null,
                        'restLabelProperty': null,
                        'tab': 'tab1',
                        'className': null,
                        'dateDisplayFormat': null,
                        'layout': {
                            'row': -1,
                            'column': -1,
                            'colspan': 2
                        },
                        'sizeX': 2,
                        'sizeY': 1,
                        'row': -1,
                        'col': -1,
                        'visibilityCondition': null,
                        'numberOfColumns': 2,
                        'fields': {
                            '1': [
                                {
                                    'fieldType': 'RestFieldRepresentation',
                                    'id': 'label9',
                                    'name': 'Label9',
                                    'type': 'dropdown',
                                    'value': 'Choose one...',
                                    'required': false,
                                    'readOnly': false,
                                    'overrideId': false,
                                    'colspan': 1,
                                    'placeholder': null,
                                    'minLength': 0,
                                    'maxLength': 0,
                                    'minValue': null,
                                    'maxValue': null,
                                    'regexPattern': null,
                                    'optionType': null,
                                    'hasEmptyValue': true,
                                    'options': [
                                        {
                                            'id': 'empty',
                                            'name': 'Choose one...'
                                        }
                                    ],
                                    'restUrl': null,
                                    'restResponsePath': null,
                                    'restIdProperty': null,
                                    'restLabelProperty': null,
                                    'tab': 'tab1',
                                    'className': null,
                                    'params': {
                                        'existingColspan': 1,
                                        'maxColspan': 2
                                    },
                                    'dateDisplayFormat': null,
                                    'layout': {
                                        'row': -1,
                                        'column': -1,
                                        'colspan': 1
                                    },
                                    'sizeX': 1,
                                    'sizeY': 1,
                                    'row': -1,
                                    'col': -1,
                                    'visibilityCondition': null,
                                    'endpoint': null,
                                    'requestHeaders': null
                                },
                                {
                                    'fieldType': 'RestFieldRepresentation',
                                    'id': 'label12',
                                    'name': 'Label12',
                                    'type': 'radio-buttons',
                                    'value': null,
                                    'required': false,
                                    'readOnly': false,
                                    'overrideId': false,
                                    'colspan': 1,
                                    'placeholder': null,
                                    'minLength': 0,
                                    'maxLength': 0,
                                    'minValue': null,
                                    'maxValue': null,
                                    'regexPattern': null,
                                    'optionType': null,
                                    'hasEmptyValue': null,
                                    'options': [
                                        {
                                            'id': 'option_1',
                                            'name': 'Option 1'
                                        },
                                        {
                                            'id': 'option_2',
                                            'name': 'Option 2'
                                        }
                                    ],
                                    'restUrl': null,
                                    'restResponsePath': null,
                                    'restIdProperty': null,
                                    'restLabelProperty': null,
                                    'tab': 'tab1',
                                    'className': null,
                                    'params': {
                                        'existingColspan': 1,
                                        'maxColspan': 2
                                    },
                                    'dateDisplayFormat': null,
                                    'layout': {
                                        'row': -1,
                                        'column': -1,
                                        'colspan': 1
                                    },
                                    'sizeX': 1,
                                    'sizeY': 1,
                                    'row': -1,
                                    'col': -1,
                                    'visibilityCondition': null,
                                    'endpoint': null,
                                    'requestHeaders': null
                                }
                            ],
                            '2': [
                                {
                                    'fieldType': 'RestFieldRepresentation',
                                    'id': 'label10',
                                    'name': 'Label10',
                                    'type': 'typeahead',
                                    'value': null,
                                    'required': false,
                                    'readOnly': false,
                                    'overrideId': false,
                                    'colspan': 1,
                                    'placeholder': null,
                                    'minLength': 0,
                                    'maxLength': 0,
                                    'minValue': null,
                                    'maxValue': null,
                                    'regexPattern': null,
                                    'optionType': null,
                                    'hasEmptyValue': null,
                                    'options': null,
                                    'restUrl': null,
                                    'restResponsePath': null,
                                    'restIdProperty': null,
                                    'restLabelProperty': null,
                                    'tab': 'tab1',
                                    'className': null,
                                    'params': {
                                        'existingColspan': 1,
                                        'maxColspan': 1
                                    },
                                    'dateDisplayFormat': null,
                                    'layout': {
                                        'row': -1,
                                        'column': -1,
                                        'colspan': 1
                                    },
                                    'sizeX': 1,
                                    'sizeY': 1,
                                    'row': -1,
                                    'col': -1,
                                    'visibilityCondition': null,
                                    'endpoint': null,
                                    'requestHeaders': null
                                }
                            ]
                        }
                    }
                ],
                'outcomes': [],
                'javascriptEvents': [],
                'className': '',
                'style': '',
                'customFieldTemplates': {},
                'metadata': {},
                'variables': [
                    {
                        'id': 'bfca9766-7bc1-45cc-8ecf-cdad551e36e2',
                        'name': 'name1',
                        'type': 'string',
                        'value': ''
                    },
                    {
                        'id': '3ed9f28a-dbae-463f-b991-47ef06658bb6',
                        'name': 'name2',
                        'type': 'string',
                        'value': ''
                    },
                    {
                        'id': 'a7710978-1e9c-4b54-a19c-c6267d2b19a2',
                        'name': 'input02',
                        'type': 'integer'
                    }
                ],
                'gridsterForm': false,
                'globalDateFormat': 'D-M-YYYY'
            }
        };
        this.simpleFormDefinition = {
            'formRepresentation': {
                'id': 1001,
                'name': 'SIMPLE_FORM_EXAMPLE',
                'description': '',
                'version': 1,
                'lastUpdatedBy': 2,
                'lastUpdatedByFullName': 'Test01 01Test',
                'lastUpdated': '2018-02-26T17:44:04.543+0000',
                'stencilSetId': 0,
                'referenceId': null,
                'taskId': '9999',
                'formDefinition': {
                    'tabs': [],
                    'fields': [
                        {
                            'fieldType': 'ContainerRepresentation',
                            'id': '1519666726245',
                            'name': 'Label',
                            'type': 'container',
                            'value': null,
                            'required': false,
                            'readOnly': false,
                            'overrideId': false,
                            'colspan': 1,
                            'placeholder': null,
                            'minLength': 0,
                            'maxLength': 0,
                            'minValue': null,
                            'maxValue': null,
                            'regexPattern': null,
                            'optionType': null,
                            'hasEmptyValue': null,
                            'options': null,
                            'restUrl': null,
                            'restResponsePath': null,
                            'restIdProperty': null,
                            'restLabelProperty': null,
                            'tab': null,
                            'className': null,
                            'dateDisplayFormat': null,
                            'layout': null,
                            'sizeX': 2,
                            'sizeY': 1,
                            'row': -1,
                            'col': -1,
                            'visibilityCondition': null,
                            'numberOfColumns': 2,
                            'fields': {
                                '1': [
                                    {
                                        'fieldType': 'RestFieldRepresentation',
                                        'id': 'typeaheadField',
                                        'name': 'TypeaheadField',
                                        'type': 'typeahead',
                                        'value': null,
                                        'required': false,
                                        'readOnly': false,
                                        'overrideId': false,
                                        'colspan': 1,
                                        'placeholder': null,
                                        'minLength': 0,
                                        'maxLength': 0,
                                        'minValue': null,
                                        'maxValue': null,
                                        'regexPattern': null,
                                        'optionType': null,
                                        'hasEmptyValue': null,
                                        'options': null,
                                        'restUrl': 'https://jsonplaceholder.typicode.com/users',
                                        'restResponsePath': null,
                                        'restIdProperty': 'id',
                                        'restLabelProperty': 'name',
                                        'tab': null,
                                        'className': null,
                                        'params': {
                                            'existingColspan': 1,
                                            'maxColspan': 2
                                        },
                                        'dateDisplayFormat': null,
                                        'layout': {
                                            'row': -1,
                                            'column': -1,
                                            'colspan': 1
                                        },
                                        'sizeX': 1,
                                        'sizeY': 1,
                                        'row': -1,
                                        'col': -1,
                                        'visibilityCondition': null,
                                        'endpoint': null,
                                        'requestHeaders': null
                                    }
                                ],
                                '2': [
                                    {
                                        'fieldType': 'RestFieldRepresentation',
                                        'id': 'radioButton',
                                        'name': 'RadioButtons',
                                        'type': 'radio-buttons',
                                        'value': null,
                                        'required': false,
                                        'readOnly': false,
                                        'overrideId': false,
                                        'colspan': 1,
                                        'placeholder': null,
                                        'minLength': 0,
                                        'maxLength': 0,
                                        'minValue': null,
                                        'maxValue': null,
                                        'regexPattern': null,
                                        'optionType': null,
                                        'hasEmptyValue': null,
                                        'options': [
                                            {
                                                'id': 'option_1',
                                                'name': 'Option 1'
                                            },
                                            {
                                                'id': 'option_2',
                                                'name': 'Option 2'
                                            },
                                            {
                                                'id': 'option_3',
                                                'name': 'Option 3'
                                            }
                                        ],
                                        'restUrl': null,
                                        'restResponsePath': null,
                                        'restIdProperty': null,
                                        'restLabelProperty': null,
                                        'tab': null,
                                        'className': null,
                                        'params': {
                                            'existingColspan': 1,
                                            'maxColspan': 1
                                        },
                                        'dateDisplayFormat': null,
                                        'layout': {
                                            'row': -1,
                                            'column': -1,
                                            'colspan': 1
                                        },
                                        'sizeX': 1,
                                        'sizeY': 2,
                                        'row': -1,
                                        'col': -1,
                                        'visibilityCondition': null,
                                        'endpoint': null,
                                        'requestHeaders': null
                                    }
                                ]
                            }
                        },
                        {
                            'fieldType': 'ContainerRepresentation',
                            'id': '1519666735185',
                            'name': 'Label',
                            'type': 'container',
                            'value': null,
                            'required': false,
                            'readOnly': false,
                            'overrideId': false,
                            'colspan': 1,
                            'placeholder': null,
                            'minLength': 0,
                            'maxLength': 0,
                            'minValue': null,
                            'maxValue': null,
                            'regexPattern': null,
                            'optionType': null,
                            'hasEmptyValue': null,
                            'options': null,
                            'restUrl': null,
                            'restResponsePath': null,
                            'restIdProperty': null,
                            'restLabelProperty': null,
                            'tab': null,
                            'className': null,
                            'dateDisplayFormat': null,
                            'layout': null,
                            'sizeX': 2,
                            'sizeY': 1,
                            'row': -1,
                            'col': -1,
                            'visibilityCondition': null,
                            'numberOfColumns': 2,
                            'fields': {
                                '1': [
                                    {
                                        'fieldType': 'RestFieldRepresentation',
                                        'id': 'selectBox',
                                        'name': 'SelectBox',
                                        'type': 'dropdown',
                                        'value': 'Choose one...',
                                        'required': false,
                                        'readOnly': false,
                                        'overrideId': false,
                                        'colspan': 1,
                                        'placeholder': null,
                                        'minLength': 0,
                                        'maxLength': 0,
                                        'minValue': null,
                                        'maxValue': null,
                                        'regexPattern': null,
                                        'optionType': 'manual',
                                        'hasEmptyValue': true,
                                        'options': [
                                            {
                                                'id': 'empty',
                                                'name': 'Choose one...'
                                            },
                                            {
                                                'id': 'option_1',
                                                'name': '1'
                                            },
                                            {
                                                'id': 'option_2',
                                                'name': '2'
                                            },
                                            {
                                                'id': 'option_3',
                                                'name': '3'
                                            }
                                        ],
                                        'restUrl': null,
                                        'restResponsePath': null,
                                        'restIdProperty': null,
                                        'restLabelProperty': null,
                                        'tab': null,
                                        'className': null,
                                        'params': {
                                            'existingColspan': 1,
                                            'maxColspan': 2
                                        },
                                        'dateDisplayFormat': null,
                                        'layout': {
                                            'row': -1,
                                            'column': -1,
                                            'colspan': 1
                                        },
                                        'sizeX': 1,
                                        'sizeY': 1,
                                        'row': -1,
                                        'col': -1,
                                        'visibilityCondition': null,
                                        'endpoint': null,
                                        'requestHeaders': null
                                    }
                                ],
                                '2': []
                            }
                        }
                    ],
                    'outcomes': [],
                    'javascriptEvents': [],
                    'className': '',
                    'style': '',
                    'customFieldTemplates': {},
                    'metadata': {},
                    'variables': [
                        {
                            'id': 'bfca9766-7bc1-45cc-8ecf-cdad551e36e2',
                            'name': 'name1',
                            'type': 'string',
                            'value': ''
                        },
                        {
                            'id': '3ed9f28a-dbae-463f-b991-47ef06658bb6',
                            'name': 'name2',
                            'type': 'string',
                            'value': ''
                        },
                        {
                            'id': 'a7710978-1e9c-4b54-a19c-c6267d2b19a2',
                            'name': 'input02',
                            'type': 'integer'
                        }
                    ],
                    'customFieldsValueInfo': {},
                    'gridsterForm': false
                }
            }
        };
        this.cloudFormDefinition = {
            'formRepresentation': {
                'id': 'text-form',
                'name': 'test-start-form',
                'version': 0,
                'description': '',
                'formDefinition': {
                    'tabs': [],
                    'fields': [
                        {
                            'id': '1511517333638',
                            'type': 'container',
                            'fieldType': 'ContainerRepresentation',
                            'name': 'Label',
                            'tab': null,
                            'numberOfColumns': 2,
                            'fields': {
                                '1': [
                                    {
                                        'fieldType': 'FormFieldRepresentation',
                                        'id': 'texttest',
                                        'name': 'texttest',
                                        'type': 'text',
                                        'value': null,
                                        'required': false,
                                        'placeholder': 'text',
                                        'params': {
                                            'existingColspan': 2,
                                            'maxColspan': 6,
                                            'inputMaskReversed': true,
                                            'inputMask': '0#',
                                            'inputMaskPlaceholder': '(0-9)'
                                        }
                                    }
                                ],
                                '2': [{
                                        'fieldType': 'AttachFileFieldRepresentation',
                                        'id': 'attachfiletest',
                                        'name': 'attachfiletest',
                                        'type': 'upload',
                                        'required': true,
                                        'colspan': 2,
                                        'placeholder': 'attachfile',
                                        'params': {
                                            'existingColspan': 2,
                                            'maxColspan': 2,
                                            'fileSource': {
                                                'serviceId': 'local-file',
                                                'name': 'Local File'
                                            },
                                            'multiple': true,
                                            'link': false
                                        },
                                        'visibilityCondition': {}
                                    }]
                            }
                        }
                    ],
                    'outcomes': [],
                    'metadata': {
                        'property1': 'value1',
                        'property2': 'value2'
                    },
                    'variables': [
                        {
                            'name': 'variable1',
                            'type': 'string',
                            'value': 'value1'
                        },
                        {
                            'name': 'variable2',
                            'type': 'string',
                            'value': 'value2'
                        }
                    ]
                }
            }
        };
    }
    getEasyForm() {
        return this.easyForm;
    }
    getFormDefinition() {
        return this.formDefinition;
    }
    getSimpleFormDefinition() {
        return this.simpleFormDefinition;
    }
    getFormCloudDefinition() {
        return this.cloudFormDefinition;
    }
}

class CoreAutomationService {
    constructor(appConfigService, alfrescoApiService, userPreferencesService, storageService) {
        this.appConfigService = appConfigService;
        this.alfrescoApiService = alfrescoApiService;
        this.userPreferencesService = userPreferencesService;
        this.storageService = storageService;
        this.forms = new DemoForm();
    }
    setup() {
        const adfProxy = window['adf'] || {};
        adfProxy.getConfigField = (field) => {
            return this.appConfigService.get(field);
        };
        adfProxy.setConfigField = (field, value) => {
            this.appConfigService.config[field] = JSON.parse(value);
        };
        adfProxy.setStorageItem = (key, data) => {
            this.storageService.setItem(key, data);
        };
        adfProxy.removeStorageItem = (key) => {
            this.storageService.removeItem(key);
        };
        adfProxy.getStorageItem = (key) => {
            return this.storageService.getItem(key);
        };
        adfProxy.setUserPreference = (key, data) => {
            this.userPreferencesService.set(key, data);
        };
        adfProxy.setFormInEditor = (json) => {
            this.forms.formDefinition = JSON.parse(json);
        };
        adfProxy.setCloudFormInEditor = (json) => {
            this.forms.cloudFormDefinition = JSON.parse(json);
        };
        adfProxy.clearStorage = () => {
            this.storageService.clear();
        };
        adfProxy.apiReset = () => {
            this.alfrescoApiService.reset();
        };
        window['adf'] = adfProxy;
    }
}
CoreAutomationService.ɵprov = ɵɵdefineInjectable({ factory: function CoreAutomationService_Factory() { return new CoreAutomationService(ɵɵinject(AppConfigService), ɵɵinject(AlfrescoApiService), ɵɵinject(UserPreferencesService), ɵɵinject(StorageService)); }, token: CoreAutomationService, providedIn: "root" });
CoreAutomationService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
CoreAutomationService.ctorParameters = () => [
    { type: AppConfigService },
    { type: AlfrescoApiService },
    { type: UserPreferencesService },
    { type: StorageService }
];

class IdentityGroupService {
    constructor(oAuth2Service, appConfigService) {
        this.oAuth2Service = oAuth2Service;
        this.appConfigService = appConfigService;
    }
    get identityHost() {
        return `${this.appConfigService.get('identityHost')}`;
    }
    getGroups() {
        const url = `${this.identityHost}/groups`;
        return this.oAuth2Service.get({ url });
    }
    getAvailableRoles(groupId) {
        const url = `${this.identityHost}/groups/${groupId}/role-mappings/realm/available`;
        return this.oAuth2Service.get({ url });
    }
    getAssignedRoles(groupId) {
        const url = `${this.identityHost}/groups/${groupId}/role-mappings/realm`;
        return this.oAuth2Service.get({ url });
    }
    assignRoles(groupId, roles) {
        const url = `${this.identityHost}/groups/${groupId}/role-mappings/realm`;
        const bodyParam = JSON.stringify(roles);
        return this.oAuth2Service.post({ url, bodyParam });
    }
    removeRoles(groupId, roles) {
        const url = `${this.identityHost}/groups/${groupId}/role-mappings/realm`;
        const bodyParam = JSON.stringify(roles);
        return this.oAuth2Service.delete({ url, bodyParam });
    }
    getEffectiveRoles(groupId) {
        const url = `${this.identityHost}/groups/${groupId}/role-mappings/realm/composite`;
        return this.oAuth2Service.get({ url });
    }
    queryGroups(requestQuery) {
        const url = `${this.identityHost}/groups`;
        const queryParams = { first: requestQuery.first || 0, max: requestQuery.max || 5 };
        return this.getTotalGroupsCount().pipe(switchMap((totalCount) => this.oAuth2Service.get({ url, queryParams }).pipe(map((response) => {
            return {
                entries: response,
                pagination: {
                    skipCount: requestQuery.first,
                    maxItems: requestQuery.max,
                    count: totalCount.count,
                    hasMoreItems: false,
                    totalItems: totalCount.count
                }
            };
        }))));
    }
    getTotalGroupsCount() {
        const url = `${this.identityHost}/groups/count`;
        return this.oAuth2Service.get({ url });
    }
    createGroup(newGroup) {
        const url = `${this.identityHost}/groups`;
        const bodyParam = newGroup;
        return this.oAuth2Service.post({ url, bodyParam });
    }
    updateGroup(groupId, updatedGroup) {
        const url = `${this.identityHost}/groups/${groupId}`;
        const bodyParam = JSON.stringify(updatedGroup);
        return this.oAuth2Service.put({ url, bodyParam });
    }
    deleteGroup(groupId) {
        const url = `${this.identityHost}/groups/${groupId}`;
        return this.oAuth2Service.delete({ url });
    }
    findGroupsByName(searchParams) {
        if (searchParams.name === '') {
            return of([]);
        }
        const url = `${this.identityHost}/groups`;
        const queryParams = { search: searchParams.name };
        return this.oAuth2Service.get({ url, queryParams });
    }
    getGroupRoles(groupId) {
        const url = this.buildRolesUrl(groupId);
        return this.oAuth2Service.get({ url });
    }
    checkGroupHasRole(groupId, roleNames) {
        return this.getGroupRoles(groupId).pipe(map((groupRoles) => {
            let hasRole = false;
            if (groupRoles && groupRoles.length > 0) {
                roleNames.forEach((roleName) => {
                    const role = groupRoles.find(({ name }) => roleName === name);
                    if (role) {
                        hasRole = true;
                        return;
                    }
                });
            }
            return hasRole;
        }));
    }
    getClientIdByApplicationName(applicationName) {
        const url = `${this.identityHost}/clients`;
        const queryParams = { clientId: applicationName };
        return this.oAuth2Service.get({ url, queryParams }).pipe(map((response) => response && response.length > 0 ? response[0].id : ''));
    }
    getClientRoles(groupId, clientId) {
        const url = `${this.identityHost}/groups/${groupId}/role-mappings/clients/${clientId}`;
        return this.oAuth2Service.get({ url });
    }
    checkGroupHasClientApp(groupId, clientId) {
        return this.getClientRoles(groupId, clientId).pipe(map((response) => response && response.length > 0));
    }
    checkGroupHasAnyClientAppRole(groupId, clientId, roleNames) {
        return this.getClientRoles(groupId, clientId).pipe(map((clientRoles) => {
            let hasRole = false;
            if (clientRoles.length > 0) {
                roleNames.forEach((roleName) => {
                    const role = clientRoles.find(({ name }) => name === roleName);
                    if (role) {
                        hasRole = true;
                        return;
                    }
                });
            }
            return hasRole;
        }));
    }
    buildRolesUrl(groupId) {
        return `${this.identityHost}/groups/${groupId}/role-mappings/realm/composite`;
    }
}
IdentityGroupService.ɵprov = ɵɵdefineInjectable({ factory: function IdentityGroupService_Factory() { return new IdentityGroupService(ɵɵinject(OAuth2Service), ɵɵinject(AppConfigService)); }, token: IdentityGroupService, providedIn: "root" });
IdentityGroupService.decorators = [
    { type: Injectable, args: [{ providedIn: 'root' },] }
];
IdentityGroupService.ctorParameters = () => [
    { type: OAuth2Service },
    { type: AppConfigService }
];

class IdentityRoleService {
    constructor(http, appConfig, logService) {
        this.http = http;
        this.appConfig = appConfig;
        this.logService = logService;
        this.contextRoot = '';
        this.identityHost = '';
        this.contextRoot = this.appConfig.get('apiHost', '');
        this.identityHost = this.appConfig.get('identityHost');
    }
    getRoles(skipCount = 0, size = 5) {
        return this.http.get(`${this.identityHost}/roles`).pipe(map(res => {
            return this.preparePaginationWithRoles(res, skipCount, size);
        }), catchError(error => this.handleError(error)));
    }
    preparePaginationWithRoles(roles, skipCount = 0, size = 5) {
        return {
            entries: roles.slice(skipCount, skipCount + size),
            pagination: {
                skipCount: skipCount,
                maxItems: size,
                count: roles.length,
                hasMoreItems: false,
                totalItems: roles.length
            }
        };
    }
    addRole(newRole) {
        if (newRole) {
            const request = newRole;
            return this.http
                .post(`${this.identityHost}/roles`, request)
                .pipe(catchError(error => this.handleError(error)));
        }
        return of();
    }
    deleteRole(deletedRole) {
        return this.http
            .delete(`${this.identityHost}/roles-by-id/${deletedRole.id}`)
            .pipe(catchError(error => this.handleError(error)));
    }
    updateRole(updatedRole, roleId) {
        if (updatedRole && roleId) {
            const request = updatedRole;
            return this.http
                .put(`${this.identityHost}/roles-by-id/${roleId}`, request)
                .pipe(catchError(error => this.handleError(error)));
        }
        return of();
    }
    handleError(error) {
        this.logService.error(error);
        return throwError(error || 'Server error');
    }
}
IdentityRoleService.ɵprov = ɵɵdefineInjectable({ factory: function IdentityRoleService_Factory() { return new IdentityRoleService(ɵɵinject(HttpClient), ɵɵinject(AppConfigService), ɵɵinject(LogService)); }, token: IdentityRoleService, providedIn: "root" });
IdentityRoleService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
IdentityRoleService.ctorParameters = () => [
    { type: HttpClient },
    { type: AppConfigService },
    { type: LogService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AuthBearerInterceptor {
    constructor(injector) {
        this.injector = injector;
    }
    loadExcludedUrlsRegex() {
        const excludedUrls = this.authService.getBearerExcludedUrls();
        this.excludedUrlsRegex = excludedUrls.map((urlPattern) => new RegExp(urlPattern, 'gi')) || [];
    }
    intercept(req, next) {
        this.authService = this.injector.get(AuthenticationService);
        if (!this.authService || !this.authService.getBearerExcludedUrls()) {
            return next.handle(req);
        }
        if (!this.excludedUrlsRegex) {
            this.loadExcludedUrlsRegex();
        }
        const urlRequest = req.url;
        const shallPass = !!this.excludedUrlsRegex.find((regex) => regex.test(urlRequest));
        if (shallPass) {
            return next.handle(req)
                .pipe(catchError((error) => {
                return throwError(error);
            }));
        }
        return this.authService.addTokenToHeader(req.headers)
            .pipe(mergeMap((headersWithBearer) => {
            const headerWithContentType = this.appendJsonContentType(headersWithBearer);
            const kcReq = req.clone({ headers: headerWithContentType });
            return next.handle(kcReq)
                .pipe(catchError((error) => {
                return throwError(error);
            }));
        }));
    }
    appendJsonContentType(headers) {
        return headers.set('Content-Type', 'application/json;charset=UTF-8');
    }
}
AuthBearerInterceptor.decorators = [
    { type: Injectable }
];
AuthBearerInterceptor.ctorParameters = () => [
    { type: Injector }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class DialogModule {
}
DialogModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    TranslateModule,
                    PipeModule
                ],
                declarations: [
                    DownloadZipDialogComponent
                ],
                exports: [
                    DownloadZipDialogComponent
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class NotificationHistoryComponent {
    constructor(notificationService, storageService, cd) {
        this.notificationService = notificationService;
        this.storageService = storageService;
        this.cd = cd;
        this.menuPositionX = 'after';
        this.menuPositionY = 'below';
        this.maxNotifications = 5;
        this.onDestroy$ = new Subject();
        this.notifications = [];
        this.paginatedNotifications = [];
    }
    ngOnInit() {
        this.notifications = JSON.parse(this.storageService.getItem(NotificationHistoryComponent.NOTIFICATION_STORAGE)) || [];
    }
    ngAfterViewInit() {
        this.notificationService.notifications$
            .pipe(takeUntil(this.onDestroy$))
            .subscribe((notification) => {
            this.addNewNotification(notification);
            this.cd.detectChanges();
        });
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
    addNewNotification(notification) {
        this.notifications.unshift(notification);
        if (this.notifications.length > NotificationHistoryComponent.MAX_NOTIFICATION_STACK_LENGTH) {
            this.notifications.shift();
        }
        this.saveNotifications();
        this.createPagination();
    }
    saveNotifications() {
        this.storageService.setItem(NotificationHistoryComponent.NOTIFICATION_STORAGE, JSON.stringify(this.notifications.filter((notification) => notification.type !== NOTIFICATION_TYPE.RECURSIVE)));
    }
    onMenuOpened() {
        this.createPagination();
    }
    onKeyPress(event) {
        this.closeUserModal(event);
    }
    closeUserModal($event) {
        if ($event.keyCode === 27) {
            this.trigger.closeMenu();
        }
    }
    markAsRead() {
        this.notifications = [];
        this.paginatedNotifications = [];
        this.storageService.removeItem(NotificationHistoryComponent.NOTIFICATION_STORAGE);
        this.createPagination();
        this.trigger.closeMenu();
    }
    createPagination() {
        this.pagination = {
            skipCount: this.maxNotifications,
            maxItems: this.maxNotifications,
            totalItems: this.notifications.length,
            hasMoreItems: this.notifications.length > this.maxNotifications
        };
        this.paginatedNotifications = this.notifications.slice(0, this.pagination.skipCount);
    }
    loadMore() {
        this.pagination.skipCount = this.pagination.maxItems + this.pagination.skipCount;
        this.pagination.hasMoreItems = this.notifications.length > this.pagination.skipCount;
        this.paginatedNotifications = this.notifications.slice(0, this.pagination.skipCount);
    }
    hasMoreNotifications() {
        var _a;
        return (_a = this.pagination) === null || _a === void 0 ? void 0 : _a.hasMoreItems;
    }
    onNotificationClick(notification) {
        if (notification.clickCallBack) {
            notification.clickCallBack(notification.args);
            this.trigger.closeMenu();
        }
    }
}
NotificationHistoryComponent.MAX_NOTIFICATION_STACK_LENGTH = 100;
NotificationHistoryComponent.NOTIFICATION_STORAGE = 'notification-history';
NotificationHistoryComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-notification-history',
                template: "<div (keyup)=\"onKeyPress($event)\">\n    <button mat-button\n            [matMenuTriggerFor]=\"menu\"\n            class=\"adf-notification-history-menu_button\"\n            id=\"adf-notification-history-open-button\"\n            (menuOpened)=\"onMenuOpened()\">\n        <mat-icon matBadge=\"&#8288;\"\n                  [matBadgeHidden]=\"!notifications.length\"\n                  matBadgeColor=\"accent\"\n                  matBadgeSize=\"small\">notifications</mat-icon>\n    </button>\n    <mat-menu #menu=\"matMenu\"\n              [xPosition]=\"menuPositionX\"\n              [yPosition]=\"menuPositionY\"\n              id=\"adf-notification-history-menu\"\n              class=\"adf-notification-history-menu\">\n\n        <div class=\"adf-notification-history-list\"\n             (click)=\"$event.stopPropagation()\">\n            <div mat-subheader>\n                <span>{{ 'NOTIFICATIONS.TITLE' | translate }}</span>\n                <button (click)=\"markAsRead()\"\n                        id=\"adf-notification-history-mark-as-read\"\n                        mat-button\n                        color=\"accent\"\n                        *ngIf=\"notifications.length\">\n                    {{ 'NOTIFICATIONS.MARK_AS_READ' | translate }}\n                </button>\n            </div>\n\n            <mat-divider></mat-divider>\n\n            <mat-list>\n                <ng-container *ngIf=\"notifications.length; else empty_list_template\">\n                    <mat-list-item *ngFor=\"let notification of paginatedNotifications\"\n                                   class=\"adf-notification-history-menu-item\"\n                                   (click)=\"onNotificationClick(notification)\">\n                        <div *ngIf=\"notification.initiator; else no_avatar\"\n                             matListAvatar\n                             [outerHTML]=\"notification.initiator | usernameInitials:'adf-notification-initiator-pic'\">\n                        </div>\n                        <ng-template #no_avatar>\n                            <mat-icon mat-list-icon\n                                      class=\"adf-notification-history-menu-initiator\">{{ notification | notificationIcon\n                                }}</mat-icon>\n                        </ng-template>\n                        <p class=\"adf-notification-history-menu-message\"\n                           *ngFor=\"let message of notification.messages\"\n                           mat-line [matTooltip]=\"message\" matTooltipShowDelay=\"1000\">{{ message }}</p>\n                        <p class=\"adf-notification-history-menu-date\"\n                           mat-line> {{notification.datetime | adfTimeAgo}} </p>\n                    </mat-list-item>\n                </ng-container>\n                <ng-template #empty_list_template>\n                    <mat-list-item id=\"adf-notification-history-component-no-message\"\n                                   class=\"adf-notification-history-menu-no-message\">\n                        <h4 mat-line>{{ 'NOTIFICATIONS.NO_MESSAGE' | translate }}</h4>\n                    </mat-list-item>\n                </ng-template>\n            </mat-list>\n\n            <mat-divider></mat-divider>\n\n            <div class=\"adf-notification-history-load-more\"\n                 *ngIf=\"hasMoreNotifications()\">\n                <button mat-button\n                        (click)=\"loadMore()\">\n                    {{ 'NOTIFICATIONS.LOAD_MORE' | translate }}\n                </button>\n            </div>\n        </div>\n    </mat-menu>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-notification-history-menu_button.mat-button{border-radius:90%;height:40px;margin-right:0;min-width:40px;padding:0}.adf-notification-history-list .mat-subheader{justify-content:space-between}.adf-notification-history-menu-item{cursor:pointer}.adf-notification-history-menu-item:focus{background:var(--theme-bg-hover-color);outline:none}.adf-notification-history-menu-item:hover{background-color:var(--theme-bg-hover-color)}.adf-notification-history-menu-message,.adf-notification-history-menu-no-message{font-size:13px!important}.adf-notification-history-menu-date{font-size:12px!important}.adf-notification-history-menu-initiator{margin:4px}.adf-notification-initiator-pic{background:var(--theme-accent-color);border-radius:100px;color:var(--theme-colors-mat-grey);display:inline-block;font-size:18px;font-weight:bolder;height:40px;line-height:40px;min-width:40px;text-align:center;text-transform:uppercase;vertical-align:middle}.adf-notification-history-load-more{display:flex;justify-content:center;padding:10px}.mat-menu-panel.adf-notification-history-menu{max-height:500px;min-width:320px}.mat-menu-panel.adf-notification-history-menu .mat-menu-content{padding:0}"]
            },] }
];
NotificationHistoryComponent.ctorParameters = () => [
    { type: NotificationService },
    { type: StorageService },
    { type: ChangeDetectorRef }
];
NotificationHistoryComponent.propDecorators = {
    trigger: [{ type: ViewChild, args: [MatMenuTrigger, { static: true },] }],
    menuPositionX: [{ type: Input }],
    menuPositionY: [{ type: Input }],
    maxNotifications: [{ type: Input }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class NotificationIconPipe {
    transform(notification) {
        if (notification.icon) {
            return notification.icon;
        }
        else {
            switch (notification.type) {
                case NOTIFICATION_TYPE.ERROR:
                    return 'error';
                case NOTIFICATION_TYPE.WARN:
                    return 'warning';
                default:
                    return 'info';
            }
        }
    }
}
NotificationIconPipe.decorators = [
    { type: Pipe, args: [{
                name: 'notificationIcon'
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class NotificationHistoryModule {
}
NotificationHistoryModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    TranslateModule,
                    PipeModule,
                    PaginationModule
                ],
                declarations: [
                    NotificationHistoryComponent,
                    NotificationIconPipe
                ],
                exports: [
                    NotificationHistoryComponent
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const searchAnimation = trigger('transitionMessages', [
    state('active', style({
        'margin-left': '{{ margin-left }}px',
        'margin-right': '{{ margin-right }}px',
        'transform': '{{ transform }}'
    }), { params: { 'margin-left': 0, 'margin-right': 0, 'transform': 'translateX(0%)' } }),
    state('inactive', style({
        'margin-left': '{{ margin-left }}px',
        'margin-right': '{{ margin-right }}px',
        'transform': '{{ transform }}'
    }), { params: { 'margin-left': 0, 'margin-right': 0, 'transform': 'translateX(0%)' } }),
    state('no-animation', style({ transform: 'translateX(0%)', width: '100%' })),
    transition('active <=> inactive', animate('400ms cubic-bezier(0.25, 0.8, 0.25, 1)'))
]);

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class SearchTextInputComponent {
    constructor(userPreferencesService) {
        this.userPreferencesService = userPreferencesService;
        this.autocomplete = false;
        this.expandable = true;
        this.inputType = 'text';
        this.liveSearchEnabled = true;
        this.searchAutocomplete = false;
        this.searchTerm = '';
        this.debounceTime = 0;
        this.collapseOnSubmit = true;
        this.defaultState = SearchTextStateEnum.collapsed;
        this.collapseOnBlur = true;
        this.showClearButton = false;
        this.placeholder = '';
        this.searchChange = new EventEmitter();
        this.submit = new EventEmitter();
        this.selectResult = new EventEmitter();
        this.reset = new EventEmitter();
        this.searchVisibility = new EventEmitter();
        this.animationStates = {
            ltr: {
                active: { value: 'active', params: { 'margin-left': 13 } },
                inactive: { value: 'inactive', params: { 'transform': 'translateX(82%)' } }
            },
            rtl: {
                active: { value: 'active', params: { 'margin-right': 13 } },
                inactive: { value: 'inactive', params: { 'transform': 'translateX(-82%)' } }
            }
        };
        this.dir = 'ltr';
        this.onDestroy$ = new Subject();
        this.toggleSearch = new Subject();
        this.valueChange = new Subject();
        this.toggleSearch
            .pipe(debounceTime(200), takeUntil(this.onDestroy$))
            .subscribe(() => {
            if (this.expandable) {
                this.subscriptAnimationState = this.toggleAnimation();
                if (this.subscriptAnimationState.value === 'inactive') {
                    this.searchTerm = '';
                    this.reset.emit(true);
                    if (document.activeElement.id === this.searchInput.nativeElement.id) {
                        this.searchInput.nativeElement.blur();
                    }
                }
                this.emitVisibilitySearch();
            }
        });
    }
    ngOnInit() {
        this.userPreferencesService
            .select('textOrientation')
            .pipe(takeUntil(this.onDestroy$))
            .subscribe((direction) => {
            this.dir = direction;
            this.subscriptAnimationState = this.getDefaultState(this.dir);
        });
        this.subscriptAnimationState = this.getDefaultState(this.dir);
        this.setValueChangeHandler();
        this.setupFocusEventHandlers();
    }
    applySearchFocus(animationDoneEvent) {
        if (animationDoneEvent.toState === 'active' && this.isDefaultStateCollapsed()) {
            this.searchInput.nativeElement.focus();
        }
    }
    getAutoComplete() {
        return this.autocomplete ? 'on' : 'off';
    }
    toggleAnimation() {
        if (this.dir === 'ltr') {
            return this.subscriptAnimationState.value === 'inactive' ?
                { value: 'active', params: { 'margin-left': 13 } } :
                { value: 'inactive', params: { 'transform': 'translateX(82%)' } };
        }
        else {
            return this.subscriptAnimationState.value === 'inactive' ?
                { value: 'active', params: { 'margin-right': 13 } } :
                { value: 'inactive', params: { 'transform': 'translateX(-82%)' } };
        }
    }
    getDefaultState(dir) {
        if (this.dir) {
            return this.getAnimationState(dir);
        }
        return this.animationStates.ltr.inactive;
    }
    getAnimationState(dir) {
        if (this.expandable && this.isDefaultStateExpanded()) {
            return this.animationStates[dir].active;
        }
        else if (this.expandable) {
            return this.animationStates[dir].inactive;
        }
        else {
            return { value: 'no-animation' };
        }
    }
    setupFocusEventHandlers() {
        if (this.focusListener) {
            const focusEvents = this.focusListener
                .pipe(debounceTime(50), filter(($event) => {
                return this.isSearchBarActive() && ($event.type === 'blur' || $event.type === 'focusout' || $event.type === 'focus');
            }), takeUntil(this.onDestroy$));
            this.focusSubscription = focusEvents.subscribe((event) => {
                if (event.type === 'focus') {
                    this.searchInput.nativeElement.focus();
                }
                else {
                    this.toggleSearchBar();
                }
            });
        }
    }
    setValueChangeHandler() {
        this.valueChange.pipe(debounceTime(this.debounceTime), takeUntil(this.onDestroy$)).subscribe((value) => {
            this.searchChange.emit(value);
        });
    }
    selectFirstResult($event) {
        this.selectResult.emit($event);
    }
    onBlur($event) {
        if (this.collapseOnBlur && !$event.relatedTarget) {
            this.resetSearch();
        }
    }
    inputChange($event) {
        this.valueChange.next($event);
    }
    toggleSearchBar() {
        if (this.toggleSearch) {
            this.toggleSearch.next();
        }
    }
    searchSubmit(event) {
        this.submit.emit(event);
        if (this.collapseOnSubmit) {
            this.toggleSearchBar();
        }
    }
    activateToolbar() {
        if (!this.isSearchBarActive()) {
            this.toggleSearchBar();
        }
        return false;
    }
    isSearchBarActive() {
        return this.subscriptAnimationState.value === 'active';
    }
    ngOnDestroy() {
        if (this.toggleSearch) {
            this.toggleSearch.complete();
            this.toggleSearch = null;
        }
        if (this.focusSubscription) {
            this.focusSubscription.unsubscribe();
            this.focusSubscription = null;
            this.focusListener = null;
        }
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
    canShowClearSearch() {
        return this.showClearButton && this.isSearchBarActive();
    }
    resetSearch() {
        if (this.isSearchBarActive()) {
            this.toggleSearchBar();
        }
    }
    isDefaultStateCollapsed() {
        return this.defaultState === SearchTextStateEnum.collapsed;
    }
    isDefaultStateExpanded() {
        return this.defaultState === SearchTextStateEnum.expanded;
    }
    emitVisibilitySearch() {
        this.isSearchBarActive() ? this.searchVisibility.emit(true) : this.searchVisibility.emit(false);
    }
}
SearchTextInputComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-search-text-input',
                template: "<div class=\"adf-search-container\" [attr.state]=\"subscriptAnimationState.value\">\n    <div [@transitionMessages]=\"subscriptAnimationState\"\n         (@transitionMessages.done)=\"applySearchFocus($event)\">\n        <button mat-icon-button\n                *ngIf=\"expandable\"\n                id=\"adf-search-button\"\n                class=\"adf-search-button\"\n                [title]=\"'SEARCH.BUTTON.TOOLTIP' | translate\"\n                (click)=\"toggleSearchBar()\"\n                (keyup.enter)=\"toggleSearchBar()\">\n            <mat-icon [attr.aria-label]=\"'SEARCH.BUTTON.ARIA-LABEL' | translate\">search</mat-icon>\n        </button>\n        <mat-form-field class=\"adf-input-form-field-divider\">\n            <input matInput\n                   #searchInput\n                   [attr.aria-label]=\"'SEARCH.INPUT.ARIA-LABEL' | translate\"\n                   [attr.type]=\"inputType\"\n                   [autocomplete]=\"getAutoComplete()\"\n                   id=\"adf-control-input\"\n                   [(ngModel)]=\"searchTerm\"\n                   [placeholder]=\"placeholder\"\n                   (focus)=\"activateToolbar()\"\n                   (blur)=\"onBlur($event)\"\n                   (keyup.escape)=\"toggleSearchBar()\"\n                   (keyup.arrowdown)=\"selectFirstResult($event)\"\n                   (ngModelChange)=\"inputChange($event)\"\n                   [searchAutocomplete]=\"searchAutocomplete ? searchAutocomplete : null\"\n                   (keyup.enter)=\"searchSubmit($event)\">\n            <button mat-icon-button matSuffix\n                    data-automation-id=\"adf-clear-search-button\"\n                    class=\"adf-clear-search-button\"\n                    *ngIf=\"canShowClearSearch()\"\n                    (mousedown)=\"resetSearch()\">\n                <mat-icon>clear</mat-icon>\n            </button>\n        </mat-form-field>\n    </div>\n</div>\n",
                animations: [searchAnimation],
                encapsulation: ViewEncapsulation.None,
                host: {
                    'class': 'adf-search-text-input'
                },
                styles: [".adf-search-container{overflow:hidden!important}.adf-search-button{left:-13px}[dir=rtl] .adf-search-button{right:-13px}[dir=ltr] .adf-search-button{left:-13px}.adf-search-fixed-text{line-height:normal}.adf-input-form-field-divider{font-size:16px}.adf-input-form-field-divider .mat-form-field-underline,.adf-input-form-field-divider .mat-form-field-underline .mat-form-field-ripple{background-color:var(--adf-search-input-bg-color)}.adf-highlight{color:var(--adf-search-input-highlight-color)}"]
            },] }
];
SearchTextInputComponent.ctorParameters = () => [
    { type: UserPreferencesService }
];
SearchTextInputComponent.propDecorators = {
    autocomplete: [{ type: Input }],
    expandable: [{ type: Input }],
    inputType: [{ type: Input }],
    liveSearchEnabled: [{ type: Input }],
    searchAutocomplete: [{ type: Input }],
    searchTerm: [{ type: Input }],
    debounceTime: [{ type: Input }],
    focusListener: [{ type: Input }],
    collapseOnSubmit: [{ type: Input }],
    defaultState: [{ type: Input }],
    collapseOnBlur: [{ type: Input }],
    showClearButton: [{ type: Input }],
    placeholder: [{ type: Input }],
    searchChange: [{ type: Output }],
    submit: [{ type: Output }],
    selectResult: [{ type: Output }],
    reset: [{ type: Output }],
    searchVisibility: [{ type: Output }],
    searchInput: [{ type: ViewChild, args: ['searchInput', { static: true },] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const SEARCH_AUTOCOMPLETE_VALUE_ACCESSOR = {
    provide: NG_VALUE_ACCESSOR,
    useExisting: forwardRef(() => SearchTriggerDirective),
    multi: true
};
class SearchTriggerDirective {
    constructor(element, ngZone, changeDetectorRef, document) {
        this.element = element;
        this.ngZone = ngZone;
        this.changeDetectorRef = changeDetectorRef;
        this.document = document;
        this.onDestroy$ = new Subject();
        this.autocomplete = 'off';
        this._panelOpen = false;
        this.escapeEventStream = new Subject();
        this.onChange = () => { };
        this.onTouched = () => { };
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
        if (this.escapeEventStream) {
            this.escapeEventStream = null;
        }
        if (this.closingActionsSubscription) {
            this.closingActionsSubscription.unsubscribe();
        }
    }
    get panelOpen() {
        return this._panelOpen && this.searchPanel.showPanel;
    }
    openPanel() {
        this.searchPanel.isOpen = this._panelOpen = true;
        this.closingActionsSubscription = this.subscribeToClosingActions();
    }
    closePanel() {
        if (this._panelOpen) {
            this.closingActionsSubscription.unsubscribe();
            this._panelOpen = false;
            this.searchPanel.resetResults();
            this.searchPanel.hidePanel();
            this.changeDetectorRef.detectChanges();
        }
    }
    get panelClosingActions() {
        return merge(this.escapeEventStream, this.outsideClickStream);
    }
    get outsideClickStream() {
        if (!this.document) {
            return of(null);
        }
        return merge(fromEvent(this.document, 'click'), fromEvent(this.document, 'touchend')).pipe(filter((event) => {
            const clickTarget = event.target;
            return this._panelOpen && clickTarget !== this.element.nativeElement;
        }), takeUntil(this.onDestroy$));
    }
    writeValue(value) {
        Promise.resolve(null).then(() => this.setTriggerValue(value));
    }
    registerOnChange(fn) {
        this.onChange = fn;
    }
    registerOnTouched(fn) {
        this.onTouched = fn;
    }
    handleKeydown(event) {
        const keyCode = event.keyCode;
        if (keyCode === ESCAPE && this.panelOpen) {
            this.escapeEventStream.next();
            event.stopPropagation();
        }
        else if (keyCode === ENTER) {
            this.escapeEventStream.next();
            event.preventDefault();
        }
    }
    handleInput(event) {
        if (document.activeElement === event.target) {
            const inputValue = event.target.value;
            this.onChange(inputValue);
            if (inputValue && this.searchPanel) {
                this.searchPanel.keyPressedStream.next(inputValue);
                this.openPanel();
            }
            else if (this.searchPanel) {
                this.searchPanel.resetResults();
                this.closePanel();
            }
        }
    }
    isPanelOptionClicked(event) {
        let isPanelOption = false;
        if (event && this.searchPanel) {
            const clickTarget = event.target;
            isPanelOption = !this.isNoResultOption() &&
                !!this.searchPanel.panel &&
                !!this.searchPanel.panel.nativeElement.contains(clickTarget);
        }
        return isPanelOption;
    }
    isNoResultOption() {
        return this.searchPanel && this.searchPanel.results.list ? this.searchPanel.results.list.entries.length === 0 : true;
    }
    subscribeToClosingActions() {
        const firstStable = this.ngZone.onStable.asObservable();
        const optionChanges = this.searchPanel.keyPressedStream.asObservable();
        return merge(firstStable, optionChanges)
            .pipe(switchMap(() => {
            this.searchPanel.setVisibility();
            return this.panelClosingActions;
        }), takeUntil(this.onDestroy$))
            .subscribe((event) => this.setValueAndClose(event));
    }
    setTriggerValue(value) {
        const toDisplay = this.searchPanel && this.searchPanel.displayWith ?
            this.searchPanel.displayWith(value) : value;
        const inputValue = toDisplay != null ? toDisplay : '';
        this.element.nativeElement.value = inputValue;
    }
    setValueAndClose(event) {
        if (this.isPanelOptionClicked(event) && !event.defaultPrevented) {
            this.setTriggerValue(event.target.textContent.trim());
            this.onChange(event.target.textContent.trim());
            this.element.nativeElement.focus();
        }
        this.closePanel();
    }
}
SearchTriggerDirective.decorators = [
    { type: Directive, args: [{
                selector: `input[searchAutocomplete], textarea[searchAutocomplete]`,
                host: {
                    'role': 'combobox',
                    '[attr.autocomplete]': 'autocomplete',
                    'aria-autocomplete': 'list',
                    '[attr.aria-expanded]': 'panelOpen.toString()',
                    '(blur)': 'onTouched()',
                    '(input)': 'handleInput($event)',
                    '(keydown)': 'handleKeydown($event)'
                },
                providers: [SEARCH_AUTOCOMPLETE_VALUE_ACCESSOR]
            },] }
];
SearchTriggerDirective.ctorParameters = () => [
    { type: ElementRef },
    { type: NgZone },
    { type: ChangeDetectorRef },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [DOCUMENT,] }] }
];
SearchTriggerDirective.propDecorators = {
    searchPanel: [{ type: Input, args: ['searchAutocomplete',] }],
    autocomplete: [{ type: Input }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class SearchTextModule {
}
SearchTextModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    SearchTextInputComponent,
                    SearchTriggerDirective
                ],
                imports: [
                    CommonModule,
                    TranslateModule,
                    MaterialModule,
                    FormsModule
                ],
                exports: [
                    SearchTextInputComponent,
                    SearchTriggerDirective
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class BlankPageComponent {
}
BlankPageComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-blank-page',
                template: ``
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class BlankPageModule {
}
BlankPageModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    BlankPageComponent
                ],
                exports: [
                    BlankPageComponent
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AlfrescoApiMock {
    login() {
        return new Promise((resolve) => {
            resolve('TICKET_4479f4d3bb155195879bfbb8d5206f433488a1b1');
        });
    }
    logout() {
        return new Promise((resolve) => {
            resolve('logout');
        });
    }
    changeConfig() {
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AppConfigServiceMock extends AppConfigService {
    constructor(http, extensionService) {
        super(http, extensionService);
        this.config = {
            application: {
                name: 'Alfresco ADF Application'
            },
            ecmHost: 'http://{hostname}{:port}/ecm',
            bpmHost: 'http://{hostname}{:port}/bpm',
            logLevel: 'silent'
        };
    }
    load() {
        return new Promise((resolve) => {
            this.status = Status.LOADED;
            this.onDataLoaded(this.config);
            resolve(this.config);
        });
    }
}
AppConfigServiceMock.decorators = [
    { type: Injectable }
];
AppConfigServiceMock.ctorParameters = () => [
    { type: HttpClient },
    { type: ExtensionService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ɵ0$6 = [
    {
        id: 1, defaultAppId: null, name: 'Sales-Fakes-App', description: 'desc-fake1', modelId: 22,
        theme: 'theme-1-fake', icon: 'glyphicon-asterisk', 'deploymentId': '111', 'tenantId': null
    },
    {
        id: 2, defaultAppId: null, name: 'health-care-Fake', description: 'desc-fake2', modelId: 33,
        theme: 'theme-2-fake', icon: 'glyphicon-asterisk', 'deploymentId': '444', 'tenantId': null
    }
];
let fakeApps = {
    size: 2, total: 2, start: 0,
    data: ɵ0$6
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AuthenticationMock {
    constructor() {
        this.redirectUrl = null;
    }
    setRedirectUrl(url) {
        this.redirectUrl = url;
    }
    getRedirectUrl() {
        return this.redirectUrl ? this.redirectUrl.url : null;
    }
    login(username, password) {
        if (username === 'fake-username' && password === 'fake-password') {
            return of({ type: 'type', ticket: 'ticket' });
        }
        if (username === 'fake-username-CORS-error' && password === 'fake-password') {
            return throwError({
                error: {
                    crossDomain: true,
                    message: 'ERROR: the network is offline, Origin is not allowed by Access-Control-Allow-Origin'
                }
            });
        }
        if (username === 'fake-username-CSRF-error' && password === 'fake-password') {
            return throwError({ message: 'ERROR: Invalid CSRF-token', status: 403 });
        }
        if (username === 'fake-username-ECM-access-error' && password === 'fake-password') {
            return throwError({ message: 'ERROR: 00170728 Access Denied.  The system is currently in read-only mode', status: 403 });
        }
        return throwError('Fake server error');
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let fakeBpmUserNoImage = {
    apps: [],
    capabilities: 'fake-capability',
    company: 'fake-company',
    created: 'fake-create-date',
    email: 'fakeBpm@fake.com',
    externalId: 'fake-external-id',
    firstName: 'fake-first-name',
    lastName: 'fake-last-name',
    groups: [],
    id: 'fake-id',
    lastUpdate: 'fake-update-date',
    latestSyncTimeStamp: 'fake-timestamp',
    password: 'fake-password',
    pictureId: undefined,
    status: 'fake-status',
    tenantId: 'fake-tenant-id',
    tenantName: 'fake-tenant-name',
    tenantPictureId: 'fake-tenant-picture-id',
    type: 'fake-type'
};
let fakeBpmUser = new BpmUserModel({
    apps: [],
    capabilities: null,
    company: 'fake-company',
    created: 'fake-create-date',
    email: 'fakeBpm@fake.com',
    externalId: 'fake-external-id',
    firstName: 'fake-bpm-first-name',
    lastName: 'fake-bpm-last-name',
    groups: [],
    id: 'fake-id',
    lastUpdate: 'fake-update-date',
    latestSyncTimeStamp: 'fake-timestamp',
    password: 'fake-password',
    pictureId: 12,
    status: 'fake-status',
    tenantId: 'fake-tenant-id',
    tenantName: 'fake-tenant-name',
    tenantPictureId: 'fake-tenant-picture-id',
    type: 'fake-type'
});
let fakeBpmEditedUser = {
    apps: [],
    capabilities: 'fake-capability',
    company: 'fake-company',
    created: 'fake-create-date',
    email: 'fakeBpm@fake.com',
    externalId: 'fake-external-id',
    firstName: 'fake-first-name',
    lastName: 'fake-last-name',
    groups: [],
    id: 'fake-id',
    lastUpdate: 'fake-update-date',
    latestSyncTimeStamp: 'fake-timestamp',
    password: 'fake-password',
    pictureId: 'src/assets/images/bpmImg.gif',
    status: 'fake-status',
    tenantId: 'fake-tenant-id',
    tenantName: 'fake-tenant-name',
    tenantPictureId: 'fake-tenant-picture-id',
    type: 'fake-type'
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let fakeUser1 = { id: 1, email: 'fake-email@dom.com', firstName: 'firstName', lastName: 'lastName' };
let fakeUser2 = { id: 1001, email: 'some-one@somegroup.com', firstName: 'some', lastName: 'one' };
const ɵ0$7 = [
    {
        id: 1, message: 'fake-message-1', created: '', createdBy: fakeUser1
    },
    {
        id: 2, message: 'fake-message-2', created: '', createdBy: fakeUser1
    }
];
let fakeTasksComment = {
    size: 2, total: 2, start: 0,
    data: ɵ0$7
};
let fakeProcessComment = new CommentModel({ id: 1, message: 'Test', created: new Date('2016-11-10T03:37:30.010+0000'), createdBy: new UserProcessModel({
        id: 13,
        firstName: 'Wilbur',
        lastName: 'Adams',
        email: 'wilbur@app.com'
    }) });

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CookieServiceMock extends CookieService {
    isEnabled() {
        return true;
    }
    getItem(key) {
        return this[key] && this[key].data || null;
    }
    setItem(key, data, expiration, path) {
        this[key] = { data, expiration, path };
    }
    clear() {
        Object.keys(this).forEach((key) => {
            if (this.hasOwnProperty(key) && typeof (this[key]) !== 'function') {
                this[key] = undefined;
            }
        });
    }
}
CookieServiceMock.decorators = [
    { type: Injectable }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const fakeEcmCompany = {
    organization: 'company-fake-name',
    address1: 'fake-address-1',
    address2: 'fake-address-2',
    address3: 'fake-address-3',
    postcode: 'fAk1',
    telephone: '00000000',
    fax: '11111111',
    email: 'fakeCompany@fake.com'
};
const fakeEcmUser = new EcmUserModel({
    id: 'fake-id',
    firstName: 'fake-ecm-first-name',
    lastName: 'fake-ecm-last-name',
    description: 'i am a fake user for test',
    avatarId: 'fake-avatar-id',
    email: 'fakeEcm@ecmUser.com',
    skypeId: 'fake-skype-id',
    googleId: 'fake-googleId-id',
    instantMessageId: 'fake-instantMessageId-id',
    company: null,
    jobTitle: 'job-ecm-test',
    location: 'fake location',
    mobile: '000000000',
    telephone: '11111111',
    statusUpdatedAt: 'fake-date',
    userStatus: 'active',
    enabled: true,
    emailNotificationsEnabled: true
});
const fakeEcmUser2 = {
    id: 'another-fake-id',
    firstName: 'another-fake-first-name',
    lastName: 'another',
    displayName: 'admin.adf User',
    email: 'admin.adf@alfresco.com',
    company: null,
    enabled: true,
    emailNotificationsEnabled: true
};
const fakeEcmUserNoImage = {
    id: 'fake-id',
    firstName: 'fake-first-name',
    lastName: 'fake-last-name',
    description: 'i am a fake user for test',
    avatarId: null,
    email: 'fakeEcm@ecmUser.com',
    skypeId: 'fake-skype-id',
    googleId: 'fake-googleId-id',
    instantMessageId: 'fake-instantMessageId-id',
    company: null,
    jobTitle: null,
    location: 'fake location',
    mobile: '000000000',
    telephone: '11111111',
    statusUpdatedAt: 'fake-date',
    userStatus: 'active',
    enabled: true,
    emailNotificationsEnabled: true
};
const fakeEcmEditedUser = {
    id: 'fake-id',
    firstName: null,
    lastName: 'fake-last-name',
    description: 'i am a fake user for test',
    avatarId: 'fake-avatar-id',
    email: 'fakeEcm@ecmUser.com',
    skypeId: 'fake-skype-id',
    googleId: 'fake-googleId-id',
    instantMessageId: 'fake-instantMessageId-id',
    company: null,
    jobTitle: 'test job',
    location: 'fake location',
    mobile: '000000000',
    telephone: '11111111',
    statusUpdatedAt: 'fake-date',
    userStatus: 'active',
    enabled: true,
    emailNotificationsEnabled: true
};
const fakeEcmUserList = new PersonPaging({
    list: {
        pagination: {
            count: 2,
            hasMoreItems: false,
            totalItems: 2,
            skipCount: 0,
            maxItems: 100
        },
        entries: [
            {
                entry: fakeEcmUser
            },
            {
                entry: fakeEcmUser2
            }
        ]
    }
});
const createNewPersonMock = {
    id: 'fake-id',
    firstName: 'fake-ecm-first-name',
    lastName: 'fake-ecm-last-name',
    description: 'i am a fake user for test',
    password: 'fake-avatar-id',
    email: 'fakeEcm@ecmUser.com'
};
function getFakeUserWithContentAdminCapability() {
    const fakeEcmUserWithAdminCapabilities = Object.assign(Object.assign({}, fakeEcmUser), { capabilities: {
            isAdmin: true
        } });
    const mockPerson = new Person(fakeEcmUserWithAdminCapabilities);
    return { entry: mockPerson };
}
function getFakeUserWithContentUserCapability() {
    const fakeEcmUserWithAdminCapabilities = Object.assign(Object.assign({}, fakeEcmUser), { capabilities: {
            isAdmin: false
        } });
    const mockPerson = new Person(fakeEcmUserWithAdminCapabilities);
    return { entry: mockPerson };
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class EventMock {
    static keyDown(key) {
        const event = document.createEvent('Event');
        event.keyCode = key;
        event.initEvent('keydown');
        document.dispatchEvent(event);
    }
    static keyUp(key) {
        const event = document.createEvent('Event');
        event.keyCode = key;
        event.initEvent('keyup');
        document.dispatchEvent(event);
    }
    static resizeMobileView() {
        window.dispatchEvent(new Event('resize'));
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let fakeRendition = {
    entry: {
        id: 'pdf',
        content: {
            mimeType: 'application/pdf',
            mimeTypeName: 'Adobe PDF Document'
        },
        status: 'NOT_CREATED'
    }
};
let fakeRenditionCreated = {
    entry: {
        id: 'pdf',
        content: {
            mimeType: 'application/pdf',
            mimeTypeName: 'Adobe PDF Document'
        },
        status: 'CREATED'
    }
};
let fakeRenditionsList = {
    list: {
        pagination: {
            count: 6,
            hasMoreItems: false,
            totalItems: 6,
            skipCount: 0,
            maxItems: 100
        },
        entries: [
            {
                entry: {
                    id: 'avatar',
                    content: {
                        mimeType: 'image/png',
                        mimeTypeName: 'PNG Image'
                    },
                    status: 'NOT_CREATED'
                }
            },
            {
                entry: {
                    id: 'avatar32',
                    content: {
                        mimeType: 'image/png',
                        mimeTypeName: 'PNG Image'
                    },
                    status: 'NOT_CREATED'
                }
            },
            {
                entry: {
                    id: 'doclib',
                    content: {
                        mimeType: 'image/png',
                        mimeTypeName: 'PNG Image'
                    },
                    status: 'NOT_CREATED'
                }
            },
            {
                entry: {
                    id: 'imgpreview',
                    content: {
                        mimeType: 'image/jpeg',
                        mimeTypeName: 'JPEG Image'
                    },
                    status: 'NOT_CREATED'
                }
            },
            {
                entry: {
                    id: 'medium',
                    content: {
                        mimeType: 'image/jpeg',
                        mimeTypeName: 'JPEG Image'
                    },
                    status: 'NOT_CREATED'
                }
            },
            {
                entry: {
                    id: 'pdf',
                    content: {
                        mimeType: 'application/pdf',
                        mimeTypeName: 'Adobe PDF Document'
                    },
                    status: 'NOT_CREATED'
                }
            }
        ]
    }
};
let fakeRenditionsListWithACreated = {
    list: {
        pagination: {
            count: 6,
            hasMoreItems: false,
            totalItems: 6,
            skipCount: 0,
            maxItems: 100
        },
        entries: [
            {
                entry: {
                    id: 'avatar',
                    content: {
                        mimeType: 'image/png',
                        mimeTypeName: 'PNG Image'
                    },
                    status: 'NOT_CREATED'
                }
            },
            {
                entry: {
                    id: 'avatar32',
                    content: {
                        mimeType: 'image/png',
                        mimeTypeName: 'PNG Image'
                    },
                    status: 'NOT_CREATED'
                }
            },
            {
                entry: {
                    id: 'doclib',
                    content: {
                        mimeType: 'image/png',
                        mimeTypeName: 'PNG Image'
                    },
                    status: 'NOT_CREATED'
                }
            },
            {
                entry: {
                    id: 'imgpreview',
                    content: {
                        mimeType: 'image/jpeg',
                        mimeTypeName: 'JPEG Image'
                    },
                    status: 'NOT_CREATED'
                }
            },
            {
                entry: {
                    id: 'medium',
                    content: {
                        mimeType: 'image/jpeg',
                        mimeTypeName: 'JPEG Image'
                    },
                    status: 'NOT_CREATED'
                }
            },
            {
                entry: {
                    id: 'pdf',
                    content: {
                        mimeType: 'application/pdf',
                        mimeTypeName: 'Adobe PDF Document'
                    },
                    status: 'CREATED'
                }
            }
        ]
    }
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let fakeSearch = {
    list: {
        pagination: {
            count: 1,
            hasMoreItems: false,
            totalItems: 1,
            skipCount: 0,
            maxItems: 100
        },
        entries: [
            {
                entry: {
                    id: '123',
                    name: 'MyDoc',
                    content: {
                        mimetype: 'text/plain'
                    },
                    createdByUser: {
                        displayName: 'John Doe'
                    },
                    modifiedByUser: {
                        displayName: 'John Doe'
                    }
                }
            }
        ]
    }
};
let mockError = {
    error: {
        errorKey: 'Search failed',
        statusCode: 400,
        briefSummary: '08220082 search failed',
        stackTrace: 'For security reasons the stack trace is no longer displayed, but the property is kept for previous versions.',
        descriptionURL: 'https://api-explorer.alfresco.com'
    }
};
const ɵ0$8 = () => Promise.resolve(fakeSearch);
let searchMockApi = {
    findNodes: ɵ0$8
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TranslationMock {
    constructor() {
        this.defaultLang = 'en';
        this.translate = {
            onLangChange: new EventEmitter()
        };
    }
    addTranslationFolder() { }
    onTranslationChanged() { }
    use() { }
    loadTranslation() { }
    get(key) {
        return of(key);
    }
    instant(key) {
        return key;
    }
}
TranslationMock.decorators = [
    { type: Injectable }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AlfrescoApiServiceMock extends AlfrescoApiService {
    constructor(appConfig, storageService) {
        super(appConfig, storageService);
        this.appConfig = appConfig;
        this.storageService = storageService;
        if (!this.alfrescoApi) {
            this.initAlfrescoApi();
        }
    }
    initialize() {
        return new Promise((resolve) => {
            this.alfrescoApiInitialized.next(true);
            resolve({});
        });
    }
}
AlfrescoApiServiceMock.decorators = [
    { type: Injectable }
];
AlfrescoApiServiceMock.ctorParameters = () => [
    { type: AppConfigService },
    { type: StorageService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const fakeForm = {
    id: 1001,
    name: 'ISSUE_FORM',
    processDefinitionId: 'ISSUE_APP:1:2504',
    processDefinitionName: 'ISSUE_APP',
    processDefinitionKey: 'ISSUE_APP',
    taskId: '7506',
    taskDefinitionKey: 'sid-F67A2996-1684-4774-855A-4591490081FD',
    tabs: [],
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: '1498212398417',
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                1: [
                    {
                        fieldType: 'RestFieldRepresentation',
                        id: 'dropdownId',
                        name: 'Label',
                        type: 'dropdown',
                        value: 'Choose one...',
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: true,
                        options: [
                            {
                                id: 'empty',
                                name: 'Choose one...'
                            },
                            {
                                id: 'option_1',
                                name: 'test1'
                            },
                            {
                                id: 'option_2',
                                name: 'test2'
                            },
                            {
                                id: 'option_3',
                                name: 'test3'
                            }
                        ],
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null,
                        endpoint: null,
                        requestHeaders: null
                    }
                ],
                2: [
                    {
                        fieldType: 'RestFieldRepresentation',
                        id: 'radio',
                        name: 'radio',
                        type: 'radio-buttons',
                        value: null,
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: [
                            {
                                id: 'option_1',
                                name: 'Option 1'
                            },
                            {
                                id: 'option_2',
                                name: 'Option 2'
                            },
                            {
                                id: 'option_3',
                                name: 'Option 3'
                            }
                        ],
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 1
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 2,
                        row: -1,
                        col: -1,
                        visibilityCondition: null,
                        endpoint: null,
                        requestHeaders: null
                    }
                ]
            }
        },
        {
            fieldType: 'ContainerRepresentation',
            id: '1498212413062',
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                1: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'date',
                        name: 'date',
                        type: 'date',
                        value: null,
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ],
                2: []
            }
        }
    ],
    outcomes: [],
    javascriptEvents: [],
    className: '',
    style: '',
    customFieldTemplates: {},
    metadata: {},
    variables: [],
    customFieldsValueInfo: {},
    gridsterForm: false,
    globalDateFormat: 'D-M-YYYY'
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const formDefinitionTwoTextFields = {
    id: 20,
    name: 'formTextDefinition',
    processDefinitionId: 'textDefinition:1:153',
    processDefinitionName: 'textDefinition',
    processDefinitionKey: 'textDefinition',
    taskId: '159',
    taskDefinitionKey: 'sid-D941F49F-2B04-4FBB-9B49-9E95991993E8',
    tabs: [],
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: '1507044399260',
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                '1': [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'firstname',
                        name: 'firstName',
                        type: 'text',
                        value: null,
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ],
                '2': [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'lastname',
                        name: 'lastName',
                        type: 'text',
                        value: null,
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 1
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ]
            }
        }
    ],
    outcomes: [],
    javascriptEvents: [],
    className: '',
    style: '',
    customFieldTemplates: {},
    metadata: {},
    variables: [],
    customFieldsValueInfo: {},
    gridsterForm: false,
    globalDateFormat: 'D-M-YYYY'
};
const formDefinitionDropdownField = {
    id: 21,
    name: 'dropdownDefinition',
    processDefinitionId: 'textDefinition:2:163',
    processDefinitionName: 'textDefinition',
    processDefinitionKey: 'textDefinition',
    taskId: '169',
    taskDefinitionKey: 'sid-D941F49F-2B04-4FBB-9B49-9E95991993E8',
    tabs: [],
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: '1507046026940',
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                '1': [
                    {
                        fieldType: 'RestFieldRepresentation',
                        id: 'country',
                        name: 'country',
                        type: 'dropdown',
                        value: 'Choose one...',
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: true,
                        options: [
                            {
                                id: 'empty',
                                name: 'Choose one...'
                            },
                            {
                                id: 'option_1',
                                name: 'united kingdom'
                            },
                            {
                                id: 'option_2',
                                name: 'italy'
                            },
                            {
                                id: 'option_3',
                                name: 'france'
                            }
                        ],
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null,
                        endpoint: null,
                        requestHeaders: null
                    }
                ],
                '2': []
            }
        }
    ],
    outcomes: [],
    javascriptEvents: [],
    className: '',
    style: '',
    customFieldTemplates: {},
    metadata: {},
    variables: [],
    customFieldsValueInfo: {},
    gridsterForm: false,
    globalDateFormat: 'D-M-YYYY'
};
const formDefinitionRequiredField = {
    id: 21,
    name: 'dropdownDefinition',
    processDefinitionId: 'textDefinition:2:163',
    processDefinitionName: 'textDefinition',
    processDefinitionKey: 'textDefinition',
    taskId: '169',
    taskDefinitionKey: 'sid-D941F49F-2B04-4FBB-9B49-9E95991993E8',
    tabs: [],
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: '1507046026940',
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                '1': [
                    {
                        fieldType: 'RestFieldRepresentation',
                        id: 'country',
                        name: 'country',
                        type: 'dropdown',
                        value: 'Choose one...',
                        required: true,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: true,
                        options: [
                            {
                                id: 'empty',
                                name: 'Choose one...'
                            },
                            {
                                id: 'option_1',
                                name: 'united kingdom'
                            },
                            {
                                id: 'option_2',
                                name: 'italy'
                            },
                            {
                                id: 'option_3',
                                name: 'france'
                            }
                        ],
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null,
                        endpoint: null,
                        requestHeaders: null
                    }
                ],
                '2': []
            }
        }
    ],
    outcomes: [],
    javascriptEvents: [],
    className: '',
    style: '',
    customFieldTemplates: {},
    metadata: {},
    variables: [],
    customFieldsValueInfo: {},
    gridsterForm: false,
    globalDateFormat: 'D-M-YYYY'
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const formReadonlyTwoTextFields = {
    id: 22,
    name: 'formTextDefinition',
    processDefinitionId: 'textDefinition:3:182',
    processDefinitionName: 'textDefinition',
    processDefinitionKey: 'textDefinition',
    taskId: '188',
    taskDefinitionKey: 'sid-D941F49F-2B04-4FBB-9B49-9E95991993E8',
    tabs: [],
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: '1507044399260',
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                '1': [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'firstname',
                        name: 'firstName',
                        type: 'readonly',
                        value: 'fakeFirstName',
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2,
                            field: {
                                id: 'firstname',
                                name: 'firstName',
                                type: 'text',
                                value: null,
                                required: false,
                                readOnly: false,
                                overrideId: false,
                                colspan: 1,
                                placeholder: null,
                                minLength: 0,
                                maxLength: 0,
                                minValue: null,
                                maxValue: null,
                                regexPattern: null,
                                optionType: null,
                                hasEmptyValue: null,
                                options: null,
                                restUrl: null,
                                restResponsePath: null,
                                restIdProperty: null,
                                restLabelProperty: null,
                                tab: null,
                                className: null,
                                dateDisplayFormat: null,
                                layout: null,
                                sizeX: 0,
                                sizeY: 0,
                                row: 0,
                                col: 0,
                                visibilityCondition: null
                            }
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ],
                '2': [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'lastname',
                        name: 'lastName',
                        type: 'readonly',
                        value: 'fakeLastName',
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 1,
                            field: {
                                id: 'lastname',
                                name: 'lastName',
                                type: 'text',
                                value: null,
                                required: false,
                                readOnly: false,
                                overrideId: false,
                                colspan: 1,
                                placeholder: null,
                                minLength: 0,
                                maxLength: 0,
                                minValue: null,
                                maxValue: null,
                                regexPattern: null,
                                optionType: null,
                                hasEmptyValue: null,
                                options: null,
                                restUrl: null,
                                restResponsePath: null,
                                restIdProperty: null,
                                restLabelProperty: null,
                                tab: null,
                                className: null,
                                dateDisplayFormat: null,
                                layout: null,
                                sizeX: 0,
                                sizeY: 0,
                                row: 0,
                                col: 0,
                                visibilityCondition: null
                            }
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ]
            }
        }
    ],
    outcomes: [],
    javascriptEvents: [],
    className: '',
    style: '',
    customFieldTemplates: {},
    metadata: {},
    variables: [],
    customFieldsValueInfo: {},
    gridsterForm: false,
    globalDateFormat: 'D-M-YYYY'
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const formDefVisibilitiFieldDependsOnNextOne = {
    id: 19,
    processDefinitionId: 'visibility:1:148',
    processDefinitionName: 'visibility',
    processDefinitionKey: 'visibility',
    tabs: [],
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: '1506960847579',
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                '1': [
                    {
                        fieldType: 'RestFieldRepresentation',
                        id: 'country',
                        name: 'country',
                        type: 'dropdown',
                        value: 'Choose one...',
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: true,
                        options: [
                            {
                                id: 'empty',
                                name: 'Choose one...'
                            },
                            {
                                id: 'option_1',
                                name: 'france'
                            },
                            {
                                id: 'option_2',
                                name: 'uk'
                            }
                        ],
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: {
                            leftType: 'field',
                            leftValue: 'name',
                            operator: '==',
                            rightValue: 'italy',
                            rightFormFieldId: '',
                            rightRestResponseId: '',
                            nextConditionOperator: '',
                            nextCondition: null
                        },
                        endpoint: null,
                        requestHeaders: null
                    }
                ],
                '2': [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'name',
                        name: 'name',
                        type: 'text',
                        value: null,
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 1
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ]
            }
        }
    ],
    outcomes: [],
    javascriptEvents: [],
    className: '',
    style: '',
    customFieldTemplates: {},
    metadata: {},
    variables: [],
    customFieldsValueInfo: {},
    gridsterForm: false,
    globalDateFormat: 'D-M-YYYY'
};
const formDefVisibilitiFieldDependsOnPreviousOne = {
    id: 19,
    processDefinitionId: 'visibility:1:148',
    processDefinitionName: 'visibility',
    processDefinitionKey: 'visibility',
    tabs: [],
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: '1506960847579',
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                '1': [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'name',
                        name: 'name',
                        type: 'text',
                        value: null,
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 1
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ],
                '2': [
                    {
                        fieldType: 'RestFieldRepresentation',
                        id: 'country',
                        name: 'country',
                        type: 'dropdown',
                        value: 'Choose one...',
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: true,
                        options: [
                            {
                                id: 'empty',
                                name: 'Choose one...'
                            },
                            {
                                id: 'option_1',
                                name: 'france'
                            },
                            {
                                id: 'option_2',
                                name: 'uk'
                            }
                        ],
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: {
                            leftType: 'field',
                            leftValue: 'name',
                            operator: '==',
                            rightValue: 'italy',
                            rightFormFieldId: '',
                            rightRestResponseId: '',
                            nextConditionOperator: '',
                            nextCondition: null
                        },
                        endpoint: null,
                        requestHeaders: null
                    }
                ]
            }
        }
    ],
    outcomes: [],
    javascriptEvents: [],
    className: '',
    style: '',
    customFieldTemplates: {},
    metadata: {},
    variables: [],
    customFieldsValueInfo: {},
    gridsterForm: false,
    globalDateFormat: 'D-M-YYYY'
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const startFormDateWidgetMock = {
    id: 4,
    name: 'Claim Review Process',
    processDefinitionId: 'ClaimReviewProcess:2: 93',
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: 1497953253784,
            name: 'Label',
            type: 'container',
            value: null,
            readOnly: false,
            fields: {
                1: [{
                        fieldType: 'FormFieldRepresentation',
                        id: 'date',
                        name: 'date',
                        type: 'date',
                        value: null
                    }]
            }
        }
    ]
};
const startFormNumberWidgetMock = {
    id: 4,
    name: 'Claim Review Process',
    processDefinitionId: 'ClaimReviewProcess:2: 93',
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: 1497953253784,
            name: 'Label',
            type: 'container',
            value: null,
            readOnly: false,
            fields: {
                1: [{
                        fieldType: 'FormFieldRepresentation',
                        id: 'number',
                        name: 'number widget',
                        type: 'integer',
                        value: null
                    }]
            }
        }
    ]
};
const startFormAmountWidgetMock = {
    id: 4,
    name: 'Claim Review Process',
    processDefinitionId: 'ClaimReviewProcess:2: 93',
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: 1497953253784,
            name: 'Label',
            type: 'container',
            value: null,
            readOnly: false,
            fields: {
                1: [{
                        fieldType: 'FormFieldRepresentation',
                        id: 'amount',
                        name: 'amount widget',
                        type: 'amount',
                        value: null
                    }]
            }
        }
    ]
};
const startFormRadioButtonWidgetMock = {
    id: 4,
    name: 'Claim Review Process',
    processDefinitionId: 'ClaimReviewProcess:2: 93',
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: 1497953253784,
            name: 'Label',
            type: 'container',
            value: null,
            readOnly: false,
            fields: {
                1: [{
                        fieldType: 'RestFieldRepresentation',
                        id: 'radio-but',
                        name: 'radio-buttons',
                        type: 'radio-buttons',
                        value: null
                    }]
            }
        }
    ]
};
const startFormTextDefinitionMock = {
    id: 4,
    name: 'Claim Review Process',
    processDefinitionId: 'ClaimReviewProcess:2: 93',
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: 1497953253784,
            name: 'Label',
            type: 'container',
            value: null,
            readOnly: false,
            fields: {
                1: [{
                        fieldType: 'FormFieldRepresentation',
                        id: 'mocktext',
                        name: 'mockText',
                        type: 'text',
                        value: null
                    }]
            }
        }
    ]
};
const startFormDropdownDefinitionMock = {
    id: 4,
    name: 'Claim Review Process',
    processDefinitionId: 'ClaimReviewProcess:2: 93',
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: 1497953253784,
            name: 'Label',
            type: 'container',
            value: null,
            readOnly: false,
            fields: {
                1: [{
                        fieldType: 'RestFieldRepresentation',
                        id: 'mockTypeDropDown',
                        name: 'mock DropDown',
                        type: 'dropdown',
                        value: 'Chooseone...',
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        options: [
                            {
                                id: 'empty',
                                name: 'Chooseone...'
                            },
                            {
                                id: 'opt1',
                                name: 'Option-1'
                            },
                            {
                                id: 'opt2',
                                name: 'Option-2'
                            },
                            {
                                id: 'opt3',
                                name: 'Option-3'
                            },
                            {
                                id: 'opt2',
                                name: 'Option-3'
                            }
                        ]
                    }]
            }
        }
    ]
};
const startMockForm = {
    id: 4,
    name: 'Claim Review Process',
    processDefinitionId: 'ClaimReviewProcess:2: 93',
    processDefinitionName: 'ClaimReviewProcess',
    processDefinitionKey: 'ClaimReviewProcess',
    tabs: [],
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: 1497953253784,
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                1: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'clientname',
                        name: 'ClientName',
                        type: 'text',
                        value: null,
                        required: true,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ],
                2: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'policyno',
                        name: 'PolicyNo',
                        type: 'integer',
                        value: null,
                        required: true,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: 'EnterPolicyName',
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 1
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ]
            }
        },
        {
            fieldType: 'ContainerRepresentation',
            id: 1497953270269,
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                1: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'billAmount',
                        name: 'BillAmount',
                        type: 'integer',
                        value: null,
                        required: true,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: 'EnterBillAmount',
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ],
                2: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'billdate',
                        name: 'BillDate',
                        type: 'date',
                        value: null,
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: 'billdate',
                        params: {
                            existingColspan: 1,
                            maxColspan: 1
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ]
            }
        },
        {
            fieldType: 'ContainerRepresentation',
            id: 1497953280930,
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                1: [
                    {
                        fieldType: 'RestFieldRepresentation',
                        id: 'claimtype',
                        name: 'ClaimType',
                        type: 'dropdown',
                        value: 'Chooseone...',
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: true,
                        options: [
                            {
                                id: 'empty',
                                name: 'Chooseone...'
                            },
                            {
                                id: 'cashless',
                                name: 'Cashless'
                            },
                            {
                                id: 'reimbursement',
                                name: 'Reimbursement'
                            }
                        ],
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null,
                        endpoint: null,
                        requestHeaders: null
                    }
                ],
                2: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'hospitalName',
                        name: 'HospitalName',
                        type: 'text',
                        value: null,
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: 'EnterHospitalName',
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 1
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ]
            }
        }
    ],
    outcomes: [
        {
            id: 'approve',
            name: 'Approve'
        },
        {
            id: 'complete',
            name: 'Complete'
        },
        {
            id: 'start_process',
            name: 'Start Process'
        }
    ],
    javascriptEvents: [],
    className: '',
    style: '',
    metadata: {},
    variables: [],
    customFieldsValueInfo: {},
    gridsterForm: false,
    globalDateFormat: 'D - M - YYYY'
};
const startMockFormWithTab = {
    id: 4,
    taskName: 'Mock Title',
    processDefinitionId: 'ClaimReviewProcess:2: 93',
    processDefinitionName: 'ClaimReviewProcess',
    processDefinitionKey: 'ClaimReviewProcess',
    tabs: [
        {
            id: 'form1',
            name: 'Tab 1'
        },
        {
            id: 'form2',
            name: 'Tab 2'
        }
    ],
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: 1497953253784,
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                1: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'clientname',
                        name: 'ClientName',
                        type: 'text',
                        value: null,
                        required: true,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ],
                2: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'policyno',
                        name: 'PolicyNo',
                        type: 'integer',
                        value: null,
                        required: true,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: 'EnterPolicyName',
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 1
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ]
            }
        },
        {
            fieldType: 'ContainerRepresentation',
            id: 1497953270269,
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                1: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'billAmount',
                        name: 'BillAmount',
                        type: 'integer',
                        value: null,
                        required: true,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: 'EnterBillAmount',
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ],
                2: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'billdate',
                        name: 'BillDate',
                        type: 'date',
                        value: null,
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: 'billdate',
                        params: {
                            existingColspan: 1,
                            maxColspan: 1
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ]
            }
        },
        {
            fieldType: 'ContainerRepresentation',
            id: 1497953280930,
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                1: [
                    {
                        fieldType: 'RestFieldRepresentation',
                        id: 'claimtype',
                        name: 'ClaimType',
                        type: 'dropdown',
                        value: 'Chooseone...',
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: true,
                        options: [
                            {
                                id: 'empty',
                                name: 'Chooseone...'
                            },
                            {
                                id: 'cashless',
                                name: 'Cashless'
                            },
                            {
                                id: 'reimbursement',
                                name: 'Reimbursement'
                            }
                        ],
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null,
                        endpoint: null,
                        requestHeaders: null
                    }
                ],
                2: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'hospitalName',
                        name: 'HospitalName',
                        type: 'text',
                        value: null,
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: 'EnterHospitalName',
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 1
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ]
            }
        }
    ],
    outcomes: [
        {
            id: 'approve',
            name: 'Approve'
        },
        {
            id: 'complete',
            name: 'Complete'
        }
    ],
    javascriptEvents: [],
    className: '',
    style: '',
    metadata: {},
    variables: [],
    customFieldsValueInfo: {},
    gridsterForm: false,
    globalDateFormat: 'D - M - YYYY'
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const formModelTabs = {
    formRepresentation: {
        id: 16,
        name: 'start event',
        description: '',
        version: 2,
        lastUpdatedBy: 4,
        lastUpdatedByFullName: 'User Test',
        lastUpdated: '2017-10-04T13:00:03.030+0000',
        stencilSetId: null,
        referenceId: null,
        formDefinition: {
            tabs: [],
            fields: [
                {
                    fieldType: 'ContainerRepresentation',
                    id: '1507037668653',
                    name: 'Label',
                    type: 'container',
                    value: null,
                    required: false,
                    readOnly: false,
                    overrideId: false,
                    colspan: 1,
                    placeholder: null,
                    minLength: 0,
                    maxLength: 0,
                    minValue: null,
                    maxValue: null,
                    regexPattern: null,
                    optionType: null,
                    hasEmptyValue: null,
                    options: null,
                    restUrl: null,
                    restResponsePath: null,
                    restIdProperty: null,
                    restLabelProperty: null,
                    tab: null,
                    className: null,
                    dateDisplayFormat: null,
                    layout: null,
                    sizeX: 2,
                    sizeY: 1,
                    row: -1,
                    col: -1,
                    visibilityCondition: null,
                    numberOfColumns: 2,
                    fields: {
                        '1': [
                            {
                                fieldType: 'AmountFieldRepresentation',
                                id: 'label',
                                name: 'Label',
                                type: 'amount',
                                value: null,
                                required: false,
                                readOnly: false,
                                overrideId: false,
                                colspan: 1,
                                placeholder: null,
                                minLength: 0,
                                maxLength: 0,
                                minValue: null,
                                maxValue: null,
                                regexPattern: null,
                                optionType: null,
                                hasEmptyValue: null,
                                options: null,
                                restUrl: null,
                                restResponsePath: null,
                                restIdProperty: null,
                                restLabelProperty: null,
                                tab: null,
                                className: null,
                                params: {
                                    existingColspan: 1,
                                    maxColspan: 2
                                },
                                dateDisplayFormat: null,
                                layout: {
                                    row: -1,
                                    column: -1,
                                    colspan: 1
                                },
                                sizeX: 1,
                                sizeY: 1,
                                row: -1,
                                col: -1,
                                visibilityCondition: null,
                                enableFractions: false,
                                currency: null
                            }
                        ],
                        '2': [
                            {
                                fieldType: 'FormFieldRepresentation',
                                id: 'label1',
                                name: 'Label1',
                                type: 'date',
                                value: null,
                                required: false,
                                readOnly: false,
                                overrideId: false,
                                colspan: 1,
                                placeholder: null,
                                minLength: 0,
                                maxLength: 0,
                                minValue: null,
                                maxValue: null,
                                regexPattern: null,
                                optionType: null,
                                hasEmptyValue: null,
                                options: null,
                                restUrl: null,
                                restResponsePath: null,
                                restIdProperty: null,
                                restLabelProperty: null,
                                tab: null,
                                className: null,
                                params: {
                                    existingColspan: 1,
                                    maxColspan: 1
                                },
                                dateDisplayFormat: null,
                                layout: {
                                    row: -1,
                                    column: -1,
                                    colspan: 1
                                },
                                sizeX: 1,
                                sizeY: 1,
                                row: -1,
                                col: -1,
                                visibilityCondition: null
                            }
                        ]
                    }
                },
                {
                    fieldType: 'ContainerRepresentation',
                    id: '1507037670167',
                    name: 'Label',
                    type: 'container',
                    value: null,
                    required: false,
                    readOnly: false,
                    overrideId: false,
                    colspan: 1,
                    placeholder: null,
                    minLength: 0,
                    maxLength: 0,
                    minValue: null,
                    maxValue: null,
                    regexPattern: null,
                    optionType: null,
                    hasEmptyValue: null,
                    options: null,
                    restUrl: null,
                    restResponsePath: null,
                    restIdProperty: null,
                    restLabelProperty: null,
                    tab: null,
                    className: null,
                    dateDisplayFormat: null,
                    layout: null,
                    sizeX: 2,
                    sizeY: 1,
                    row: -1,
                    col: -1,
                    visibilityCondition: null,
                    numberOfColumns: 2,
                    fields: {
                        '1': [
                            {
                                fieldType: 'FormFieldRepresentation',
                                id: 'label2',
                                name: 'Label2',
                                type: 'boolean',
                                value: null,
                                required: false,
                                readOnly: false,
                                overrideId: false,
                                colspan: 1,
                                placeholder: null,
                                minLength: 0,
                                maxLength: 0,
                                minValue: null,
                                maxValue: null,
                                regexPattern: null,
                                optionType: null,
                                hasEmptyValue: null,
                                options: null,
                                restUrl: null,
                                restResponsePath: null,
                                restIdProperty: null,
                                restLabelProperty: null,
                                tab: null,
                                className: null,
                                params: {
                                    existingColspan: 1,
                                    maxColspan: 2
                                },
                                dateDisplayFormat: null,
                                layout: {
                                    row: -1,
                                    column: -1,
                                    colspan: 1
                                },
                                sizeX: 1,
                                sizeY: 1,
                                row: -1,
                                col: -1,
                                visibilityCondition: null
                            }
                        ],
                        '2': []
                    }
                }
            ],
            outcomes: [],
            javascriptEvents: [],
            className: '',
            style: '',
            customFieldTemplates: {},
            metadata: {},
            variables: [],
            customFieldsValueInfo: {},
            gridsterForm: false
        }
    }
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let formTest = new FormModel({});
const fakeTaskProcessVariableModels = [
    { id: 'TEST_VAR_1', type: 'string', value: 'test_value_1' },
    { id: 'TEST_VAR_2', type: 'string', value: 'test_value_2' },
    { id: 'TEST_VAR_3', type: 'string', value: 'test_value_3' }
];
const formValues = {
    'test_1': 'value_1',
    'test_2': 'value_2',
    'test_3': 'value_1',
    'test_4': 'dropdown_id',
    'test_5': 'dropdown_label',
    'dropdown': { 'id': 'dropdown_id', 'name': 'dropdown_label' }
};
const fakeFormJson = {
    id: '9999',
    name: 'FORM_VISIBILITY',
    processDefinitionId: 'PROCESS_TEST:  9:  9999',
    processDefinitionName: 'PROCESS_TEST',
    processDefinitionKey: 'PROCESS_TEST',
    taskId: '999',
    taskName: 'TEST',
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: '000000000000000000',
            name: 'Label',
            type: 'container',
            value: null,
            numberOfColumns: 2,
            fields: {
                1: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'FIELD_TEST',
                        name: 'FIELD_TEST',
                        type: 'text',
                        value: 'RIGHT_FORM_FIELD_VALUE',
                        visibilityCondition: null,
                        isVisible: true
                    },
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'FIELD_WITH_CONDITION',
                        name: 'FIELD_WITH_CONDITION',
                        type: 'text',
                        value: 'field_with_condition_value',
                        visibilityCondition: null,
                        isVisible: true
                    },
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'LEFT_FORM_FIELD_ID',
                        name: 'LEFT_FORM_FIELD_NAME',
                        type: 'text',
                        value: 'LEFT_FORM_FIELD_VALUE',
                        visibilityCondition: null,
                        isVisible: true
                    }
                ],
                2: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'RIGHT_FORM_FIELD_ID',
                        name: 'RIGHT_FORM_FIELD_NAME',
                        type: 'text',
                        value: 'RIGHT_FORM_FIELD_VALUE',
                        visibilityCondition: null,
                        isVisible: true
                    }
                ]
            }
        }
    ],
    variables: [
        {
            'id': 'e621e8ff-42a6-499c-8121-33c7c35d8641',
            'name': 'age',
            'type': 'integer',
            'value': 11
        },
        {
            'id': '4f8aa99e-8526-429c-9d99-809978489d96',
            'name': 'name',
            'type': 'string',
            'value': 'abc'
        },
        {
            'id': '0207b649-ff07-4f3a-a589-d10afa507b9b',
            'name': 'dob',
            'type': 'date',
            'value': '2019-05-13'
        }
    ]
};
const fakeFormCheckBoxVisibilityJson = {
    referenceId: '33033',
    name: 'test_condition_form',
    description: '',
    tabs: [],
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: '1623514352532',
            name: 'Label',
            type: 'container',
            value: 'null',
            required: 'false',
            readOnly: 'false',
            overrideId: 'false',
            colspan: '1',
            placeholder: 'null',
            minLength: '0',
            maxLength: '0',
            minValue: 'null',
            maxValue: 'null',
            regexPattern: 'null',
            optionType: 'null',
            hasEmptyValue: 'null',
            options: 'null',
            restUrl: 'null',
            restResponsePath: 'null',
            restIdProperty: 'null',
            restLabelProperty: 'null',
            tab: 'null',
            className: 'null',
            dateDisplayFormat: 'null',
            layout: 'null',
            sizeX: '2',
            sizeY: '1',
            row: '-1',
            col: '-1',
            visibilityCondition: 'null',
            numberOfColumns: '2',
            fields: {
                1: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'a',
                        name: 'A',
                        type: 'boolean',
                        value: 'null',
                        required: 'false',
                        readOnly: 'false',
                        overrideId: 'false',
                        colspan: '1',
                        placeholder: 'null',
                        minLength: '0',
                        maxLength: '0',
                        minValue: 'null',
                        maxValue: 'null',
                        regexPattern: 'null',
                        optionType: 'null',
                        hasEmptyValue: 'null',
                        options: 'null',
                        restUrl: 'null',
                        restResponsePath: 'null',
                        restIdProperty: 'null',
                        restLabelProperty: 'null',
                        tab: 'null',
                        className: 'null',
                        params: {
                            existingColspan: '1',
                            maxColspan: '2'
                        },
                        dateDisplayFormat: 'null',
                        layout: {
                            row: '-1',
                            column: '-1',
                            colspan: '1'
                        },
                        sizeX: '1',
                        sizeY: '1',
                        row: '-1',
                        col: '-1',
                        visibilityCondition: 'null'
                    }
                ],
                2: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'b',
                        name: 'B',
                        type: 'boolean',
                        value: 'null',
                        required: 'false',
                        readOnly: 'false',
                        overrideId: 'false',
                        colspan: '1',
                        placeholder: 'null',
                        minLength: '0',
                        maxLength: '0',
                        minValue: 'null',
                        maxValue: 'null',
                        regexPattern: 'null',
                        optionType: 'null',
                        hasEmptyValue: 'null',
                        options: 'null',
                        restUrl: 'null',
                        restResponsePath: 'null',
                        restIdProperty: 'null',
                        restLabelProperty: 'null',
                        tab: 'null',
                        className: 'null',
                        params: {
                            existingColspan: '1',
                            maxColspan: '1'
                        },
                        dateDisplayFormat: 'null',
                        layout: {
                            row: '-1',
                            column: '-1',
                            colspan: '1'
                        },
                        sizeX: '1',
                        sizeY: '1',
                        row: '-1',
                        col: '-1',
                        visibilityCondition: 'null'
                    }
                ]
            }
        },
        {
            fieldType: 'ContainerRepresentation',
            id: '1623514356352',
            name: 'Label',
            type: 'container',
            value: 'null',
            required: 'false',
            readOnly: 'false',
            overrideId: 'false',
            colspan: '1',
            placeholder: 'null',
            minLength: '0',
            maxLength: '0',
            minValue: 'null',
            maxValue: 'null',
            regexPattern: 'null',
            optionType: 'null',
            hasEmptyValue: 'null',
            options: 'null',
            restUrl: 'null',
            restResponsePath: 'null',
            restIdProperty: 'null',
            restLabelProperty: 'null',
            tab: 'null',
            className: 'null',
            dateDisplayFormat: 'null',
            layout: 'null',
            sizeX: '2',
            sizeY: '1',
            row: '-1',
            col: '-1',
            visibilityCondition: 'null',
            numberOfColumns: '2',
            fields: {
                1: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'c',
                        name: 'C',
                        type: 'boolean',
                        value: 'null',
                        required: 'false',
                        readOnly: 'false',
                        overrideId: 'false',
                        colspan: '1',
                        placeholder: 'null',
                        minLength: '0',
                        maxLength: '0',
                        minValue: 'null',
                        maxValue: 'null',
                        regexPattern: 'null',
                        optionType: 'null',
                        hasEmptyValue: 'null',
                        options: 'null',
                        restUrl: 'null',
                        restResponsePath: 'null',
                        restIdProperty: 'null',
                        restLabelProperty: 'null',
                        tab: 'null',
                        className: 'null',
                        params: {
                            existingColspan: '1',
                            maxColspan: '2'
                        },
                        dateDisplayFormat: 'null',
                        layout: {
                            row: '-1',
                            column: '-1',
                            colspan: '1'
                        },
                        sizeX: '1',
                        sizeY: '1',
                        row: '-1',
                        col: '-1',
                        visibilityCondition: 'null'
                    }
                ],
                2: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'd',
                        name: 'D',
                        type: 'boolean',
                        value: 'null',
                        required: 'false',
                        readOnly: 'false',
                        overrideId: 'false',
                        colspan: '1',
                        placeholder: 'null',
                        minLength: '0',
                        maxLength: '0',
                        minValue: 'null',
                        maxValue: 'null',
                        regexPattern: 'null',
                        optionType: 'null',
                        hasEmptyValue: 'null',
                        options: 'null',
                        restUrl: 'null',
                        restResponsePath: 'null',
                        restIdProperty: 'null',
                        restLabelProperty: 'null',
                        tab: 'null',
                        className: 'null',
                        params: {
                            existingColspan: '1',
                            maxColspan: '1'
                        },
                        dateDisplayFormat: 'null',
                        layout: {
                            row: '-1',
                            column: '-1',
                            colspan: '1'
                        },
                        sizeX: '1',
                        sizeY: '1',
                        row: '-1',
                        col: '-1',
                        visibilityCondition: 'null'
                    }
                ]
            }
        },
        {
            fieldType: 'ContainerRepresentation',
            id: '1623514409166',
            name: 'Label',
            type: 'container',
            value: 'null',
            required: 'false',
            readOnly: 'false',
            overrideId: 'false',
            colspan: '1',
            placeholder: 'null',
            minLength: '0',
            maxLength: '0',
            minValue: 'null',
            maxValue: 'null',
            regexPattern: 'null',
            optionType: 'null',
            hasEmptyValue: 'null',
            options: 'null',
            restUrl: 'null',
            restResponsePath: 'null',
            restIdProperty: 'null',
            restLabelProperty: 'null',
            tab: 'null',
            className: 'null',
            dateDisplayFormat: 'null',
            layout: 'null',
            sizeX: '2',
            sizeY: '1',
            row: '-1',
            col: '-1',
            visibilityCondition: 'null',
            numberOfColumns: '2',
            fields: {
                1: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'a_b_c_d',
                        name: 'Textfield ( A && B || C && D)',
                        type: 'text',
                        value: 'null',
                        required: 'false',
                        readOnly: 'false',
                        overrideId: 'true',
                        colspan: '1',
                        placeholder: 'null',
                        minLength: '0',
                        maxLength: '0',
                        minValue: 'null',
                        maxValue: 'null',
                        regexPattern: 'null',
                        optionType: 'null',
                        hasEmptyValue: 'null',
                        options: 'null',
                        restUrl: 'null',
                        restResponsePath: 'null',
                        restIdProperty: 'null',
                        restLabelProperty: 'null',
                        tab: 'null',
                        className: 'null',
                        params: {
                            existingColspan: '1',
                            maxColspan: '2'
                        },
                        dateDisplayFormat: 'null',
                        layout: {
                            row: '-1',
                            column: '-1',
                            colspan: '1'
                        },
                        sizeX: '1',
                        sizeY: '1',
                        row: '-1',
                        col: '-1',
                        visibilityCondition: {
                            leftFormFieldId: 'a',
                            leftRestResponseId: 'null',
                            operator: '==',
                            rightValue: 'true',
                            rightType: 'null',
                            rightFormFieldId: '',
                            rightRestResponseId: '',
                            nextConditionOperator: 'and',
                            nextCondition: {
                                leftFormFieldId: 'b',
                                leftRestResponseId: 'null',
                                operator: '==',
                                rightValue: 'true',
                                rightType: 'null',
                                rightFormFieldId: '',
                                rightRestResponseId: '',
                                nextConditionOperator: 'or',
                                nextCondition: {
                                    leftFormFieldId: 'c',
                                    leftRestResponseId: 'null',
                                    operator: '==',
                                    rightValue: 'true',
                                    rightType: 'null',
                                    rightFormFieldId: '',
                                    rightRestResponseId: '',
                                    nextConditionOperator: 'and',
                                    nextCondition: {
                                        leftFormFieldId: 'd',
                                        leftRestResponseId: 'null',
                                        operator: '==',
                                        rightValue: 'true',
                                        rightType: 'null',
                                        rightFormFieldId: '',
                                        rightRestResponseId: '',
                                        nextConditionOperator: '',
                                        nextCondition: 'null'
                                    }
                                }
                            }
                        }
                    }
                ],
                2: []
            }
        }
    ],
    outcomes: [],
    javascriptEvents: [],
    className: '',
    style: '',
    customFieldTemplates: {},
    metadata: {},
    variables: [],
    customFieldsValueInfo: {},
    gridsterForm: 'false'
};
const fakeFormChainedVisibilityJson = {
    id: '8800',
    name: 'FORM_VISIBILITYl_CHAIN',
    processDefinitionId: 'PROCESS_TEST:  9:  9999',
    processDefinitionName: 'PROCESS_TEST',
    processDefinitionKey: 'PROCESS_TEST',
    taskId: '999',
    taskName: 'TEST',
    fields: [
        {
            fieldType: 'ContainerRepresentation',
            id: '1615506402205',
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                1: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'installments',
                        name: 'Installments',
                        type: 'integer',
                        value: null,
                        required: true,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null
                    }
                ],
                2: [
                    {
                        fieldType: 'RestFieldRepresentation',
                        id: 'schedule',
                        name: 'Schedule',
                        type: 'dropdown',
                        value: 'Choose one...',
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: true,
                        options: [
                            {
                                id: 'empty',
                                name: 'Choose one...'
                            },
                            {
                                id: 'ANNUAL',
                                name: 'Annual'
                            },
                            {
                                id: 'QUARTERLY',
                                name: 'Quarterly'
                            },
                            {
                                id: 'MONTHLY',
                                name: 'Monthly'
                            }
                        ],
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 1
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: null,
                        endpoint: null,
                        requestHeaders: null
                    }
                ]
            }
        },
        {
            fieldType: 'ContainerRepresentation',
            id: 1615506384790,
            name: 'Label',
            type: 'container',
            value: null,
            required: false,
            readOnly: false,
            overrideId: false,
            colspan: 1,
            placeholder: null,
            minLength: 0,
            maxLength: 0,
            minValue: null,
            maxValue: null,
            regexPattern: null,
            optionType: null,
            hasEmptyValue: null,
            options: null,
            restUrl: null,
            restResponsePath: null,
            restIdProperty: null,
            restLabelProperty: null,
            tab: null,
            className: null,
            dateDisplayFormat: null,
            layout: null,
            sizeX: 2,
            sizeY: 1,
            row: -1,
            col: -1,
            visibilityCondition: null,
            numberOfColumns: 2,
            fields: {
                1: [
                    {
                        fieldType: 'FormFieldRepresentation',
                        id: 'showtext',
                        name: 'Show text',
                        type: 'readonly-text',
                        value: 'This test is shown when the visibility logic is displayed.\nThis should only show under the following conditions:\nAnnual and installment > 5\nQuarterly and installment > 20\nMonthly and installment > 60',
                        required: false,
                        readOnly: false,
                        overrideId: false,
                        colspan: 1,
                        placeholder: null,
                        minLength: 0,
                        maxLength: 0,
                        minValue: null,
                        maxValue: null,
                        regexPattern: null,
                        optionType: null,
                        hasEmptyValue: null,
                        options: null,
                        restUrl: null,
                        restResponsePath: null,
                        restIdProperty: null,
                        restLabelProperty: null,
                        tab: null,
                        className: null,
                        params: {
                            existingColspan: 1,
                            maxColspan: 2
                        },
                        dateDisplayFormat: null,
                        layout: {
                            row: -1,
                            column: -1,
                            colspan: 1
                        },
                        sizeX: 1,
                        sizeY: 1,
                        row: -1,
                        col: -1,
                        visibilityCondition: {
                            leftFormFieldId: 'schedule',
                            leftRestResponseId: null,
                            operator: '==',
                            rightValue: 'ANNUAL',
                            rightType: null,
                            rightFormFieldId: '',
                            rightRestResponseId: '',
                            nextConditionOperator: 'and',
                            nextCondition: {
                                leftFormFieldId: 'installments',
                                leftRestResponseId: null,
                                operator: '>',
                                rightValue: 5,
                                rightType: null,
                                rightFormFieldId: '',
                                rightRestResponseId: '',
                                nextConditionOperator: 'or',
                                nextCondition: {
                                    leftFormFieldId: 'schedule',
                                    leftRestResponseId: null,
                                    operator: '==',
                                    rightValue: 'QUARTERLY',
                                    rightType: null,
                                    rightFormFieldId: '',
                                    rightRestResponseId: '',
                                    nextConditionOperator: 'and',
                                    nextCondition: {
                                        leftFormFieldId: 'installments',
                                        leftRestResponseId: null,
                                        operator: '>',
                                        rightValue: 20,
                                        rightType: null,
                                        rightFormFieldId: '',
                                        rightRestResponseId: '',
                                        nextConditionOperator: 'or',
                                        nextCondition: {
                                            leftFormFieldId: 'schedule',
                                            leftRestResponseId: null,
                                            operator: '==',
                                            rightValue: 'MONTHLY',
                                            rightType: null,
                                            rightFormFieldId: '',
                                            rightRestResponseId: '',
                                            nextConditionOperator: 'and',
                                            nextCondition: {
                                                leftFormFieldId: 'installments',
                                                leftRestResponseId: null,
                                                operator: '>',
                                                rightValue: 60,
                                                rightType: null,
                                                rightFormFieldId: '',
                                                rightRestResponseId: '',
                                                nextConditionOperator: '',
                                                nextCondition: null
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                ],
                2: []
            }
        }
    ],
    variables: [
        {
            'id': 'e621e8ff-42a6-499c-8121-33c7c35d8641',
            'name': 'age',
            'type': 'integer',
            'value': 11
        },
        {
            'id': '4f8aa99e-8526-429c-9d99-809978489d96',
            'name': 'name',
            'type': 'string',
            'value': 'abc'
        },
        {
            'id': '0207b649-ff07-4f3a-a589-d10afa507b9b',
            'name': 'dob',
            'type': 'date',
            'value': '2019-05-13'
        }
    ]
};
const complexVisibilityJsonVisible = {
    'id': 47591,
    'name': 'Test-visibility',
    'description': '',
    'version': 4,
    'lastUpdatedBy': 13,
    'lastUpdatedByFullName': 'romano romano',
    'lastUpdated': '2019-06-11T11:  04:  36.870+0000',
    'stencilSetId': 0,
    'referenceId': null,
    'formDefinition': {
        'tabs': [],
        'fields': [{
                'fieldType': 'ContainerRepresentation',
                'id': '1560246123312',
                'name': 'Label',
                'type': 'container',
                'value': null,
                'required': false,
                'readOnly': false,
                'overrideId': false,
                'colspan': 1,
                'placeholder': null,
                'minLength': 0,
                'maxLength': 0,
                'minValue': null,
                'maxValue': null,
                'regexPattern': null,
                'optionType': null,
                'hasEmptyValue': null,
                'options': null,
                'restUrl': null,
                'restResponsePath': null,
                'restIdProperty': null,
                'restLabelProperty': null,
                'tab': null,
                'className': null,
                'dateDisplayFormat': null,
                'layout': null,
                'sizeX': 2,
                'sizeY': 1,
                'row': -1,
                'col': -1,
                'visibilityCondition': null,
                'numberOfColumns': 2,
                'fields': {
                    '1': [{
                            'fieldType': 'FormFieldRepresentation',
                            'id': 'label',
                            'name': 'Label',
                            'type': 'text',
                            'value': null,
                            'required': false,
                            'readOnly': false,
                            'overrideId': false,
                            'colspan': 1,
                            'placeholder': null,
                            'minLength': 0,
                            'maxLength': 0,
                            'minValue': null,
                            'maxValue': null,
                            'regexPattern': null,
                            'optionType': null,
                            'hasEmptyValue': null,
                            'options': null,
                            'restUrl': null,
                            'restResponsePath': null,
                            'restIdProperty': null,
                            'restLabelProperty': null,
                            'tab': null,
                            'className': null,
                            'params': { 'existingColspan': 1, 'maxColspan': 2 },
                            'dateDisplayFormat': null,
                            'layout': { 'row': -1, 'column': -1, 'colspan': 1 },
                            'sizeX': 1,
                            'sizeY': 1,
                            'row': -1,
                            'col': -1,
                            'visibilityCondition': null
                        }],
                    '2': [{
                            'fieldType': 'FormFieldRepresentation',
                            'id': 'label1',
                            'name': 'Label1',
                            'type': 'text',
                            'value': null,
                            'required': false,
                            'readOnly': false,
                            'overrideId': false,
                            'colspan': 1,
                            'placeholder': null,
                            'minLength': 0,
                            'maxLength': 0,
                            'minValue': null,
                            'maxValue': null,
                            'regexPattern': null,
                            'optionType': null,
                            'hasEmptyValue': null,
                            'options': null,
                            'restUrl': null,
                            'restResponsePath': null,
                            'restIdProperty': null,
                            'restLabelProperty': null,
                            'tab': null,
                            'className': null,
                            'params': { 'existingColspan': 1, 'maxColspan': 1 },
                            'dateDisplayFormat': null,
                            'layout': { 'row': -1, 'column': -1, 'colspan': 1 },
                            'sizeX': 1,
                            'sizeY': 1,
                            'row': -1,
                            'col': -1,
                            'visibilityCondition': null
                        }]
                }
            }, {
                'fieldType': 'ContainerRepresentation',
                'id': '1560246128696',
                'name': 'Label',
                'type': 'container',
                'value': null,
                'required': false,
                'readOnly': false,
                'overrideId': false,
                'colspan': 1,
                'placeholder': null,
                'minLength': 0,
                'maxLength': 0,
                'minValue': null,
                'maxValue': null,
                'regexPattern': null,
                'optionType': null,
                'hasEmptyValue': null,
                'options': null,
                'restUrl': null,
                'restResponsePath': null,
                'restIdProperty': null,
                'restLabelProperty': null,
                'tab': null,
                'className': null,
                'dateDisplayFormat': null,
                'layout': null,
                'sizeX': 2,
                'sizeY': 1,
                'row': -1,
                'col': -1,
                'visibilityCondition': null,
                'numberOfColumns': 2,
                'fields': {
                    '1': [{
                            'fieldType': 'FormFieldRepresentation',
                            'id': 'label4',
                            'name': 'Label4',
                            'type': 'text',
                            'value': null,
                            'required': false,
                            'readOnly': false,
                            'overrideId': false,
                            'colspan': 1,
                            'placeholder': null,
                            'minLength': 0,
                            'maxLength': 0,
                            'minValue': null,
                            'maxValue': null,
                            'regexPattern': null,
                            'optionType': null,
                            'hasEmptyValue': null,
                            'options': null,
                            'restUrl': null,
                            'restResponsePath': null,
                            'restIdProperty': null,
                            'restLabelProperty': null,
                            'tab': null,
                            'className': null,
                            'params': { 'existingColspan': 1, 'maxColspan': 2 },
                            'dateDisplayFormat': null,
                            'layout': { 'row': -1, 'column': -1, 'colspan': 1 },
                            'sizeX': 1,
                            'sizeY': 1,
                            'row': -1,
                            'col': -1,
                            'visibilityCondition': null
                        }],
                    '2': [{
                            'fieldType': 'FormFieldRepresentation',
                            'id': 'label3',
                            'name': 'Label3',
                            'type': 'text',
                            'value': '',
                            'required': false,
                            'readOnly': false,
                            'overrideId': false,
                            'colspan': 1,
                            'placeholder': null,
                            'minLength': 0,
                            'maxLength': 0,
                            'minValue': null,
                            'maxValue': null,
                            'regexPattern': null,
                            'optionType': null,
                            'hasEmptyValue': null,
                            'options': null,
                            'restUrl': null,
                            'restResponsePath': null,
                            'restIdProperty': null,
                            'restLabelProperty': null,
                            'tab': null,
                            'className': null,
                            'params': { 'existingColspan': 1, 'maxColspan': 1 },
                            'dateDisplayFormat': null,
                            'layout': { 'row': -1, 'column': -1, 'colspan': 1 },
                            'sizeX': 1,
                            'sizeY': 1,
                            'row': -1,
                            'col': -1,
                            'visibilityCondition': null
                        }]
                }
            }, {
                'fieldType': 'ContainerRepresentation',
                'id': '1560246126964',
                'name': 'Label',
                'type': 'container',
                'value': null,
                'required': false,
                'readOnly': false,
                'overrideId': false,
                'colspan': 1,
                'placeholder': null,
                'minLength': 0,
                'maxLength': 0,
                'minValue': null,
                'maxValue': null,
                'regexPattern': null,
                'optionType': null,
                'hasEmptyValue': null,
                'options': null,
                'restUrl': null,
                'restResponsePath': null,
                'restIdProperty': null,
                'restLabelProperty': null,
                'tab': null,
                'className': null,
                'dateDisplayFormat': null,
                'layout': null,
                'sizeX': 2,
                'sizeY': 1,
                'row': -1,
                'col': -1,
                'visibilityCondition': null,
                'numberOfColumns': 2,
                'fields': {
                    '1': [{
                            'fieldType': 'FormFieldRepresentation',
                            'id': 'label2',
                            'name': 'Label2',
                            'type': 'text',
                            'value': null,
                            'required': false,
                            'readOnly': false,
                            'overrideId': false,
                            'colspan': 1,
                            'placeholder': null,
                            'minLength': 0,
                            'maxLength': 0,
                            'minValue': null,
                            'maxValue': null,
                            'regexPattern': null,
                            'optionType': null,
                            'hasEmptyValue': null,
                            'options': null,
                            'restUrl': null,
                            'restResponsePath': null,
                            'restIdProperty': null,
                            'restLabelProperty': null,
                            'tab': null,
                            'className': null,
                            'params': { 'existingColspan': 1, 'maxColspan': 2 },
                            'dateDisplayFormat': null,
                            'layout': { 'row': -1, 'column': -1, 'colspan': 1 },
                            'sizeX': 1,
                            'sizeY': 1,
                            'row': -1,
                            'col': -1,
                            'visibilityCondition': null
                        }],
                    '2': [{
                            'fieldType': 'FormFieldRepresentation',
                            'id': 'label5',
                            'name': 'Label5',
                            'type': 'boolean',
                            'value': null,
                            'required': false,
                            'readOnly': false,
                            'overrideId': false,
                            'colspan': 1,
                            'placeholder': null,
                            'minLength': 0,
                            'maxLength': 0,
                            'minValue': null,
                            'maxValue': null,
                            'regexPattern': null,
                            'optionType': null,
                            'hasEmptyValue': null,
                            'options': null,
                            'restUrl': null,
                            'restResponsePath': null,
                            'restIdProperty': null,
                            'restLabelProperty': null,
                            'tab': null,
                            'className': null,
                            'params': { 'existingColspan': 1, 'maxColspan': 1 },
                            'dateDisplayFormat': null,
                            'layout': { 'row': -1, 'column': -1, 'colspan': 1 },
                            'sizeX': 1,
                            'sizeY': 1,
                            'row': -1,
                            'col': -1,
                            'visibilityCondition': {
                                'leftFormFieldId': 'label',
                                'leftRestResponseId': null,
                                'operator': '==',
                                'rightValue': 'aaa',
                                'rightType': null,
                                'rightFormFieldId': '',
                                'rightRestResponseId': '',
                                'nextConditionOperator': 'and',
                                'nextCondition': {
                                    'leftFormFieldId': 'label1',
                                    'leftRestResponseId': null,
                                    'operator': '!=',
                                    'rightValue': 'aaa',
                                    'rightType': null,
                                    'rightFormFieldId': '',
                                    'rightRestResponseId': '',
                                    'nextConditionOperator': 'and',
                                    'nextCondition': {
                                        'leftFormFieldId': 'label2',
                                        'leftRestResponseId': null,
                                        'operator': '!empty',
                                        'rightValue': null,
                                        'rightType': null,
                                        'rightFormFieldId': '',
                                        'rightRestResponseId': '',
                                        'nextConditionOperator': 'or',
                                        'nextCondition': {
                                            'leftFormFieldId': 'label3',
                                            'leftRestResponseId': null,
                                            'operator': 'empty',
                                            'rightValue': null,
                                            'rightType': null,
                                            'rightFormFieldId': '',
                                            'rightRestResponseId': '',
                                            'nextConditionOperator': null,
                                            'nextCondition': null
                                        }
                                    }
                                }
                            }
                        }]
                }
            }],
        'outcomes': [],
        'javascriptEvents': [],
        'className': '',
        'style': '',
        'customFieldTemplates': {},
        'metadata': {},
        'variables': [],
        'customFieldsValueInfo': {},
        'gridsterForm': false
    }
};
const complexVisibilityJsonNotVisible = {
    'id': 47591,
    'name': 'Test-visibility',
    'description': '',
    'version': 4,
    'lastUpdatedBy': 13,
    'lastUpdatedByFullName': 'romano romano',
    'lastUpdated': '2019-06-11T11:  04:  36.870+0000',
    'stencilSetId': 0,
    'referenceId': null,
    'formDefinition': {
        'tabs': [],
        'fields': [{
                'fieldType': 'ContainerRepresentation',
                'id': '1560246123312',
                'name': 'Label',
                'type': 'container',
                'value': null,
                'required': false,
                'readOnly': false,
                'overrideId': false,
                'colspan': 1,
                'placeholder': null,
                'minLength': 0,
                'maxLength': 0,
                'minValue': null,
                'maxValue': null,
                'regexPattern': null,
                'optionType': null,
                'hasEmptyValue': null,
                'options': null,
                'restUrl': null,
                'restResponsePath': null,
                'restIdProperty': null,
                'restLabelProperty': null,
                'tab': null,
                'className': null,
                'dateDisplayFormat': null,
                'layout': null,
                'sizeX': 2,
                'sizeY': 1,
                'row': -1,
                'col': -1,
                'visibilityCondition': null,
                'numberOfColumns': 2,
                'fields': {
                    '1': [{
                            'fieldType': 'FormFieldRepresentation',
                            'id': 'label',
                            'name': 'Label',
                            'type': 'text',
                            'value': null,
                            'required': false,
                            'readOnly': false,
                            'overrideId': false,
                            'colspan': 1,
                            'placeholder': null,
                            'minLength': 0,
                            'maxLength': 0,
                            'minValue': null,
                            'maxValue': null,
                            'regexPattern': null,
                            'optionType': null,
                            'hasEmptyValue': null,
                            'options': null,
                            'restUrl': null,
                            'restResponsePath': null,
                            'restIdProperty': null,
                            'restLabelProperty': null,
                            'tab': null,
                            'className': null,
                            'params': { 'existingColspan': 1, 'maxColspan': 2 },
                            'dateDisplayFormat': null,
                            'layout': { 'row': -1, 'column': -1, 'colspan': 1 },
                            'sizeX': 1,
                            'sizeY': 1,
                            'row': -1,
                            'col': -1,
                            'visibilityCondition': null
                        }],
                    '2': [{
                            'fieldType': 'FormFieldRepresentation',
                            'id': 'label1',
                            'name': 'Label1',
                            'type': 'text',
                            'value': null,
                            'required': false,
                            'readOnly': false,
                            'overrideId': false,
                            'colspan': 1,
                            'placeholder': null,
                            'minLength': 0,
                            'maxLength': 0,
                            'minValue': null,
                            'maxValue': null,
                            'regexPattern': null,
                            'optionType': null,
                            'hasEmptyValue': null,
                            'options': null,
                            'restUrl': null,
                            'restResponsePath': null,
                            'restIdProperty': null,
                            'restLabelProperty': null,
                            'tab': null,
                            'className': null,
                            'params': { 'existingColspan': 1, 'maxColspan': 1 },
                            'dateDisplayFormat': null,
                            'layout': { 'row': -1, 'column': -1, 'colspan': 1 },
                            'sizeX': 1,
                            'sizeY': 1,
                            'row': -1,
                            'col': -1,
                            'visibilityCondition': null
                        }]
                }
            }, {
                'fieldType': 'ContainerRepresentation',
                'id': '1560246128696',
                'name': 'Label',
                'type': 'container',
                'value': null,
                'required': false,
                'readOnly': false,
                'overrideId': false,
                'colspan': 1,
                'placeholder': null,
                'minLength': 0,
                'maxLength': 0,
                'minValue': null,
                'maxValue': null,
                'regexPattern': null,
                'optionType': null,
                'hasEmptyValue': null,
                'options': null,
                'restUrl': null,
                'restResponsePath': null,
                'restIdProperty': null,
                'restLabelProperty': null,
                'tab': null,
                'className': null,
                'dateDisplayFormat': null,
                'layout': null,
                'sizeX': 2,
                'sizeY': 1,
                'row': -1,
                'col': -1,
                'visibilityCondition': null,
                'numberOfColumns': 2,
                'fields': {
                    '1': [{
                            'fieldType': 'FormFieldRepresentation',
                            'id': 'label4',
                            'name': 'Label4',
                            'type': 'text',
                            'value': null,
                            'required': false,
                            'readOnly': false,
                            'overrideId': false,
                            'colspan': 1,
                            'placeholder': null,
                            'minLength': 0,
                            'maxLength': 0,
                            'minValue': null,
                            'maxValue': null,
                            'regexPattern': null,
                            'optionType': null,
                            'hasEmptyValue': null,
                            'options': null,
                            'restUrl': null,
                            'restResponsePath': null,
                            'restIdProperty': null,
                            'restLabelProperty': null,
                            'tab': null,
                            'className': null,
                            'params': { 'existingColspan': 1, 'maxColspan': 2 },
                            'dateDisplayFormat': null,
                            'layout': { 'row': -1, 'column': -1, 'colspan': 1 },
                            'sizeX': 1,
                            'sizeY': 1,
                            'row': -1,
                            'col': -1,
                            'visibilityCondition': null
                        }],
                    '2': [{
                            'fieldType': 'FormFieldRepresentation',
                            'id': 'label3',
                            'name': 'Label3',
                            'type': 'text',
                            'value': 'OPSSS',
                            'required': false,
                            'readOnly': false,
                            'overrideId': false,
                            'colspan': 1,
                            'placeholder': null,
                            'minLength': 0,
                            'maxLength': 0,
                            'minValue': null,
                            'maxValue': null,
                            'regexPattern': null,
                            'optionType': null,
                            'hasEmptyValue': null,
                            'options': null,
                            'restUrl': null,
                            'restResponsePath': null,
                            'restIdProperty': null,
                            'restLabelProperty': null,
                            'tab': null,
                            'className': null,
                            'params': { 'existingColspan': 1, 'maxColspan': 1 },
                            'dateDisplayFormat': null,
                            'layout': { 'row': -1, 'column': -1, 'colspan': 1 },
                            'sizeX': 1,
                            'sizeY': 1,
                            'row': -1,
                            'col': -1,
                            'visibilityCondition': null
                        }]
                }
            }, {
                'fieldType': 'ContainerRepresentation',
                'id': '1560246126964',
                'name': 'Label',
                'type': 'container',
                'value': null,
                'required': false,
                'readOnly': false,
                'overrideId': false,
                'colspan': 1,
                'placeholder': null,
                'minLength': 0,
                'maxLength': 0,
                'minValue': null,
                'maxValue': null,
                'regexPattern': null,
                'optionType': null,
                'hasEmptyValue': null,
                'options': null,
                'restUrl': null,
                'restResponsePath': null,
                'restIdProperty': null,
                'restLabelProperty': null,
                'tab': null,
                'className': null,
                'dateDisplayFormat': null,
                'layout': null,
                'sizeX': 2,
                'sizeY': 1,
                'row': -1,
                'col': -1,
                'visibilityCondition': null,
                'numberOfColumns': 2,
                'fields': {
                    '1': [{
                            'fieldType': 'FormFieldRepresentation',
                            'id': 'label2',
                            'name': 'Label2',
                            'type': 'text',
                            'value': null,
                            'required': false,
                            'readOnly': false,
                            'overrideId': false,
                            'colspan': 1,
                            'placeholder': null,
                            'minLength': 0,
                            'maxLength': 0,
                            'minValue': null,
                            'maxValue': null,
                            'regexPattern': null,
                            'optionType': null,
                            'hasEmptyValue': null,
                            'options': null,
                            'restUrl': null,
                            'restResponsePath': null,
                            'restIdProperty': null,
                            'restLabelProperty': null,
                            'tab': null,
                            'className': null,
                            'params': { 'existingColspan': 1, 'maxColspan': 2 },
                            'dateDisplayFormat': null,
                            'layout': { 'row': -1, 'column': -1, 'colspan': 1 },
                            'sizeX': 1,
                            'sizeY': 1,
                            'row': -1,
                            'col': -1,
                            'visibilityCondition': null
                        }],
                    '2': [{
                            'fieldType': 'FormFieldRepresentation',
                            'id': 'label5',
                            'name': 'Label5',
                            'type': 'boolean',
                            'value': null,
                            'required': false,
                            'readOnly': false,
                            'overrideId': false,
                            'colspan': 1,
                            'placeholder': null,
                            'minLength': 0,
                            'maxLength': 0,
                            'minValue': null,
                            'maxValue': null,
                            'regexPattern': null,
                            'optionType': null,
                            'hasEmptyValue': null,
                            'options': null,
                            'restUrl': null,
                            'restResponsePath': null,
                            'restIdProperty': null,
                            'restLabelProperty': null,
                            'tab': null,
                            'className': null,
                            'params': { 'existingColspan': 1, 'maxColspan': 1 },
                            'dateDisplayFormat': null,
                            'layout': { 'row': -1, 'column': -1, 'colspan': 1 },
                            'sizeX': 1,
                            'sizeY': 1,
                            'row': -1,
                            'col': -1,
                            'visibilityCondition': {
                                'leftFormFieldId': 'label',
                                'leftRestResponseId': null,
                                'operator': '==',
                                'rightValue': 'aaa',
                                'rightFormFieldId': '',
                                'rightRestResponseId': '',
                                'nextConditionOperator': 'and',
                                'nextCondition': {
                                    'leftFormFieldId': 'label1',
                                    'leftRestResponseId': null,
                                    'operator': '!=',
                                    'rightValue': 'aaa',
                                    'rightFormFieldId': '',
                                    'rightRestResponseId': '',
                                    'nextConditionOperator': 'and',
                                    'nextCondition': {
                                        'leftFormFieldId': 'label2',
                                        'leftRestResponseId': null,
                                        'operator': '!empty',
                                        'rightValue': null,
                                        'rightFormFieldId': '',
                                        'rightRestResponseId': '',
                                        'nextConditionOperator': 'or',
                                        'nextCondition': {
                                            'leftFormFieldId': 'label3',
                                            'leftRestResponseId': null,
                                            'operator': 'empty',
                                            'rightValue': null,
                                            'rightFormFieldId': '',
                                            'rightRestResponseId': '',
                                            'nextConditionOperator': null,
                                            'nextCondition': null
                                        }
                                    }
                                }
                            }
                        }]
                }
            }],
        'outcomes': [],
        'javascriptEvents': [],
        'className': '',
        'style': '',
        'customFieldTemplates': {},
        'metadata': {},
        'variables': [],
        'customFieldsValueInfo': {},
        'gridsterForm': false
    }
};
const tabVisibilityJsonMock = {
    'id': 45231,
    'name': 'visibility-form',
    'description': '',
    'version': 2,
    'lastUpdatedBy': 4255,
    'lastUpdatedByFullName': 'first last',
    'lastUpdated': '2019-08-26T08: 04: 02.091+0000',
    'stencilSetId': null,
    'referenceId': null,
    'tabs': [
        {
            'id': 'tab1',
            'title': 'tab1',
            'visibilityCondition': null
        },
        {
            'id': 'tab2',
            'title': 'Tab2',
            'visibilityCondition': {
                'leftFormFieldId': 'label',
                'leftRestResponseId': null,
                'operator': '==',
                'rightValue': 'text',
                'rightType': null,
                'rightFormFieldId': '',
                'rightRestResponseId': '',
                'nextConditionOperator': '',
                'nextCondition': null
            }
        }
    ],
    'formDefinition': {
        'fields': [
            {
                'fieldType': 'ContainerRepresentation',
                'id': '1566806229182',
                'name': 'Label',
                'type': 'container',
                'value': null,
                'required': false,
                'readOnly': false,
                'overrideId': false,
                'colspan': 1,
                'placeholder': null,
                'minLength': 0,
                'maxLength': 0,
                'minValue': null,
                'maxValue': null,
                'regexPattern': null,
                'optionType': null,
                'hasEmptyValue': null,
                'options': null,
                'restUrl': null,
                'restResponsePath': null,
                'restIdProperty': null,
                'restLabelProperty': null,
                'tab': 'tab1',
                'className': null,
                'dateDisplayFormat': null,
                'layout': null,
                'sizeX': 2,
                'sizeY': 1,
                'row': -1,
                'col': -1,
                'visibilityCondition': null,
                'numberOfColumns': 2,
                'fields': {
                    '1': [
                        {
                            'fieldType': 'FormFieldRepresentation',
                            'id': 'label',
                            'name': 'Label',
                            'type': 'text',
                            'value': null,
                            'required': false,
                            'readOnly': false,
                            'overrideId': false,
                            'colspan': 1,
                            'placeholder': null,
                            'minLength': 0,
                            'maxLength': 0,
                            'minValue': null,
                            'maxValue': null,
                            'regexPattern': null,
                            'optionType': null,
                            'hasEmptyValue': null,
                            'options': null,
                            'restUrl': null,
                            'restResponsePath': null,
                            'restIdProperty': null,
                            'restLabelProperty': null,
                            'tab': 'tab1',
                            'className': null,
                            'params': {
                                'existingColspan': 1,
                                'maxColspan': 2
                            },
                            'dateDisplayFormat': null,
                            'layout': {
                                'row': -1,
                                'column': -1,
                                'colspan': 1
                            },
                            'sizeX': 1,
                            'sizeY': 1,
                            'row': -1,
                            'col': -1,
                            'visibilityCondition': null
                        }
                    ],
                    '2': []
                }
            }
        ],
        'outcomes': [],
        'javascriptEvents': [],
        'className': '',
        'style': '',
        'customFieldTemplates': {},
        'metadata': {},
        'variables': [],
        'customFieldsValueInfo': {},
        'gridsterForm': false
    }
};
const tabInvalidFormVisibility = {
    'id': 'form-0668939d-34b2-440c-ab4d-01ab8b05a881',
    'name': 'tab-visibility',
    'description': '',
    'version': 0,
    'standalone': true,
    'tabs': [
        {
            'id': 'a8a4718d-5019-4852-9645-bba9b8253d86',
            'title': 'tab1',
            'visibilityCondition': {
                'leftType': 'field',
                'leftValue': 'Text1',
                'operator': '==',
                'rightValue': 'showtab',
                'rightType': 'value',
                'nextConditionOperator': '',
                'nextCondition': null
            }
        },
        {
            'id': 'bb9033ca-55ef-432a-8120-bffc8a179ebb',
            'title': 'tab2',
            'visibilityCondition': null
        }
    ],
    'formDefinition': {
        'fields': [
            {
                'id': '093270a5-6e28-4cf0-a72a-09731c0d59fd',
                'name': 'Label',
                'type': 'container',
                'tab': 'a8a4718d-5019-4852-9645-bba9b8253d86',
                'numberOfColumns': 2,
                'fields': {
                    '1': [
                        {
                            'id': 'Number1',
                            'name': 'Number1',
                            'type': 'integer',
                            'colspan': 1,
                            'placeholder': null,
                            'minValue': null,
                            'maxValue': null,
                            'required': false,
                            'visibilityCondition': null,
                            'params': {
                                'existingColspan': 1,
                                'maxColspan': 2
                            }
                        },
                        {
                            'id': 'Number2',
                            'name': 'Number2',
                            'type': 'integer',
                            'colspan': 1,
                            'placeholder': null,
                            'minValue': null,
                            'maxValue': null,
                            'required': false,
                            'visibilityCondition': {
                                'leftType': 'field',
                                'leftValue': 'Text2',
                                'operator': '==',
                                'rightValue': 'shownumber',
                                'rightType': 'value',
                                'nextConditionOperator': '',
                                'nextCondition': null
                            },
                            'params': {
                                'existingColspan': 1,
                                'maxColspan': 2
                            }
                        }
                    ],
                    '2': [
                        {
                            'id': 'Text2',
                            'name': 'Text2',
                            'type': 'text',
                            'required': false,
                            'colspan': 1,
                            'placeholder': null,
                            'minLength': 0,
                            'maxLength': 0,
                            'regexPattern': null,
                            'visibilityCondition': null,
                            'params': {
                                'existingColspan': 1,
                                'maxColspan': 2
                            }
                        }
                    ]
                }
            },
            {
                'id': 'c33579eb-3514-42cc-832d-2998d06a3eab',
                'name': 'Label',
                'type': 'container',
                'tab': 'bb9033ca-55ef-432a-8120-bffc8a179ebb',
                'numberOfColumns': 2,
                'fields': {
                    '1': [
                        {
                            'id': 'Text1',
                            'name': 'Text1',
                            'type': 'text',
                            'required': false,
                            'colspan': 1,
                            'placeholder': null,
                            'minLength': 0,
                            'maxLength': 0,
                            'regexPattern': null,
                            'visibilityCondition': null,
                            'params': {
                                'existingColspan': 1,
                                'maxColspan': 2
                            }
                        }
                    ],
                    '2': []
                }
            }
        ],
        'outcomes': [],
        'metadata': {},
        'variables': []
    }
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let mockToken = 'eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ' +
    'zdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiZmFtaWx5X25hbWUiOiJEb2UiLCJnaXZ' +
    'lbl9uYW1lIjoiSm9obiIsImFkbWluIjp0cnVlLCJlbWFpbCI6ImpvaG5Eb2VAZ21haWwuY29tIiwicHJ' +
    'lZmVycmVkX3VzZXJuYW1lIjoiam9obkRvZTEiLCJqdGkiOiI2MmQ3YjA4NS1hNTJjLTRjZmEtYjA2Zi1' +
    'hODFhN2IwNjRjZDIiLCJpYXQiOjE1NDM0MTA0NzcsImV4cCI6MTU0MzQxNTIxM30.pSP86kmX3keuU5E3ndaOUq2TzKdJRsuMnBdFz3Y-UEU';

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const mockIdentityGroup1 = {
    id: 'mock-group-id-1', name: 'Mock Group 1', path: '/mock', subGroups: []
};
const mockIdentityGroup2 = {
    id: 'mock-group-id-2', name: 'Mock Group 2', path: '', subGroups: []
};
const mockIdentityGroup3 = {
    id: 'mock-group-id-3', name: 'Mock Group 3', path: '', subGroups: []
};
const mockIdentityGroup4 = {
    id: 'mock-group-id-4', name: 'Mock Group 4', path: '', subGroups: []
};
const mockIdentityGroup5 = {
    id: 'mock-group-id-5', name: 'Mock Group 5', path: '', subGroups: []
};
const mockIdentityGroupsCount = { count: 10 };
const mockIdentityGroups = [
    mockIdentityGroup1, mockIdentityGroup2, mockIdentityGroup3, mockIdentityGroup4, mockIdentityGroup5
];
const mockApplicationDetails = { id: 'mock-app-id', name: 'mock-app-name' };
const roleMappingMock = [
    { id: 'role-id-1', name: 'role-name-1' }, { id: 'role-id-2', name: 'role-name-2' }
];
const ɵ0$9 = () => {
    return Promise.resolve(roleMappingMock);
};
const roleMappingApi = {
    oauth2Auth: {
        callCustomApi: ɵ0$9
    }
};
const ɵ1$4 = () => {
    return Promise.resolve([]);
};
const noRoleMappingApi = {
    oauth2Auth: {
        callCustomApi: ɵ1$4
    }
};
const ɵ2$1 = () => {
    return Promise.resolve(mockIdentityGroups);
};
const groupsMockApi = {
    oauth2Auth: {
        callCustomApi: ɵ2$1
    }
};
const ɵ3 = () => {
    return Promise.resolve();
};
const createGroupMappingApi = {
    oauth2Auth: {
        callCustomApi: ɵ3
    }
};
const ɵ4 = () => {
    return Promise.resolve();
};
const updateGroupMappingApi = {
    oauth2Auth: {
        callCustomApi: ɵ4
    }
};
const ɵ5 = () => {
    return Promise.resolve();
};
const deleteGroupMappingApi = {
    oauth2Auth: {
        callCustomApi: ɵ5
    }
};
const ɵ6 = () => {
    return Promise.resolve([mockApplicationDetails]);
};
const applicationDetailsMockApi = {
    oauth2Auth: {
        callCustomApi: ɵ6
    }
};
const mockIdentityRoles = [
    new IdentityRoleModel({ id: 'mock-role-id', name: 'MOCK-ADMIN-ROLE' }),
    new IdentityRoleModel({ id: 'mock-role-id', name: 'MOCK-USER-ROLE' }),
    new IdentityRoleModel({ id: 'mock-role-id', name: 'MOCK-ROLE-1' })
];
const clientRoles = [
    new IdentityRoleModel({ name: 'MOCK-ADMIN-ROLE' }),
    new IdentityRoleModel({ name: 'MOCK-USER-ROLE' })
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const resetTestingModule = TestBed.resetTestingModule;
const preventAngularFromResetting = () => (TestBed.resetTestingModule = () => TestBed);
const ɵ0$a = preventAngularFromResetting;
const allowAngularToReset = () => (TestBed.resetTestingModule = resetTestingModule);
const ɵ1$5 = allowAngularToReset;
const setupTestBed = (moduleDef) => {
    beforeAll((done) => {
        localStorage.clear();
        sessionStorage.clear();
        resetTestingModule();
        preventAngularFromResetting();
        TestBed.configureTestingModule(moduleDef);
        TestBed.compileComponents()
            .then(() => {
            TestBed.resetTestingModule = () => TestBed;
            done();
        })
            .catch(done.fail);
    });
    afterAll(() => allowAngularToReset());
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function startupServiceFactory(alfrescoApiService) {
    return () => alfrescoApiService.load();
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function directionalityConfigFactory(directionalityConfigService) { return () => directionalityConfigService; }

class DirectionalityConfigService {
    constructor(document, rendererFactory, userPreferencesService, directionality) {
        this.document = document;
        this.rendererFactory = rendererFactory;
        this.userPreferencesService = userPreferencesService;
        this.directionality = directionality;
        const renderer = this.rendererFactory.createRenderer(null, null);
        this.userPreferencesService
            .select('textOrientation')
            .subscribe((direction) => {
            renderer.setAttribute(this.document.body, 'dir', direction);
            this.directionality.value = direction;
        });
    }
}
DirectionalityConfigService.ɵprov = ɵɵdefineInjectable({ factory: function DirectionalityConfigService_Factory() { return new DirectionalityConfigService(ɵɵinject(DOCUMENT), ɵɵinject(RendererFactory2), ɵɵinject(UserPreferencesService), ɵɵinject(Directionality)); }, token: DirectionalityConfigService, providedIn: "root" });
DirectionalityConfigService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
DirectionalityConfigService.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Inject, args: [DOCUMENT,] }] },
    { type: RendererFactory2 },
    { type: UserPreferencesService },
    { type: Directionality }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function versionCompatibilityFactory(versionCompatibilityService) { return () => versionCompatibilityService; }

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CoreModule {
    constructor(translation) {
        translation.addTranslationFolder('adf-core', 'assets/adf-core');
    }
    static forRoot() {
        return {
            ngModule: CoreModule,
            providers: [
                TranslateStore,
                TranslateService,
                { provide: TranslateLoader, useClass: TranslateLoaderService },
                {
                    provide: APP_INITIALIZER,
                    useFactory: startupServiceFactory,
                    deps: [
                        AlfrescoApiService
                    ],
                    multi: true
                },
                {
                    provide: APP_INITIALIZER,
                    useFactory: directionalityConfigFactory,
                    deps: [DirectionalityConfigService],
                    multi: true
                },
                {
                    provide: APP_INITIALIZER,
                    useFactory: versionCompatibilityFactory,
                    deps: [VersionCompatibilityService],
                    multi: true
                }
            ]
        };
    }
    static forChild() {
        return {
            ngModule: CoreModule
        };
    }
}
CoreModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    TranslateModule,
                    ExtensionsModule,
                    AboutModule,
                    ViewerModule,
                    SidenavLayoutModule,
                    PipeModule,
                    CommonModule,
                    DirectiveModule,
                    DialogModule,
                    FormsModule,
                    ReactiveFormsModule,
                    HostSettingsModule,
                    UserInfoModule,
                    MaterialModule,
                    AppConfigModule,
                    PaginationModule,
                    ToolbarModule,
                    ContextMenuModule,
                    CardViewModule,
                    FormBaseModule,
                    CommentsModule,
                    LoginModule,
                    LanguageMenuModule,
                    InfoDrawerModule,
                    DataColumnModule,
                    DataTableModule,
                    ButtonsMenuModule,
                    TemplateModule,
                    IconModule,
                    SortingPickerModule,
                    NotificationHistoryModule,
                    SearchTextModule,
                    BlankPageModule
                ],
                exports: [
                    AboutModule,
                    ViewerModule,
                    SidenavLayoutModule,
                    PipeModule,
                    CommonModule,
                    DirectiveModule,
                    DialogModule,
                    ClipboardModule,
                    FormsModule,
                    ReactiveFormsModule,
                    HostSettingsModule,
                    UserInfoModule,
                    MaterialModule,
                    AppConfigModule,
                    PaginationModule,
                    ToolbarModule,
                    ContextMenuModule,
                    CardViewModule,
                    FormBaseModule,
                    CommentsModule,
                    LoginModule,
                    LanguageMenuModule,
                    InfoDrawerModule,
                    DataColumnModule,
                    DataTableModule,
                    TranslateModule,
                    ButtonsMenuModule,
                    TemplateModule,
                    SortingPickerModule,
                    IconModule,
                    NotificationHistoryModule,
                    SearchTextModule,
                    BlankPageModule
                ]
            },] }
];
CoreModule.ctorParameters = () => [
    { type: TranslationService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ɵ0$b = directionalityConfigFactory, ɵ1$6 = versionCompatibilityFactory;
class CoreTestingModule {
}
CoreTestingModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    NoopAnimationsModule,
                    RouterTestingModule,
                    HttpClientModule,
                    TranslateModule.forRoot(),
                    CoreModule.forRoot()
                ],
                providers: [
                    DatePipe,
                    { provide: AlfrescoApiService, useClass: AlfrescoApiServiceMock },
                    { provide: AppConfigService, useClass: AppConfigServiceMock },
                    { provide: TranslationService, useClass: TranslationMock },
                    { provide: CookieService, useClass: CookieServiceMock },
                    {
                        provide: APP_INITIALIZER,
                        useFactory: ɵ0$b,
                        deps: [DirectionalityConfigService],
                        multi: true
                    },
                    {
                        provide: APP_INITIALIZER,
                        useFactory: ɵ1$6,
                        deps: [VersionCompatibilityService],
                        multi: true
                    }
                ],
                exports: [
                    NoopAnimationsModule,
                    CoreModule,
                    TranslateModule
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { ADF_AMOUNT_SETTINGS, AboutApplicationModulesComponent, AboutGithubLinkComponent, AboutModule, AboutProductVersionComponent, AboutServerSettingsComponent, ActivitiContentService, AlfrescoApiMock, AlfrescoApiService, AlfrescoApiServiceMock, AllowableOperationsEnum, AmountEditorComponent, AmountWidgetComponent, AppConfigModule, AppConfigPipe, AppConfigService, AppConfigServiceMock, AppConfigValues, AppsProcessService, AuthBearerInterceptor, AuthGuard, AuthGuardBase, AuthGuardBpm, AuthGuardEcm, AuthGuardSsoRoleService, AuthenticationMock, AuthenticationService, BaseEvent, BaseUIEvent, BlankPageComponent, BlankPageModule, BooleanEditorComponent, BoundaryDateFieldValidator, BpmProductVersionModel, BpmUserModel, BpmUserService, ButtonsMenuComponent, ButtonsMenuModule, CUSTOM_INPUT_CONTROL_VALUE_ACCESSOR, CardItemTypeService, CardViewArrayItemComponent, CardViewArrayItemModel, CardViewBaseItemModel, CardViewBoolItemComponent, CardViewBoolItemModel, CardViewComponent, CardViewContentProxyDirective, CardViewDateItemComponent, CardViewDateItemModel, CardViewDatetimeItemModel, CardViewFloatItemModel, CardViewIntItemModel, CardViewItemFloatValidator, CardViewItemIntValidator, CardViewItemLengthValidator, CardViewItemMatchValidator, CardViewItemMinMaxValidator, CardViewKeyValuePairsItemComponent, CardViewKeyValuePairsItemModel, CardViewMapItemComponent, CardViewMapItemModel, CardViewModule, CardViewSelectItemComponent, CardViewSelectItemModel, CardViewTextItemComponent, CardViewTextItemModel, CardViewUpdateService, CheckAllowableOperationDirective, CheckboxWidgetComponent, ClipboardComponent, ClipboardDirective, ClipboardModule, ClipboardService, CommentContentService, CommentListComponent, CommentModel, CommentProcessService, CommentsComponent, CommentsModule, ContainerColumnModel, ContainerModel, ContainerWidgetComponent, ContentGroups, ContentLinkModel, ContentService, ContentWidgetComponent, ContextMenuDirective, ContextMenuModule, ContextMenuOverlayService, CookieService, CookieServiceMock, CoreAutomationService, CoreModule, CoreTestingModule, CustomEmptyContentTemplateDirective, CustomLoadingContentTemplateDirective, CustomNoPermissionTemplateDirective, DataCellEvent, DataCellEventModel, DataColumnComponent, DataColumnListComponent, DataColumnModule, DataRowActionEvent, DataRowActionModel, DataRowEvent, DataSorting, DataTableCellComponent, DataTableComponent, DataTableModule, DataTableRowComponent, DataTableSchema, DateCellComponent, DateColumnHeaderComponent, DateEditorComponent, DateFieldValidator, DateTimeEditorComponent, DateTimeFieldValidator, DateTimeWidgetComponent, DateWidgetComponent, DebugAppConfigService, DecimalNumberModel, DecimalNumberPipe, DeletedNodesApiService, DialogModule, DirectiveModule, DiscoveryApiService, DisplayMode, DisplayTextWidgetComponent, DocumentWidgetComponent, DownloadService, DownloadZipDialogComponent, DownloadZipService, DropZoneDirective, DropdownEditorComponent, DropdownWidgetComponent, DynamicComponentMapper, DynamicComponentResolver, DynamicTableModel, DynamicTableWidgetComponent, EXTENDIBLE_COMPONENT, EcmCompanyModel, EcmModelService, EcmProductVersionModel, EcmUserModel, EcmUserService, EditJsonDialogComponent, EditJsonDialogModule, EmptyContentComponent, EmptyListBodyDirective, EmptyListComponent, EmptyListFooterDirective, EmptyListHeaderDirective, ErrorContentComponent, ErrorMessageModel, ErrorWidgetComponent, EventMock, ExternalAlfrescoApiService, FORM_FIELD_VALIDATORS, FavoritesApiService, FileModel, FileSizeCellComponent, FileSizePipe, FileTypePipe, FileUploadCompleteEvent, FileUploadDeleteEvent, FileUploadErrorEvent, FileUploadEvent, FileUploadOptions, FileUploadStatus, FileUtils, FileViewerWidgetComponent, FixedValueFieldValidator, FormBaseComponent, FormBaseModule, FormErrorEvent, FormEvent, FormFieldComponent, FormFieldEvent, FormFieldModel, FormFieldTypes, FormListComponent, FormModel, FormOutcomeEvent, FormOutcomeModel, FormRendererComponent, FormRenderingService, FormService, FormWidgetModel, FormatSpacePipe, FullNamePipe, FunctionalGroupWidgetComponent, HeaderFilterTemplateDirective, HeaderLayoutComponent, HighlightDirective, HighlightPipe, HighlightTransformService, HostSettingsComponent, HostSettingsModule, HyperlinkWidgetComponent, IconComponent, IconModule, IdentityGroupService, IdentityRoleModel, IdentityRoleService, IdentityUserService, ImgViewerComponent, InfinitePaginationComponent, InfiniteSelectScrollDirective, InfoDrawerButtonsDirective, InfoDrawerComponent, InfoDrawerContentDirective, InfoDrawerLayoutComponent, InfoDrawerModule, InfoDrawerTabComponent, InfoDrawerTitleDirective, InitialUsernamePipe, InputMaskDirective, JSON_TYPE, JsonCellComponent, JsonWidgetComponent, JwtHelperService, LanguageMenuComponent, LanguageMenuModule, LanguagePickerComponent, LanguageService, LayoutContainerComponent, LibraryFavoriteDirective, LibraryMembershipDirective, LicenseModel, LoadingContentTemplateDirective, LocalizedDatePipe, LocalizedRolePipe, LocationCellComponent, LockService, LogService, LoginComponent, LoginDialogComponent, LoginDialogPanelComponent, LoginDialogService, LoginErrorEvent, LoginFooterDirective, LoginHeaderDirective, LoginModule, LoginSubmitEvent, LoginSuccessEvent, LogoutDirective, MASK_DIRECTIVE, MOMENT_DATE_FORMATS, MaterialModule, MaxDateFieldValidator, MaxDateTimeFieldValidator, MaxLengthFieldValidator, MaxValueFieldValidator, MediaPlayerComponent, MimeTypeIconPipe, MinDateFieldValidator, MinDateTimeFieldValidator, MinLengthFieldValidator, MinValueFieldValidator, MomentDateAdapter, MomentDatePipe, MomentDateTimePipe, MultiValuePipe, MultilineTextWidgetComponentComponent, NOTIFICATION_TYPE, NoContentTemplateDirective, NoPermissionTemplateDirective, NodeDeleteDirective, NodeDownloadDirective, NodeFavoriteDirective, NodeMetadata, NodeNameTooltipPipe, NodeRestoreDirective, NodeService, NodesApiService, NotificationHistoryComponent, NotificationHistoryModule, NotificationService, NumberFieldValidator, NumberWidgetComponent, OAuth2Service, ObjectDataColumn, ObjectDataRow, ObjectDataTableAdapter, ObjectUtils, PageTitleService, PaginationComponent, PaginationModel, PaginationModule, PdfPasswordDialogComponent, PdfThumbComponent, PdfThumbListComponent, PdfViewerComponent, PeopleContentService, PeopleProcessService, PeopleWidgetComponent, PermissionsEnum, PipeModule, ProcessContentService, RadioButtonsWidgetComponent, RedirectionModel, RegExFieldValidator, RenditionsService, RequestPaginationModel, RequiredFieldValidator, RestoreMessageModel, RowEditorComponent, SEARCH_AUTOCOMPLETE_VALUE_ACCESSOR, SearchConfigurationService, SearchService, SearchTextInputComponent, SearchTextModule, SearchTextStateEnum, SearchTriggerDirective, SelectFilterInputComponent, SharedLinksApiService, ShowHeaderMode, SidebarActionMenuComponent, SidebarMenuDirective, SidebarMenuExpandIconDirective, SidebarMenuTitleIconDirective, SidenavLayoutComponent, SidenavLayoutContentDirective, SidenavLayoutHeaderDirective, SidenavLayoutModule, SidenavLayoutNavigationDirective, SitesService, SortingPickerComponent, SortingPickerModule, StartFormCustomButtonDirective, Status, StorageService, TRANSLATION_PROVIDER, TabModel, TabsWidgetComponent, TemplateModule, TextEditorComponent, TextWidgetComponent, ThumbnailService, TimeAgoPipe, ToolbarComponent, ToolbarDividerComponent, ToolbarModule, ToolbarTitleComponent, TooltipCardDirective, TranslateLoaderService, TranslationMock, TranslationService, TxtViewerComponent, TypeaheadWidgetComponent, UnknownFormatComponent, UnknownWidgetComponent, UploadDirective, UploadFolderWidgetComponent, UploadService, UploadWidgetComponent, UploadWidgetContentLinkModel, UserInfoComponent, UserInfoModule, UserPreferenceValues, UserPreferencesService, UserProcessModel, ValidateDynamicTableRowEvent, ValidateFormEvent, ValidateFormFieldEvent, VersionCompatibilityDirective, VersionCompatibilityService, VersionModel, VersionModuleModel, VersionStatusModel, ViewUtilService, ViewerComponent, ViewerExtensionDirective, ViewerModule, ViewerMoreActionsComponent, ViewerOpenWithComponent, ViewerSidebarComponent, ViewerToolbarActionsComponent, ViewerToolbarComponent, WIDGET_DIRECTIVES, WidgetComponent, WidgetVisibilityService, applicationDetailsMockApi, clientRoles, complexVisibilityJsonNotVisible, complexVisibilityJsonVisible, createGroupMappingApi, createNewPersonMock, deleteGroupMappingApi, error, fakeApps, fakeBpmEditedUser, fakeBpmUser, fakeBpmUserNoImage, fakeEcmCompany, fakeEcmEditedUser, fakeEcmUser, fakeEcmUser2, fakeEcmUserList, fakeEcmUserNoImage, fakeForm, fakeFormChainedVisibilityJson, fakeFormCheckBoxVisibilityJson, fakeFormJson, fakeProcessComment, fakeRendition, fakeRenditionCreated, fakeRenditionsList, fakeRenditionsListWithACreated, fakeSearch, fakeTaskProcessVariableModels, fakeTasksComment, fakeUser1, fakeUser2, formDefVisibilitiFieldDependsOnNextOne, formDefVisibilitiFieldDependsOnPreviousOne, formDefinitionDropdownField, formDefinitionRequiredField, formDefinitionTwoTextFields, formModelTabs, formReadonlyTwoTextFields, formTest, formValues, getFakeUserWithContentAdminCapability, getFakeUserWithContentUserCapability, groupsMockApi, info, mockApplicationDetails, mockError, mockIdentityGroup1, mockIdentityGroup2, mockIdentityGroup3, mockIdentityGroup4, mockIdentityGroup5, mockIdentityGroups, mockIdentityGroupsCount, mockIdentityRoles, mockToken, noRoleMappingApi, roleMappingApi, roleMappingMock, rootInitiator, searchAnimation, searchMockApi, setupTestBed, startFormAmountWidgetMock, startFormDateWidgetMock, startFormDropdownDefinitionMock, startFormNumberWidgetMock, startFormRadioButtonWidgetMock, startFormTextDefinitionMock, startMockForm, startMockFormWithTab, tabInvalidFormVisibility, tabVisibilityJsonMock, transformKeyToObject, updateGroupMappingApi, warning, ɵ0, ɵ1, ɵ2, ɵ3, ɵ4, ɵ5, ɵ6, BaseCardView as ɵa, CardViewItemDispatcherComponent as ɵb, ContextMenuListComponent as ɵc, contextMenuAnimation as ɵd, ContextMenuOverlayRef as ɵe, CONTEXT_MENU_DATA as ɵf, TooltipCardComponent as ɵg, RenderingQueueServices as ɵh, DynamicRowValidationSummary as ɵj, sidenavAnimation as ɵk, contentAnimation as ɵl, getType as ɵm, NotificationIconPipe as ɵn, startupServiceFactory as ɵo, directionalityConfigFactory as ɵp, DirectionalityConfigService as ɵq, versionCompatibilityFactory as ɵr };
//# sourceMappingURL=adf-core.js.map
