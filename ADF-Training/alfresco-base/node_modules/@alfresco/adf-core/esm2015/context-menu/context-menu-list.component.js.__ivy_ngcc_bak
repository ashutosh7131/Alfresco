/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Component, ViewEncapsulation, HostListener, Optional, Inject, QueryList, ViewChildren } from '@angular/core';
import { trigger } from '@angular/animations';
import { DOWN_ARROW, UP_ARROW } from '@angular/cdk/keycodes';
import { FocusKeyManager } from '@angular/cdk/a11y';
import { MatMenuItem } from '@angular/material/menu';
import { ContextMenuOverlayRef } from './context-menu-overlay';
import { contextMenuAnimation } from './animations';
import { CONTEXT_MENU_DATA } from './context-menu.tokens';
export class ContextMenuListComponent {
    constructor(contextMenuOverlayRef, data) {
        this.contextMenuOverlayRef = contextMenuOverlayRef;
        this.data = data;
        this.links = this.data;
    }
    handleKeydownEscape(event) {
        if (event) {
            this.contextMenuOverlayRef.close();
        }
    }
    handleKeydownEvent(event) {
        if (event) {
            const keyCode = event.keyCode;
            if (keyCode === UP_ARROW || keyCode === DOWN_ARROW) {
                this.keyManager.onKeydown(event);
            }
        }
    }
    onMenuItemClick(event, menuItem) {
        if (menuItem && menuItem.model && menuItem.model.disabled) {
            event.preventDefault();
            event.stopImmediatePropagation();
            return;
        }
        menuItem.subject.next(menuItem);
        this.contextMenuOverlayRef.close();
    }
    ngAfterViewInit() {
        this.keyManager = new FocusKeyManager(this.items);
        this.keyManager.setFirstItemActive();
    }
}
ContextMenuListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-context-menu',
                template: `
        <div mat-menu class="mat-menu-panel" @panelAnimation>
            <div id="adf-context-menu-content" class="mat-menu-content">
                <ng-container *ngFor="let link of links">
                    <button *ngIf="link.model?.visible"
                            [attr.data-automation-id]="'context-'+((link.title || link.model?.title) | translate)"
                            mat-menu-item
                            [disabled]="link.model?.disabled"
                            (click)="onMenuItemClick($event, link)">
                        <mat-icon *ngIf="link.model?.icon">{{ link.model.icon }}</mat-icon>
                        <span>{{ (link.title || link.model?.title) | translate }}</span>
                    </button>
                </ng-container>
            </div>
        </div>
    `,
                host: {
                    role: 'menu',
                    class: 'adf-context-menu'
                },
                encapsulation: ViewEncapsulation.None,
                animations: [
                    trigger('panelAnimation', contextMenuAnimation)
                ]
            },] }
];
ContextMenuListComponent.ctorParameters = () => [
    { type: ContextMenuOverlayRef, decorators: [{ type: Inject, args: [ContextMenuOverlayRef,] }] },
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [CONTEXT_MENU_DATA,] }] }
];
ContextMenuListComponent.propDecorators = {
    items: [{ type: ViewChildren, args: [MatMenuItem,] }],
    handleKeydownEscape: [{ type: HostListener, args: ['document:keydown.Escape', ['$event'],] }],
    handleKeydownEvent: [{ type: HostListener, args: ['document:keydown', ['$event'],] }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29udGV4dC1tZW51LWxpc3QuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Ii9ob21lL3RyYXZpcy9idWlsZC9BbGZyZXNjby9hbGZyZXNjby1uZzItY29tcG9uZW50cy9saWIvY29yZS8iLCJzb3VyY2VzIjpbImNvbnRleHQtbWVudS9jb250ZXh0LW1lbnUtbGlzdC5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBRUgsT0FBTyxFQUNILFNBQVMsRUFBRSxpQkFBaUIsRUFBRSxZQUFZLEVBQzFDLFFBQVEsRUFBRSxNQUFNLEVBQUUsU0FBUyxFQUFFLFlBQVksRUFDNUMsTUFBTSxlQUFlLENBQUM7QUFDdkIsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQzlDLE9BQU8sRUFBRSxVQUFVLEVBQUUsUUFBUSxFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUFDN0QsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQ3BELE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUNyRCxPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUMvRCxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxjQUFjLENBQUM7QUFDcEQsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sdUJBQXVCLENBQUM7QUE2QjFELE1BQU0sT0FBTyx3QkFBd0I7SUFzQmpDLFlBQzJDLHFCQUE0QyxFQUNwQyxJQUFTO1FBRGpCLDBCQUFxQixHQUFyQixxQkFBcUIsQ0FBdUI7UUFDcEMsU0FBSSxHQUFKLElBQUksQ0FBSztRQUV4RCxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxJQUFJLENBQUM7SUFDM0IsQ0FBQztJQXJCRCxtQkFBbUIsQ0FBQyxLQUFvQjtRQUNwQyxJQUFJLEtBQUssRUFBRTtZQUNQLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxLQUFLLEVBQUUsQ0FBQztTQUN0QztJQUNMLENBQUM7SUFHRCxrQkFBa0IsQ0FBQyxLQUFvQjtRQUNuQyxJQUFJLEtBQUssRUFBRTtZQUNQLE1BQU0sT0FBTyxHQUFHLEtBQUssQ0FBQyxPQUFPLENBQUM7WUFDOUIsSUFBSSxPQUFPLEtBQUssUUFBUSxJQUFJLE9BQU8sS0FBSyxVQUFVLEVBQUU7Z0JBQ2hELElBQUksQ0FBQyxVQUFVLENBQUMsU0FBUyxDQUFDLEtBQUssQ0FBQyxDQUFDO2FBQ3BDO1NBQ0o7SUFDTCxDQUFDO0lBU0QsZUFBZSxDQUFDLEtBQVksRUFBRSxRQUFhO1FBQ3ZDLElBQUksUUFBUSxJQUFJLFFBQVEsQ0FBQyxLQUFLLElBQUksUUFBUSxDQUFDLEtBQUssQ0FBQyxRQUFRLEVBQUU7WUFDdkQsS0FBSyxDQUFDLGNBQWMsRUFBRSxDQUFDO1lBQ3ZCLEtBQUssQ0FBQyx3QkFBd0IsRUFBRSxDQUFDO1lBQ2pDLE9BQU87U0FDVjtRQUVELFFBQVEsQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDO1FBQ2hDLElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxLQUFLLEVBQUUsQ0FBQztJQUN2QyxDQUFDO0lBRUQsZUFBZTtRQUNYLElBQUksQ0FBQyxVQUFVLEdBQUcsSUFBSSxlQUFlLENBQWMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQy9ELElBQUksQ0FBQyxVQUFVLENBQUMsa0JBQWtCLEVBQUUsQ0FBQztJQUN6QyxDQUFDOzs7WUF0RUosU0FBUyxTQUFDO2dCQUNQLFFBQVEsRUFBRSxrQkFBa0I7Z0JBQzVCLFFBQVEsRUFBRTs7Ozs7Ozs7Ozs7Ozs7O0tBZVQ7Z0JBQ0QsSUFBSSxFQUFFO29CQUNGLElBQUksRUFBRSxNQUFNO29CQUNaLEtBQUssRUFBRSxrQkFBa0I7aUJBQzVCO2dCQUNELGFBQWEsRUFBRSxpQkFBaUIsQ0FBQyxJQUFJO2dCQUNyQyxVQUFVLEVBQUU7b0JBQ1IsT0FBTyxDQUFDLGdCQUFnQixFQUFFLG9CQUFvQixDQUFDO2lCQUNsRDthQUNKOzs7WUE5QlEscUJBQXFCLHVCQXNEckIsTUFBTSxTQUFDLHFCQUFxQjs0Q0FDNUIsUUFBUSxZQUFJLE1BQU0sU0FBQyxpQkFBaUI7OztvQkF0QnhDLFlBQVksU0FBQyxXQUFXO2tDQUd4QixZQUFZLFNBQUMseUJBQXlCLEVBQUUsQ0FBQyxRQUFRLENBQUM7aUNBT2xELFlBQVksU0FBQyxrQkFBa0IsRUFBRSxDQUFDLFFBQVEsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7XG4gICAgQ29tcG9uZW50LCBWaWV3RW5jYXBzdWxhdGlvbiwgSG9zdExpc3RlbmVyLCBBZnRlclZpZXdJbml0LFxuICAgIE9wdGlvbmFsLCBJbmplY3QsIFF1ZXJ5TGlzdCwgVmlld0NoaWxkcmVuXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgdHJpZ2dlciB9IGZyb20gJ0Bhbmd1bGFyL2FuaW1hdGlvbnMnO1xuaW1wb3J0IHsgRE9XTl9BUlJPVywgVVBfQVJST1cgfSBmcm9tICdAYW5ndWxhci9jZGsva2V5Y29kZXMnO1xuaW1wb3J0IHsgRm9jdXNLZXlNYW5hZ2VyIH0gZnJvbSAnQGFuZ3VsYXIvY2RrL2ExMXknO1xuaW1wb3J0IHsgTWF0TWVudUl0ZW0gfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbC9tZW51JztcbmltcG9ydCB7IENvbnRleHRNZW51T3ZlcmxheVJlZiB9IGZyb20gJy4vY29udGV4dC1tZW51LW92ZXJsYXknO1xuaW1wb3J0IHsgY29udGV4dE1lbnVBbmltYXRpb24gfSBmcm9tICcuL2FuaW1hdGlvbnMnO1xuaW1wb3J0IHsgQ09OVEVYVF9NRU5VX0RBVEEgfSBmcm9tICcuL2NvbnRleHQtbWVudS50b2tlbnMnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2FkZi1jb250ZXh0LW1lbnUnLFxuICAgIHRlbXBsYXRlOiBgXG4gICAgICAgIDxkaXYgbWF0LW1lbnUgY2xhc3M9XCJtYXQtbWVudS1wYW5lbFwiIEBwYW5lbEFuaW1hdGlvbj5cbiAgICAgICAgICAgIDxkaXYgaWQ9XCJhZGYtY29udGV4dC1tZW51LWNvbnRlbnRcIiBjbGFzcz1cIm1hdC1tZW51LWNvbnRlbnRcIj5cbiAgICAgICAgICAgICAgICA8bmctY29udGFpbmVyICpuZ0Zvcj1cImxldCBsaW5rIG9mIGxpbmtzXCI+XG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gKm5nSWY9XCJsaW5rLm1vZGVsPy52aXNpYmxlXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBbYXR0ci5kYXRhLWF1dG9tYXRpb24taWRdPVwiJ2NvbnRleHQtJysoKGxpbmsudGl0bGUgfHwgbGluay5tb2RlbD8udGl0bGUpIHwgdHJhbnNsYXRlKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0LW1lbnUtaXRlbVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtkaXNhYmxlZF09XCJsaW5rLm1vZGVsPy5kaXNhYmxlZFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKGNsaWNrKT1cIm9uTWVudUl0ZW1DbGljaygkZXZlbnQsIGxpbmspXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8bWF0LWljb24gKm5nSWY9XCJsaW5rLm1vZGVsPy5pY29uXCI+e3sgbGluay5tb2RlbC5pY29uIH19PC9tYXQtaWNvbj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuPnt7IChsaW5rLnRpdGxlIHx8IGxpbmsubW9kZWw/LnRpdGxlKSB8IHRyYW5zbGF0ZSB9fTwvc3Bhbj5cbiAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgPC9uZy1jb250YWluZXI+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC9kaXY+XG4gICAgYCxcbiAgICBob3N0OiB7XG4gICAgICAgIHJvbGU6ICdtZW51JyxcbiAgICAgICAgY2xhc3M6ICdhZGYtY29udGV4dC1tZW51J1xuICAgIH0sXG4gICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICBhbmltYXRpb25zOiBbXG4gICAgICAgIHRyaWdnZXIoJ3BhbmVsQW5pbWF0aW9uJywgY29udGV4dE1lbnVBbmltYXRpb24pXG4gICAgXVxufSlcbmV4cG9ydCBjbGFzcyBDb250ZXh0TWVudUxpc3RDb21wb25lbnQgaW1wbGVtZW50cyBBZnRlclZpZXdJbml0IHtcbiAgICBwcml2YXRlIGtleU1hbmFnZXI6IEZvY3VzS2V5TWFuYWdlcjxNYXRNZW51SXRlbT47XG4gICAgQFZpZXdDaGlsZHJlbihNYXRNZW51SXRlbSkgaXRlbXM6IFF1ZXJ5TGlzdDxNYXRNZW51SXRlbT47XG4gICAgbGlua3M6IGFueVtdO1xuXG4gICAgQEhvc3RMaXN0ZW5lcignZG9jdW1lbnQ6a2V5ZG93bi5Fc2NhcGUnLCBbJyRldmVudCddKVxuICAgIGhhbmRsZUtleWRvd25Fc2NhcGUoZXZlbnQ6IEtleWJvYXJkRXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHRNZW51T3ZlcmxheVJlZi5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgQEhvc3RMaXN0ZW5lcignZG9jdW1lbnQ6a2V5ZG93bicsIFsnJGV2ZW50J10pXG4gICAgaGFuZGxlS2V5ZG93bkV2ZW50KGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudCkge1xuICAgICAgICAgICAgY29uc3Qga2V5Q29kZSA9IGV2ZW50LmtleUNvZGU7XG4gICAgICAgICAgICBpZiAoa2V5Q29kZSA9PT0gVVBfQVJST1cgfHwga2V5Q29kZSA9PT0gRE9XTl9BUlJPVykge1xuICAgICAgICAgICAgICAgIHRoaXMua2V5TWFuYWdlci5vbktleWRvd24oZXZlbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IoXG4gICAgICAgIEBJbmplY3QoQ29udGV4dE1lbnVPdmVybGF5UmVmKSBwcml2YXRlIGNvbnRleHRNZW51T3ZlcmxheVJlZjogQ29udGV4dE1lbnVPdmVybGF5UmVmLFxuICAgICAgICBAT3B0aW9uYWwoKSBASW5qZWN0KENPTlRFWFRfTUVOVV9EQVRBKSBwcml2YXRlIGRhdGE6IGFueVxuICAgICkge1xuICAgICAgICB0aGlzLmxpbmtzID0gdGhpcy5kYXRhO1xuICAgIH1cblxuICAgIG9uTWVudUl0ZW1DbGljayhldmVudDogRXZlbnQsIG1lbnVJdGVtOiBhbnkpIHtcbiAgICAgICAgaWYgKG1lbnVJdGVtICYmIG1lbnVJdGVtLm1vZGVsICYmIG1lbnVJdGVtLm1vZGVsLmRpc2FibGVkKSB7XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICBtZW51SXRlbS5zdWJqZWN0Lm5leHQobWVudUl0ZW0pO1xuICAgICAgICB0aGlzLmNvbnRleHRNZW51T3ZlcmxheVJlZi5jbG9zZSgpO1xuICAgIH1cblxuICAgIG5nQWZ0ZXJWaWV3SW5pdCgpIHtcbiAgICAgICAgdGhpcy5rZXlNYW5hZ2VyID0gbmV3IEZvY3VzS2V5TWFuYWdlcjxNYXRNZW51SXRlbT4odGhpcy5pdGVtcyk7XG4gICAgICAgIHRoaXMua2V5TWFuYWdlci5zZXRGaXJzdEl0ZW1BY3RpdmUoKTtcbiAgICB9XG59XG4iXX0=