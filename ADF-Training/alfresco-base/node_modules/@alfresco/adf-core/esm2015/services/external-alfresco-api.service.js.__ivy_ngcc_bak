import { Injectable } from '@angular/core';
import { AlfrescoApiCompatibility, NodesApi } from '@alfresco/js-api';
import { ReplaySubject, Subject } from 'rxjs';
import * as i0 from "@angular/core";
export class ExternalAlfrescoApiService {
    constructor() {
        this.nodeUpdated = new Subject();
        this.alfrescoApiInitialized = new ReplaySubject(1);
    }
    getInstance() {
        return this.alfrescoApi;
    }
    get contentApi() {
        return this.getInstance().content;
    }
    get nodesApi() {
        var _a;
        this._nodesApi = (_a = this._nodesApi) !== null && _a !== void 0 ? _a : new NodesApi(this.getInstance());
        return this._nodesApi;
    }
    init(ecmHost, contextRoot) {
        const domainPrefix = this.createPrefixFromHost(ecmHost);
        const config = {
            provider: 'ECM',
            hostEcm: ecmHost,
            authType: 'BASIC',
            contextRoot: contextRoot,
            domainPrefix
        };
        this.initAlfrescoApi(config);
        this.alfrescoApiInitialized.next(true);
    }
    initAlfrescoApi(config) {
        if (this.alfrescoApi) {
            this.alfrescoApi.configureJsApi(config);
        }
        else {
            this.alfrescoApi = new AlfrescoApiCompatibility(config);
        }
    }
    createPrefixFromHost(url) {
        const match = url.match(/:\/\/(www[0-9]?\.)?(.[^/:]+)/i);
        let result = null;
        if (match != null && match.length > 2 && typeof match[2] === 'string' && match[2].length > 0) {
            result = match[2];
        }
        return result;
    }
}
ExternalAlfrescoApiService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ExternalAlfrescoApiService_Factory() { return new ExternalAlfrescoApiService(); }, token: ExternalAlfrescoApiService, providedIn: "root" });
ExternalAlfrescoApiService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXh0ZXJuYWwtYWxmcmVzY28tYXBpLnNlcnZpY2UuanMiLCJzb3VyY2VSb290IjoiL2hvbWUvdHJhdmlzL2J1aWxkL0FsZnJlc2NvL2FsZnJlc2NvLW5nMi1jb21wb25lbnRzL2xpYi9jb3JlLyIsInNvdXJjZXMiOlsic2VydmljZXMvZXh0ZXJuYWwtYWxmcmVzY28tYXBpLnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBaUJBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUNILHdCQUF3QixFQUVsQixRQUFRLEVBQ2pCLE1BQU0sa0JBQWtCLENBQUM7QUFDMUIsT0FBTyxFQUFFLGFBQWEsRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7O0FBSzlDLE1BQU0sT0FBTywwQkFBMEI7SUFIdkM7UUFRSSxnQkFBVyxHQUFHLElBQUksT0FBTyxFQUFRLENBQUM7UUFFbEMsMkJBQXNCLEdBQTJCLElBQUksYUFBYSxDQUFDLENBQUMsQ0FBQyxDQUFDO0tBaUR6RTtJQTVDRyxXQUFXO1FBQ1AsT0FBTyxJQUFJLENBQUMsV0FBVyxDQUFDO0lBQzVCLENBQUM7SUFFRCxJQUFJLFVBQVU7UUFDVixPQUFPLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxPQUFPLENBQUM7SUFDdEMsQ0FBQztJQUVELElBQUksUUFBUTs7UUFDUixJQUFJLENBQUMsU0FBUyxTQUFHLElBQUksQ0FBQyxTQUFTLG1DQUFJLElBQUksUUFBUSxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsQ0FBQyxDQUFDO1FBQ3BFLE9BQU8sSUFBSSxDQUFDLFNBQVMsQ0FBQztJQUMxQixDQUFDO0lBRUQsSUFBSSxDQUFDLE9BQWUsRUFBRSxXQUFtQjtRQUVyQyxNQUFNLFlBQVksR0FBRyxJQUFJLENBQUMsb0JBQW9CLENBQUMsT0FBTyxDQUFDLENBQUM7UUFFeEQsTUFBTSxNQUFNLEdBQUc7WUFDWCxRQUFRLEVBQUUsS0FBSztZQUNmLE9BQU8sRUFBRSxPQUFPO1lBQ2hCLFFBQVEsRUFBRSxPQUFPO1lBQ2pCLFdBQVcsRUFBRSxXQUFXO1lBQ3hCLFlBQVk7U0FDZixDQUFDO1FBQ0YsSUFBSSxDQUFDLGVBQWUsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUM3QixJQUFJLENBQUMsc0JBQXNCLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQzNDLENBQUM7SUFFUyxlQUFlLENBQUMsTUFBTTtRQUM1QixJQUFJLElBQUksQ0FBQyxXQUFXLEVBQUU7WUFDbEIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLENBQUM7U0FDM0M7YUFBTTtZQUNILElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSx3QkFBd0IsQ0FBQyxNQUFNLENBQUMsQ0FBQztTQUMzRDtJQUNMLENBQUM7SUFFTyxvQkFBb0IsQ0FBQyxHQUFXO1FBQ3BDLE1BQU0sS0FBSyxHQUFHLEdBQUcsQ0FBQyxLQUFLLENBQUMsK0JBQStCLENBQUMsQ0FBQztRQUN6RCxJQUFJLE1BQU0sR0FBRyxJQUFJLENBQUM7UUFDbEIsSUFBSSxLQUFLLElBQUksSUFBSSxJQUFJLEtBQUssQ0FBQyxNQUFNLEdBQUcsQ0FBQyxJQUFJLE9BQU8sS0FBSyxDQUFDLENBQUMsQ0FBQyxLQUFLLFFBQVEsSUFBSSxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUMsTUFBTSxHQUFHLENBQUMsRUFBRTtZQUMxRixNQUFNLEdBQUcsS0FBSyxDQUFDLENBQUMsQ0FBQyxDQUFDO1NBQ3JCO1FBQ0QsT0FBTyxNQUFNLENBQUM7SUFDbEIsQ0FBQzs7OztZQTFESixVQUFVLFNBQUM7Z0JBQ1IsVUFBVSxFQUFFLE1BQU07YUFDckIiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBJbmplY3RhYmxlIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQge1xuICAgIEFsZnJlc2NvQXBpQ29tcGF0aWJpbGl0eSxcbiAgICBDb250ZW50QXBpLFxuICAgIE5vZGUsIE5vZGVzQXBpXG59IGZyb20gJ0BhbGZyZXNjby9qcy1hcGknO1xuaW1wb3J0IHsgUmVwbGF5U3ViamVjdCwgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuXG5ASW5qZWN0YWJsZSh7XG4gICAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIEV4dGVybmFsQWxmcmVzY29BcGlTZXJ2aWNlIHtcblxuICAgIC8qKlxuICAgICAqIFB1Ymxpc2gvc3Vic2NyaWJlIHRvIGV2ZW50cyByZWxhdGVkIHRvIG5vZGUgdXBkYXRlcy5cbiAgICAgKi9cbiAgICBub2RlVXBkYXRlZCA9IG5ldyBTdWJqZWN0PE5vZGU+KCk7XG5cbiAgICBhbGZyZXNjb0FwaUluaXRpYWxpemVkOiBSZXBsYXlTdWJqZWN0PGJvb2xlYW4+ID0gbmV3IFJlcGxheVN1YmplY3QoMSk7XG5cbiAgICBwcm90ZWN0ZWQgYWxmcmVzY29BcGk6IEFsZnJlc2NvQXBpQ29tcGF0aWJpbGl0eTtcbiAgICBfbm9kZXNBcGk6IE5vZGVzQXBpO1xuXG4gICAgZ2V0SW5zdGFuY2UoKTogQWxmcmVzY29BcGlDb21wYXRpYmlsaXR5IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuYWxmcmVzY29BcGk7XG4gICAgfVxuXG4gICAgZ2V0IGNvbnRlbnRBcGkoKTogQ29udGVudEFwaSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEluc3RhbmNlKCkuY29udGVudDtcbiAgICB9XG5cbiAgICBnZXQgbm9kZXNBcGkoKTogTm9kZXNBcGkge1xuICAgICAgICB0aGlzLl9ub2Rlc0FwaSA9IHRoaXMuX25vZGVzQXBpID8/IG5ldyBOb2Rlc0FwaSh0aGlzLmdldEluc3RhbmNlKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5fbm9kZXNBcGk7XG4gICAgfVxuXG4gICAgaW5pdChlY21Ib3N0OiBzdHJpbmcsIGNvbnRleHRSb290OiBzdHJpbmcpIHtcblxuICAgICAgICBjb25zdCBkb21haW5QcmVmaXggPSB0aGlzLmNyZWF0ZVByZWZpeEZyb21Ib3N0KGVjbUhvc3QpO1xuXG4gICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgICAgIHByb3ZpZGVyOiAnRUNNJyxcbiAgICAgICAgICAgIGhvc3RFY206IGVjbUhvc3QsXG4gICAgICAgICAgICBhdXRoVHlwZTogJ0JBU0lDJyxcbiAgICAgICAgICAgIGNvbnRleHRSb290OiBjb250ZXh0Um9vdCxcbiAgICAgICAgICAgIGRvbWFpblByZWZpeFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLmluaXRBbGZyZXNjb0FwaShjb25maWcpO1xuICAgICAgICB0aGlzLmFsZnJlc2NvQXBpSW5pdGlhbGl6ZWQubmV4dCh0cnVlKTtcbiAgICB9XG5cbiAgICBwcm90ZWN0ZWQgaW5pdEFsZnJlc2NvQXBpKGNvbmZpZykge1xuICAgICAgICBpZiAodGhpcy5hbGZyZXNjb0FwaSkge1xuICAgICAgICAgICAgdGhpcy5hbGZyZXNjb0FwaS5jb25maWd1cmVKc0FwaShjb25maWcpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5hbGZyZXNjb0FwaSA9IG5ldyBBbGZyZXNjb0FwaUNvbXBhdGliaWxpdHkoY29uZmlnKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHByaXZhdGUgY3JlYXRlUHJlZml4RnJvbUhvc3QodXJsOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHVybC5tYXRjaCgvOlxcL1xcLyh3d3dbMC05XT9cXC4pPyguW14vOl0rKS9pKTtcbiAgICAgICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgICAgIGlmIChtYXRjaCAhPSBudWxsICYmIG1hdGNoLmxlbmd0aCA+IDIgJiYgdHlwZW9mIG1hdGNoWzJdID09PSAnc3RyaW5nJyAmJiBtYXRjaFsyXS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBtYXRjaFsyXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbiJdfQ==