import { Injectable } from '@angular/core';
import { from, throwError } from 'rxjs';
import { AlfrescoApiService } from './alfresco-api.service';
import { LogService } from './log.service';
import { BpmUserModel } from '../models/bpm-user.model';
import { map, catchError } from 'rxjs/operators';
import { UserProfileApi } from '@alfresco/js-api';
import * as i0 from "@angular/core";
import * as i1 from "./alfresco-api.service";
import * as i2 from "./log.service";
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from './alfresco-api.service';
import * as ɵngcc2 from './log.service';
export class BpmUserService {
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
    }
    get profileApi() {
        var _a;
        this._profileApi = (_a = this._profileApi) !== null && _a !== void 0 ? _a : new UserProfileApi(this.apiService.getInstance());
        return this._profileApi;
    }
    getCurrentUserInfo() {
        return from(this.profileApi.getProfile())
            .pipe(map((userRepresentation) => {
            return new BpmUserModel(userRepresentation);
        }), catchError((err) => this.handleError(err)));
    }
    getCurrentUserProfileImage() {
        return this.profileApi.getProfilePictureUrl();
    }
    handleError(error) {
        this.logService.error(error);
        return throwError(error || 'Server error');
    }
}
BpmUserService.ɵfac = function BpmUserService_Factory(t) { return new (t || BpmUserService)(ɵngcc0.ɵɵinject(ɵngcc1.AlfrescoApiService), ɵngcc0.ɵɵinject(ɵngcc2.LogService)); };
BpmUserService.ɵprov = i0.ɵɵdefineInjectable({ factory: function BpmUserService_Factory() { return new BpmUserService(i0.ɵɵinject(i1.AlfrescoApiService), i0.ɵɵinject(i2.LogService)); }, token: BpmUserService, providedIn: "root" });
BpmUserService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: LogService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(BpmUserService, [{
        type: Injectable,
        args: [{
                providedIn: 'root'
            }]
    }], function () { return [{ type: ɵngcc1.AlfrescoApiService }, { type: ɵngcc2.LogService }]; }, null); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnBtLXVzZXIuc2VydmljZS5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vaG9tZS90cmF2aXMvYnVpbGQvQWxmcmVzY28vYWxmcmVzY28tbmcyLWNvbXBvbmVudHMvbGliL2NvcmUvc2VydmljZXMvYnBtLXVzZXIuc2VydmljZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFpQkEsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQyxPQUFPLEVBQWMsSUFBSSxFQUFFLFVBQVUsRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUNwRCxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsTUFBTSx3QkFBd0IsQ0FBQztBQUM1RCxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQzNDLE9BQU8sRUFBRSxZQUFZLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUN4RCxPQUFPLEVBQUUsR0FBRyxFQUFFLFVBQVUsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ2pELE9BQU8sRUFBRSxjQUFjLEVBQXNCLE1BQU0sa0JBQWtCLENBQUM7QUFDdEU7QUFHNkI7QUFHeEI7Ozs7QUFHTCxNQUFNLE9BQU8sY0FBYztBQUMzQixJQU9JLFlBQW9CLFVBQThCLEVBQzlCLFVBQXNCO0FBQzlDLFFBRndCLGVBQVUsR0FBVixVQUFVLENBQW9CO0FBQUMsUUFDL0IsZUFBVSxHQUFWLFVBQVUsQ0FBWTtBQUFDLElBQzNDLENBQUM7QUFDTCxJQVJJLElBQUksVUFBVTtBQUFLO0FBQ3ZCLFFBQVEsSUFBSSxDQUFDLFdBQVcsU0FBRyxJQUFJLENBQUMsV0FBVyxtQ0FBSSxJQUFJLGNBQWMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLFdBQVcsRUFBRSxDQUFDLENBQUM7QUFDakcsUUFBUSxPQUFPLElBQUksQ0FBQyxXQUFXLENBQUM7QUFDaEMsSUFBSSxDQUFDO0FBQ0wsSUFTSSxrQkFBa0I7QUFBSyxRQUNuQixPQUFPLElBQUksQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLFVBQVUsRUFBRSxDQUFDO0FBQ2pELGFBQWEsSUFBSSxDQUNELEdBQUcsQ0FBQyxDQUFDLGtCQUFzQyxFQUFFLEVBQUU7QUFDL0QsWUFBb0IsT0FBTyxJQUFJLFlBQVksQ0FBQyxrQkFBa0IsQ0FBQyxDQUFDO0FBQ2hFLFFBQWdCLENBQUMsQ0FBQyxFQUNGLFVBQVUsQ0FBQyxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FBQyxDQUM3QyxDQUFDO0FBQ2QsSUFBSSxDQUFDO0FBQ0wsSUFLSSwwQkFBMEI7QUFBSyxRQUMzQixPQUFPLElBQUksQ0FBQyxVQUFVLENBQUMsb0JBQW9CLEVBQUUsQ0FBQztBQUN0RCxJQUFJLENBQUM7QUFDTCxJQUtZLFdBQVcsQ0FBQyxLQUFVO0FBQ2xDLFFBRVEsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDckMsUUFBUSxPQUFPLFVBQVUsQ0FBQyxLQUFLLElBQUksY0FBYyxDQUFDLENBQUM7QUFDbkQsSUFBSSxDQUFDO0FBQ0w7K0tBQ0E7QUFBQyx1T0E3Q0k7QUFBQztFQUhMLFVBQVUsU0FBQyxyQkFLRyxZQWhCTixrQkFBa0I7S0FZdkIsVUFBVSxFQUFFLE1BQU0sdkJBWlMsWUFDdEIsVUFBVTtBQUFHO1NBWXJCOzs7OztnSEFadUI7QUFBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IE9ic2VydmFibGUsIGZyb20sIHRocm93RXJyb3IgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IEFsZnJlc2NvQXBpU2VydmljZSB9IGZyb20gJy4vYWxmcmVzY28tYXBpLnNlcnZpY2UnO1xuaW1wb3J0IHsgTG9nU2VydmljZSB9IGZyb20gJy4vbG9nLnNlcnZpY2UnO1xuaW1wb3J0IHsgQnBtVXNlck1vZGVsIH0gZnJvbSAnLi4vbW9kZWxzL2JwbS11c2VyLm1vZGVsJztcbmltcG9ydCB7IG1hcCwgY2F0Y2hFcnJvciB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcbmltcG9ydCB7IFVzZXJQcm9maWxlQXBpLCBVc2VyUmVwcmVzZW50YXRpb24gfSBmcm9tICdAYWxmcmVzY28vanMtYXBpJztcblxuLyoqXG4gKlxuICogQlBNVXNlclNlcnZpY2UgcmV0cmlldmUgYWxsIHRoZSBpbmZvcm1hdGlvbiBvZiBhbiBFY20gdXNlci5cbiAqXG4gKi9cbkBJbmplY3RhYmxlKHtcbiAgICBwcm92aWRlZEluOiAncm9vdCdcbn0pXG5leHBvcnQgY2xhc3MgQnBtVXNlclNlcnZpY2Uge1xuXG4gICAgX3Byb2ZpbGVBcGk6IFVzZXJQcm9maWxlQXBpO1xuICAgIGdldCBwcm9maWxlQXBpKCk6IFVzZXJQcm9maWxlQXBpIHtcbiAgICAgICAgdGhpcy5fcHJvZmlsZUFwaSA9IHRoaXMuX3Byb2ZpbGVBcGkgPz8gbmV3IFVzZXJQcm9maWxlQXBpKHRoaXMuYXBpU2VydmljZS5nZXRJbnN0YW5jZSgpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3Byb2ZpbGVBcGk7XG4gICAgfVxuXG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSBhcGlTZXJ2aWNlOiBBbGZyZXNjb0FwaVNlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBsb2dTZXJ2aWNlOiBMb2dTZXJ2aWNlKSB7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBpbmZvcm1hdGlvbiBhYm91dCB0aGUgY3VycmVudCB1c2VyLlxuICAgICAqIEByZXR1cm5zIFVzZXIgaW5mb3JtYXRpb24gb2JqZWN0XG4gICAgICovXG4gICAgZ2V0Q3VycmVudFVzZXJJbmZvKCk6IE9ic2VydmFibGU8QnBtVXNlck1vZGVsPiB7XG4gICAgICAgIHJldHVybiBmcm9tKHRoaXMucHJvZmlsZUFwaS5nZXRQcm9maWxlKCkpXG4gICAgICAgICAgICAucGlwZShcbiAgICAgICAgICAgICAgICBtYXAoKHVzZXJSZXByZXNlbnRhdGlvbjogVXNlclJlcHJlc2VudGF0aW9uKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQnBtVXNlck1vZGVsKHVzZXJSZXByZXNlbnRhdGlvbik7XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgY2F0Y2hFcnJvcigoZXJyKSA9PiB0aGlzLmhhbmRsZUVycm9yKGVycikpXG4gICAgICAgICAgICApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGN1cnJlbnQgdXNlcidzIHByb2ZpbGUgaW1hZ2UgYXMgYSBVUkwuXG4gICAgICogQHJldHVybnMgVVJMIHN0cmluZ1xuICAgICAqL1xuICAgIGdldEN1cnJlbnRVc2VyUHJvZmlsZUltYWdlKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLnByb2ZpbGVBcGkuZ2V0UHJvZmlsZVBpY3R1cmVVcmwoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaHJvdyB0aGUgZXJyb3JcbiAgICAgKiBAcGFyYW0gZXJyb3JcbiAgICAgKi9cbiAgICBwcml2YXRlIGhhbmRsZUVycm9yKGVycm9yOiBhbnkpIHtcbiAgICAgICAgLy8gaW4gYSByZWFsIHdvcmxkIGFwcCwgd2UgbWF5IHNlbmQgdGhlIGVycm9yIHRvIHNvbWUgcmVtb3RlIGxvZ2dpbmcgaW5mcmFzdHJ1Y3R1cmVcbiAgICAgICAgLy8gaW5zdGVhZCBvZiBqdXN0IGxvZ2dpbmcgaXQgdG8gdGhlIGNvbnNvbGVcbiAgICAgICAgdGhpcy5sb2dTZXJ2aWNlLmVycm9yKGVycm9yKTtcbiAgICAgICAgcmV0dXJuIHRocm93RXJyb3IoZXJyb3IgfHwgJ1NlcnZlciBlcnJvcicpO1xuICAgIH1cblxufVxuIl19