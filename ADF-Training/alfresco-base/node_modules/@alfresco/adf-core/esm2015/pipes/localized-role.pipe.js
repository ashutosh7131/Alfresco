/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Pipe } from '@angular/core';
import { TranslationService } from '../services/translation.service';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '../services/translation.service';
export class LocalizedRolePipe {
    constructor(translationService) {
        this.translationService = translationService;
    }
    transform(value) {
        if (value) {
            const key = `ADF.ROLES.${value.toUpperCase()}`;
            const translation = this.translationService.instant(key);
            if (translation) {
                return translation;
            }
        }
        return value;
    }
}
LocalizedRolePipe.ɵfac = function LocalizedRolePipe_Factory(t) { return new (t || LocalizedRolePipe)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.TranslationService)); };
LocalizedRolePipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "adfLocalizedRole", type: LocalizedRolePipe, pure: true });
LocalizedRolePipe.ctorParameters = () => [
    { type: TranslationService }
];
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(LocalizedRolePipe, [{
        type: Pipe,
        args: [{
                name: 'adfLocalizedRole'
            }]
    }], function () { return [{ type: ɵngcc1.TranslationService }]; }, null); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibG9jYWxpemVkLXJvbGUucGlwZS5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vaG9tZS90cmF2aXMvYnVpbGQvQWxmcmVzY28vYWxmcmVzY28tbmcyLWNvbXBvbmVudHMvbGliL2NvcmUvcGlwZXMvbG9jYWxpemVkLXJvbGUucGlwZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBRUgsT0FBTyxFQUFFLElBQUksRUFBaUIsTUFBTSxlQUFlLENBQUM7QUFDcEQsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0saUNBQWlDLENBQUM7OztBQUtyRSxNQUFNLE9BQU8saUJBQWlCO0FBQUcsSUFDN0IsWUFBb0Isa0JBQXNDO0FBQzlELFFBRHdCLHVCQUFrQixHQUFsQixrQkFBa0IsQ0FBb0I7QUFBQyxJQUMzRCxDQUFDO0FBQ0wsSUFDSSxTQUFTLENBQUMsS0FBYTtBQUFJLFFBQ3ZCLElBQUksS0FBSyxFQUFFO0FBQ25CLFlBQVksTUFBTSxHQUFHLEdBQUcsYUFBYSxLQUFLLENBQUMsV0FBVyxFQUFFLEVBQUUsQ0FBQztBQUMzRCxZQUFZLE1BQU0sV0FBVyxHQUFHLElBQUksQ0FBQyxrQkFBa0IsQ0FBQyxPQUFPLENBQUMsR0FBRyxDQUFDLENBQUM7QUFDckUsWUFDWSxJQUFJLFdBQVcsRUFBRTtBQUM3QixnQkFBZ0IsT0FBTyxXQUFXLENBQUM7QUFDbkMsYUFBYTtBQUNiLFNBQVM7QUFDVCxRQUFRLE9BQU8sS0FBSyxDQUFDO0FBQ3JCLElBQUksQ0FBQztBQUNMOzZDQWxCQyxJQUFJLFNBQUMsa0JBQ0YsSUFBSSxFQUFFLGtCQUFrQixjQUMzQjtpSEFDSTtBQUFDO0FBQTJDLFlBTHhDLGtCQUFrQjtBQUFHOzs7Ozs7bUZBQUU7QUFBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IFBpcGUsIFBpcGVUcmFuc2Zvcm0gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFRyYW5zbGF0aW9uU2VydmljZSB9IGZyb20gJy4uL3NlcnZpY2VzL3RyYW5zbGF0aW9uLnNlcnZpY2UnO1xuXG5AUGlwZSh7XG4gICAgbmFtZTogJ2FkZkxvY2FsaXplZFJvbGUnXG59KVxuZXhwb3J0IGNsYXNzIExvY2FsaXplZFJvbGVQaXBlIGltcGxlbWVudHMgUGlwZVRyYW5zZm9ybSB7XG4gICAgY29uc3RydWN0b3IocHJpdmF0ZSB0cmFuc2xhdGlvblNlcnZpY2U6IFRyYW5zbGF0aW9uU2VydmljZSkge1xuICAgIH1cblxuICAgIHRyYW5zZm9ybSh2YWx1ZTogc3RyaW5nKTogYW55IHtcbiAgICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSBgQURGLlJPTEVTLiR7dmFsdWUudG9VcHBlckNhc2UoKX1gO1xuICAgICAgICAgICAgY29uc3QgdHJhbnNsYXRpb24gPSB0aGlzLnRyYW5zbGF0aW9uU2VydmljZS5pbnN0YW50KGtleSk7XG5cbiAgICAgICAgICAgIGlmICh0cmFuc2xhdGlvbikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cmFuc2xhdGlvbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxufVxuIl19