/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { UserPreferencesService, UserPreferenceValues } from '../../../../../../services/user-preferences.service';
import { MomentDateAdapter } from '../../../../../../utils/moment-date-adapter';
import { MOMENT_DATE_FORMATS } from '../../../../../../utils/moment-date-formats.model';
import { Component, Input } from '@angular/core';
import { DateAdapter, MAT_DATE_FORMATS } from '@angular/material/core';
import moment from 'moment-es6';
import { DynamicTableModel } from './../../dynamic-table.widget.model';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/material/core';
import * as ɵngcc2 from '../../../../../../services/user-preferences.service';
import * as ɵngcc3 from '@angular/material/form-field';
import * as ɵngcc4 from '@angular/material/input';
import * as ɵngcc5 from '@angular/material/datepicker';
import * as ɵngcc6 from '@angular/common';

function DateEditorComponent_mat_datepicker_toggle_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "mat-datepicker-toggle", 5);
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext();
    const _r1 = ɵngcc0.ɵɵreference(7);
    ɵngcc0.ɵɵproperty("for", _r1);
} }
const ɵ0 = MOMENT_DATE_FORMATS;
export class DateEditorComponent {
    constructor(dateAdapter, userPreferencesService) {
        this.dateAdapter = dateAdapter;
        this.userPreferencesService = userPreferencesService;
        this.DATE_FORMAT = 'DD-MM-YYYY';
        this.onDestroy$ = new Subject();
    }
    ngOnInit() {
        this.userPreferencesService
            .select(UserPreferenceValues.Locale)
            .pipe(takeUntil(this.onDestroy$))
            .subscribe(locale => this.dateAdapter.setLocale(locale));
        const momentDateAdapter = this.dateAdapter;
        momentDateAdapter.overrideDisplayFormat = this.DATE_FORMAT;
        this.value = moment(this.table.getCellValue(this.row, this.column), this.DATE_FORMAT);
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
    onDateChanged(newDateValue) {
        if (newDateValue && newDateValue.value) {
            const momentDate = moment(newDateValue.value, this.DATE_FORMAT, true);
            if (!momentDate.isValid()) {
                this.row.value[this.column.id] = newDateValue.value;
            }
            else {
                this.row.value[this.column.id] = `${momentDate.format('YYYY-MM-DD')}T00:00:00.000Z`;
                this.table.flushValue();
            }
        }
        else {
            this.row.value[this.column.id] = '';
        }
    }
}
DateEditorComponent.ɵfac = function DateEditorComponent_Factory(t) { return new (t || DateEditorComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.DateAdapter), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.UserPreferencesService)); };
DateEditorComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: DateEditorComponent, selectors: [["adf-date-editor"]], inputs: { table: "table", row: "row", column: "column" }, features: [ɵngcc0.ɵɵProvidersFeature([
            { provide: DateAdapter, useClass: MomentDateAdapter },
            { provide: MAT_DATE_FORMATS, useValue: ɵ0 }
        ])], decls: 8, vars: 10, consts: [[1, "adf-date-editor"], ["matInput", "", "id", "dateInput", "type", "text", 3, "matDatepicker", "value", "id", "required", "disabled", "focusout", "dateChange"], ["matSuffix", "", "class", "adf-date-editor-button", 3, "for", 4, "ngIf"], [3, "touchUi"], ["datePicker", ""], ["matSuffix", "", 1, "adf-date-editor-button", 3, "for"]], template: function DateEditorComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div");
        ɵngcc0.ɵɵelementStart(1, "mat-form-field", 0);
        ɵngcc0.ɵɵelementStart(2, "label");
        ɵngcc0.ɵɵtext(3);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(4, "input", 1);
        ɵngcc0.ɵɵlistener("focusout", function DateEditorComponent_Template_input_focusout_4_listener($event) { return ctx.onDateChanged($event.srcElement); })("dateChange", function DateEditorComponent_Template_input_dateChange_4_listener($event) { return ctx.onDateChanged($event); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(5, DateEditorComponent_mat_datepicker_toggle_5_Template, 1, 1, "mat-datepicker-toggle", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(6, "mat-datepicker", 3, 4);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        const _r1 = ɵngcc0.ɵɵreference(7);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵattribute("for", ctx.column.id);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate2("", ctx.column.name, " (", ctx.DATE_FORMAT, ")");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("matDatepicker", _r1)("value", ctx.value)("id", ctx.column.id)("required", ctx.column.required)("disabled", !ctx.column.editable);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.column.editable);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("touchUi", true);
    } }, directives: [ɵngcc3.MatFormField, ɵngcc4.MatInput, ɵngcc5.MatDatepickerInput, ɵngcc6.NgIf, ɵngcc5.MatDatepicker, ɵngcc5.MatDatepickerToggle, ɵngcc3.MatSuffix], styles: [".adf-date-editor[_ngcontent-%COMP%]{width:100%}.adf-date-editor-button[_ngcontent-%COMP%]{position:relative;top:25px}"] });
DateEditorComponent.ctorParameters = () => [
    { type: DateAdapter },
    { type: UserPreferencesService }
];
DateEditorComponent.propDecorators = {
    table: [{ type: Input }],
    row: [{ type: Input }],
    column: [{ type: Input }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(DateEditorComponent, [{
        type: Component,
        args: [{
                selector: 'adf-date-editor',
                template: "<div>\n    <mat-form-field class=\"adf-date-editor\">\n        <label [attr.for]=\"column.id\">{{column.name}} ({{DATE_FORMAT}})</label>\n        <input matInput\n            id=\"dateInput\"\n            type=\"text\"\n            [matDatepicker]=\"datePicker\"\n            [value]=\"value\"\n            [id]=\"column.id\"\n            [required]=\"column.required\"\n            [disabled]=\"!column.editable\"\n            (focusout)=\"onDateChanged($any($event).srcElement)\"\n            (dateChange)=\"onDateChanged($event)\">\n        <mat-datepicker-toggle  *ngIf=\"column.editable\" matSuffix [for]=\"datePicker\" class=\"adf-date-editor-button\" ></mat-datepicker-toggle>\n    </mat-form-field>\n    <mat-datepicker #datePicker [touchUi]=\"true\"></mat-datepicker>\n</div>\n",
                providers: [
                    { provide: DateAdapter, useClass: MomentDateAdapter },
                    { provide: MAT_DATE_FORMATS, useValue: ɵ0 }
                ],
                styles: [".adf-date-editor{width:100%}.adf-date-editor-button{position:relative;top:25px}"]
            }]
    }], function () { return [{ type: ɵngcc1.DateAdapter }, { type: ɵngcc2.UserPreferencesService }]; }, { table: [{
            type: Input
        }], row: [{
            type: Input
        }], column: [{
            type: Input
        }] }); })();
export { ɵ0 };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZGF0ZS5lZGl0b3IuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL2hvbWUvdHJhdmlzL2J1aWxkL0FsZnJlc2NvL2FsZnJlc2NvLW5nMi1jb21wb25lbnRzL2xpYi9jb3JlL2Zvcm0vY29tcG9uZW50cy93aWRnZXRzL2R5bmFtaWMtdGFibGUvZWRpdG9ycy9kYXRlL2RhdGUuZWRpdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFJSCxPQUFPLEVBQUUsc0JBQXNCLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSxxREFBcUQsQ0FBQztBQUVuSCxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSw2Q0FBNkMsQ0FBQztBQUNoRixPQUFPLEVBQUUsbUJBQW1CLEVBQUUsTUFBTSxtREFBbUQsQ0FBQztBQUN4RixPQUFPLEVBQUUsU0FBUyxFQUFFLEtBQUssRUFBcUIsTUFBTSxlQUFlLENBQUM7QUFDcEUsT0FBTyxFQUFFLFdBQVcsRUFBRSxnQkFBZ0IsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBRXZFLE9BQU8sTUFBTSxNQUFNLFlBQVksQ0FBQztBQUloQyxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxvQ0FBb0MsQ0FBQztBQUN2RSxPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sTUFBTSxDQUFDO0FBQy9CLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxnQkFBZ0IsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7OztBQUMzQyxXQU04QyxtQkFBbUI7QUFHakUsTUFBTSxPQUFPLG1CQUFtQjtBQUFHLElBb0IvQixZQUFvQixXQUFnQyxFQUNoQyxzQkFBOEM7QUFDdEUsUUFGd0IsZ0JBQVcsR0FBWCxXQUFXLENBQXFCO0FBQUMsUUFDakMsMkJBQXNCLEdBQXRCLHNCQUFzQixDQUF3QjtBQUFDLFFBbkJuRSxnQkFBVyxHQUFXLFlBQVksQ0FBQztBQUN2QyxRQWVZLGVBQVUsR0FBRyxJQUFJLE9BQU8sRUFBVyxDQUFDO0FBQ2hELElBR0ksQ0FBQztBQUNMLElBQ0ksUUFBUTtBQUNaLFFBQVEsSUFBSSxDQUFDLHNCQUFzQjtBQUNuQyxhQUFhLE1BQU0sQ0FBQyxvQkFBb0IsQ0FBQyxNQUFNLENBQUM7QUFDaEQsYUFBYSxJQUFJLENBQUMsU0FBUyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsQ0FBQztBQUM3QyxhQUFhLFNBQVMsQ0FBQyxNQUFNLENBQUMsRUFBRSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsU0FBUyxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUM7QUFDckUsUUFDUSxNQUFNLGlCQUFpQixHQUF1QixJQUFJLENBQUMsV0FBVyxDQUFDO0FBQ3ZFLFFBQVEsaUJBQWlCLENBQUMscUJBQXFCLEdBQUcsSUFBSSxDQUFDLFdBQVcsQ0FBQztBQUNuRSxRQUNRLElBQUksQ0FBQyxLQUFLLEdBQUcsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztBQUM5RixJQUFJLENBQUM7QUFDTCxJQUNJLFdBQVc7QUFDZixRQUFRLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ25DLFFBQVEsSUFBSSxDQUFDLFVBQVUsQ0FBQyxRQUFRLEVBQUUsQ0FBQztBQUNuQyxJQUFJLENBQUM7QUFDTCxJQUNJLGFBQWEsQ0FBQyxZQUE2RDtBQUMvRSxRQUFRLElBQUksWUFBWSxJQUFJLFlBQVksQ0FBQyxLQUFLLEVBQUU7QUFDaEQsWUFDWSxNQUFNLFVBQVUsR0FBRyxNQUFNLENBQUMsWUFBWSxDQUFDLEtBQUssRUFBRSxJQUFJLENBQUMsV0FBVyxFQUFFLElBQUksQ0FBQyxDQUFDO0FBQ2xGLFlBQ1ksSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPLEVBQUUsRUFBRTtBQUN2QyxnQkFBZ0IsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsR0FBSSxZQUFZLENBQUMsS0FBSyxDQUFDO0FBQ3JFLGFBQWE7QUFBQyxpQkFBSztBQUNuQixnQkFBZ0IsSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsR0FBRyxHQUFHLFVBQVUsQ0FBQyxNQUFNLENBQUMsWUFBWSxDQUFDLGdCQUFnQixDQUFDO0FBQ3BHLGdCQUFnQixJQUFJLENBQUMsS0FBSyxDQUFDLFVBQVUsRUFBRSxDQUFDO0FBQ3hDLGFBQWE7QUFDYixTQUFTO0FBQUMsYUFBSztBQUNmLFlBQ1ksSUFBSSxDQUFDLEdBQUcsQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQUMsR0FBRyxFQUFFLENBQUM7QUFDaEQsU0FBUztBQUNULElBQUksQ0FBQztBQUNMOytDQWpFQyxTQUFTLFNBQUMsa0JBQ1AsUUFBUSxFQUFFLGlCQUFpQixrQkFDM0I7Ozs7eVhBQWlDLGtCQUNqQyxTQUFTLEVBQUUsc0JBQ1AsRUFBQyxPQUFPLEVBQUU7R0FBVyxFQUFFLFFBQVEsRUFBRSxpQkFBaUIsRUFBQztlQUNuRCxFQUFDLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxRQUFRO0NBQXFCLEVBQUMsa0JBQUM7Ozs0Q0FFbEU7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OFNBQ0k7QUFBQztBQUE2QyxZQWxCMUMsV0FBVztBQUFJLFlBTGYsc0JBQXNCO0FBQUc7QUFBRztBQUF1QyxvQkE2QnZFLEtBQUs7QUFDUixrQkFFRyxLQUFLO0FBQ1IscUJBRUcsS0FBSztBQUNUOzs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFBQztBQUFlIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogdHNsaW50OmRpc2FibGU6Y29tcG9uZW50LXNlbGVjdG9yICAqL1xuXG5pbXBvcnQgeyBVc2VyUHJlZmVyZW5jZXNTZXJ2aWNlLCBVc2VyUHJlZmVyZW5jZVZhbHVlcyB9IGZyb20gJy4uLy4uLy4uLy4uLy4uLy4uL3NlcnZpY2VzL3VzZXItcHJlZmVyZW5jZXMuc2VydmljZSc7XG5cbmltcG9ydCB7IE1vbWVudERhdGVBZGFwdGVyIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vLi4vdXRpbHMvbW9tZW50LWRhdGUtYWRhcHRlcic7XG5pbXBvcnQgeyBNT01FTlRfREFURV9GT1JNQVRTIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vLi4vdXRpbHMvbW9tZW50LWRhdGUtZm9ybWF0cy5tb2RlbCc7XG5pbXBvcnQgeyBDb21wb25lbnQsIElucHV0LCBPbkluaXQsIE9uRGVzdHJveSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRGF0ZUFkYXB0ZXIsIE1BVF9EQVRFX0ZPUk1BVFMgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbC9jb3JlJztcbmltcG9ydCB7IE1hdERhdGVwaWNrZXJJbnB1dEV2ZW50IH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwvZGF0ZXBpY2tlcic7XG5pbXBvcnQgbW9tZW50IGZyb20gJ21vbWVudC1lczYnO1xuaW1wb3J0IHsgTW9tZW50IH0gZnJvbSAnbW9tZW50JztcbmltcG9ydCB7IER5bmFtaWNUYWJsZUNvbHVtbiB9IGZyb20gJy4vLi4vLi4vZHluYW1pYy10YWJsZS1jb2x1bW4ubW9kZWwnO1xuaW1wb3J0IHsgRHluYW1pY1RhYmxlUm93IH0gZnJvbSAnLi8uLi8uLi9keW5hbWljLXRhYmxlLXJvdy5tb2RlbCc7XG5pbXBvcnQgeyBEeW5hbWljVGFibGVNb2RlbCB9IGZyb20gJy4vLi4vLi4vZHluYW1pYy10YWJsZS53aWRnZXQubW9kZWwnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2FkZi1kYXRlLWVkaXRvcicsXG4gICAgdGVtcGxhdGVVcmw6ICcuL2RhdGUuZWRpdG9yLmh0bWwnLFxuICAgIHByb3ZpZGVyczogW1xuICAgICAgICB7cHJvdmlkZTogRGF0ZUFkYXB0ZXIsIHVzZUNsYXNzOiBNb21lbnREYXRlQWRhcHRlcn0sXG4gICAgICAgIHtwcm92aWRlOiBNQVRfREFURV9GT1JNQVRTLCB1c2VWYWx1ZTogTU9NRU5UX0RBVEVfRk9STUFUU31dLFxuICAgIHN0eWxlVXJsczogWycuL2RhdGUuZWRpdG9yLnNjc3MnXVxufSlcbmV4cG9ydCBjbGFzcyBEYXRlRWRpdG9yQ29tcG9uZW50IGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xuXG4gICAgREFURV9GT1JNQVQ6IHN0cmluZyA9ICdERC1NTS1ZWVlZJztcblxuICAgIHZhbHVlOiBhbnk7XG5cbiAgICBASW5wdXQoKVxuICAgIHRhYmxlOiBEeW5hbWljVGFibGVNb2RlbDtcblxuICAgIEBJbnB1dCgpXG4gICAgcm93OiBEeW5hbWljVGFibGVSb3c7XG5cbiAgICBASW5wdXQoKVxuICAgIGNvbHVtbjogRHluYW1pY1RhYmxlQ29sdW1uO1xuXG4gICAgbWluRGF0ZTogTW9tZW50O1xuICAgIG1heERhdGU6IE1vbWVudDtcblxuICAgIHByaXZhdGUgb25EZXN0cm95JCA9IG5ldyBTdWJqZWN0PGJvb2xlYW4+KCk7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGRhdGVBZGFwdGVyOiBEYXRlQWRhcHRlcjxNb21lbnQ+LFxuICAgICAgICAgICAgICAgIHByaXZhdGUgdXNlclByZWZlcmVuY2VzU2VydmljZTogVXNlclByZWZlcmVuY2VzU2VydmljZSkge1xuICAgIH1cblxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnVzZXJQcmVmZXJlbmNlc1NlcnZpY2VcbiAgICAgICAgICAgIC5zZWxlY3QoVXNlclByZWZlcmVuY2VWYWx1ZXMuTG9jYWxlKVxuICAgICAgICAgICAgLnBpcGUodGFrZVVudGlsKHRoaXMub25EZXN0cm95JCkpXG4gICAgICAgICAgICAuc3Vic2NyaWJlKGxvY2FsZSA9PiB0aGlzLmRhdGVBZGFwdGVyLnNldExvY2FsZShsb2NhbGUpKTtcblxuICAgICAgICBjb25zdCBtb21lbnREYXRlQWRhcHRlciA9IDxNb21lbnREYXRlQWRhcHRlcj4gdGhpcy5kYXRlQWRhcHRlcjtcbiAgICAgICAgbW9tZW50RGF0ZUFkYXB0ZXIub3ZlcnJpZGVEaXNwbGF5Rm9ybWF0ID0gdGhpcy5EQVRFX0ZPUk1BVDtcblxuICAgICAgICB0aGlzLnZhbHVlID0gbW9tZW50KHRoaXMudGFibGUuZ2V0Q2VsbFZhbHVlKHRoaXMucm93LCB0aGlzLmNvbHVtbiksIHRoaXMuREFURV9GT1JNQVQpO1xuICAgIH1cblxuICAgIG5nT25EZXN0cm95KCkge1xuICAgICAgICB0aGlzLm9uRGVzdHJveSQubmV4dCh0cnVlKTtcbiAgICAgICAgdGhpcy5vbkRlc3Ryb3kkLmNvbXBsZXRlKCk7XG4gICAgfVxuXG4gICAgb25EYXRlQ2hhbmdlZChuZXdEYXRlVmFsdWU6IE1hdERhdGVwaWNrZXJJbnB1dEV2ZW50PGFueT4gfCBIVE1MSW5wdXRFbGVtZW50KSB7XG4gICAgICAgIGlmIChuZXdEYXRlVmFsdWUgJiYgbmV3RGF0ZVZhbHVlLnZhbHVlKSB7XG4gICAgICAgICAgICAvKiB2YWxpZGF0ZXMgdGhlIHVzZXIgaW5wdXRzICovXG4gICAgICAgICAgICBjb25zdCBtb21lbnREYXRlID0gbW9tZW50KG5ld0RhdGVWYWx1ZS52YWx1ZSwgdGhpcy5EQVRFX0ZPUk1BVCwgdHJ1ZSk7XG5cbiAgICAgICAgICAgIGlmICghbW9tZW50RGF0ZS5pc1ZhbGlkKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJvdy52YWx1ZVt0aGlzLmNvbHVtbi5pZF0gPSAgbmV3RGF0ZVZhbHVlLnZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJvdy52YWx1ZVt0aGlzLmNvbHVtbi5pZF0gPSBgJHttb21lbnREYXRlLmZvcm1hdCgnWVlZWS1NTS1ERCcpfVQwMDowMDowMC4wMDBaYDtcbiAgICAgICAgICAgICAgICB0aGlzLnRhYmxlLmZsdXNoVmFsdWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8qIHJlbW92ZXMgdGhlIGRhdGUgICovXG4gICAgICAgICAgICB0aGlzLnJvdy52YWx1ZVt0aGlzLmNvbHVtbi5pZF0gPSAnJztcbiAgICAgICAgfVxuICAgIH1cblxufVxuIl19