/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { LogService } from '../../../../../../services/log.service';
import { Component, Input } from '@angular/core';
import { FormService } from './../../../../../services/form.service';
import { DynamicTableModel } from './../../dynamic-table.widget.model';
export class DropdownEditorComponent {
    constructor(formService, logService) {
        this.formService = formService;
        this.logService = logService;
        this.value = null;
        this.options = [];
    }
    ngOnInit() {
        const field = this.table.field;
        if (field) {
            if (this.column.optionType === 'rest') {
                if (this.table.form && this.table.form.taskId) {
                    this.getValuesByTaskId(field);
                }
                else {
                    this.getValuesByProcessDefinitionId(field);
                }
            }
            else {
                this.options = this.column.options || [];
                this.value = this.table.getCellValue(this.row, this.column);
            }
        }
    }
    getValuesByTaskId(field) {
        this.formService
            .getRestFieldValuesColumn(field.form.taskId, field.id, this.column.id)
            .subscribe((dynamicTableColumnOption) => {
            this.column.options = dynamicTableColumnOption || [];
            this.options = this.column.options;
            this.value = this.table.getCellValue(this.row, this.column);
        }, (err) => this.handleError(err));
    }
    getValuesByProcessDefinitionId(field) {
        this.formService
            .getRestFieldValuesColumnByProcessId(field.form.processDefinitionId, field.id, this.column.id)
            .subscribe((dynamicTableColumnOption) => {
            this.column.options = dynamicTableColumnOption || [];
            this.options = this.column.options;
            this.value = this.table.getCellValue(this.row, this.column);
        }, (err) => this.handleError(err));
    }
    onValueChanged(row, column, event) {
        let value = event.value;
        value = column.options.find((opt) => opt.name === value);
        row.value[column.id] = value;
    }
    handleError(error) {
        this.logService.error(error);
    }
}
DropdownEditorComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-dropdown-editor',
                template: "<div class=\"dropdown-editor\">\n    <label [attr.for]=\"column.id\">{{column.name}}</label>\n    <mat-form-field>\n        <mat-select\n            floatPlaceholder=\"never\"\n            class=\"adf-dropdown-editor-select\"\n            [id]=\"column.id\"\n            [(ngModel)]=\"value\"\n            [required]=\"column.required\"\n            [disabled]=\"!column.editable\"\n            (selectionChange)=\"onValueChanged(row, column, $event)\">\n            <mat-option></mat-option>\n            <mat-option *ngFor=\"let opt of options\" [value]=\"opt.name\" [id]=\"opt.id\">{{opt.name}}</mat-option>\n        </mat-select>\n    </mat-form-field>\n</div>\n",
                styles: [".adf-dropdown-editor-select{width:100%}"]
            },] }
];
DropdownEditorComponent.ctorParameters = () => [
    { type: FormService },
    { type: LogService }
];
DropdownEditorComponent.propDecorators = {
    table: [{ type: Input }],
    row: [{ type: Input }],
    column: [{ type: Input }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJvcGRvd24uZWRpdG9yLmpzIiwic291cmNlUm9vdCI6Ii9ob21lL3RyYXZpcy9idWlsZC9BbGZyZXNjby9hbGZyZXNjby1uZzItY29tcG9uZW50cy9saWIvY29yZS8iLCJzb3VyY2VzIjpbImZvcm0vY29tcG9uZW50cy93aWRnZXRzL2R5bmFtaWMtdGFibGUvZWRpdG9ycy9kcm9wZG93bi9kcm9wZG93bi5lZGl0b3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBSUgsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLHdDQUF3QyxDQUFDO0FBQ3BFLE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFVLE1BQU0sZUFBZSxDQUFDO0FBQ3pELE9BQU8sRUFBRSxXQUFXLEVBQUUsTUFBTSx3Q0FBd0MsQ0FBQztBQUlyRSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxvQ0FBb0MsQ0FBQztBQU92RSxNQUFNLE9BQU8sdUJBQXVCO0lBY2hDLFlBQW1CLFdBQXdCLEVBQ3ZCLFVBQXNCO1FBRHZCLGdCQUFXLEdBQVgsV0FBVyxDQUFhO1FBQ3ZCLGVBQVUsR0FBVixVQUFVLENBQVk7UUFiMUMsVUFBSyxHQUFRLElBQUksQ0FBQztRQUNsQixZQUFPLEdBQStCLEVBQUUsQ0FBQztJQWF6QyxDQUFDO0lBRUQsUUFBUTtRQUNKLE1BQU0sS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDO1FBQy9CLElBQUksS0FBSyxFQUFFO1lBQ1AsSUFBSSxJQUFJLENBQUMsTUFBTSxDQUFDLFVBQVUsS0FBSyxNQUFNLEVBQUU7Z0JBQ25DLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLElBQUksSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFO29CQUMzQyxJQUFJLENBQUMsaUJBQWlCLENBQUMsS0FBSyxDQUFDLENBQUM7aUJBQ2pDO3FCQUFNO29CQUNILElBQUksQ0FBQyw4QkFBOEIsQ0FBQyxLQUFLLENBQUMsQ0FBQztpQkFDOUM7YUFDSjtpQkFBTTtnQkFDSCxJQUFJLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxNQUFNLENBQUMsT0FBTyxJQUFJLEVBQUUsQ0FBQztnQkFDekMsSUFBSSxDQUFDLEtBQUssR0FBRyxJQUFJLENBQUMsS0FBSyxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLElBQUksQ0FBQyxNQUFNLENBQUMsQ0FBQzthQUMvRDtTQUNKO0lBQ0wsQ0FBQztJQUVELGlCQUFpQixDQUFDLEtBQUs7UUFDbkIsSUFBSSxDQUFDLFdBQVc7YUFDWCx3QkFBd0IsQ0FDckIsS0FBSyxDQUFDLElBQUksQ0FBQyxNQUFNLEVBQ2pCLEtBQUssQ0FBQyxFQUFFLEVBQ1IsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQ2pCO2FBQ0EsU0FBUyxDQUNOLENBQUMsd0JBQW9ELEVBQUUsRUFBRTtZQUNyRCxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sR0FBRyx3QkFBd0IsSUFBSSxFQUFFLENBQUM7WUFDckQsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQztZQUNuQyxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ2hFLENBQUMsRUFDRCxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FDakMsQ0FBQztJQUNWLENBQUM7SUFFRCw4QkFBOEIsQ0FBQyxLQUFLO1FBQ2hDLElBQUksQ0FBQyxXQUFXO2FBQ1gsbUNBQW1DLENBQ2hDLEtBQUssQ0FBQyxJQUFJLENBQUMsbUJBQW1CLEVBQzlCLEtBQUssQ0FBQyxFQUFFLEVBQ1IsSUFBSSxDQUFDLE1BQU0sQ0FBQyxFQUFFLENBQ2pCO2FBQ0EsU0FBUyxDQUNOLENBQUMsd0JBQW9ELEVBQUUsRUFBRTtZQUNyRCxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sR0FBRyx3QkFBd0IsSUFBSSxFQUFFLENBQUM7WUFDckQsSUFBSSxDQUFDLE9BQU8sR0FBRyxJQUFJLENBQUMsTUFBTSxDQUFDLE9BQU8sQ0FBQztZQUNuQyxJQUFJLENBQUMsS0FBSyxHQUFHLElBQUksQ0FBQyxLQUFLLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxHQUFHLEVBQUUsSUFBSSxDQUFDLE1BQU0sQ0FBQyxDQUFDO1FBQ2hFLENBQUMsRUFDRCxDQUFDLEdBQUcsRUFBRSxFQUFFLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxHQUFHLENBQUMsQ0FDakMsQ0FBQztJQUNWLENBQUM7SUFFRCxjQUFjLENBQUMsR0FBb0IsRUFBRSxNQUEwQixFQUFFLEtBQVU7UUFDdkUsSUFBSSxLQUFLLEdBQTRCLEtBQU0sQ0FBQyxLQUFLLENBQUM7UUFDbEQsS0FBSyxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxHQUFHLENBQUMsSUFBSSxLQUFLLEtBQUssQ0FBQyxDQUFDO1FBQ3pELEdBQUcsQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLEVBQUUsQ0FBQyxHQUFHLEtBQUssQ0FBQztJQUNqQyxDQUFDO0lBRUQsV0FBVyxDQUFDLEtBQVU7UUFDbEIsSUFBSSxDQUFDLFVBQVUsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDakMsQ0FBQzs7O1lBakZKLFNBQVMsU0FBQztnQkFDUCxRQUFRLEVBQUUscUJBQXFCO2dCQUMvQixzcUJBQXFDOzthQUV4Qzs7O1lBVlEsV0FBVztZQUZYLFVBQVU7OztvQkFrQmQsS0FBSztrQkFHTCxLQUFLO3FCQUdMLEtBQUsiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4gLyogdHNsaW50OmRpc2FibGU6Y29tcG9uZW50LXNlbGVjdG9yICAqL1xuXG5pbXBvcnQgeyBMb2dTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vLi4vLi4vLi4vLi4vc2VydmljZXMvbG9nLnNlcnZpY2UnO1xuaW1wb3J0IHsgQ29tcG9uZW50LCBJbnB1dCwgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBGb3JtU2VydmljZSB9IGZyb20gJy4vLi4vLi4vLi4vLi4vLi4vc2VydmljZXMvZm9ybS5zZXJ2aWNlJztcbmltcG9ydCB7IER5bmFtaWNUYWJsZUNvbHVtbk9wdGlvbiB9IGZyb20gJy4vLi4vLi4vZHluYW1pYy10YWJsZS1jb2x1bW4tb3B0aW9uLm1vZGVsJztcbmltcG9ydCB7IER5bmFtaWNUYWJsZUNvbHVtbiB9IGZyb20gJy4vLi4vLi4vZHluYW1pYy10YWJsZS1jb2x1bW4ubW9kZWwnO1xuaW1wb3J0IHsgRHluYW1pY1RhYmxlUm93IH0gZnJvbSAnLi8uLi8uLi9keW5hbWljLXRhYmxlLXJvdy5tb2RlbCc7XG5pbXBvcnQgeyBEeW5hbWljVGFibGVNb2RlbCB9IGZyb20gJy4vLi4vLi4vZHluYW1pYy10YWJsZS53aWRnZXQubW9kZWwnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2FkZi1kcm9wZG93bi1lZGl0b3InLFxuICAgIHRlbXBsYXRlVXJsOiAnLi9kcm9wZG93bi5lZGl0b3IuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJy4vZHJvcGRvd24uZWRpdG9yLnNjc3MnXVxufSlcbmV4cG9ydCBjbGFzcyBEcm9wZG93bkVkaXRvckNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCB7XG5cbiAgICB2YWx1ZTogYW55ID0gbnVsbDtcbiAgICBvcHRpb25zOiBEeW5hbWljVGFibGVDb2x1bW5PcHRpb25bXSA9IFtdO1xuXG4gICAgQElucHV0KClcbiAgICB0YWJsZTogRHluYW1pY1RhYmxlTW9kZWw7XG5cbiAgICBASW5wdXQoKVxuICAgIHJvdzogRHluYW1pY1RhYmxlUm93O1xuXG4gICAgQElucHV0KClcbiAgICBjb2x1bW46IER5bmFtaWNUYWJsZUNvbHVtbjtcblxuICAgIGNvbnN0cnVjdG9yKHB1YmxpYyBmb3JtU2VydmljZTogRm9ybVNlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBsb2dTZXJ2aWNlOiBMb2dTZXJ2aWNlKSB7XG4gICAgfVxuXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkID0gdGhpcy50YWJsZS5maWVsZDtcbiAgICAgICAgaWYgKGZpZWxkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jb2x1bW4ub3B0aW9uVHlwZSA9PT0gJ3Jlc3QnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudGFibGUuZm9ybSAmJiB0aGlzLnRhYmxlLmZvcm0udGFza0lkKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0VmFsdWVzQnlUYXNrSWQoZmllbGQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0VmFsdWVzQnlQcm9jZXNzRGVmaW5pdGlvbklkKGZpZWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IHRoaXMuY29sdW1uLm9wdGlvbnMgfHwgW107XG4gICAgICAgICAgICAgICAgdGhpcy52YWx1ZSA9IHRoaXMudGFibGUuZ2V0Q2VsbFZhbHVlKHRoaXMucm93LCB0aGlzLmNvbHVtbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBnZXRWYWx1ZXNCeVRhc2tJZChmaWVsZCkge1xuICAgICAgICB0aGlzLmZvcm1TZXJ2aWNlXG4gICAgICAgICAgICAuZ2V0UmVzdEZpZWxkVmFsdWVzQ29sdW1uKFxuICAgICAgICAgICAgICAgIGZpZWxkLmZvcm0udGFza0lkLFxuICAgICAgICAgICAgICAgIGZpZWxkLmlkLFxuICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uLmlkXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuc3Vic2NyaWJlKFxuICAgICAgICAgICAgICAgIChkeW5hbWljVGFibGVDb2x1bW5PcHRpb246IER5bmFtaWNUYWJsZUNvbHVtbk9wdGlvbltdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uLm9wdGlvbnMgPSBkeW5hbWljVGFibGVDb2x1bW5PcHRpb24gfHwgW107XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IHRoaXMuY29sdW1uLm9wdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnRhYmxlLmdldENlbGxWYWx1ZSh0aGlzLnJvdywgdGhpcy5jb2x1bW4pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgKGVycikgPT4gdGhpcy5oYW5kbGVFcnJvcihlcnIpXG4gICAgICAgICAgICApO1xuICAgIH1cblxuICAgIGdldFZhbHVlc0J5UHJvY2Vzc0RlZmluaXRpb25JZChmaWVsZCkge1xuICAgICAgICB0aGlzLmZvcm1TZXJ2aWNlXG4gICAgICAgICAgICAuZ2V0UmVzdEZpZWxkVmFsdWVzQ29sdW1uQnlQcm9jZXNzSWQoXG4gICAgICAgICAgICAgICAgZmllbGQuZm9ybS5wcm9jZXNzRGVmaW5pdGlvbklkLFxuICAgICAgICAgICAgICAgIGZpZWxkLmlkLFxuICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uLmlkXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuc3Vic2NyaWJlKFxuICAgICAgICAgICAgICAgIChkeW5hbWljVGFibGVDb2x1bW5PcHRpb246IER5bmFtaWNUYWJsZUNvbHVtbk9wdGlvbltdKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29sdW1uLm9wdGlvbnMgPSBkeW5hbWljVGFibGVDb2x1bW5PcHRpb24gfHwgW107XG4gICAgICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IHRoaXMuY29sdW1uLm9wdGlvbnM7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudmFsdWUgPSB0aGlzLnRhYmxlLmdldENlbGxWYWx1ZSh0aGlzLnJvdywgdGhpcy5jb2x1bW4pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgKGVycikgPT4gdGhpcy5oYW5kbGVFcnJvcihlcnIpXG4gICAgICAgICAgICApO1xuICAgIH1cblxuICAgIG9uVmFsdWVDaGFuZ2VkKHJvdzogRHluYW1pY1RhYmxlUm93LCBjb2x1bW46IER5bmFtaWNUYWJsZUNvbHVtbiwgZXZlbnQ6IGFueSkge1xuICAgICAgICBsZXQgdmFsdWU6IGFueSA9ICg8SFRNTElucHV0RWxlbWVudD4gZXZlbnQpLnZhbHVlO1xuICAgICAgICB2YWx1ZSA9IGNvbHVtbi5vcHRpb25zLmZpbmQoKG9wdCkgPT4gb3B0Lm5hbWUgPT09IHZhbHVlKTtcbiAgICAgICAgcm93LnZhbHVlW2NvbHVtbi5pZF0gPSB2YWx1ZTtcbiAgICB9XG5cbiAgICBoYW5kbGVFcnJvcihlcnJvcjogYW55KSB7XG4gICAgICAgIHRoaXMubG9nU2VydmljZS5lcnJvcihlcnJvcik7XG4gICAgfVxufVxuIl19