/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { ContentService, EXTENDIBLE_COMPONENT, FileUtils, LogService, TranslationService, UploadService, AllowableOperationsEnum } from '@alfresco/adf-core';
import { Component, EventEmitter, forwardRef, Input, Output, ViewEncapsulation, NgZone } from '@angular/core';
import { Subject } from 'rxjs';
import { PermissionModel } from '../../document-list/models/permissions.model';
import { UploadBase } from './base-upload/upload-base';
export class UploadButtonComponent extends UploadBase {
    constructor(uploadService, contentService, translationService, logService, ngZone) {
        super(uploadService, translationService, ngZone);
        this.uploadService = uploadService;
        this.contentService = contentService;
        this.translationService = translationService;
        this.logService = logService;
        this.ngZone = ngZone;
        this.uploadFolders = false;
        this.multipleFiles = false;
        this.tooltip = null;
        this.permissionEvent = new EventEmitter();
        this.hasAllowableOperations = false;
        this.permissionValue = new Subject();
    }
    ngOnInit() {
        this.permissionValue.subscribe((permission) => {
            this.hasAllowableOperations = permission;
        });
    }
    ngOnChanges(changes) {
        const rootFolderId = changes['rootFolderId'];
        if (rootFolderId && rootFolderId.currentValue) {
            this.checkPermission();
        }
    }
    isButtonDisabled() {
        return this.disabled ? true : undefined;
    }
    onFilesAdded($event) {
        const files = FileUtils.toFileArray($event.currentTarget.files);
        if (this.hasAllowableOperations) {
            this.uploadFiles(files);
        }
        else {
            this.permissionEvent.emit(new PermissionModel({ type: 'content', action: 'upload', permission: 'create' }));
        }
        $event.target.value = '';
    }
    onClickUploadButton() {
        if (this.file) {
            const files = [this.file];
            if (this.hasAllowableOperations) {
                this.uploadFiles(files);
            }
            else {
                this.permissionEvent.emit(new PermissionModel({ type: 'content', action: 'upload', permission: 'create' }));
            }
        }
    }
    onDirectoryAdded($event) {
        if (this.hasAllowableOperations) {
            const files = FileUtils.toFileArray($event.currentTarget.files);
            this.uploadFiles(files);
        }
        else {
            this.permissionEvent.emit(new PermissionModel({ type: 'content', action: 'upload', permission: 'create' }));
        }
        $event.target.value = '';
    }
    checkPermission() {
        if (this.rootFolderId) {
            const opts = {
                includeSource: true,
                include: ['allowableOperations']
            };
            this.contentService.getNode(this.rootFolderId, opts).subscribe((res) => this.permissionValue.next(this.nodeHasPermission(res.entry, AllowableOperationsEnum.CREATE)), (error) => {
                if (error && error.error) {
                    this.error.emit({ error: error.error.message });
                }
                else {
                    this.error.emit({ error: 'FILE_UPLOAD.BUTTON.PERMISSION_CHECK_ERROR' });
                }
            });
        }
    }
    nodeHasPermission(node, permission) {
        return this.contentService.hasAllowableOperations(node, permission);
    }
}
UploadButtonComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-upload-button',
                template: "<form class=\"adf-upload-button-file-container\">\n    <!--Files Upload-->\n    <div *ngIf=\"!uploadFolders\">\n\n        <!--Single Files Upload-->\n        <button *ngIf=\"!multipleFiles\"\n            [disabled]=\"isButtonDisabled()\"\n            mat-button\n            (click)=\"uploadSingleFile.click()\">\n            <mat-icon>file_upload</mat-icon>\n            <span id=\"upload-single-file-label\"\n                *ngIf=\"!staticTitle\">{{ 'FILE_UPLOAD.BUTTON.UPLOAD_FILE' | translate }}</span>\n            <span id=\"upload-single-file-label-static\"\n                *ngIf=\"staticTitle\">{{ staticTitle }}</span>\n            <input #uploadSingleFile\n                id=\"upload-single-file\"\n                data-automation-id=\"upload-single-file\"\n                [type]=\"file ? 'button' : 'file'\"\n                name=\"uploadFiles\"\n                accept=\"{{acceptedFilesType}}\"\n                [attr.disabled]=\"isButtonDisabled()\"\n                [title]=\"tooltip\"\n                (change)=\"onFilesAdded($event)\"\n                (click)=\"onClickUploadButton()\">\n        </button>\n\n        <!--Multiple Files Upload-->\n        <button *ngIf=\"multipleFiles\"\n            [disabled]=\"isButtonDisabled()\"\n            mat-button\n            (click)=\"uploadMultipleFiles.click()\">\n            <mat-icon>file_upload</mat-icon>\n\n            <span id=\"upload-multiple-file-label\"\n                *ngIf=\"!staticTitle\">{{ 'FILE_UPLOAD.BUTTON.UPLOAD_FILE' | translate }}</span>\n            <span\n                id=\"upload-multiple-file-label-static\"\n                *ngIf=\"staticTitle\">{{ staticTitle }}</span>\n            <input #uploadMultipleFiles\n                id=\"upload-multiple-files\"\n                data-automation-id=\"upload-multiple-files\"\n                type=\"file\"\n                name=\"uploadFiles\"\n                multiple=\"multiple\"\n                accept=\"{{acceptedFilesType}}\"\n                [attr.disabled]=\"isButtonDisabled()\"\n                [title]=\"tooltip\"\n                (change)=\"onFilesAdded($event)\">\n        </button>\n    </div>\n\n    <!--Folders Upload-->\n    <div *ngIf=\"uploadFolders\">\n        <button\n            [disabled]=\"isButtonDisabled()\"\n            mat-button\n            (click)=\"uploadFolders.click()\">\n            <mat-icon>file_upload</mat-icon>\n            <span id=\"uploadFolder-label\"\n                *ngIf=\"!staticTitle\">{{ 'FILE_UPLOAD.BUTTON.UPLOAD_FOLDER' | translate }}</span>\n            <span id=\"uploadFolder-label-static\"\n                *ngIf=\"staticTitle\">{{ staticTitle }}</span>\n            <input #uploadFolders\n                id=\"uploadFolder\"\n                data-automation-id=\"uploadFolder\"\n                type=\"file\"\n                name=\"uploadFiles\"\n                multiple=\"multiple\"\n                accept=\"{{acceptedFilesType}}\"\n                webkitdirectory directory\n                [attr.disabled]=\"isButtonDisabled()\"\n                [title]=\"tooltip\"\n                (change)=\"onDirectoryAdded($event)\">\n        </button>\n    </div>\n</form>\n",
                viewProviders: [
                    { provide: EXTENDIBLE_COMPONENT, useExisting: forwardRef(() => UploadButtonComponent) }
                ],
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-upload-button-file-container input{display:none}"]
            },] }
];
UploadButtonComponent.ctorParameters = () => [
    { type: UploadService },
    { type: ContentService },
    { type: TranslationService },
    { type: LogService },
    { type: NgZone }
];
UploadButtonComponent.propDecorators = {
    uploadFolders: [{ type: Input }],
    multipleFiles: [{ type: Input }],
    staticTitle: [{ type: Input }],
    tooltip: [{ type: Input }],
    file: [{ type: Input }],
    permissionEvent: [{ type: Output }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidXBsb2FkLWJ1dHRvbi5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiL2hvbWUvdHJhdmlzL2J1aWxkL0FsZnJlc2NvL2FsZnJlc2NvLW5nMi1jb21wb25lbnRzL2xpYi9jb250ZW50LXNlcnZpY2VzL3NyYy8iLCJzb3VyY2VzIjpbImxpYi91cGxvYWQvY29tcG9uZW50cy91cGxvYWQtYnV0dG9uLmNvbXBvbmVudC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7O0dBZUc7QUFFSCxPQUFPLEVBQ0gsY0FBYyxFQUFFLG9CQUFvQixFQUFFLFNBQVMsRUFDL0MsVUFBVSxFQUFpQyxrQkFBa0IsRUFBRSxhQUFhLEVBQUUsdUJBQXVCLEVBQ3hHLE1BQU0sb0JBQW9CLENBQUM7QUFDNUIsT0FBTyxFQUNILFNBQVMsRUFBRSxZQUFZLEVBQUUsVUFBVSxFQUFFLEtBQUssRUFDdkIsTUFBTSxFQUFpQixpQkFBaUIsRUFBRSxNQUFNLEVBQ3RFLE1BQU0sZUFBZSxDQUFDO0FBRXZCLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDL0IsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLDhDQUE4QyxDQUFDO0FBQy9FLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQVd2RCxNQUFNLE9BQU8scUJBQXNCLFNBQVEsVUFBVTtJQThCakQsWUFBc0IsYUFBNEIsRUFDOUIsY0FBOEIsRUFDNUIsa0JBQXNDLEVBQ3RDLFVBQXNCLEVBQ3RCLE1BQWM7UUFDaEMsS0FBSyxDQUFDLGFBQWEsRUFBRSxrQkFBa0IsRUFBRSxNQUFNLENBQUMsQ0FBQztRQUwvQixrQkFBYSxHQUFiLGFBQWEsQ0FBZTtRQUM5QixtQkFBYyxHQUFkLGNBQWMsQ0FBZ0I7UUFDNUIsdUJBQWtCLEdBQWxCLGtCQUFrQixDQUFvQjtRQUN0QyxlQUFVLEdBQVYsVUFBVSxDQUFZO1FBQ3RCLFdBQU0sR0FBTixNQUFNLENBQVE7UUE5QnBDLGtCQUFh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QUFLOzhCQUlMLE1BQU0iLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge1xuICAgIENvbnRlbnRTZXJ2aWNlLCBFWFRFTkRJQkxFX0NPTVBPTkVOVCwgRmlsZVV0aWxzLFxuICAgIExvZ1NlcnZpY2UsIE5vZGVBbGxvd2FibGVPcGVyYXRpb25TdWJqZWN0LCBUcmFuc2xhdGlvblNlcnZpY2UsIFVwbG9hZFNlcnZpY2UsIEFsbG93YWJsZU9wZXJhdGlvbnNFbnVtXG59IGZyb20gJ0BhbGZyZXNjby9hZGYtY29yZSc7XG5pbXBvcnQge1xuICAgIENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBmb3J3YXJkUmVmLCBJbnB1dCxcbiAgICBPbkNoYW5nZXMsIE9uSW5pdCwgT3V0cHV0LCBTaW1wbGVDaGFuZ2VzLCBWaWV3RW5jYXBzdWxhdGlvbiwgTmdab25lXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTm9kZSB9IGZyb20gJ0BhbGZyZXNjby9qcy1hcGknO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgUGVybWlzc2lvbk1vZGVsIH0gZnJvbSAnLi4vLi4vZG9jdW1lbnQtbGlzdC9tb2RlbHMvcGVybWlzc2lvbnMubW9kZWwnO1xuaW1wb3J0IHsgVXBsb2FkQmFzZSB9IGZyb20gJy4vYmFzZS11cGxvYWQvdXBsb2FkLWJhc2UnO1xuXG5AQ29tcG9uZW50KHtcbiAgICBzZWxlY3RvcjogJ2FkZi11cGxvYWQtYnV0dG9uJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vdXBsb2FkLWJ1dHRvbi5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJy4vdXBsb2FkLWJ1dHRvbi5jb21wb25lbnQuc2NzcyddLFxuICAgIHZpZXdQcm92aWRlcnM6IFtcbiAgICAgICAgeyBwcm92aWRlOiBFWFRFTkRJQkxFX0NPTVBPTkVOVCwgdXNlRXhpc3Rpbmc6IGZvcndhcmRSZWYoKCkgPT4gVXBsb2FkQnV0dG9uQ29tcG9uZW50KSB9XG4gICAgXSxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lXG59KVxuZXhwb3J0IGNsYXNzIFVwbG9hZEJ1dHRvbkNvbXBvbmVudCBleHRlbmRzIFVwbG9hZEJhc2UgaW1wbGVtZW50cyBPbkluaXQsIE9uQ2hhbmdlcywgTm9kZUFsbG93YWJsZU9wZXJhdGlvblN1YmplY3Qge1xuXG4gICAgLyoqIEFsbG93cy9kaXNhbGxvd3MgdXBsb2FkIGZvbGRlcnMgKG9ubHkgZm9yIENocm9tZSkuICovXG4gICAgQElucHV0KClcbiAgICB1cGxvYWRGb2xkZXJzOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICAvKiogQWxsb3dzL2Rpc2FsbG93cyBtdWx0aXBsZSBmaWxlcyAqL1xuICAgIEBJbnB1dCgpXG4gICAgbXVsdGlwbGVGaWxlczogYm9vbGVhbiA9IGZhbHNlO1xuXG4gICAgLyoqIERlZmluZXMgdGhlIHRleHQgb2YgdGhlIHVwbG9hZCBidXR0b24uICovXG4gICAgQElucHV0KClcbiAgICBzdGF0aWNUaXRsZTogc3RyaW5nO1xuXG4gICAgLyoqIEN1c3RvbSB0b29sdGlwIHRleHQuICovXG4gICAgQElucHV0KClcbiAgICB0b29sdGlwOiBzdHJpbmcgPSBudWxsO1xuXG4gICAgLyoqIEN1c3RvbSBhZGRlZCBmaWxlLiBUaGUgdXBsb2FkIGJ1dHRvbiB0eXBlIHdpbGwgYmUgJ2J1dHRvbicgaW5zdGVhZCBvZiAnZmlsZScgKi9cbiAgICBASW5wdXQoKVxuICAgIGZpbGU6IEZpbGU7XG5cbiAgICAvKiogRW1pdHRlZCB3aGVuIGNyZWF0ZSBwZXJtaXNzaW9uIGlzIG1pc3NpbmcuICovXG4gICAgQE91dHB1dCgpXG4gICAgcGVybWlzc2lvbkV2ZW50OiBFdmVudEVtaXR0ZXI8UGVybWlzc2lvbk1vZGVsPiA9IG5ldyBFdmVudEVtaXR0ZXI8UGVybWlzc2lvbk1vZGVsPigpO1xuXG4gICAgcHJpdmF0ZSBoYXNBbGxvd2FibGVPcGVyYXRpb25zOiBib29sZWFuID0gZmFsc2U7XG5cbiAgICBwcm90ZWN0ZWQgcGVybWlzc2lvblZhbHVlOiBTdWJqZWN0PGJvb2xlYW4+ID0gbmV3IFN1YmplY3Q8Ym9vbGVhbj4oKTtcblxuICAgIGNvbnN0cnVjdG9yKHByb3RlY3RlZCB1cGxvYWRTZXJ2aWNlOiBVcGxvYWRTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHByaXZhdGUgY29udGVudFNlcnZpY2U6IENvbnRlbnRTZXJ2aWNlLFxuICAgICAgICAgICAgICAgIHByb3RlY3RlZCB0cmFuc2xhdGlvblNlcnZpY2U6IFRyYW5zbGF0aW9uU2VydmljZSxcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgbG9nU2VydmljZTogTG9nU2VydmljZSxcbiAgICAgICAgICAgICAgICBwcm90ZWN0ZWQgbmdab25lOiBOZ1pvbmUpIHtcbiAgICAgICAgc3VwZXIodXBsb2FkU2VydmljZSwgdHJhbnNsYXRpb25TZXJ2aWNlLCBuZ1pvbmUpO1xuICAgIH1cblxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLnBlcm1pc3Npb25WYWx1ZS5zdWJzY3JpYmUoKHBlcm1pc3Npb246IGJvb2xlYW4pID0+IHtcbiAgICAgICAgICAgIHRoaXMuaGFzQWxsb3dhYmxlT3BlcmF0aW9ucyA9IHBlcm1pc3Npb247XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIG5nT25DaGFuZ2VzKGNoYW5nZXM6IFNpbXBsZUNoYW5nZXMpIHtcbiAgICAgICAgY29uc3Qgcm9vdEZvbGRlcklkID0gY2hhbmdlc1sncm9vdEZvbGRlcklkJ107XG4gICAgICAgIGlmIChyb290Rm9sZGVySWQgJiYgcm9vdEZvbGRlcklkLmN1cnJlbnRWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5jaGVja1Blcm1pc3Npb24oKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlzQnV0dG9uRGlzYWJsZWQoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmRpc2FibGVkID8gdHJ1ZSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICBvbkZpbGVzQWRkZWQoJGV2ZW50OiBhbnkpOiB2b2lkIHtcbiAgICAgICAgY29uc3QgZmlsZXM6IEZpbGVbXSA9IEZpbGVVdGlscy50b0ZpbGVBcnJheSgkZXZlbnQuY3VycmVudFRhcmdldC5maWxlcyk7XG5cbiAgICAgICAgaWYgKHRoaXMuaGFzQWxsb3dhYmxlT3BlcmF0aW9ucykge1xuICAgICAgICAgICAgdGhpcy51cGxvYWRGaWxlcyhmaWxlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnBlcm1pc3Npb25FdmVudC5lbWl0KG5ldyBQZXJtaXNzaW9uTW9kZWwoeyB0eXBlOiAnY29udGVudCcsIGFjdGlvbjogJ3VwbG9hZCcsIHBlcm1pc3Npb246ICdjcmVhdGUnIH0pKTtcbiAgICAgICAgfVxuICAgICAgICAvLyByZXNldCB0aGUgdmFsdWUgb2YgdGhlIGlucHV0IGZpbGVcbiAgICAgICAgJGV2ZW50LnRhcmdldC52YWx1ZSA9ICcnO1xuICAgIH1cblxuICAgIG9uQ2xpY2tVcGxvYWRCdXR0b24oKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmZpbGUpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpbGVzOiBGaWxlW10gPSBbdGhpcy5maWxlXTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuaGFzQWxsb3dhYmxlT3BlcmF0aW9ucykge1xuICAgICAgICAgICAgICAgIHRoaXMudXBsb2FkRmlsZXMoZmlsZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLnBlcm1pc3Npb25FdmVudC5lbWl0KG5ldyBQZXJtaXNzaW9uTW9kZWwoeyB0eXBlOiAnY29udGVudCcsIGFjdGlvbjogJ3VwbG9hZCcsIHBlcm1pc3Npb246ICdjcmVhdGUnIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uRGlyZWN0b3J5QWRkZWQoJGV2ZW50OiBhbnkpOiB2b2lkIHtcbiAgICAgICAgaWYgKHRoaXMuaGFzQWxsb3dhYmxlT3BlcmF0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgZmlsZXM6IEZpbGVbXSA9IEZpbGVVdGlscy50b0ZpbGVBcnJheSgkZXZlbnQuY3VycmVudFRhcmdldC5maWxlcyk7XG4gICAgICAgICAgICB0aGlzLnVwbG9hZEZpbGVzKGZpbGVzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMucGVybWlzc2lvbkV2ZW50LmVtaXQobmV3IFBlcm1pc3Npb25Nb2RlbCh7IHR5cGU6ICdjb250ZW50JywgYWN0aW9uOiAndXBsb2FkJywgcGVybWlzc2lvbjogJ2NyZWF0ZScgfSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIHJlc2V0IHRoZSB2YWx1ZSBvZiB0aGUgaW5wdXQgZmlsZVxuICAgICAgICAkZXZlbnQudGFyZ2V0LnZhbHVlID0gJyc7XG4gICAgfVxuXG4gICAgY2hlY2tQZXJtaXNzaW9uKCkge1xuICAgICAgICBpZiAodGhpcy5yb290Rm9sZGVySWQpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdHM6IGFueSA9IHtcbiAgICAgICAgICAgICAgICBpbmNsdWRlU291cmNlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGluY2x1ZGU6IFsnYWxsb3dhYmxlT3BlcmF0aW9ucyddXG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICB0aGlzLmNvbnRlbnRTZXJ2aWNlLmdldE5vZGUodGhpcy5yb290Rm9sZGVySWQsIG9wdHMpLnN1YnNjcmliZShcbiAgICAgICAgICAgICAgICAocmVzKSA9PiB0aGlzLnBlcm1pc3Npb25WYWx1ZS5uZXh0KHRoaXMubm9kZUhhc1Blcm1pc3Npb24ocmVzLmVudHJ5LCBBbGxvd2FibGVPcGVyYXRpb25zRW51bS5DUkVBVEUpKSxcbiAgICAgICAgICAgICAgICAoZXJyb3I6IHsgZXJyb3I6IEVycm9yIH0pID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVycm9yICYmIGVycm9yLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yLmVtaXQoeyBlcnJvcjogZXJyb3IuZXJyb3IubWVzc2FnZSB9IGFzIGFueSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVycm9yLmVtaXQoeyBlcnJvcjogJ0ZJTEVfVVBMT0FELkJVVFRPTi5QRVJNSVNTSU9OX0NIRUNLX0VSUk9SJ30gYXMgYW55KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBub2RlSGFzUGVybWlzc2lvbihub2RlOiBOb2RlLCBwZXJtaXNzaW9uOiBBbGxvd2FibGVPcGVyYXRpb25zRW51bSB8IHN0cmluZyk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5jb250ZW50U2VydmljZS5oYXNBbGxvd2FibGVPcGVyYXRpb25zKG5vZGUsIHBlcm1pc3Npb24pO1xuICAgIH1cbn1cbiJdfQ==