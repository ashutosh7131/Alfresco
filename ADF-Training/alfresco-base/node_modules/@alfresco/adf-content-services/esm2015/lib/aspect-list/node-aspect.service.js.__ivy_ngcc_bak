import { Injectable } from '@angular/core';
import { AlfrescoApiService, CardViewUpdateService, NodesApiService } from '@alfresco/adf-core';
import { AspectListService } from './aspect-list.service';
import * as i0 from "@angular/core";
import * as i1 from "@alfresco/adf-core";
import * as i2 from "./aspect-list.service";
export class NodeAspectService {
    constructor(alfrescoApiService, nodesApiService, aspectListService, cardViewUpdateService) {
        this.alfrescoApiService = alfrescoApiService;
        this.nodesApiService = nodesApiService;
        this.aspectListService = aspectListService;
        this.cardViewUpdateService = cardViewUpdateService;
    }
    updateNodeAspects(nodeId) {
        this.aspectListService.openAspectListDialog(nodeId).subscribe((aspectList) => {
            this.nodesApiService.updateNode(nodeId, { aspectNames: [...aspectList] }).subscribe((updatedNode) => {
                this.alfrescoApiService.nodeUpdated.next(updatedNode);
                this.cardViewUpdateService.updateNodeAspect(updatedNode);
            });
        });
    }
}
NodeAspectService.ɵprov = i0.ɵɵdefineInjectable({ factory: function NodeAspectService_Factory() { return new NodeAspectService(i0.ɵɵinject(i1.AlfrescoApiService), i0.ɵɵinject(i1.NodesApiService), i0.ɵɵinject(i2.AspectListService), i0.ɵɵinject(i1.CardViewUpdateService)); }, token: NodeAspectService, providedIn: "root" });
NodeAspectService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
NodeAspectService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: NodesApiService },
    { type: AspectListService },
    { type: CardViewUpdateService }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZS1hc3BlY3Quc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIvaG9tZS90cmF2aXMvYnVpbGQvQWxmcmVzY28vYWxmcmVzY28tbmcyLWNvbXBvbmVudHMvbGliL2NvbnRlbnQtc2VydmljZXMvc3JjLyIsInNvdXJjZXMiOlsibGliL2FzcGVjdC1saXN0L25vZGUtYXNwZWN0LnNlcnZpY2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBaUJBLE9BQU8sRUFBRSxVQUFVLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDM0MsT0FBTyxFQUFFLGtCQUFrQixFQUFFLHFCQUFxQixFQUFFLGVBQWUsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBQ2hHLE9BQU8sRUFBRSxpQkFBaUIsRUFBRSxNQUFNLHVCQUF1QixDQUFDOzs7O0FBSzFELE1BQU0sT0FBTyxpQkFBaUI7SUFFMUIsWUFBb0Isa0JBQXNDLEVBQ3RDLGVBQWdDLEVBQ2hDLGlCQUFvQyxFQUNwQyxxQkFBNEM7UUFINUMsdUJBQWtCLEdBQWxCLGtCQUFrQixDQUFvQjtRQUN0QyxvQkFBZSxHQUFmLGVBQWUsQ0FBaUI7UUFDaEMsc0JBQWlCLEdBQWpCLGlCQUFpQixDQUFtQjtRQUNwQywwQkFBcUIsR0FBckIscUJBQXFCLENBQXVCO0lBQ2hFLENBQUM7SUFFRCxpQkFBaUIsQ0FBQyxNQUFjO1FBQzVCLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxvQkFBb0IsQ0FBQyxNQUFNLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxVQUFVLEVBQUUsRUFBRTtZQUN6RSxJQUFJLENBQUMsZUFBZSxDQUFDLFVBQVUsQ0FBQyxNQUFNLEVBQUUsRUFBRSxXQUFXLEVBQUUsQ0FBQyxHQUFHLFVBQVUsQ0FBQyxFQUFFLENBQUMsQ0FBQyxTQUFTLENBQUMsQ0FBQyxXQUFXLEVBQUUsRUFBRTtnQkFDaEcsSUFBSSxDQUFDLGtCQUFrQixDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLENBQUM7Z0JBQ3RELElBQUksQ0FBQyxxQkFBcUIsQ0FBQyxnQkFBZ0IsQ0FBQyxXQUFXLENBQUMsQ0FBQztZQUM3RCxDQUFDLENBQUMsQ0FBQztRQUNQLENBQUMsQ0FBQyxDQUFDO0lBQ1AsQ0FBQzs7OztZQWxCSixVQUFVLFNBQUM7Z0JBQ1IsVUFBVSxFQUFFLE1BQU07YUFDckI7OztZQUxRLGtCQUFrQjtZQUF5QixlQUFlO1lBQzFELGlCQUFpQjtZQURHLHFCQUFxQiIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IEluamVjdGFibGUgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEFsZnJlc2NvQXBpU2VydmljZSwgQ2FyZFZpZXdVcGRhdGVTZXJ2aWNlLCBOb2Rlc0FwaVNlcnZpY2UgfSBmcm9tICdAYWxmcmVzY28vYWRmLWNvcmUnO1xuaW1wb3J0IHsgQXNwZWN0TGlzdFNlcnZpY2UgfSBmcm9tICcuL2FzcGVjdC1saXN0LnNlcnZpY2UnO1xuXG5ASW5qZWN0YWJsZSh7XG4gICAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIE5vZGVBc3BlY3RTZXJ2aWNlIHtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgYWxmcmVzY29BcGlTZXJ2aWNlOiBBbGZyZXNjb0FwaVNlcnZpY2UsXG4gICAgICAgICAgICAgICAgcHJpdmF0ZSBub2Rlc0FwaVNlcnZpY2U6IE5vZGVzQXBpU2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIGFzcGVjdExpc3RTZXJ2aWNlOiBBc3BlY3RMaXN0U2VydmljZSxcbiAgICAgICAgICAgICAgICBwcml2YXRlIGNhcmRWaWV3VXBkYXRlU2VydmljZTogQ2FyZFZpZXdVcGRhdGVTZXJ2aWNlKSB7XG4gICAgfVxuXG4gICAgdXBkYXRlTm9kZUFzcGVjdHMobm9kZUlkOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5hc3BlY3RMaXN0U2VydmljZS5vcGVuQXNwZWN0TGlzdERpYWxvZyhub2RlSWQpLnN1YnNjcmliZSgoYXNwZWN0TGlzdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5ub2Rlc0FwaVNlcnZpY2UudXBkYXRlTm9kZShub2RlSWQsIHsgYXNwZWN0TmFtZXM6IFsuLi5hc3BlY3RMaXN0XSB9KS5zdWJzY3JpYmUoKHVwZGF0ZWROb2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbGZyZXNjb0FwaVNlcnZpY2Uubm9kZVVwZGF0ZWQubmV4dCh1cGRhdGVkTm9kZSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jYXJkVmlld1VwZGF0ZVNlcnZpY2UudXBkYXRlTm9kZUFzcGVjdCh1cGRhdGVkTm9kZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIl19