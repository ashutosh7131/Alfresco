/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Directive, Input, Component, ComponentFactoryResolver, ViewContainerRef } from '@angular/core';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@ngx-translate/core';

const _c0 = function (a0) { return { count: a0 }; };
export class NodeCounterDirective {
    constructor(resolver, viewContainerRef) {
        this.resolver = resolver;
        this.viewContainerRef = viewContainerRef;
    }
    ngOnInit() {
        const componentFactory = this.resolver.resolveComponentFactory(NodeCounterComponent);
        this.componentRef = this.viewContainerRef.createComponent(componentFactory).instance;
        this.componentRef.counter = this.counter;
    }
    ngOnChanges() {
        if (this.componentRef) {
            this.componentRef.counter = this.counter;
        }
    }
}
NodeCounterDirective.ɵfac = function NodeCounterDirective_Factory(t) { return new (t || NodeCounterDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ComponentFactoryResolver), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ViewContainerRef)); };
NodeCounterDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: NodeCounterDirective, selectors: [["", "adf-node-counter", ""]], inputs: { counter: ["adf-node-counter", "counter"] }, features: [ɵngcc0.ɵɵNgOnChangesFeature] });
NodeCounterDirective.ctorParameters = () => [
    { type: ComponentFactoryResolver },
    { type: ViewContainerRef }
];
NodeCounterDirective.propDecorators = {
    counter: [{ type: Input, args: ['adf-node-counter',] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NodeCounterDirective, [{
        type: Directive,
        args: [{
                selector: '[adf-node-counter]'
            }]
    }], function () { return [{ type: ɵngcc0.ComponentFactoryResolver }, { type: ɵngcc0.ViewContainerRef }]; }, { counter: [{
            type: Input,
            args: ['adf-node-counter']
        }] }); })();
export class NodeCounterComponent {
}
NodeCounterComponent.ɵfac = function NodeCounterComponent_Factory(t) { return new (t || NodeCounterComponent)(); };
NodeCounterComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: NodeCounterComponent, selectors: [["adf-node-counter"]], decls: 3, vars: 6, template: function NodeCounterComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div");
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵpipe(2, "translate");
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate(ɵngcc0.ɵɵpipeBind2(2, 1, "NODE_COUNTER.SELECTED_COUNT", ɵngcc0.ɵɵpureFunction1(4, _c0, ctx.counter)));
    } }, pipes: [ɵngcc1.TranslatePipe], encapsulation: 2 });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(NodeCounterComponent, [{
        type: Component,
        args: [{
                selector: 'adf-node-counter',
                template: `
        <div>{{ 'NODE_COUNTER.SELECTED_COUNT' | translate: { count: counter } }}</div>
    `
            }]
    }], null, null); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibm9kZS1jb3VudGVyLmRpcmVjdGl2ZS5qcyIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vLi4vaG9tZS90cmF2aXMvYnVpbGQvQWxmcmVzY28vYWxmcmVzY28tbmcyLWNvbXBvbmVudHMvbGliL2NvbnRlbnQtc2VydmljZXMvc3JjL2xpYi9kaXJlY3RpdmVzL25vZGUtY291bnRlci5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUVILE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUFFLFNBQVMsRUFBcUIsd0JBQXdCLEVBQUUsZ0JBQWdCLEVBQUUsTUFBTSxlQUFlLENBQUM7Ozs7O0FBSzNILE1BQU0sT0FBTyxvQkFBb0I7QUFBRyxJQVFoQyxZQUNZLFFBQWtDLEVBQ25DLGdCQUFrQztBQUM5QyxRQUZhLGFBQVEsR0FBUixRQUFRLENBQTBCO0FBQUMsUUFDcEMscUJBQWdCLEdBQWhCLGdCQUFnQixDQUFrQjtBQUNqRCxJQUFPLENBQUM7QUFDUixJQUNJLFFBQVE7QUFDWixRQUFRLE1BQU0sZ0JBQWdCLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyx1QkFBdUIsQ0FBQyxvQkFBb0IsQ0FBQyxDQUFDO0FBQzdGLFFBQVEsSUFBSSxDQUFDLFlBQVksR0FBRyxJQUFJLENBQUMsZ0JBQWdCLENBQUMsZUFBZSxDQUFDLGdCQUFnQixDQUFDLENBQUMsUUFBUSxDQUFDO0FBQzdGLFFBQVEsSUFBSSxDQUFDLFlBQVksQ0FBQyxPQUFPLEdBQUcsSUFBSSxDQUFDLE9BQU8sQ0FBQztBQUNqRCxJQUFJLENBQUM7QUFDTCxJQUNJLFdBQVc7QUFDZixRQUFRLElBQUksSUFBSSxDQUFDLFlBQVksRUFBRTtBQUMvQixZQUFZLElBQUksQ0FBQyxZQUFZLENBQUMsT0FBTyxHQUFHLElBQUksQ0FBQyxPQUFPLENBQUM7QUFDckQsU0FBUztBQUNULElBQUksQ0FBQztBQUNMO2dEQTNCQyxTQUFTLFNBQUMsa0JBQ1AsUUFBUSxFQUFFLG9CQUFvQixjQUNqQzsrTkFDSTtBQUFDO0FBQThDLFlBTEssd0JBQXdCO0FBQUksWUFBRixnQkFBZ0I7QUFBRztBQUFHO0FBR2xHLHNCQUtGLEtBQUssU0FBQyxrQkFBa0I7QUFDekI7Ozs7Ozs7OztvQkFBRTtBQTRCTixNQUFNLE9BQU8sb0JBQW9CO0FBQ2pDO2dEQVBDLFNBQVMsU0FBQyxrQkFDUCxRQUFRLEVBQUUsa0JBQWtCO2NBQzVCLFFBQVEsRUFBRSw4RkFFVCxjQUNKOzs7Ozs7Ozs7Ozs7Ozs7OzswQkFDSTtBQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgRGlyZWN0aXZlLCBJbnB1dCwgQ29tcG9uZW50LCBPbkluaXQsIE9uQ2hhbmdlcywgQ29tcG9uZW50RmFjdG9yeVJlc29sdmVyLCBWaWV3Q29udGFpbmVyUmVmIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbkBEaXJlY3RpdmUoe1xuICAgIHNlbGVjdG9yOiAnW2FkZi1ub2RlLWNvdW50ZXJdJ1xufSlcbmV4cG9ydCBjbGFzcyBOb2RlQ291bnRlckRpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzIHtcblxuICAgIC8qKiBOdW1iZXIgdG8gZGlzcGxheSBpbiB0aGUgY291bnRlciBiYWRnZSAqL1xuICAgIEBJbnB1dCgnYWRmLW5vZGUtY291bnRlcicpXG4gICAgY291bnRlcjogbnVtYmVyO1xuXG4gICAgY29tcG9uZW50UmVmOiBOb2RlQ291bnRlckNvbXBvbmVudDtcblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwcml2YXRlIHJlc29sdmVyOiBDb21wb25lbnRGYWN0b3J5UmVzb2x2ZXIsXG4gICAgICAgIHB1YmxpYyB2aWV3Q29udGFpbmVyUmVmOiBWaWV3Q29udGFpbmVyUmVmXG4gICAgKSB7fVxuXG4gICAgbmdPbkluaXQoKSB7XG4gICAgICAgIGNvbnN0IGNvbXBvbmVudEZhY3RvcnkgPSB0aGlzLnJlc29sdmVyLnJlc29sdmVDb21wb25lbnRGYWN0b3J5KE5vZGVDb3VudGVyQ29tcG9uZW50KTtcbiAgICAgICAgdGhpcy5jb21wb25lbnRSZWYgPSB0aGlzLnZpZXdDb250YWluZXJSZWYuY3JlYXRlQ29tcG9uZW50KGNvbXBvbmVudEZhY3RvcnkpLmluc3RhbmNlO1xuICAgICAgICB0aGlzLmNvbXBvbmVudFJlZi5jb3VudGVyID0gdGhpcy5jb3VudGVyO1xuICAgIH1cblxuICAgIG5nT25DaGFuZ2VzKCkge1xuICAgICAgICBpZiAodGhpcy5jb21wb25lbnRSZWYpIHtcbiAgICAgICAgICAgIHRoaXMuY29tcG9uZW50UmVmLmNvdW50ZXIgPSB0aGlzLmNvdW50ZXI7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYWRmLW5vZGUtY291bnRlcicsXG4gICAgdGVtcGxhdGU6IGBcbiAgICAgICAgPGRpdj57eyAnTk9ERV9DT1VOVEVSLlNFTEVDVEVEX0NPVU5UJyB8IHRyYW5zbGF0ZTogeyBjb3VudDogY291bnRlciB9IH19PC9kaXY+XG4gICAgYFxufSlcbmV4cG9ydCBjbGFzcyBOb2RlQ291bnRlckNvbXBvbmVudCB7XG4gICAgY291bnRlcjogbnVtYmVyO1xufVxuIl19