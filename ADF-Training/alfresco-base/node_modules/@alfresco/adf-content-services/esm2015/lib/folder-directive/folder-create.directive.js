/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Directive, HostListener, Input, Output, EventEmitter } from '@angular/core';
import { MatDialog } from '@angular/material/dialog';
import { FolderDialogComponent } from '../dialogs/folder.dialog';
import { ContentService } from '@alfresco/adf-core';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/material/dialog';
import * as ɵngcc2 from '@alfresco/adf-core';
const DEFAULT_FOLDER_PARENT_ID = '-my-';
export class FolderCreateDirective {
    constructor(dialogRef, content) {
        this.dialogRef = dialogRef;
        this.content = content;
        this.parentNodeId = DEFAULT_FOLDER_PARENT_ID;
        this.title = null;
        this.nodeType = 'cm:folder';
        this.error = new EventEmitter();
        this.success = new EventEmitter();
    }
    onClick(event) {
        event.preventDefault();
        this.openDialog();
    }
    get dialogConfig() {
        const { DIALOG_WIDTH: width } = FolderCreateDirective;
        const { parentNodeId, title: createTitle, nodeType } = this;
        return {
            data: { parentNodeId, createTitle, nodeType },
            width: `${width}px`
        };
    }
    openDialog() {
        const { dialogRef, dialogConfig, content } = this;
        const dialogInstance = dialogRef.open(FolderDialogComponent, dialogConfig);
        dialogInstance.componentInstance.error.subscribe((error) => {
            this.error.emit(error);
        });
        dialogInstance.componentInstance.success.subscribe((node) => {
            this.success.emit(node);
        });
        dialogInstance.afterClosed().subscribe((node) => {
            if (node) {
                content.folderCreate.next(node);
            }
        });
    }
}
FolderCreateDirective.ɵfac = function FolderCreateDirective_Factory(t) { return new (t || FolderCreateDirective)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.MatDialog), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.ContentService)); };
FolderCreateDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: FolderCreateDirective, selectors: [["", "adf-create-folder", ""]], hostBindings: function FolderCreateDirective_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("click", function FolderCreateDirective_click_HostBindingHandler($event) { return ctx.onClick($event); });
    } }, inputs: { parentNodeId: ["adf-create-folder", "parentNodeId"], title: "title", nodeType: "nodeType" }, outputs: { error: "error", success: "success" } });
FolderCreateDirective.DIALOG_WIDTH = 400;
FolderCreateDirective.ctorParameters = () => [
    { type: MatDialog },
    { type: ContentService }
];
FolderCreateDirective.propDecorators = {
    parentNodeId: [{ type: Input, args: ['adf-create-folder',] }],
    title: [{ type: Input }],
    nodeType: [{ type: Input }],
    error: [{ type: Output }],
    success: [{ type: Output }],
    onClick: [{ type: HostListener, args: ['click', ['$event'],] }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FolderCreateDirective, [{
        type: Directive,
        args: [{
                selector: '[adf-create-folder]'
            }]
    }], function () { return [{ type: ɵngcc1.MatDialog }, { type: ɵngcc2.ContentService }]; }, { parentNodeId: [{
            type: Input,
            args: ['adf-create-folder']
        }], title: [{
            type: Input
        }], nodeType: [{
            type: Input
        }], error: [{
            type: Output
        }], success: [{
            type: Output
        }], onClick: [{
            type: HostListener,
            args: ['click', ['$event']]
        }] }); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZm9sZGVyLWNyZWF0ZS5kaXJlY3RpdmUuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL2hvbWUvdHJhdmlzL2J1aWxkL0FsZnJlc2NvL2FsZnJlc2NvLW5nMi1jb21wb25lbnRzL2xpYi9jb250ZW50LXNlcnZpY2VzL3NyYy9saWIvZm9sZGVyLWRpcmVjdGl2ZS9mb2xkZXItY3JlYXRlLmRpcmVjdGl2ZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBSUgsT0FBTyxFQUFFLFNBQVMsRUFBRSxZQUFZLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxZQUFZLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDckYsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBRXJELE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLDBCQUEwQixDQUFDO0FBQ2pFLE9BQU8sRUFBRSxjQUFjLEVBQUUsTUFBTSxvQkFBb0IsQ0FBQzs7OztBQUVwRCxNQUFNLHdCQUF3QixHQUFHLE1BQU0sQ0FBQztBQUt4QyxNQUFNLE9BQU8scUJBQXFCO0FBQ2xDLElBNEJJLFlBQ1csU0FBb0IsRUFDcEIsT0FBdUI7QUFDbkMsUUFGWSxjQUFTLEdBQVQsU0FBUyxDQUFXO0FBQUMsUUFDckIsWUFBTyxHQUFQLE9BQU8sQ0FBZ0I7QUFDdEMsUUEzQkksaUJBQVksR0FBVyx3QkFBd0IsQ0FBQztBQUNwRCxRQUdJLFVBQUssR0FBVyxJQUFJLENBQUM7QUFDekIsUUFHSSxhQUFRLEdBQUcsV0FBVyxDQUFDO0FBQzNCLFFBR0ksVUFBSyxHQUFzQixJQUFJLFlBQVksRUFBTyxDQUFDO0FBQ3ZELFFBR0ksWUFBTyxHQUF1QixJQUFJLFlBQVksRUFBUSxDQUFDO0FBQzNELElBVU8sQ0FBQztBQUNSLElBVEksT0FBTyxDQUFDLEtBQUs7QUFDakIsUUFBUSxLQUFLLENBQUMsY0FBYyxFQUFFLENBQUM7QUFDL0IsUUFBUSxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7QUFDMUIsSUFBSSxDQUFDO0FBQ0wsSUFNSSxJQUFZLFlBQVk7QUFDNUIsUUFBUSxNQUFNLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBRSxHQUFHLHFCQUFxQixDQUFDO0FBQzlELFFBQVEsTUFBTSxFQUFFLFlBQVksRUFBRSxLQUFLLEVBQUUsV0FBVyxFQUFFLFFBQVEsRUFBRSxHQUFHLElBQUksQ0FBQztBQUNwRSxRQUNRLE9BQU87QUFDZixZQUFZLElBQUksRUFBRSxFQUFFLFlBQVksRUFBRSxXQUFXLEVBQUUsUUFBUSxFQUFFO0FBQ3pELFlBQVksS0FBSyxFQUFFLEdBQUcsS0FBSyxJQUFJO0FBQy9CLFNBQVMsQ0FBQztBQUNWLElBQUksQ0FBQztBQUNMLElBQ1ksVUFBVTtBQUFLLFFBQ25CLE1BQU0sRUFBRSxTQUFTLEVBQUUsWUFBWSxFQUFFLE9BQU8sRUFBRSxHQUFHLElBQUksQ0FBQztBQUMxRCxRQUFRLE1BQU0sY0FBYyxHQUFHLFNBQVMsQ0FBQyxJQUFJLENBQUMscUJBQXFCLEVBQUUsWUFBWSxDQUFDLENBQUM7QUFDbkYsUUFDUSxjQUFjLENBQUMsaUJBQWlCLENBQUMsS0FBSyxDQUFDLFNBQVMsQ0FBQyxDQUFDLEtBQUssRUFBRSxFQUFFO0FBQ25FLFlBQVksSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7QUFDbkMsUUFBUSxDQUFDLENBQUMsQ0FBQztBQUNYLFFBQ1EsY0FBYyxDQUFDLGlCQUFpQixDQUFDLE9BQU8sQ0FBQyxTQUFTLENBQUMsQ0FBQyxJQUFVLEVBQUUsRUFBRTtBQUMxRSxZQUFZLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0FBQ3BDLFFBQVEsQ0FBQyxDQUFDLENBQUM7QUFDWCxRQUNRLGNBQWMsQ0FBQyxXQUFXLEVBQUUsQ0FBQyxTQUFTLENBQUMsQ0FBQyxJQUFVLEVBQUUsRUFBRTtBQUM5RCxZQUFZLElBQUksSUFBSSxFQUFFO0FBQ3RCLGdCQUFnQixPQUFPLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNoRCxhQUFhO0FBQ2IsUUFBUSxDQUFDLENBQUMsQ0FBQztBQUNYLElBQUksQ0FBQztBQUNMOzs7O21LQUFDO0FBN0RVLGtDQUFZLEdBQVcsR0FBRyxDQUFDLEFBRGpDO0FBQUM7RUFITCxTQUFTLFNBQUMscEJBSUssWUFYUCxTQUFTO2FBUWQsUUFBUSxFQUFFLHZCQVJRLFlBR2IsY0FBYztBQUFHO1lBS1MsY0FDbEMsMUJBTjRCO0FBRWIsMkJBU1gsS0FBSyxTQUFDLG1CQUFtQjtBQUN6QixvQkFHQSxLQUFLO0FBQ1IsdUJBR0csS0FBSztBQUNSLG9CQUdHLE1BQU07QUFDVCxzQkFHRyxNQUFNO0FBQ1Qsc0JBRUcsWUFBWSxTQUFDLE9BQU8sRUFBRSxDQUFFLFFBQVEsQ0FBRTtBQUNuQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7b0JBQUU7QUFBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qIHRzbGludDpkaXNhYmxlOm5vLWlucHV0LXJlbmFtZSAgKi9cblxuaW1wb3J0IHsgRGlyZWN0aXZlLCBIb3N0TGlzdGVuZXIsIElucHV0LCBPdXRwdXQsIEV2ZW50RW1pdHRlciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgTWF0RGlhbG9nIH0gZnJvbSAnQGFuZ3VsYXIvbWF0ZXJpYWwvZGlhbG9nJztcbmltcG9ydCB7IE5vZGUgfSBmcm9tICdAYWxmcmVzY28vanMtYXBpJztcbmltcG9ydCB7IEZvbGRlckRpYWxvZ0NvbXBvbmVudCB9IGZyb20gJy4uL2RpYWxvZ3MvZm9sZGVyLmRpYWxvZyc7XG5pbXBvcnQgeyBDb250ZW50U2VydmljZSB9IGZyb20gJ0BhbGZyZXNjby9hZGYtY29yZSc7XG5cbmNvbnN0IERFRkFVTFRfRk9MREVSX1BBUkVOVF9JRCA9ICctbXktJztcblxuQERpcmVjdGl2ZSh7XG4gICAgc2VsZWN0b3I6ICdbYWRmLWNyZWF0ZS1mb2xkZXJdJ1xufSlcbmV4cG9ydCBjbGFzcyBGb2xkZXJDcmVhdGVEaXJlY3RpdmUge1xuICAgIHN0YXRpYyBESUFMT0dfV0lEVEg6IG51bWJlciA9IDQwMDtcblxuICAgIC8qKiBQYXJlbnQgZm9sZGVyIHdoZXJlIHRoZSBuZXcgZm9sZGVyIHdpbGwgYmUgbG9jYXRlZCBhZnRlciBjcmVhdGlvbi4gKi9cbiAgICBASW5wdXQoJ2FkZi1jcmVhdGUtZm9sZGVyJylcbiAgICBwYXJlbnROb2RlSWQ6IHN0cmluZyA9IERFRkFVTFRfRk9MREVSX1BBUkVOVF9JRDtcblxuICAgIC8qKiBUaXRsZSBvZiBmb2xkZXIgY3JlYXRpb24gZGlhbG9nLiAqL1xuICAgIEBJbnB1dCgpXG4gICAgdGl0bGU6IHN0cmluZyA9IG51bGw7XG5cbiAgICAvKiogVHlwZSBvZiBub2RlIHRvIGNyZWF0ZS4gKi9cbiAgICBASW5wdXQoKVxuICAgIG5vZGVUeXBlID0gJ2NtOmZvbGRlcic7XG5cbiAgICAvKiogRW1pdHRlZCB3aGVuIGFuIGVycm9yIG9jY3VycyAoZWcsIGEgZm9sZGVyIHdpdGggc2FtZSBuYW1lIGFscmVhZHkgZXhpc3RzKS4gKi9cbiAgICBAT3V0cHV0KClcbiAgICBlcnJvcjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyPGFueT4oKTtcblxuICAgIC8qKiBFbWl0dGVkIHdoZW4gdGhlIGZvbGRlciBpcyBjcmVhdGVkIHN1Y2Nlc3NmdWxseS4gKi9cbiAgICBAT3V0cHV0KClcbiAgICBzdWNjZXNzOiBFdmVudEVtaXR0ZXI8Tm9kZT4gPSBuZXcgRXZlbnRFbWl0dGVyPE5vZGU+KCk7XG5cbiAgICBASG9zdExpc3RlbmVyKCdjbGljaycsIFsgJyRldmVudCcgXSlcbiAgICBvbkNsaWNrKGV2ZW50KSB7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMub3BlbkRpYWxvZygpO1xuICAgIH1cblxuICAgIGNvbnN0cnVjdG9yKFxuICAgICAgICBwdWJsaWMgZGlhbG9nUmVmOiBNYXREaWFsb2csXG4gICAgICAgIHB1YmxpYyBjb250ZW50OiBDb250ZW50U2VydmljZVxuICAgICkge31cblxuICAgIHByaXZhdGUgZ2V0IGRpYWxvZ0NvbmZpZygpIHtcbiAgICAgICAgY29uc3QgeyBESUFMT0dfV0lEVEg6IHdpZHRoIH0gPSBGb2xkZXJDcmVhdGVEaXJlY3RpdmU7XG4gICAgICAgIGNvbnN0IHsgcGFyZW50Tm9kZUlkLCB0aXRsZTogY3JlYXRlVGl0bGUsIG5vZGVUeXBlIH0gPSB0aGlzO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkYXRhOiB7IHBhcmVudE5vZGVJZCwgY3JlYXRlVGl0bGUsIG5vZGVUeXBlIH0sXG4gICAgICAgICAgICB3aWR0aDogYCR7d2lkdGh9cHhgXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBvcGVuRGlhbG9nKCk6IHZvaWQge1xuICAgICAgICBjb25zdCB7IGRpYWxvZ1JlZiwgZGlhbG9nQ29uZmlnLCBjb250ZW50IH0gPSB0aGlzO1xuICAgICAgICBjb25zdCBkaWFsb2dJbnN0YW5jZSA9IGRpYWxvZ1JlZi5vcGVuKEZvbGRlckRpYWxvZ0NvbXBvbmVudCwgZGlhbG9nQ29uZmlnKTtcblxuICAgICAgICBkaWFsb2dJbnN0YW5jZS5jb21wb25lbnRJbnN0YW5jZS5lcnJvci5zdWJzY3JpYmUoKGVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVycm9yLmVtaXQoZXJyb3IpO1xuICAgICAgICB9KTtcblxuICAgICAgICBkaWFsb2dJbnN0YW5jZS5jb21wb25lbnRJbnN0YW5jZS5zdWNjZXNzLnN1YnNjcmliZSgobm9kZTogTm9kZSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdWNjZXNzLmVtaXQobm9kZSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGRpYWxvZ0luc3RhbmNlLmFmdGVyQ2xvc2VkKCkuc3Vic2NyaWJlKChub2RlOiBOb2RlKSA9PiB7XG4gICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgIGNvbnRlbnQuZm9sZGVyQ3JlYXRlLm5leHQobm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiJdfQ==