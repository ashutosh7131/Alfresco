/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Component, EventEmitter, Input, Output, ViewEncapsulation } from '@angular/core';
import { TagService } from './services/tag.service';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from './services/tag.service';
import * as ɵngcc2 from '@angular/material/chips';
import * as ɵngcc3 from '@angular/common';
import * as ɵngcc4 from '@angular/material/icon';

function TagNodeListComponent_mat_chip_1_mat_icon_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mat-icon", 4);
    ɵngcc0.ɵɵtext(1, "cancel ");
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const currentEntry_r1 = ɵngcc0.ɵɵnextContext().$implicit;
    ɵngcc0.ɵɵpropertyInterpolate1("id", "tag_chips_delete_", currentEntry_r1.entry.tag, "");
} }
function TagNodeListComponent_mat_chip_1_Template(rf, ctx) { if (rf & 1) {
    const _r6 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "mat-chip", 1);
    ɵngcc0.ɵɵlistener("removed", function TagNodeListComponent_mat_chip_1_Template_mat_chip_removed_0_listener() { ɵngcc0.ɵɵrestoreView(_r6); const currentEntry_r1 = ctx.$implicit; const ctx_r5 = ɵngcc0.ɵɵnextContext(); return ctx_r5.removeTag(currentEntry_r1.entry.id); });
    ɵngcc0.ɵɵelementStart(1, "span", 2);
    ɵngcc0.ɵɵtext(2);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(3, TagNodeListComponent_mat_chip_1_mat_icon_3_Template, 2, 1, "mat-icon", 3);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const currentEntry_r1 = ctx.$implicit;
    const idx_r2 = ctx.index;
    const ctx_r0 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵpropertyInterpolate1("id", "tag_name_", idx_r2, "");
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate(currentEntry_r1.entry.tag);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r0.showDelete);
} }
export class TagNodeListComponent {
    constructor(tagService) {
        this.tagService = tagService;
        this.showDelete = true;
        this.results = new EventEmitter();
        this.onDestroy$ = new Subject();
    }
    ngOnChanges() {
        this.refreshTag();
    }
    ngOnInit() {
        this.tagService.refresh
            .pipe(takeUntil(this.onDestroy$))
            .subscribe(() => this.refreshTag());
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
    refreshTag() {
        if (this.nodeId) {
            this.tagService.getTagsByNodeId(this.nodeId).subscribe((tagPaging) => {
                this.tagsEntries = tagPaging.list.entries;
                this.results.emit(this.tagsEntries);
            });
        }
    }
    removeTag(tag) {
        this.tagService.removeTag(this.nodeId, tag).subscribe(() => {
            this.refreshTag();
        });
    }
}
TagNodeListComponent.ɵfac = function TagNodeListComponent_Factory(t) { return new (t || TagNodeListComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc1.TagService)); };
TagNodeListComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: TagNodeListComponent, selectors: [["adf-tag-node-list"]], hostAttrs: [1, "adf-tag-node-list"], inputs: { showDelete: "showDelete", nodeId: "nodeId" }, outputs: { results: "results" }, features: [ɵngcc0.ɵɵNgOnChangesFeature], decls: 2, vars: 1, consts: [["class", "adf-tag-chips", 3, "removed", 4, "ngFor", "ngForOf"], [1, "adf-tag-chips", 3, "removed"], [3, "id"], ["class", "adf-tag-chips-delete-icon", "matChipRemove", "", 3, "id", 4, "ngIf"], ["matChipRemove", "", 1, "adf-tag-chips-delete-icon", 3, "id"]], template: function TagNodeListComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "mat-chip-list");
        ɵngcc0.ɵɵtemplate(1, TagNodeListComponent_mat_chip_1_Template, 4, 3, "mat-chip", 0);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngForOf", ctx.tagsEntries);
    } }, directives: [ɵngcc2.MatChipList, ɵngcc3.NgForOf, ɵngcc2.MatChip, ɵngcc3.NgIf, ɵngcc4.MatIcon, ɵngcc2.MatChipRemove], styles: [".adf-tag-node-list .adf-tag-chips{background-color:var(--theme-primary-color);color:var(--theme-primary-color-default-contrast)}.adf-tag-node-list .adf-tag-chips-delete{background:none;border:0;cursor:pointer;float:right;height:17px;margin:-1px 0 0 10px;overflow:visible;padding:0;width:20px}.adf-tag-node-list .adf-tag-chips-delete-icon{background-repeat:no-repeat;color:var(--theme-primary-color-default-contrast)!important;display:inline-block;fill:currentColor;font-size:20px;height:20px;width:20px}"], encapsulation: 2 });
TagNodeListComponent.ctorParameters = () => [
    { type: TagService }
];
TagNodeListComponent.propDecorators = {
    nodeId: [{ type: Input }],
    showDelete: [{ type: Input }],
    results: [{ type: Output }]
};
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(TagNodeListComponent, [{
        type: Component,
        args: [{
                selector: 'adf-tag-node-list',
                template: "<mat-chip-list>\n    <mat-chip class=\"adf-tag-chips\"\n              *ngFor=\"let currentEntry of tagsEntries; let idx = index\" (removed)=\"removeTag(currentEntry.entry.id)\">\n        <span id=\"tag_name_{{idx}}\">{{currentEntry.entry.tag}}</span>\n        <mat-icon *ngIf=\"showDelete\" id=\"tag_chips_delete_{{currentEntry.entry.tag}}\"\n                  class=\"adf-tag-chips-delete-icon\" matChipRemove>cancel\n        </mat-icon>\n    </mat-chip>\n</mat-chip-list>\n",
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-tag-node-list' },
                styles: [".adf-tag-node-list .adf-tag-chips{background-color:var(--theme-primary-color);color:var(--theme-primary-color-default-contrast)}.adf-tag-node-list .adf-tag-chips-delete{background:none;border:0;cursor:pointer;float:right;height:17px;margin:-1px 0 0 10px;overflow:visible;padding:0;width:20px}.adf-tag-node-list .adf-tag-chips-delete-icon{background-repeat:no-repeat;color:var(--theme-primary-color-default-contrast)!important;display:inline-block;fill:currentColor;font-size:20px;height:20px;width:20px}"]
            }]
    }], function () { return [{ type: ɵngcc1.TagService }]; }, { showDelete: [{
            type: Input
        }], results: [{
            type: Output
        }], nodeId: [{
            type: Input
        }] }); })();

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGFnLW5vZGUtbGlzdC5jb21wb25lbnQuanMiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uLy4uL2hvbWUvdHJhdmlzL2J1aWxkL0FsZnJlc2NvL2FsZnJlc2NvLW5nMi1jb21wb25lbnRzL2xpYi9jb250ZW50LXNlcnZpY2VzL3NyYy9saWIvdGFnL3RhZy1ub2RlLWxpc3QuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFFSCxPQUFPLEVBQUUsU0FBUyxFQUFFLFlBQVksRUFBRSxLQUFLLEVBQWEsTUFBTSxFQUFFLGlCQUFpQixFQUFxQixNQUFNLGVBQWUsQ0FBQztBQUN4SCxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFFcEQsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLE1BQU0sQ0FBQztBQUMvQixPQUFPLEVBQUUsU0FBUyxFQUFFLE1BQU0sZ0JBQWdCLENBQUM7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBYzNDLE1BQU0sT0FBTyxvQkFBb0I7QUFBRyxJQXFCaEMsWUFBb0IsVUFBc0I7QUFDOUMsUUFEd0IsZUFBVSxHQUFWLFVBQVUsQ0FBWTtBQUFDLFFBZDNDLGVBQVUsR0FBRyxJQUFJLENBQUM7QUFDdEIsUUFLSSxZQUFPLEdBQUcsSUFBSSxZQUFZLEVBQUUsQ0FBQztBQUNqQyxRQUNZLGVBQVUsR0FBRyxJQUFJLE9BQU8sRUFBVyxDQUFDO0FBQ2hELElBTUksQ0FBQztBQUNMLElBQ0ksV0FBVztBQUNmLFFBQVEsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDO0FBQzFCLElBQUksQ0FBQztBQUNMLElBQ0ksUUFBUTtBQUNaLFFBQVEsSUFBSSxDQUFDLFVBQVUsQ0FBQyxPQUFPO0FBQy9CLGFBQWEsSUFBSSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDLENBQUM7QUFDN0MsYUFBYSxTQUFTLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxDQUFDLFVBQVUsRUFBRSxDQUFDLENBQUM7QUFDaEQsSUFBSSxDQUFDO0FBQ0wsSUFDSSxXQUFXO0FBQ2YsUUFBUSxJQUFJLENBQUMsVUFBVSxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztBQUNuQyxRQUFRLElBQUksQ0FBQyxVQUFVLENBQUMsUUFBUSxFQUFFLENBQUM7QUFDbkMsSUFBSSxDQUFDO0FBQ0wsSUFDSSxVQUFVO0FBQ2QsUUFBUSxJQUFJLElBQUksQ0FBQyxNQUFNLEVBQUU7QUFDekIsWUFBWSxJQUFJLENBQUMsVUFBVSxDQUFDLGVBQWUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsU0FBUyxDQUFDLENBQUMsU0FBUyxFQUFFLEVBQUU7QUFDakYsZ0JBQWdCLElBQUksQ0FBQyxXQUFXLEdBQUcsU0FBUyxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUM7QUFDMUQsZ0JBQWdCLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxXQUFXLENBQUMsQ0FBQztBQUNwRCxZQUFZLENBQUMsQ0FBQyxDQUFDO0FBQ2YsU0FBUztBQUNULElBQUksQ0FBQztBQUNMLElBQ0ksU0FBUyxDQUFDLEdBQVc7QUFDekIsUUFBUSxJQUFJLENBQUMsVUFBVSxDQUFDLFNBQVMsQ0FBQyxJQUFJLENBQUMsTUFBTSxFQUFFLEdBQUcsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxHQUFHLEVBQUU7QUFDbkUsWUFBWSxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7QUFDOUIsUUFBUSxDQUFDLENBQUMsQ0FBQztBQUNYLElBQUksQ0FBQztBQUNMO2dEQTVEQyxTQUFTLFNBQUMsa0JBQ1AsUUFBUSxFQUFFLG1CQUFtQixrQkFDN0I7MmNBQTZDLGtCQUU3QyxhQUFhLEVBQUUsaUJBQWlCLENBQUMsSUFBSSxrQkFDckMsSUFBSSxFQUFFLEVBQUUsS0FBSyxFQUFFLG1CQUFtQixFQUFFOzs7Ozs7OzhMQUN2Qyx5ZEFDSTtBQUFDO0FBQThDLFlBakIzQyxVQUFVO0FBQUc7QUFBRztBQUNiLHFCQWtCUCxLQUFLO0FBQ1IseUJBR0csS0FBSztBQUNSLHNCQUtHLE1BQU07QUFDVjs7Ozs7Ozs7Ozs7Ozs7OztvQkFBRTtBQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQ29tcG9uZW50LCBFdmVudEVtaXR0ZXIsIElucHV0LCBPbkNoYW5nZXMsIE91dHB1dCwgVmlld0VuY2Fwc3VsYXRpb24sIE9uRGVzdHJveSwgT25Jbml0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBUYWdTZXJ2aWNlIH0gZnJvbSAnLi9zZXJ2aWNlcy90YWcuc2VydmljZSc7XG5pbXBvcnQgeyBUYWdFbnRyeSB9IGZyb20gJ0BhbGZyZXNjby9qcy1hcGknO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuXG4vKipcbiAqXG4gKiBUaGlzIGNvbXBvbmVudCwgU2hvd05vZGVUYWcgYSBsaXN0IG9mIHRoZSB0YWcgb24gcmVsYXRpdmUgYSBub2RlXG4gKi9cblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhZGYtdGFnLW5vZGUtbGlzdCcsXG4gICAgdGVtcGxhdGVVcmw6ICcuL3RhZy1ub2RlLWxpc3QuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWycuL3RhZy1ub2RlLWxpc3QuY29tcG9uZW50LnNjc3MnXSxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgIGhvc3Q6IHsgY2xhc3M6ICdhZGYtdGFnLW5vZGUtbGlzdCcgfVxufSlcbmV4cG9ydCBjbGFzcyBUYWdOb2RlTGlzdENvbXBvbmVudCBpbXBsZW1lbnRzIE9uQ2hhbmdlcywgT25EZXN0cm95LCBPbkluaXQge1xuICAgIC8qKiBUaGUgaWRlbnRpZmllciBvZiBhIG5vZGUuICovXG4gICAgQElucHV0KClcbiAgICBub2RlSWQ6IHN0cmluZztcblxuICAgIC8qKiBTaG93IGRlbGV0ZSBidXR0b24gKi9cbiAgICBASW5wdXQoKVxuICAgIHNob3dEZWxldGUgPSB0cnVlO1xuXG4gICAgdGFnc0VudHJpZXM6IFRhZ0VudHJ5W107XG5cbiAgICAvKiogRW1pdHRlZCB3aGVuIGEgdGFnIGlzIHNlbGVjdGVkLiAqL1xuICAgIEBPdXRwdXQoKVxuICAgIHJlc3VsdHMgPSBuZXcgRXZlbnRFbWl0dGVyKCk7XG5cbiAgICBwcml2YXRlIG9uRGVzdHJveSQgPSBuZXcgU3ViamVjdDxib29sZWFuPigpO1xuXG4gICAgLyoqXG4gICAgICogQ29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0gdGFnU2VydmljZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgdGFnU2VydmljZTogVGFnU2VydmljZSkge1xuICAgIH1cblxuICAgIG5nT25DaGFuZ2VzKCkge1xuICAgICAgICB0aGlzLnJlZnJlc2hUYWcoKTtcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy50YWdTZXJ2aWNlLnJlZnJlc2hcbiAgICAgICAgICAgIC5waXBlKHRha2VVbnRpbCh0aGlzLm9uRGVzdHJveSQpKVxuICAgICAgICAgICAgLnN1YnNjcmliZSgoKSA9PiB0aGlzLnJlZnJlc2hUYWcoKSk7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMub25EZXN0cm95JC5uZXh0KHRydWUpO1xuICAgICAgICB0aGlzLm9uRGVzdHJveSQuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICByZWZyZXNoVGFnKCkge1xuICAgICAgICBpZiAodGhpcy5ub2RlSWQpIHtcbiAgICAgICAgICAgIHRoaXMudGFnU2VydmljZS5nZXRUYWdzQnlOb2RlSWQodGhpcy5ub2RlSWQpLnN1YnNjcmliZSgodGFnUGFnaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy50YWdzRW50cmllcyA9IHRhZ1BhZ2luZy5saXN0LmVudHJpZXM7XG4gICAgICAgICAgICAgICAgdGhpcy5yZXN1bHRzLmVtaXQodGhpcy50YWdzRW50cmllcyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJlbW92ZVRhZyh0YWc6IHN0cmluZykge1xuICAgICAgICB0aGlzLnRhZ1NlcnZpY2UucmVtb3ZlVGFnKHRoaXMubm9kZUlkLCB0YWcpLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnJlZnJlc2hUYWcoKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuIl19