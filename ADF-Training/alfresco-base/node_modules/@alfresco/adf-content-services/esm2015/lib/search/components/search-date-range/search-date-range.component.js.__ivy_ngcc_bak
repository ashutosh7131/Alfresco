/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Component, ViewEncapsulation } from '@angular/core';
import { FormControl, FormGroup, Validators } from '@angular/forms';
import { DateAdapter, MAT_DATE_FORMATS, MAT_DATE_LOCALE } from '@angular/material/core';
import { MOMENT_DATE_FORMATS, MomentDateAdapter, UserPreferencesService, UserPreferenceValues } from '@alfresco/adf-core';
import { LiveErrorStateMatcher } from '../../forms/live-error-state-matcher';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
const DEFAULT_FORMAT_DATE = 'DD/MM/YYYY';
const Éµ0 = MOMENT_DATE_FORMATS;
export class SearchDateRangeComponent {
    constructor(dateAdapter, userPreferencesService) {
        this.dateAdapter = dateAdapter;
        this.userPreferencesService = userPreferencesService;
        this.matcher = new LiveErrorStateMatcher();
        this.isActive = false;
        this.displayValue$ = new Subject();
        this.onDestroy$ = new Subject();
    }
    getFromValidationMessage() {
        return this.from.hasError('invalidOnChange') || this.hasParseError(this.from) ? 'SEARCH.FILTER.VALIDATION.INVALID-DATE' :
            this.from.hasError('matDatepickerMax') ? 'SEARCH.FILTER.VALIDATION.BEYOND-MAX-DATE' :
                this.from.hasError('required') ? 'SEARCH.FILTER.VALIDATION.REQUIRED-VALUE' :
                    '';
    }
    getToValidationMessage() {
        return this.to.hasError('invalidOnChange') || this.hasParseError(this.to) ? 'SEARCH.FILTER.VALIDATION.INVALID-DATE' :
            this.to.hasError('matDatepickerMin') ? 'SEARCH.FILTER.VALIDATION.NO-DAYS' :
                this.to.hasError('matDatepickerMax') ? 'SEARCH.FILTER.VALIDATION.BEYOND-MAX-DATE' :
                    this.to.hasError('required') ? 'SEARCH.FILTER.VALIDATION.REQUIRED-VALUE' :
                        '';
    }
    ngOnInit() {
        var _a, _b, _c;
        this.datePickerFormat = ((_a = this.settings) === null || _a === void 0 ? void 0 : _a.dateFormat) ? this.settings.dateFormat : DEFAULT_FORMAT_DATE;
        const customDateAdapter = this.dateAdapter;
        customDateAdapter.overrideDisplayFormat = this.datePickerFormat;
        this.userPreferencesService
            .select(UserPreferenceValues.Locale)
            .pipe(takeUntil(this.onDestroy$))
            .subscribe(locale => this.setLocale(locale));
        const validators = Validators.compose([
            Validators.required
        ]);
        if (this.settings && this.settings.maxDate) {
            if (this.settings.maxDate === 'today') {
                this.maxDate = this.dateAdapter.today().endOf('day');
            }
            else {
                this.maxDate = moment(this.settings.maxDate).endOf('day');
            }
        }
        if (this.startValue) {
            const splitValue = this.startValue.split('||');
            const fromValue = this.dateAdapter.parse(splitValue[0], this.datePickerFormat);
            const toValue = this.dateAdapter.parse(splitValue[1], this.datePickerFormat);
            this.from = new FormControl(fromValue, validators);
            this.to = new FormControl(toValue, validators);
        }
        else {
            this.from = new FormControl('', validators);
            this.to = new FormControl('', validators);
        }
        this.form = new FormGroup({
            from: this.from,
            to: this.to
        });
        this.setFromMaxDate();
        this.enableChangeUpdate = (_c = (_b = this.settings) === null || _b === void 0 ? void 0 : _b.allowUpdateOnChange) !== null && _c !== void 0 ? _c : true;
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
    apply(model, isValid) {
        if (isValid && this.id && this.context && this.settings && this.settings.field) {
            this.isActive = true;
            const start = moment(model.from).startOf('day').format();
            const end = moment(model.to).endOf('day').format();
            this.context.queryFragments[this.id] = `${this.settings.field}:['${start}' TO '${end}']`;
            this.updateDisplayValue();
            this.context.update();
        }
    }
    submitValues() {
        this.apply(this.form.value, this.form.valid);
    }
    hasValidValue() {
        return this.form.valid;
    }
    getCurrentValue() {
        return {
            from: this.dateAdapter.format(this.form.value.from, this.datePickerFormat),
            to: this.dateAdapter.format(this.form.value.from, this.datePickerFormat)
        };
    }
    updateDisplayValue() {
        if (this.form.invalid || this.form.pristine) {
            this.displayValue$.next('');
        }
        else {
            this.displayValue$.next(`${this.dateAdapter.format(this.form.value.from, this.datePickerFormat)} - ${this.dateAdapter.format(this.form.value.to, this.datePickerFormat)}`);
        }
    }
    setValue(parsedDate) {
        const splitValue = parsedDate.split('||');
        const fromValue = this.dateAdapter.parse(splitValue[0], this.datePickerFormat);
        const toValue = this.dateAdapter.parse(splitValue[1], this.datePickerFormat);
        this.from.setValue(fromValue);
        this.from.markAsDirty();
        this.from.markAsTouched();
        this.to.setValue(toValue);
        this.to.markAsDirty();
        this.to.markAsTouched();
        this.submitValues();
    }
    clear() {
        this.isActive = false;
        this.form.reset({
            from: '',
            to: ''
        });
        if (this.id && this.context) {
            this.context.queryFragments[this.id] = '';
            if (this.enableChangeUpdate) {
                this.updateQuery();
            }
        }
        this.setFromMaxDate();
    }
    reset() {
        this.clear();
        this.updateQuery();
    }
    updateQuery() {
        if (this.id && this.context) {
            this.updateDisplayValue();
            this.context.update();
        }
    }
    onChangedHandler(event, formControl) {
        const inputValue = event.value;
        const formatDate = this.dateAdapter.parse(inputValue, this.datePickerFormat);
        if (formatDate && formatDate.isValid()) {
            formControl.setValue(formatDate);
        }
        else if (formatDate) {
            formControl.setErrors({
                'invalidOnChange': true
            });
        }
        this.setFromMaxDate();
    }
    setLocale(locale) {
        this.dateAdapter.setLocale(locale);
        moment.locale(locale);
    }
    hasParseError(formControl) {
        return formControl.hasError('matDatepickerParse') && formControl.getError('matDatepickerParse').text;
    }
    forcePlaceholder(event) {
        event.srcElement.click();
    }
    setFromMaxDate() {
        this.fromMaxDate = (!this.to.value || this.maxDate && (moment(this.maxDate).isBefore(this.to.value))) ? this.maxDate : moment(this.to.value);
    }
}
SearchDateRangeComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-search-date-range',
                template: "<form [formGroup]=\"form\" novalidate (ngSubmit)=\"apply(form.value, form.valid)\">\n    <mat-form-field>\n        <input matInput\n                (input)=\"forcePlaceholder($event)\"\n                [formControl]=\"from\"\n                [errorStateMatcher]=\"matcher\"\n                placeholder=\"{{ 'SEARCH.FILTER.RANGE.FROM-DATE' | translate }}\"\n                [matDatepicker]=\"fromDatepicker\"\n                [max]=\"fromMaxDate\"\n                (dateChange)=\"onChangedHandler($event, from)\"\n                data-automation-id=\"date-range-from-input\">\n        <mat-datepicker-toggle matSuffix [for]=\"fromDatepicker\" data-automation-id=\"date-range-from-date-toggle\"></mat-datepicker-toggle>\n        <mat-datepicker #fromDatepicker color=\"accent\"></mat-datepicker>\n        <mat-error *ngIf=\"from.invalid\" data-automation-id=\"date-range-from-error\">\n            {{ getFromValidationMessage() | translate: { requiredFormat: datePickerFormat } }}\n        </mat-error>\n    </mat-form-field>\n\n    <mat-form-field>\n        <input matInput\n                (input)=\"forcePlaceholder($event)\"\n                [formControl]=\"to\"\n                [errorStateMatcher]=\"matcher\"\n                placeholder=\"{{ 'SEARCH.FILTER.RANGE.TO-DATE' | translate }}\"\n                [matDatepicker]=\"toDatepicker\"\n                [min]=\"from.value\"\n                [max]=\"maxDate\"\n                (dateChange)=\"onChangedHandler($event, to)\"\n                data-automation-id=\"date-range-to-input\">\n        <mat-datepicker-toggle matSuffix [for]=\"toDatepicker\" data-automation-id=\"date-range-to-date-toggle\"></mat-datepicker-toggle>\n        <mat-datepicker #toDatepicker color=\"accent\"></mat-datepicker>\n        <mat-error *ngIf=\"to.invalid\" data-automation-id=\"date-range-to-error\">\n            {{ getToValidationMessage() | translate: { requiredFormat: datePickerFormat } }}\n        </mat-error>\n    </mat-form-field>\n\n    <div class=\"adf-facet-buttons adf-facet-buttons--topSpace\" *ngIf=\"!settings?.hideDefaultAction\">\n        <button mat-button color=\"primary\" type=\"button\" (click)=\"clear()\" data-automation-id=\"date-range-clear-btn\">\n            {{ 'SEARCH.FILTER.ACTIONS.CLEAR' | translate }}\n        </button>\n        <button mat-button color=\"primary\" type=\"submit\" [disabled]=\"!form.valid\" data-automation-id=\"date-range-apply-btn\">\n            {{ 'SEARCH.FILTER.ACTIONS.APPLY' | translate }}\n        </button>\n    </div>\n</form>\n",
                providers: [
                    { provide: DateAdapter, useClass: MomentDateAdapter, deps: [MAT_DATE_LOCALE] },
                    { provide: MAT_DATE_FORMATS, useValue: Éµ0 }
                ],
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-search-date-range' },
                styles: [".adf-search-date-range>form{display:inline-flex;flex-direction:column;width:100%}"]
            },] }
];
SearchDateRangeComponent.ctorParameters = () => [
    { type: DateAdapter },
    { type: UserPreferencesService }
];
export { Éµ0 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VhcmNoLWRhdGUtcmFuZ2UuY29tcG9uZW50LmpzIiwic291cmNlUm9vdCI6Ii9ob21lL3RyYXZpcy9idWlsZC9BbGZyZXNjby9hbGZyZXNjby1uZzItY29tcG9uZW50cy9saWIvY29udGVudC1zZXJ2aWNlcy9zcmMvIiwic291cmNlcyI6WyJsaWIvc2VhcmNoL2NvbXBvbmVudHMvc2VhcmNoLWRhdGUtcmFuZ2Uvc2VhcmNoLWRhdGUtcmFuZ2UuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUVILE9BQU8sRUFBRSxTQUFTLEVBQXFCLGlCQUFpQixFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ2hGLE9BQU8sRUFBRSxXQUFXLEVBQUUsU0FBUyxFQUFFLFVBQVUsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3BFLE9BQU8sRUFBRSxXQUFXLEVBQUUsZ0JBQWdCLEVBQUUsZUFBZSxFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFDeEYsT0FBTyxFQUNILG1CQUFtQixFQUNuQixpQkFBaUIsRUFDakIsc0JBQXNCLEVBQ3RCLG9CQUFvQixFQUN2QixNQUFNLG9CQUFvQixDQUFDO0FBSzVCLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLHNDQUFzQyxDQUFDO0FBRTdFLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDL0IsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBUzNDLE1BQU0sbUJBQW1CLEdBQVcsWUFBWSxDQUFDO1dBUUYsbUJBQW1CO0FBS2xFLE1BQU0sT0FBTyx3QkFBd0I7SUFxQmpDLFlBQW9CLFdBQWdDLEVBQ2hDLHNCQUE4QztRQUQ5QyxnQkFBVyxHQUFYLFdBQVcsQ0FBcUI7UUFDaEMsMkJBQXNCLEdBQXRCLHNCQUFzQixDQUF3QjtRQWhCbEUsWUFBTyxHQUFHLElBQUkscUJBQXFCLEVBQUUsQ0FBQztRQVF0QyxhQUFRLEdBQUcsS0FBSyxDQUFDO1FB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QUFDLGVBQWUsQ0FBQyxFQUFFO29CQUM5RSxFQUFFLE9BQU8sRUFBRSxnQkFBZ0IsRUFBRSxRQUFRLElBQXFCLEVBQUU7aUJBQy9EO2dCQUNELGFBQWEsRUFBRSxpQkFBaUIsQ0FBQyxJQUFJO2dCQUNyQyxJQUFJLEVBQUUsRUFBRSxLQUFLLEVBQUUsdUJBQXVCLEVBQUU7O2FBQzNDOzs7WUFuQ1EsV0FBVztZQUloQixzQkFBc0IiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQsIE9uRGVzdHJveSwgT25Jbml0LCBWaWV3RW5jYXBzdWxhdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRm9ybUNvbnRyb2wsIEZvcm1Hcm91cCwgVmFsaWRhdG9ycyB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IERhdGVBZGFwdGVyLCBNQVRfREFURV9GT1JNQVRTLCBNQVRfREFURV9MT0NBTEUgfSBmcm9tICdAYW5ndWxhci9tYXRlcmlhbC9jb3JlJztcbmltcG9ydCB7XG4gICAgTU9NRU5UX0RBVEVfRk9STUFUUyxcbiAgICBNb21lbnREYXRlQWRhcHRlcixcbiAgICBVc2VyUHJlZmVyZW5jZXNTZXJ2aWNlLFxuICAgIFVzZXJQcmVmZXJlbmNlVmFsdWVzXG59IGZyb20gJ0BhbGZyZXNjby9hZGYtY29yZSc7XG5cbmltcG9ydCB7IFNlYXJjaFdpZGdldCB9IGZyb20gJy4uLy4uL21vZGVscy9zZWFyY2gtd2lkZ2V0LmludGVyZmFjZSc7XG5pbXBvcnQgeyBTZWFyY2hXaWRnZXRTZXR0aW5ncyB9IGZyb20gJy4uLy4uL21vZGVscy9zZWFyY2gtd2lkZ2V0LXNldHRpbmdzLmludGVyZmFjZSc7XG5pbXBvcnQgeyBTZWFyY2hRdWVyeUJ1aWxkZXJTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vc2VydmljZXMvc2VhcmNoLXF1ZXJ5LWJ1aWxkZXIuc2VydmljZSc7XG5pbXBvcnQgeyBMaXZlRXJyb3JTdGF0ZU1hdGNoZXIgfSBmcm9tICcuLi8uLi9mb3Jtcy9saXZlLWVycm9yLXN0YXRlLW1hdGNoZXInO1xuaW1wb3J0IHsgTW9tZW50IH0gZnJvbSAnbW9tZW50JztcbmltcG9ydCB7IFN1YmplY3QgfSBmcm9tICdyeGpzJztcbmltcG9ydCB7IHRha2VVbnRpbCB9IGZyb20gJ3J4anMvb3BlcmF0b3JzJztcblxuZXhwb3J0IGludGVyZmFjZSBEYXRlUmFuZ2VWYWx1ZSB7XG4gICAgZnJvbTogc3RyaW5nO1xuICAgIHRvOiBzdHJpbmc7XG59XG5cbmRlY2xhcmUgbGV0IG1vbWVudDogYW55O1xuXG5jb25zdCBERUZBVUxUX0ZPUk1BVF9EQVRFOiBzdHJpbmcgPSAnREQvTU0vWVlZWSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYWRmLXNlYXJjaC1kYXRlLXJhbmdlJyxcbiAgICB0ZW1wbGF0ZVVybDogJy4vc2VhcmNoLWRhdGUtcmFuZ2UuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWycuL3NlYXJjaC1kYXRlLXJhbmdlLmNvbXBvbmVudC5zY3NzJ10sXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIHsgcHJvdmlkZTogRGF0ZUFkYXB0ZXIsIHVzZUNsYXNzOiBNb21lbnREYXRlQWRhcHRlciwgZGVwczogW01BVF9EQVRFX0xPQ0FMRV0gfSxcbiAgICAgICAgeyBwcm92aWRlOiBNQVRfREFURV9GT1JNQVRTLCB1c2VWYWx1ZTogTU9NRU5UX0RBVEVfRk9STUFUUyB9XG4gICAgXSxcbiAgICBlbmNhcHN1bGF0aW9uOiBWaWV3RW5jYXBzdWxhdGlvbi5Ob25lLFxuICAgIGhvc3Q6IHsgY2xhc3M6ICdhZGYtc2VhcmNoLWRhdGUtcmFuZ2UnIH1cbn0pXG5leHBvcnQgY2xhc3MgU2VhcmNoRGF0ZVJhbmdlQ29tcG9uZW50IGltcGxlbWVudHMgU2VhcmNoV2lkZ2V0LCBPbkluaXQsIE9uRGVzdHJveSB7XG5cbiAgICBmcm9tOiBGb3JtQ29udHJvbDtcbiAgICB0bzogRm9ybUNvbnRyb2w7XG5cbiAgICBmb3JtOiBGb3JtR3JvdXA7XG4gICAgbWF0Y2hlciA9IG5ldyBMaXZlRXJyb3JTdGF0ZU1hdGNoZXIoKTtcblxuICAgIGlkOiBzdHJpbmc7XG4gICAgc2V0dGluZ3M/OiBTZWFyY2hXaWRnZXRTZXR0aW5ncztcbiAgICBjb250ZXh0PzogU2VhcmNoUXVlcnlCdWlsZGVyU2VydmljZTtcbiAgICBkYXRlUGlja2VyRm9ybWF0OiBzdHJpbmc7XG4gICAgbWF4RGF0ZTogYW55O1xuICAgIGZyb21NYXhEYXRlOiBhbnk7XG4gICAgaXNBY3RpdmUgPSBmYWxzZTtcbiAgICBzdGFydFZhbHVlOiBhbnk7XG4gICAgZW5hYmxlQ2hhbmdlVXBkYXRlOiBib29sZWFuO1xuICAgIGRpc3BsYXlWYWx1ZSQ6IFN1YmplY3Q8c3RyaW5nPiA9IG5ldyBTdWJqZWN0PHN0cmluZz4oKTtcblxuICAgIHByaXZhdGUgb25EZXN0cm95JCA9IG5ldyBTdWJqZWN0PGJvb2xlYW4+KCk7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIGRhdGVBZGFwdGVyOiBEYXRlQWRhcHRlcjxNb21lbnQ+LFxuICAgICAgICAgICAgICAgIHByaXZhdGUgdXNlclByZWZlcmVuY2VzU2VydmljZTogVXNlclByZWZlcmVuY2VzU2VydmljZSkge1xuICAgIH1cblxuICAgIGdldEZyb21WYWxpZGF0aW9uTWVzc2FnZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tLmhhc0Vycm9yKCdpbnZhbGlkT25DaGFuZ2UnKSB8fCB0aGlzLmhhc1BhcnNlRXJyb3IodGhpcy5mcm9tKSA/ICdTRUFSQ0guRklMVEVSLlZBTElEQVRJT04uSU5WQUxJRC1EQVRFJyA6XG4gICAgICAgICAgICB0aGlzLmZyb20uaGFzRXJyb3IoJ21hdERhdGVwaWNrZXJNYXgnKSA/ICdTRUFSQ0guRklMVEVSLlZBTElEQVRJT04uQkVZT05ELU1BWC1EQVRFJyA6XG4gICAgICAgICAgICB0aGlzLmZyb20uaGFzRXJyb3IoJ3JlcXVpcmVkJykgPyAnU0VBUkNILkZJTFRFUi5WQUxJREFUSU9OLlJFUVVJUkVELVZBTFVFJyA6XG4gICAgICAgICAgICAnJztcbiAgICB9XG5cbiAgICBnZXRUb1ZhbGlkYXRpb25NZXNzYWdlKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB0aGlzLnRvLmhhc0Vycm9yKCdpbnZhbGlkT25DaGFuZ2UnKSB8fCB0aGlzLmhhc1BhcnNlRXJyb3IodGhpcy50bykgPyAnU0VBUkNILkZJTFRFUi5WQUxJREFUSU9OLklOVkFMSUQtREFURScgOlxuICAgICAgICAgICAgdGhpcy50by5oYXNFcnJvcignbWF0RGF0ZXBpY2tlck1pbicpID8gJ1NFQVJDSC5GSUxURVIuVkFMSURBVElPTi5OTy1EQVlTJyA6XG4gICAgICAgICAgICB0aGlzLnRvLmhhc0Vycm9yKCdtYXREYXRlcGlja2VyTWF4JykgPyAnU0VBUkNILkZJTFRFUi5WQUxJREFUSU9OLkJFWU9ORC1NQVgtREFURScgOlxuICAgICAgICAgICAgdGhpcy50by5oYXNFcnJvcigncmVxdWlyZWQnKSA/ICdTRUFSQ0guRklMVEVSLlZBTElEQVRJT04uUkVRVUlSRUQtVkFMVUUnIDpcbiAgICAgICAgICAgICcnO1xuICAgIH1cblxuICAgIG5nT25Jbml0KCkge1xuICAgICAgICB0aGlzLmRhdGVQaWNrZXJGb3JtYXQgPSB0aGlzLnNldHRpbmdzPy5kYXRlRm9ybWF0ID8gdGhpcy5zZXR0aW5ncy5kYXRlRm9ybWF0IDogREVGQVVMVF9GT1JNQVRfREFURTtcblxuICAgICAgICBjb25zdCBjdXN0b21EYXRlQWRhcHRlciA9IDxNb21lbnREYXRlQWRhcHRlcj4gPGFueT4gdGhpcy5kYXRlQWRhcHRlcjtcbiAgICAgICAgY3VzdG9tRGF0ZUFkYXB0ZXIub3ZlcnJpZGVEaXNwbGF5Rm9ybWF0ID0gdGhpcy5kYXRlUGlja2VyRm9ybWF0O1xuXG4gICAgICAgIHRoaXMudXNlclByZWZlcmVuY2VzU2VydmljZVxuICAgICAgICAgICAgLnNlbGVjdChVc2VyUHJlZmVyZW5jZVZhbHVlcy5Mb2NhbGUpXG4gICAgICAgICAgICAucGlwZSh0YWtlVW50aWwodGhpcy5vbkRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUobG9jYWxlID0+IHRoaXMuc2V0TG9jYWxlKGxvY2FsZSkpO1xuXG4gICAgICAgIGNvbnN0IHZhbGlkYXRvcnMgPSBWYWxpZGF0b3JzLmNvbXBvc2UoW1xuICAgICAgICAgICAgVmFsaWRhdG9ycy5yZXF1aXJlZFxuICAgICAgICBdKTtcblxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncyAmJiB0aGlzLnNldHRpbmdzLm1heERhdGUpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNldHRpbmdzLm1heERhdGUgPT09ICd0b2RheScpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1heERhdGUgPSB0aGlzLmRhdGVBZGFwdGVyLnRvZGF5KCkuZW5kT2YoJ2RheScpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1heERhdGUgPSBtb21lbnQodGhpcy5zZXR0aW5ncy5tYXhEYXRlKS5lbmRPZignZGF5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5zdGFydFZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCBzcGxpdFZhbHVlID0gdGhpcy5zdGFydFZhbHVlLnNwbGl0KCd8fCcpO1xuICAgICAgICAgICAgY29uc3QgZnJvbVZhbHVlID0gdGhpcy5kYXRlQWRhcHRlci5wYXJzZShzcGxpdFZhbHVlWzBdLCB0aGlzLmRhdGVQaWNrZXJGb3JtYXQpO1xuICAgICAgICAgICAgY29uc3QgdG9WYWx1ZSA9IHRoaXMuZGF0ZUFkYXB0ZXIucGFyc2Uoc3BsaXRWYWx1ZVsxXSwgdGhpcy5kYXRlUGlja2VyRm9ybWF0KTtcbiAgICAgICAgICAgIHRoaXMuZnJvbSA9IG5ldyBGb3JtQ29udHJvbChmcm9tVmFsdWUsIHZhbGlkYXRvcnMpO1xuICAgICAgICAgICAgdGhpcy50byA9IG5ldyBGb3JtQ29udHJvbCh0b1ZhbHVlLCB2YWxpZGF0b3JzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZnJvbSA9IG5ldyBGb3JtQ29udHJvbCgnJywgdmFsaWRhdG9ycyk7XG4gICAgICAgICAgICB0aGlzLnRvID0gbmV3IEZvcm1Db250cm9sKCcnLCB2YWxpZGF0b3JzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZm9ybSA9IG5ldyBGb3JtR3JvdXAoe1xuICAgICAgICAgICAgZnJvbTogdGhpcy5mcm9tLFxuICAgICAgICAgICAgdG86IHRoaXMudG9cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5zZXRGcm9tTWF4RGF0ZSgpO1xuICAgICAgICB0aGlzLmVuYWJsZUNoYW5nZVVwZGF0ZSA9IHRoaXMuc2V0dGluZ3M/LmFsbG93VXBkYXRlT25DaGFuZ2UgPz8gdHJ1ZTtcbiAgICB9XG5cbiAgICBuZ09uRGVzdHJveSgpIHtcbiAgICAgICAgdGhpcy5vbkRlc3Ryb3kkLm5leHQodHJ1ZSk7XG4gICAgICAgIHRoaXMub25EZXN0cm95JC5jb21wbGV0ZSgpO1xuICAgIH1cblxuICAgIGFwcGx5KG1vZGVsOiB7IGZyb206IHN0cmluZywgdG86IHN0cmluZyB9LCBpc1ZhbGlkOiBib29sZWFuKSB7XG4gICAgICAgIGlmIChpc1ZhbGlkICYmIHRoaXMuaWQgJiYgdGhpcy5jb250ZXh0ICYmIHRoaXMuc2V0dGluZ3MgJiYgdGhpcy5zZXR0aW5ncy5maWVsZCkge1xuICAgICAgICAgICAgdGhpcy5pc0FjdGl2ZSA9IHRydWU7XG5cbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gbW9tZW50KG1vZGVsLmZyb20pLnN0YXJ0T2YoJ2RheScpLmZvcm1hdCgpO1xuICAgICAgICAgICAgY29uc3QgZW5kID0gbW9tZW50KG1vZGVsLnRvKS5lbmRPZignZGF5JykuZm9ybWF0KCk7XG5cbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5xdWVyeUZyYWdtZW50c1t0aGlzLmlkXSA9IGAke3RoaXMuc2V0dGluZ3MuZmllbGR9OlsnJHtzdGFydH0nIFRPICcke2VuZH0nXWA7XG5cbiAgICAgICAgICAgIHRoaXMudXBkYXRlRGlzcGxheVZhbHVlKCk7XG4gICAgICAgICAgICB0aGlzLmNvbnRleHQudXBkYXRlKCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzdWJtaXRWYWx1ZXMoKSB7XG4gICAgICAgIHRoaXMuYXBwbHkodGhpcy5mb3JtLnZhbHVlLCB0aGlzLmZvcm0udmFsaWQpO1xuICAgIH1cblxuICAgIGhhc1ZhbGlkVmFsdWUoKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiB0aGlzLmZvcm0udmFsaWQ7XG4gICAgfVxuXG4gICAgZ2V0Q3VycmVudFZhbHVlKCk6IERhdGVSYW5nZVZhbHVlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGZyb206IHRoaXMuZGF0ZUFkYXB0ZXIuZm9ybWF0KHRoaXMuZm9ybS52YWx1ZS5mcm9tLCB0aGlzLmRhdGVQaWNrZXJGb3JtYXQpLFxuICAgICAgICAgICAgdG86IHRoaXMuZGF0ZUFkYXB0ZXIuZm9ybWF0KHRoaXMuZm9ybS52YWx1ZS5mcm9tLCB0aGlzLmRhdGVQaWNrZXJGb3JtYXQpXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdXBkYXRlRGlzcGxheVZhbHVlKCk6IHZvaWQge1xuICAgICAgICBpZiAodGhpcy5mb3JtLmludmFsaWQgfHwgdGhpcy5mb3JtLnByaXN0aW5lKSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXlWYWx1ZSQubmV4dCgnJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYXlWYWx1ZSQubmV4dChgJHt0aGlzLmRhdGVBZGFwdGVyLmZvcm1hdCh0aGlzLmZvcm0udmFsdWUuZnJvbSwgdGhpcy5kYXRlUGlja2VyRm9ybWF0KX0gLSAke3RoaXMuZGF0ZUFkYXB0ZXIuZm9ybWF0KHRoaXMuZm9ybS52YWx1ZS50bywgdGhpcy5kYXRlUGlja2VyRm9ybWF0KX1gKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHNldFZhbHVlKHBhcnNlZERhdGU6IHN0cmluZykge1xuICAgICAgICBjb25zdCBzcGxpdFZhbHVlID0gcGFyc2VkRGF0ZS5zcGxpdCgnfHwnKTtcbiAgICAgICAgY29uc3QgZnJvbVZhbHVlID0gdGhpcy5kYXRlQWRhcHRlci5wYXJzZShzcGxpdFZhbHVlWzBdLCB0aGlzLmRhdGVQaWNrZXJGb3JtYXQpO1xuICAgICAgICBjb25zdCB0b1ZhbHVlID0gdGhpcy5kYXRlQWRhcHRlci5wYXJzZShzcGxpdFZhbHVlWzFdLCB0aGlzLmRhdGVQaWNrZXJGb3JtYXQpO1xuICAgICAgICB0aGlzLmZyb20uc2V0VmFsdWUoZnJvbVZhbHVlKTtcbiAgICAgICAgdGhpcy5mcm9tLm1hcmtBc0RpcnR5KCk7XG4gICAgICAgIHRoaXMuZnJvbS5tYXJrQXNUb3VjaGVkKCk7XG4gICAgICAgIHRoaXMudG8uc2V0VmFsdWUodG9WYWx1ZSk7XG4gICAgICAgIHRoaXMudG8ubWFya0FzRGlydHkoKTtcbiAgICAgICAgdGhpcy50by5tYXJrQXNUb3VjaGVkKCk7XG4gICAgICAgIHRoaXMuc3VibWl0VmFsdWVzKCk7XG4gICAgfVxuICAgIGNsZWFyKCkge1xuICAgICAgICB0aGlzLmlzQWN0aXZlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuZm9ybS5yZXNldCh7XG4gICAgICAgICAgICBmcm9tOiAnJyxcbiAgICAgICAgICAgIHRvOiAnJ1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAodGhpcy5pZCAmJiB0aGlzLmNvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5xdWVyeUZyYWdtZW50c1t0aGlzLmlkXSA9ICcnO1xuICAgICAgICAgICAgaWYgKHRoaXMuZW5hYmxlQ2hhbmdlVXBkYXRlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51cGRhdGVRdWVyeSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuc2V0RnJvbU1heERhdGUoKTtcbiAgICB9XG5cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICB0aGlzLnVwZGF0ZVF1ZXJ5KCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVRdWVyeSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaWQgJiYgdGhpcy5jb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZURpc3BsYXlWYWx1ZSgpO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25DaGFuZ2VkSGFuZGxlcihldmVudDogYW55LCBmb3JtQ29udHJvbDogRm9ybUNvbnRyb2wpIHtcblxuICAgICAgICBjb25zdCBpbnB1dFZhbHVlID0gZXZlbnQudmFsdWU7XG4gICAgICAgIGNvbnN0IGZvcm1hdERhdGUgPSB0aGlzLmRhdGVBZGFwdGVyLnBhcnNlKGlucHV0VmFsdWUsIHRoaXMuZGF0ZVBpY2tlckZvcm1hdCk7XG4gICAgICAgIGlmIChmb3JtYXREYXRlICYmIGZvcm1hdERhdGUuaXNWYWxpZCgpKSB7XG4gICAgICAgICAgICBmb3JtQ29udHJvbC5zZXRWYWx1ZShmb3JtYXREYXRlKTtcbiAgICAgICAgfSBlbHNlIGlmIChmb3JtYXREYXRlKSB7XG4gICAgICAgICAgICBmb3JtQ29udHJvbC5zZXRFcnJvcnMoe1xuICAgICAgICAgICAgICAgICdpbnZhbGlkT25DaGFuZ2UnOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuc2V0RnJvbU1heERhdGUoKTtcbiAgICB9XG5cbiAgICBzZXRMb2NhbGUobG9jYWxlKSB7XG4gICAgICAgIHRoaXMuZGF0ZUFkYXB0ZXIuc2V0TG9jYWxlKGxvY2FsZSk7XG4gICAgICAgIG1vbWVudC5sb2NhbGUobG9jYWxlKTtcbiAgICB9XG5cbiAgICBoYXNQYXJzZUVycm9yKGZvcm1Db250cm9sKTogYm9vbGVhbiB7XG4gICAgICAgIHJldHVybiBmb3JtQ29udHJvbC5oYXNFcnJvcignbWF0RGF0ZXBpY2tlclBhcnNlJykgJiYgZm9ybUNvbnRyb2wuZ2V0RXJyb3IoJ21hdERhdGVwaWNrZXJQYXJzZScpLnRleHQ7XG4gICAgfVxuXG4gICAgZm9yY2VQbGFjZWhvbGRlcihldmVudDogYW55KSB7XG4gICAgICAgIGV2ZW50LnNyY0VsZW1lbnQuY2xpY2soKTtcbiAgICB9XG5cbiAgICBzZXRGcm9tTWF4RGF0ZSgpIHtcbiAgICAgICAgdGhpcy5mcm9tTWF4RGF0ZSA9ICghdGhpcy50by52YWx1ZSB8fCB0aGlzLm1heERhdGUgJiYgKG1vbWVudCh0aGlzLm1heERhdGUpLmlzQmVmb3JlKHRoaXMudG8udmFsdWUpKSkgPyB0aGlzLm1heERhdGUgOiBtb21lbnQodGhpcy50by52YWx1ZSk7XG4gICAgfVxufVxuIl19