/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { Component, ViewEncapsulation } from '@angular/core';
import { FormControl, FormGroup, Validators } from '@angular/forms';
import { UserPreferencesService, UserPreferenceValues } from '@alfresco/adf-core';
import { LiveErrorStateMatcher } from '../../forms/live-error-state-matcher';
import { Subject } from 'rxjs';
import { takeUntil } from 'rxjs/operators';
import { DatetimeAdapter, MAT_DATETIME_FORMATS } from '@mat-datetimepicker/core';
import { MAT_MOMENT_DATETIME_FORMATS } from '@mat-datetimepicker/moment';
const DEFAULT_DATETIME_FORMAT = 'DD/MM/YYYY HH:mm';
const ɵ0 = MAT_MOMENT_DATETIME_FORMATS;
export class SearchDatetimeRangeComponent {
    constructor(dateAdapter, userPreferencesService) {
        this.dateAdapter = dateAdapter;
        this.userPreferencesService = userPreferencesService;
        this.matcher = new LiveErrorStateMatcher();
        this.isActive = false;
        this.displayValue$ = new Subject();
        this.onDestroy$ = new Subject();
    }
    getFromValidationMessage() {
        return this.from.hasError('invalidOnChange') || this.hasParseError(this.from) ? 'SEARCH.FILTER.VALIDATION.INVALID-DATETIME' :
            this.from.hasError('matDatepickerMax') ? 'SEARCH.FILTER.VALIDATION.BEYOND-MAX-DATETIME' :
                this.from.hasError('required') ? 'SEARCH.FILTER.VALIDATION.REQUIRED-VALUE' :
                    '';
    }
    getToValidationMessage() {
        return this.to.hasError('invalidOnChange') || this.hasParseError(this.to) ? 'SEARCH.FILTER.VALIDATION.INVALID-DATETIME' :
            this.to.hasError('matDatepickerMin') ? 'SEARCH.FILTER.VALIDATION.NO-DAYS' :
                this.to.hasError('matDatepickerMax') ? 'SEARCH.FILTER.VALIDATION.BEYOND-MAX-DATETIME' :
                    this.to.hasError('required') ? 'SEARCH.FILTER.VALIDATION.REQUIRED-VALUE' :
                        '';
    }
    ngOnInit() {
        var _a, _b, _c;
        this.datetimePickerFormat = ((_a = this.settings) === null || _a === void 0 ? void 0 : _a.datetimeFormat) ? this.settings.datetimeFormat : DEFAULT_DATETIME_FORMAT;
        this.userPreferencesService
            .select(UserPreferenceValues.Locale)
            .pipe(takeUntil(this.onDestroy$))
            .subscribe(locale => this.setLocale(locale));
        const validators = Validators.compose([
            Validators.required
        ]);
        if (this.settings && this.settings.maxDatetime) {
            this.maxDatetime = moment(this.settings.maxDatetime);
        }
        if (this.startValue) {
            const splitValue = this.startValue.split('||');
            const fromValue = this.dateAdapter.parse(splitValue[0], this.datetimePickerFormat);
            const toValue = this.dateAdapter.parse(splitValue[1], this.datetimePickerFormat);
            this.from = new FormControl(fromValue, validators);
            this.to = new FormControl(toValue, validators);
        }
        else {
            this.from = new FormControl('', validators);
            this.to = new FormControl('', validators);
        }
        this.form = new FormGroup({
            from: this.from,
            to: this.to
        });
        this.setFromMaxDatetime();
        this.enableChangeUpdate = (_c = (_b = this.settings) === null || _b === void 0 ? void 0 : _b.allowUpdateOnChange) !== null && _c !== void 0 ? _c : true;
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
    apply(model, isValid) {
        if (isValid && this.id && this.context && this.settings && this.settings.field) {
            this.isActive = true;
            const start = moment.utc(model.from).startOf('minute').format();
            const end = moment.utc(model.to).endOf('minute').format();
            this.context.queryFragments[this.id] = `${this.settings.field}:['${start}' TO '${end}']`;
            this.updateDisplayValue();
            this.context.update();
        }
    }
    submitValues() {
        this.apply(this.form.value, this.form.valid);
    }
    hasValidValue() {
        return this.form.valid;
    }
    getCurrentValue() {
        return {
            from: this.dateAdapter.format(this.form.value.from, this.datetimePickerFormat),
            to: this.dateAdapter.format(this.form.value.to, this.datetimePickerFormat)
        };
    }
    updateDisplayValue() {
        if (this.form.invalid || this.form.pristine) {
            this.displayValue$.next('');
        }
        else {
            this.displayValue$.next(`${this.dateAdapter.format(this.form.value.from, this.datetimePickerFormat)} - ${this.dateAdapter.format(this.form.value.to, this.datetimePickerFormat)}`);
        }
    }
    setValue(parsedDate) {
        const splitValue = parsedDate.split('||');
        const fromValue = this.dateAdapter.parse(splitValue[0], this.datetimePickerFormat);
        const toValue = this.dateAdapter.parse(splitValue[1], this.datetimePickerFormat);
        this.from.setValue(fromValue);
        this.from.markAsDirty();
        this.from.markAsTouched();
        this.to.setValue(toValue);
        this.to.markAsDirty();
        this.to.markAsTouched();
        this.submitValues();
    }
    clear() {
        this.isActive = false;
        this.form.reset({
            from: '',
            to: ''
        });
        if (this.id && this.context) {
            this.context.queryFragments[this.id] = '';
        }
        if (this.id && this.context && this.enableChangeUpdate) {
            this.updateQuery();
        }
        this.setFromMaxDatetime();
    }
    reset() {
        this.clear();
        this.updateQuery();
    }
    updateQuery() {
        if (this.id && this.context) {
            this.updateDisplayValue();
            this.context.update();
        }
    }
    onChangedHandler(event, formControl) {
        const inputValue = event.value;
        const formatDate = this.dateAdapter.parse(inputValue, this.datetimePickerFormat);
        if (formatDate && formatDate.isValid()) {
            formControl.setValue(formatDate);
        }
        else if (formatDate) {
            formControl.setErrors({
                'invalidOnChange': true
            });
        }
        this.setFromMaxDatetime();
    }
    setLocale(locale) {
        this.dateAdapter.setLocale(locale);
        moment.locale(locale);
    }
    hasParseError(formControl) {
        return formControl.hasError('matDatepickerParse') && formControl.getError('matDatepickerParse').text;
    }
    forcePlaceholder(event) {
        event.srcElement.click();
    }
    setFromMaxDatetime() {
        this.fromMaxDatetime = (!this.to.value || this.maxDatetime && (moment(this.maxDatetime).isBefore(this.to.value))) ? this.maxDatetime : moment(this.to.value);
    }
}
SearchDatetimeRangeComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-search-datetime-range',
                template: "<form [formGroup]=\"form\" novalidate (ngSubmit)=\"apply(form.value, form.valid)\">\n    <mat-form-field>\n        <input matInput\n                (input)=\"forcePlaceholder($event)\"\n                [formControl]=\"from\"\n                [errorStateMatcher]=\"matcher\"\n                placeholder=\"{{ 'SEARCH.FILTER.RANGE.FROM-DATE' | translate }}\"\n                [matDatetimepicker]=\"fromDatetimePicker\"\n                [max]=\"fromMaxDatetime\"\n                (dateChange)=\"onChangedHandler($event, from)\"\n                data-automation-id=\"datetime-range-from-input\">\n        <mat-datetimepicker-toggle matSuffix [for]=\"fromDatetimePicker\" data-automation-id=\"datetime-range-from-date-toggle\"></mat-datetimepicker-toggle>\n        <mat-datetimepicker #fromDatetimePicker color=\"accent\" type=\"datetime\"></mat-datetimepicker>\n        <mat-error *ngIf=\"from.invalid\" data-automation-id=\"datetime-range-from-error\">\n            {{ getFromValidationMessage() | translate: { requiredFormat: datetimePickerFormat } }}\n        </mat-error>\n    </mat-form-field>\n\n    <mat-form-field>\n        <input matInput\n                (input)=\"forcePlaceholder($event)\"\n                [formControl]=\"to\"\n                [errorStateMatcher]=\"matcher\"\n                placeholder=\"{{ 'SEARCH.FILTER.RANGE.TO-DATE' | translate }}\"\n                [matDatetimepicker]=\"toDatetimePicker\"\n                [min]=\"from.value\"\n                [max]=\"maxDatetime\"\n                (dateChange)=\"onChangedHandler($event, to)\"\n                data-automation-id=\"datetime-range-to-input\">\n        <mat-datetimepicker-toggle matSuffix [for]=\"toDatetimePicker\" data-automation-id=\"datetime-range-to-date-toggle\"></mat-datetimepicker-toggle>\n        <mat-datetimepicker #toDatetimePicker color=\"accent\" type=\"datetime\"></mat-datetimepicker>\n        <mat-error *ngIf=\"to.invalid\" data-automation-id=\"datetime-range-to-error\">\n            {{ getToValidationMessage() | translate: { requiredFormat: datetimePickerFormat } }}\n        </mat-error>\n    </mat-form-field>\n\n    <div class=\"adf-facet-buttons adf-facet-buttons--topSpace\" *ngIf=\"!settings?.hideDefaultAction\">\n        <button mat-button color=\"primary\" type=\"button\" (click)=\"clear()\" data-automation-id=\"datetime-range-clear-btn\">\n            {{ 'SEARCH.FILTER.ACTIONS.CLEAR' | translate }}\n        </button>\n        <button mat-button color=\"primary\" type=\"submit\" [disabled]=\"!form.valid\" data-automation-id=\"datetime-range-apply-btn\">\n            {{ 'SEARCH.FILTER.ACTIONS.APPLY' | translate }}\n        </button>\n    </div>\n</form>\n",
                providers: [
                    { provide: MAT_DATETIME_FORMATS, useValue: ɵ0 }
                ],
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-search-date-range' },
                styles: [".adf-search-date-range>form{display:inline-flex;flex-direction:column;width:100%}"]
            },] }
];
SearchDatetimeRangeComponent.ctorParameters = () => [
    { type: DatetimeAdapter },
    { type: UserPreferencesService }
];
export { ɵ0 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VhcmNoLWRhdGV0aW1lLXJhbmdlLmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIvaG9tZS90cmF2aXMvYnVpbGQvQWxmcmVzY28vYWxmcmVzY28tbmcyLWNvbXBvbmVudHMvbGliL2NvbnRlbnQtc2VydmljZXMvc3JjLyIsInNvdXJjZXMiOlsibGliL3NlYXJjaC9jb21wb25lbnRzL3NlYXJjaC1kYXRldGltZS1yYW5nZS9zZWFyY2gtZGF0ZXRpbWUtcmFuZ2UuY29tcG9uZW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7Ozs7Ozs7Ozs7Ozs7R0FlRztBQUVILE9BQU8sRUFBRSxTQUFTLEVBQXFCLGlCQUFpQixFQUFFLE1BQU0sZUFBZSxDQUFDO0FBQ2hGLE9BQU8sRUFBRSxXQUFXLEVBQUUsU0FBUyxFQUFFLFVBQVUsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQ3BFLE9BQU8sRUFBRSxzQkFBc0IsRUFBRSxvQkFBb0IsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBS2xGLE9BQU8sRUFBRSxxQkFBcUIsRUFBRSxNQUFNLHNDQUFzQyxDQUFDO0FBRTdFLE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDL0IsT0FBTyxFQUFFLFNBQVMsRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBQzNDLE9BQU8sRUFBRSxlQUFlLEVBQUUsb0JBQW9CLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUNqRixPQUFPLEVBQUUsMkJBQTJCLEVBQUUsTUFBTSw0QkFBNEIsQ0FBQztBQVN6RSxNQUFNLHVCQUF1QixHQUFXLGtCQUFrQixDQUFDO1dBT1IsMkJBQTJCO0FBSzlFLE1BQU0sT0FBTyw0QkFBNEI7SUFxQnJDLFlBQW9CLFdBQW9DLEVBQ3BDLHNCQUE4QztRQUQ5QyxnQkFBVyxHQUFYLFdBQVcsQ0FBeUI7UUFDcEMsMkJBQXNCLEdBQXRCLHNCQUFzQixDQUF3QjtRQWhCbEUsWUFBTyxHQUFHLElBQUkscUJBQXFCLEVBQUUsQ0FBQztRQVF0Qyxh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V0FBVyxDQUFDLFNBQVMsQ0FBQyxNQUFNLENBQUMsQ0FBQztRQUNuQyxNQUFNLENBQUMsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDO0lBQzFCLENBQUM7SUFFRCxhQUFhLENBQUMsV0FBVztRQUNyQixPQUFPLFdBQVcsQ0FBQyxRQUFRLENBQUMsb0JBQW9CLENBQUMsSUFBSSxXQUFXLENBQUMsUUFBUSxDQUFDLG9CQUFvQixDQUFDLENBQUMsSUFBSSxDQUFDO0lBQ3pHLENBQUM7SUFFRCxnQkFBZ0IsQ0FBQyxLQUFVO1FBQ3ZCLEtBQUssQ0FBQyxVQUFVLENBQUMsS0FBSyxFQUFFLENBQUM7SUFDN0IsQ0FBQztJQUVELGtCQUFrQjtRQUNkLElBQUksQ0FBQyxlQUFlLEdBQUcsQ0FBQyxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsS0FBSyxJQUFJLElBQUksQ0FBQyxXQUFXLElBQUksQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUMsSUFBSSxDQUFDLFdBQVcsQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDLElBQUksQ0FBQyxFQUFFLENBQUMsS0FBSyxDQUFDLENBQUM7SUFDakssQ0FBQzs7O1lBdE1KLFNBQVMsU0FBQztnQkFDUCxRQUFRLEVBQUUsMkJBQTJCO2dCQUNyQyxtb0ZBQXFEO2dCQUVyRCxTQUFTLEVBQUU7b0JBQ1AsRUFBRSxPQUFPLEVBQUUsb0JBQW9CLEVBQUUsUUFBUSxJQUE2QixFQUFFO2lCQUMzRTtnQkFDRCxhQUFhLEVBQUUsaUJBQWlCLENBQUMsSUFBSTtnQkFDckMsSUFBSSxFQUFFLEVBQUUsS0FBSyxFQUFFLHVCQUF1QixFQUFFOzthQUMzQzs7O1lBckJRLGVBQWU7WUFUZixzQkFBc0IiLCJzb3VyY2VzQ29udGVudCI6WyIvKiFcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxOSBBbGZyZXNjbyBTb2Z0d2FyZSwgTHRkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgeyBDb21wb25lbnQsIE9uRGVzdHJveSwgT25Jbml0LCBWaWV3RW5jYXBzdWxhdGlvbiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgRm9ybUNvbnRyb2wsIEZvcm1Hcm91cCwgVmFsaWRhdG9ycyB9IGZyb20gJ0Bhbmd1bGFyL2Zvcm1zJztcbmltcG9ydCB7IFVzZXJQcmVmZXJlbmNlc1NlcnZpY2UsIFVzZXJQcmVmZXJlbmNlVmFsdWVzIH0gZnJvbSAnQGFsZnJlc2NvL2FkZi1jb3JlJztcblxuaW1wb3J0IHsgU2VhcmNoV2lkZ2V0IH0gZnJvbSAnLi4vLi4vbW9kZWxzL3NlYXJjaC13aWRnZXQuaW50ZXJmYWNlJztcbmltcG9ydCB7IFNlYXJjaFdpZGdldFNldHRpbmdzIH0gZnJvbSAnLi4vLi4vbW9kZWxzL3NlYXJjaC13aWRnZXQtc2V0dGluZ3MuaW50ZXJmYWNlJztcbmltcG9ydCB7IFNlYXJjaFF1ZXJ5QnVpbGRlclNlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9zZWFyY2gtcXVlcnktYnVpbGRlci5zZXJ2aWNlJztcbmltcG9ydCB7IExpdmVFcnJvclN0YXRlTWF0Y2hlciB9IGZyb20gJy4uLy4uL2Zvcm1zL2xpdmUtZXJyb3Itc3RhdGUtbWF0Y2hlcic7XG5pbXBvcnQgeyBNb21lbnQgfSBmcm9tICdtb21lbnQnO1xuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMnO1xuaW1wb3J0IHsgdGFrZVVudGlsIH0gZnJvbSAncnhqcy9vcGVyYXRvcnMnO1xuaW1wb3J0IHsgRGF0ZXRpbWVBZGFwdGVyLCBNQVRfREFURVRJTUVfRk9STUFUUyB9IGZyb20gJ0BtYXQtZGF0ZXRpbWVwaWNrZXIvY29yZSc7XG5pbXBvcnQgeyBNQVRfTU9NRU5UX0RBVEVUSU1FX0ZPUk1BVFMgfSBmcm9tICdAbWF0LWRhdGV0aW1lcGlja2VyL21vbWVudCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgRGF0ZXRpbWVSYW5nZVZhbHVlIHtcbiAgICBmcm9tOiBzdHJpbmc7XG4gICAgdG86IHN0cmluZztcbn1cblxuZGVjbGFyZSBsZXQgbW9tZW50OiBhbnk7XG5cbmNvbnN0IERFRkFVTFRfREFURVRJTUVfRk9STUFUOiBzdHJpbmcgPSAnREQvTU0vWVlZWSBISDptbSc7XG5cbkBDb21wb25lbnQoe1xuICAgIHNlbGVjdG9yOiAnYWRmLXNlYXJjaC1kYXRldGltZS1yYW5nZScsXG4gICAgdGVtcGxhdGVVcmw6ICcuL3NlYXJjaC1kYXRldGltZS1yYW5nZS5jb21wb25lbnQuaHRtbCcsXG4gICAgc3R5bGVVcmxzOiBbJy4vc2VhcmNoLWRhdGV0aW1lLXJhbmdlLmNvbXBvbmVudC5zY3NzJ10sXG4gICAgcHJvdmlkZXJzOiBbXG4gICAgICAgIHsgcHJvdmlkZTogTUFUX0RBVEVUSU1FX0ZPUk1BVFMsIHVzZVZhbHVlOiBNQVRfTU9NRU5UX0RBVEVUSU1FX0ZPUk1BVFMgfVxuICAgIF0sXG4gICAgZW5jYXBzdWxhdGlvbjogVmlld0VuY2Fwc3VsYXRpb24uTm9uZSxcbiAgICBob3N0OiB7IGNsYXNzOiAnYWRmLXNlYXJjaC1kYXRlLXJhbmdlJyB9XG59KVxuZXhwb3J0IGNsYXNzIFNlYXJjaERhdGV0aW1lUmFuZ2VDb21wb25lbnQgaW1wbGVtZW50cyBTZWFyY2hXaWRnZXQsIE9uSW5pdCwgT25EZXN0cm95IHtcblxuICAgIGZyb206IEZvcm1Db250cm9sO1xuICAgIHRvOiBGb3JtQ29udHJvbDtcblxuICAgIGZvcm06IEZvcm1Hcm91cDtcbiAgICBtYXRjaGVyID0gbmV3IExpdmVFcnJvclN0YXRlTWF0Y2hlcigpO1xuXG4gICAgaWQ6IHN0cmluZztcbiAgICBzZXR0aW5ncz86IFNlYXJjaFdpZGdldFNldHRpbmdzO1xuICAgIGNvbnRleHQ/OiBTZWFyY2hRdWVyeUJ1aWxkZXJTZXJ2aWNlO1xuICAgIGRhdGV0aW1lUGlja2VyRm9ybWF0OiBzdHJpbmc7XG4gICAgbWF4RGF0ZXRpbWU6IGFueTtcbiAgICBmcm9tTWF4RGF0ZXRpbWU6IGFueTtcbiAgICBpc0FjdGl2ZSA9IGZhbHNlO1xuICAgIHN0YXJ0VmFsdWU6IGFueTtcbiAgICBlbmFibGVDaGFuZ2VVcGRhdGU6IGJvb2xlYW47XG4gICAgZGlzcGxheVZhbHVlJDogU3ViamVjdDxzdHJpbmc+ID0gbmV3IFN1YmplY3Q8c3RyaW5nPigpO1xuXG4gICAgcHJpdmF0ZSBvbkRlc3Ryb3kkID0gbmV3IFN1YmplY3Q8Ym9vbGVhbj4oKTtcblxuICAgIGNvbnN0cnVjdG9yKHByaXZhdGUgZGF0ZUFkYXB0ZXI6IERhdGV0aW1lQWRhcHRlcjxNb21lbnQ+LFxuICAgICAgICAgICAgICAgIHByaXZhdGUgdXNlclByZWZlcmVuY2VzU2VydmljZTogVXNlclByZWZlcmVuY2VzU2VydmljZSkge1xuICAgIH1cblxuICAgIGdldEZyb21WYWxpZGF0aW9uTWVzc2FnZSgpOiBzdHJpbmcge1xuICAgICAgICByZXR1cm4gdGhpcy5mcm9tLmhhc0Vycm9yKCdpbnZhbGlkT25DaGFuZ2UnKSB8fCB0aGlzLmhhc1BhcnNlRXJyb3IodGhpcy5mcm9tKSA/ICdTRUFSQ0guRklMVEVSLlZBTElEQVRJT04uSU5WQUxJRC1EQVRFVElNRScgOlxuICAgICAgICAgICAgdGhpcy5mcm9tLmhhc0Vycm9yKCdtYXREYXRlcGlja2VyTWF4JykgPyAnU0VBUkNILkZJTFRFUi5WQUxJREFUSU9OLkJFWU9ORC1NQVgtREFURVRJTUUnIDpcbiAgICAgICAgICAgIHRoaXMuZnJvbS5oYXNFcnJvcigncmVxdWlyZWQnKSA/ICdTRUFSQ0guRklMVEVSLlZBTElEQVRJT04uUkVRVUlSRUQtVkFMVUUnIDpcbiAgICAgICAgICAgICcnO1xuICAgIH1cblxuICAgIGdldFRvVmFsaWRhdGlvbk1lc3NhZ2UoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG8uaGFzRXJyb3IoJ2ludmFsaWRPbkNoYW5nZScpIHx8IHRoaXMuaGFzUGFyc2VFcnJvcih0aGlzLnRvKSA/ICdTRUFSQ0guRklMVEVSLlZBTElEQVRJT04uSU5WQUxJRC1EQVRFVElNRScgOlxuICAgICAgICAgICAgdGhpcy50by5oYXNFcnJvcignbWF0RGF0ZXBpY2tlck1pbicpID8gJ1NFQVJDSC5GSUxURVIuVkFMSURBVElPTi5OTy1EQVlTJyA6XG4gICAgICAgICAgICB0aGlzLnRvLmhhc0Vycm9yKCdtYXREYXRlcGlja2VyTWF4JykgPyAnU0VBUkNILkZJTFRFUi5WQUxJREFUSU9OLkJFWU9ORC1NQVgtREFURVRJTUUnIDpcbiAgICAgICAgICAgIHRoaXMudG8uaGFzRXJyb3IoJ3JlcXVpcmVkJykgPyAnU0VBUkNILkZJTFRFUi5WQUxJREFUSU9OLlJFUVVJUkVELVZBTFVFJyA6XG4gICAgICAgICAgICAnJztcbiAgICB9XG5cbiAgICBuZ09uSW5pdCgpIHtcbiAgICAgICAgdGhpcy5kYXRldGltZVBpY2tlckZvcm1hdCA9IHRoaXMuc2V0dGluZ3M/LmRhdGV0aW1lRm9ybWF0ID8gdGhpcy5zZXR0aW5ncy5kYXRldGltZUZvcm1hdCA6IERFRkFVTFRfREFURVRJTUVfRk9STUFUO1xuXG4gICAgICAgIHRoaXMudXNlclByZWZlcmVuY2VzU2VydmljZVxuICAgICAgICAgICAgLnNlbGVjdChVc2VyUHJlZmVyZW5jZVZhbHVlcy5Mb2NhbGUpXG4gICAgICAgICAgICAucGlwZSh0YWtlVW50aWwodGhpcy5vbkRlc3Ryb3kkKSlcbiAgICAgICAgICAgIC5zdWJzY3JpYmUobG9jYWxlID0+IHRoaXMuc2V0TG9jYWxlKGxvY2FsZSkpO1xuXG4gICAgICAgIGNvbnN0IHZhbGlkYXRvcnMgPSBWYWxpZGF0b3JzLmNvbXBvc2UoW1xuICAgICAgICAgICAgVmFsaWRhdG9ycy5yZXF1aXJlZFxuICAgICAgICBdKTtcblxuICAgICAgICBpZiAodGhpcy5zZXR0aW5ncyAmJiB0aGlzLnNldHRpbmdzLm1heERhdGV0aW1lKSB7XG4gICAgICAgICAgICB0aGlzLm1heERhdGV0aW1lID0gbW9tZW50KHRoaXMuc2V0dGluZ3MubWF4RGF0ZXRpbWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuc3RhcnRWYWx1ZSkge1xuICAgICAgICAgICAgY29uc3Qgc3BsaXRWYWx1ZSA9IHRoaXMuc3RhcnRWYWx1ZS5zcGxpdCgnfHwnKTtcbiAgICAgICAgICAgIGNvbnN0IGZyb21WYWx1ZSA9IHRoaXMuZGF0ZUFkYXB0ZXIucGFyc2Uoc3BsaXRWYWx1ZVswXSwgdGhpcy5kYXRldGltZVBpY2tlckZvcm1hdCk7XG4gICAgICAgICAgICBjb25zdCB0b1ZhbHVlID0gdGhpcy5kYXRlQWRhcHRlci5wYXJzZShzcGxpdFZhbHVlWzFdLCB0aGlzLmRhdGV0aW1lUGlja2VyRm9ybWF0KTtcbiAgICAgICAgICAgIHRoaXMuZnJvbSA9IG5ldyBGb3JtQ29udHJvbChmcm9tVmFsdWUsIHZhbGlkYXRvcnMpO1xuICAgICAgICAgICAgdGhpcy50byA9IG5ldyBGb3JtQ29udHJvbCh0b1ZhbHVlLCB2YWxpZGF0b3JzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZnJvbSA9IG5ldyBGb3JtQ29udHJvbCgnJywgdmFsaWRhdG9ycyk7XG4gICAgICAgICAgICB0aGlzLnRvID0gbmV3IEZvcm1Db250cm9sKCcnLCB2YWxpZGF0b3JzKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZm9ybSA9IG5ldyBGb3JtR3JvdXAoe1xuICAgICAgICAgICAgZnJvbTogdGhpcy5mcm9tLFxuICAgICAgICAgICAgdG86IHRoaXMudG9cbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5zZXRGcm9tTWF4RGF0ZXRpbWUoKTtcbiAgICAgICAgdGhpcy5lbmFibGVDaGFuZ2VVcGRhdGUgPSB0aGlzLnNldHRpbmdzPy5hbGxvd1VwZGF0ZU9uQ2hhbmdlID8/IHRydWU7XG4gICAgfVxuXG4gICAgbmdPbkRlc3Ryb3koKSB7XG4gICAgICAgIHRoaXMub25EZXN0cm95JC5uZXh0KHRydWUpO1xuICAgICAgICB0aGlzLm9uRGVzdHJveSQuY29tcGxldGUoKTtcbiAgICB9XG5cbiAgICBhcHBseShtb2RlbDogeyBmcm9tOiBzdHJpbmcsIHRvOiBzdHJpbmcgfSwgaXNWYWxpZDogYm9vbGVhbikge1xuICAgICAgICBpZiAoaXNWYWxpZCAmJiB0aGlzLmlkICYmIHRoaXMuY29udGV4dCAmJiB0aGlzLnNldHRpbmdzICYmIHRoaXMuc2V0dGluZ3MuZmllbGQpIHtcbiAgICAgICAgICAgIHRoaXMuaXNBY3RpdmUgPSB0cnVlO1xuXG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IG1vbWVudC51dGMobW9kZWwuZnJvbSkuc3RhcnRPZignbWludXRlJykuZm9ybWF0KCk7XG4gICAgICAgICAgICBjb25zdCBlbmQgPSBtb21lbnQudXRjKG1vZGVsLnRvKS5lbmRPZignbWludXRlJykuZm9ybWF0KCk7XG5cbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5xdWVyeUZyYWdtZW50c1t0aGlzLmlkXSA9IGAke3RoaXMuc2V0dGluZ3MuZmllbGR9OlsnJHtzdGFydH0nIFRPICcke2VuZH0nXWA7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZURpc3BsYXlWYWx1ZSgpO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgc3VibWl0VmFsdWVzKCkge1xuICAgICAgICB0aGlzLmFwcGx5KHRoaXMuZm9ybS52YWx1ZSwgdGhpcy5mb3JtLnZhbGlkKTtcbiAgICB9XG5cbiAgICBoYXNWYWxpZFZhbHVlKCk6IGJvb2xlYW4ge1xuICAgICAgICByZXR1cm4gdGhpcy5mb3JtLnZhbGlkO1xuICAgIH1cblxuICAgIGdldEN1cnJlbnRWYWx1ZSgpOiBEYXRldGltZVJhbmdlVmFsdWUge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZnJvbTogdGhpcy5kYXRlQWRhcHRlci5mb3JtYXQodGhpcy5mb3JtLnZhbHVlLmZyb20sIHRoaXMuZGF0ZXRpbWVQaWNrZXJGb3JtYXQpLFxuICAgICAgICAgICAgdG86IHRoaXMuZGF0ZUFkYXB0ZXIuZm9ybWF0KHRoaXMuZm9ybS52YWx1ZS50bywgdGhpcy5kYXRldGltZVBpY2tlckZvcm1hdClcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICB1cGRhdGVEaXNwbGF5VmFsdWUoKTogdm9pZCB7XG4gICAgICAgIGlmICh0aGlzLmZvcm0uaW52YWxpZCB8fCB0aGlzLmZvcm0ucHJpc3RpbmUpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheVZhbHVlJC5uZXh0KCcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGlzcGxheVZhbHVlJC5uZXh0KGAke3RoaXMuZGF0ZUFkYXB0ZXIuZm9ybWF0KHRoaXMuZm9ybS52YWx1ZS5mcm9tLCB0aGlzLmRhdGV0aW1lUGlja2VyRm9ybWF0KX0gLSAke3RoaXMuZGF0ZUFkYXB0ZXIuZm9ybWF0KHRoaXMuZm9ybS52YWx1ZS50bywgdGhpcy5kYXRldGltZVBpY2tlckZvcm1hdCl9YCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBzZXRWYWx1ZShwYXJzZWREYXRlOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3Qgc3BsaXRWYWx1ZSA9IHBhcnNlZERhdGUuc3BsaXQoJ3x8Jyk7XG4gICAgICAgIGNvbnN0IGZyb21WYWx1ZSA9IHRoaXMuZGF0ZUFkYXB0ZXIucGFyc2Uoc3BsaXRWYWx1ZVswXSwgdGhpcy5kYXRldGltZVBpY2tlckZvcm1hdCk7XG4gICAgICAgIGNvbnN0IHRvVmFsdWUgPSB0aGlzLmRhdGVBZGFwdGVyLnBhcnNlKHNwbGl0VmFsdWVbMV0sIHRoaXMuZGF0ZXRpbWVQaWNrZXJGb3JtYXQpO1xuICAgICAgICB0aGlzLmZyb20uc2V0VmFsdWUoZnJvbVZhbHVlKTtcbiAgICAgICAgdGhpcy5mcm9tLm1hcmtBc0RpcnR5KCk7XG4gICAgICAgIHRoaXMuZnJvbS5tYXJrQXNUb3VjaGVkKCk7XG4gICAgICAgIHRoaXMudG8uc2V0VmFsdWUodG9WYWx1ZSk7XG4gICAgICAgIHRoaXMudG8ubWFya0FzRGlydHkoKTtcbiAgICAgICAgdGhpcy50by5tYXJrQXNUb3VjaGVkKCk7XG4gICAgICAgIHRoaXMuc3VibWl0VmFsdWVzKCk7XG4gICAgfVxuXG4gICAgY2xlYXIoKSB7XG4gICAgICAgIHRoaXMuaXNBY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5mb3JtLnJlc2V0KHtcbiAgICAgICAgICAgIGZyb206ICcnLFxuICAgICAgICAgICAgdG86ICcnXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5pZCAmJiB0aGlzLmNvbnRleHQpIHtcbiAgICAgICAgICAgIHRoaXMuY29udGV4dC5xdWVyeUZyYWdtZW50c1t0aGlzLmlkXSA9ICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMuaWQgJiYgdGhpcy5jb250ZXh0ICYmIHRoaXMuZW5hYmxlQ2hhbmdlVXBkYXRlKSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZVF1ZXJ5KCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRGcm9tTWF4RGF0ZXRpbWUoKTtcbiAgICB9XG5cbiAgICByZXNldCgpIHtcbiAgICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgICB0aGlzLnVwZGF0ZVF1ZXJ5KCk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSB1cGRhdGVRdWVyeSgpIHtcbiAgICAgICAgaWYgKHRoaXMuaWQgJiYgdGhpcy5jb250ZXh0KSB7XG4gICAgICAgICAgICB0aGlzLnVwZGF0ZURpc3BsYXlWYWx1ZSgpO1xuICAgICAgICAgICAgdGhpcy5jb250ZXh0LnVwZGF0ZSgpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgb25DaGFuZ2VkSGFuZGxlcihldmVudDogYW55LCBmb3JtQ29udHJvbDogRm9ybUNvbnRyb2wpIHtcblxuICAgICAgICBjb25zdCBpbnB1dFZhbHVlID0gZXZlbnQudmFsdWU7XG4gICAgICAgIGNvbnN0IGZvcm1hdERhdGUgPSB0aGlzLmRhdGVBZGFwdGVyLnBhcnNlKGlucHV0VmFsdWUsIHRoaXMuZGF0ZXRpbWVQaWNrZXJGb3JtYXQpO1xuICAgICAgICBpZiAoZm9ybWF0RGF0ZSAmJiBmb3JtYXREYXRlLmlzVmFsaWQoKSkge1xuICAgICAgICAgICAgZm9ybUNvbnRyb2wuc2V0VmFsdWUoZm9ybWF0RGF0ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAoZm9ybWF0RGF0ZSkge1xuICAgICAgICAgICAgZm9ybUNvbnRyb2wuc2V0RXJyb3JzKHtcbiAgICAgICAgICAgICAgICAnaW52YWxpZE9uQ2hhbmdlJzogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldEZyb21NYXhEYXRldGltZSgpO1xuICAgIH1cblxuICAgIHNldExvY2FsZShsb2NhbGUpIHtcbiAgICAgICAgdGhpcy5kYXRlQWRhcHRlci5zZXRMb2NhbGUobG9jYWxlKTtcbiAgICAgICAgbW9tZW50LmxvY2FsZShsb2NhbGUpO1xuICAgIH1cblxuICAgIGhhc1BhcnNlRXJyb3IoZm9ybUNvbnRyb2wpOiBib29sZWFuIHtcbiAgICAgICAgcmV0dXJuIGZvcm1Db250cm9sLmhhc0Vycm9yKCdtYXREYXRlcGlja2VyUGFyc2UnKSAmJiBmb3JtQ29udHJvbC5nZXRFcnJvcignbWF0RGF0ZXBpY2tlclBhcnNlJykudGV4dDtcbiAgICB9XG5cbiAgICBmb3JjZVBsYWNlaG9sZGVyKGV2ZW50OiBhbnkpIHtcbiAgICAgICAgZXZlbnQuc3JjRWxlbWVudC5jbGljaygpO1xuICAgIH1cblxuICAgIHNldEZyb21NYXhEYXRldGltZSgpIHtcbiAgICAgICAgdGhpcy5mcm9tTWF4RGF0ZXRpbWUgPSAoIXRoaXMudG8udmFsdWUgfHwgdGhpcy5tYXhEYXRldGltZSAmJiAobW9tZW50KHRoaXMubWF4RGF0ZXRpbWUpLmlzQmVmb3JlKHRoaXMudG8udmFsdWUpKSkgPyB0aGlzLm1heERhdGV0aW1lIDogbW9tZW50KHRoaXMudG8udmFsdWUpO1xuICAgIH1cbn1cbiJdfQ==