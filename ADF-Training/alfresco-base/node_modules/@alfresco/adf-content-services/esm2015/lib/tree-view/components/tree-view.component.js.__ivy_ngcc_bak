/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
import { FlatTreeControl } from '@angular/cdk/tree';
import { Component, Input, Output, EventEmitter } from '@angular/core';
import { TreeViewDataSource } from '../data/tree-view-datasource';
import { TreeViewService } from '../services/tree-view.service';
export class TreeViewComponent {
    constructor(treeViewService) {
        this.treeViewService = treeViewService;
        this.nodeClicked = new EventEmitter();
        this.error = new EventEmitter();
        this.getLevel = (node) => node.level;
        this.isExpandable = (node) => node.expandable;
        this.hasChild = (_, nodeData) => nodeData.expandable;
        this.treeControl = new FlatTreeControl(this.getLevel, this.isExpandable);
        this.dataSource = new TreeViewDataSource(this.treeControl, this.treeViewService);
    }
    ngOnChanges(changes) {
        if (changes['nodeId'] && changes['nodeId'].currentValue &&
            changes['nodeId'].currentValue !== changes['nodeId'].previousValue) {
            this.loadTreeNode();
        }
        else {
            this.dataSource.data = [];
        }
    }
    onNodeClicked(node) {
        this.nodeClicked.emit(node);
    }
    loadTreeNode() {
        this.treeViewService.getTreeNodes(this.nodeId)
            .subscribe((treeNode) => {
            this.dataSource.data = treeNode;
        }, (error) => this.error.emit(error));
    }
}
TreeViewComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-tree-view-list',
                template: "<mat-tree class=\"adf-tree-view-main\" [dataSource]=\"dataSource\"\n          [treeControl]=\"treeControl\" *ngIf=\"nodeId; else missingNodeId\">\n    <mat-tree-node class=\"adf-tree-view-node\"\n        *matTreeNodeDef=\"let treeNode\" id=\"{{treeNode.name + '-tree-node'}}\"\n        matTreeNodePadding [matTreeNodePaddingIndent]=\"15\">\n        {{treeNode.name}}\n    </mat-tree-node>\n    <mat-tree-node class=\"adf-tree-view-node\"\n        id=\"{{treeNode.name + '-tree-child-node'}}\" *matTreeNodeDef=\"let treeNode; when: hasChild\"\n        matTreeNodePadding [matTreeNodePaddingIndent]=\"15\">\n        <button matTreeNodeToggle id=\"{{'button-'+treeNode.name}}\" (click)=\"onNodeClicked(treeNode.node)\"\n                mat-icon-button [attr.aria-label]=\"'ADF-TREE-VIEW.ACCESSIBILITY.ARIA_LABEL' | translate: {\n                    name:  treeNode.name\n                }\">\n            <mat-icon class=\"adf-tree-view-icon\">\n                {{treeControl.isExpanded(treeNode) ? 'folder_open' : 'folder'}}\n            </mat-icon>\n        </button>\n        <span class=\"adf-tree-view-label\" matTreeNodeToggle (click)=\"onNodeClicked(treeNode.node)\">{{treeNode.name}}</span>\n    </mat-tree-node>\n</mat-tree>\n<ng-template #missingNodeId>\n    <div id=\"adf-tree-view-missing-node\">\n        {{'ADF-TREE-VIEW.MISSING-ID' | translate}}\n    </div>\n</ng-template>\n",
                styles: [".adf-tree-view-icon{color:#d9e022}.adf-tree-view-node.mat-tree-node{align-items:baseline;font-size:12px;min-height:40px}.adf-tree-view-label{cursor:pointer}"]
            },] }
];
TreeViewComponent.ctorParameters = () => [
    { type: TreeViewService }
];
TreeViewComponent.propDecorators = {
    nodeId: [{ type: Input }],
    nodeClicked: [{ type: Output }],
    error: [{ type: Output }]
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHJlZS12aWV3LmNvbXBvbmVudC5qcyIsInNvdXJjZVJvb3QiOiIvaG9tZS90cmF2aXMvYnVpbGQvQWxmcmVzY28vYWxmcmVzY28tbmcyLWNvbXBvbmVudHMvbGliL2NvbnRlbnQtc2VydmljZXMvc3JjLyIsInNvdXJjZXMiOlsibGliL3RyZWUtdmlldy9jb21wb25lbnRzL3RyZWUtdmlldy5jb21wb25lbnQudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztHQWVHO0FBRUgsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLG1CQUFtQixDQUFDO0FBQ3BELE9BQU8sRUFBRSxTQUFTLEVBQUUsS0FBSyxFQUE0QixNQUFNLEVBQUUsWUFBWSxFQUFFLE1BQU0sZUFBZSxDQUFDO0FBRWpHLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLDhCQUE4QixDQUFDO0FBQ2xFLE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSwrQkFBK0IsQ0FBQztBQVNoRSxNQUFNLE9BQU8saUJBQWlCO0lBaUIxQixZQUFvQixlQUFnQztRQUFoQyxvQkFBZSxHQUFmLGVBQWUsQ0FBaUI7UUFUcEQsZ0JBQVcsR0FBNEIsSUFBSSxZQUFZLEVBQUUsQ0FBQztRQUkxRCxVQUFLLEdBQXNCLElBQUksWUFBWSxFQUFFLENBQUM7UUF1QjlDLGFBQVEsR0FBRyxDQUFDLElBQWtCLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUM7UUFFOUMsaUJBQVksR0FBRyxDQUFDLElBQWtCLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUM7UUFFdkQsYUFBUSxHQUFHLENBQUMsQ0FBUyxFQUFFLFFBQXNCLEVBQUUsRUFBRSxDQUFDLFFBQVEsQ0FBQyxVQUFVLENBQUM7UUFyQmxFLElBQUksQ0FBQyxXQUFXLEdBQUcsSUFBSSxlQUFlLENBQWUsSUFBSSxDQUFDLFFBQVEsRUFBRSxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7UUFDdkYsSUFBSSxDQUFDLFVBQVUsR0FBRyxJQUFJLGtCQUFrQixDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsSUFBSSxDQUFDLGVBQWUsQ0FBQyxDQUFDO0lBQ3JGLENBQUM7SUFFRCxXQUFXLENBQUMsT0FBc0I7UUFDOUIsSUFBSSxPQUFPLENBQUMsUUFBUSxDQUFDLElBQUksT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLFlBQVk7WUFDbkQsT0FBTyxDQUFDLFFBQVEsQ0FBQyxDQUFDLFlBQVksS0FBSyxPQUFPLENBQUMsUUFBUSxDQUFDLENBQUMsYUFBYSxFQUFFO1lBQ3BFLElBQUksQ0FBQyxZQUFZLEVBQUUsQ0FBQztTQUN2QjthQUFNO1lBQ0gsSUFBSSxDQUFDLFVBQVUsQ0FBQyxJQUFJLEdBQUcsRUFBRSxDQUFDO1NBQzdCO0lBQ0wsQ0FBQztJQUVELGFBQWEsQ0FBQyxJQUFlO1FBQ3pCLElBQUksQ0FBQyxXQUFXLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxDQUFDO0lBQ2hDLENBQUM7SUFRTyxZQUFZO1FBQ2hCLElBQUksQ0FBQyxlQUFlLENBQUMsWUFBWSxDQUFDLElBQUksQ0FBQyxNQUFNLENBQUM7YUFDekMsU0FBUyxDQUNOLENBQUMsUUFBd0IsRUFBRSxFQUFFO1lBQ3pCLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxHQUFHLFFBQVEsQ0FBQztRQUNwQyxDQUFDLEVBQ0QsQ0FBQyxLQUFLLEVBQUUsRUFBRSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUNwQyxDQUFDO0lBQ1YsQ0FBQzs7O1lBdkRKLFNBQVMsU0FBQztnQkFDUCxRQUFRLEVBQUUsb0JBQW9CO2dCQUM5Qix1M0NBQXlDOzthQUU1Qzs7O1lBUFEsZUFBZTs7O3FCQVluQixLQUFLOzBCQUlMLE1BQU07b0JBSU4sTUFBTSIsInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE5IEFsZnJlc2NvIFNvZnR3YXJlLCBMdGQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7IEZsYXRUcmVlQ29udHJvbCB9IGZyb20gJ0Bhbmd1bGFyL2Nkay90cmVlJztcbmltcG9ydCB7IENvbXBvbmVudCwgSW5wdXQsIE9uQ2hhbmdlcywgU2ltcGxlQ2hhbmdlcywgT3V0cHV0LCBFdmVudEVtaXR0ZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IFRyZWVCYXNlTm9kZSB9IGZyb20gJy4uL21vZGVscy90cmVlLXZpZXcubW9kZWwnO1xuaW1wb3J0IHsgVHJlZVZpZXdEYXRhU291cmNlIH0gZnJvbSAnLi4vZGF0YS90cmVlLXZpZXctZGF0YXNvdXJjZSc7XG5pbXBvcnQgeyBUcmVlVmlld1NlcnZpY2UgfSBmcm9tICcuLi9zZXJ2aWNlcy90cmVlLXZpZXcuc2VydmljZSc7XG5pbXBvcnQgeyBOb2RlRW50cnkgfSBmcm9tICdAYWxmcmVzY28vanMtYXBpJztcblxuQENvbXBvbmVudCh7XG4gICAgc2VsZWN0b3I6ICdhZGYtdHJlZS12aWV3LWxpc3QnLFxuICAgIHRlbXBsYXRlVXJsOiAnLi90cmVlLXZpZXcuY29tcG9uZW50Lmh0bWwnLFxuICAgIHN0eWxlVXJsczogWycuL3RyZWUtdmlldy5jb21wb25lbnQuc2NzcyddXG59KVxuXG5leHBvcnQgY2xhc3MgVHJlZVZpZXdDb21wb25lbnQgaW1wbGVtZW50cyBPbkNoYW5nZXMge1xuXG4gICAgLyoqIElkZW50aWZpZXIgb2YgdGhlIG5vZGUgdG8gZGlzcGxheS4gKi9cbiAgICBASW5wdXQoKVxuICAgIG5vZGVJZDogc3RyaW5nO1xuXG4gICAgLyoqIEVtaXR0ZWQgd2hlbiBhIG5vZGUgaW4gdGhlIHRyZWUgdmlldyBpcyBjbGlja2VkLiAqL1xuICAgIEBPdXRwdXQoKVxuICAgIG5vZGVDbGlja2VkOiBFdmVudEVtaXR0ZXI8Tm9kZUVudHJ5PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIC8qKiBFbWl0dGVkIHdoZW4gYW4gaW52YWxpZCBub2RlIGlkIGlzIGdpdmVuLiAqL1xuICAgIEBPdXRwdXQoKVxuICAgIGVycm9yOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcblxuICAgIHRyZWVDb250cm9sOiBGbGF0VHJlZUNvbnRyb2w8VHJlZUJhc2VOb2RlPjtcbiAgICBkYXRhU291cmNlOiBUcmVlVmlld0RhdGFTb3VyY2U7XG5cbiAgICBjb25zdHJ1Y3Rvcihwcml2YXRlIHRyZWVWaWV3U2VydmljZTogVHJlZVZpZXdTZXJ2aWNlKSB7XG4gICAgICAgIHRoaXMudHJlZUNvbnRyb2wgPSBuZXcgRmxhdFRyZWVDb250cm9sPFRyZWVCYXNlTm9kZT4odGhpcy5nZXRMZXZlbCwgdGhpcy5pc0V4cGFuZGFibGUpO1xuICAgICAgICB0aGlzLmRhdGFTb3VyY2UgPSBuZXcgVHJlZVZpZXdEYXRhU291cmNlKHRoaXMudHJlZUNvbnRyb2wsIHRoaXMudHJlZVZpZXdTZXJ2aWNlKTtcbiAgICB9XG5cbiAgICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKSB7XG4gICAgICAgIGlmIChjaGFuZ2VzWydub2RlSWQnXSAmJiBjaGFuZ2VzWydub2RlSWQnXS5jdXJyZW50VmFsdWUgJiZcbiAgICAgICAgICAgIGNoYW5nZXNbJ25vZGVJZCddLmN1cnJlbnRWYWx1ZSAhPT0gY2hhbmdlc1snbm9kZUlkJ10ucHJldmlvdXNWYWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5sb2FkVHJlZU5vZGUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuZGF0YVNvdXJjZS5kYXRhID0gW107XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBvbk5vZGVDbGlja2VkKG5vZGU6IE5vZGVFbnRyeSkge1xuICAgICAgICB0aGlzLm5vZGVDbGlja2VkLmVtaXQobm9kZSk7XG4gICAgfVxuXG4gICAgZ2V0TGV2ZWwgPSAobm9kZTogVHJlZUJhc2VOb2RlKSA9PiBub2RlLmxldmVsO1xuXG4gICAgaXNFeHBhbmRhYmxlID0gKG5vZGU6IFRyZWVCYXNlTm9kZSkgPT4gbm9kZS5leHBhbmRhYmxlO1xuXG4gICAgaGFzQ2hpbGQgPSAoXzogbnVtYmVyLCBub2RlRGF0YTogVHJlZUJhc2VOb2RlKSA9PiBub2RlRGF0YS5leHBhbmRhYmxlO1xuXG4gICAgcHJpdmF0ZSBsb2FkVHJlZU5vZGUoKSB7XG4gICAgICAgIHRoaXMudHJlZVZpZXdTZXJ2aWNlLmdldFRyZWVOb2Rlcyh0aGlzLm5vZGVJZClcbiAgICAgICAgICAgIC5zdWJzY3JpYmUoXG4gICAgICAgICAgICAgICAgKHRyZWVOb2RlOiBUcmVlQmFzZU5vZGVbXSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRhdGFTb3VyY2UuZGF0YSA9IHRyZWVOb2RlO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgKGVycm9yKSA9PiB0aGlzLmVycm9yLmVtaXQoZXJyb3IpXG4gICAgICAgICAgICApO1xuICAgIH1cbn1cbiJdfQ==