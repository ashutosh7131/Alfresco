import { AlfrescoApiService, AppConfigService, DiscoveryApiService, UploadService } from '@alfresco/adf-core';
import { ActivitiContentApi } from '@alfresco/js-api';
import { Injectable } from '@angular/core';
import { throwError } from 'rxjs';
import * as i0 from "@angular/core";
import * as i1 from "@alfresco/adf-core";
export class ProcessUploadService extends UploadService {
    constructor(apiService, appConfigService, discoveryApiService) {
        super(apiService, appConfigService, discoveryApiService);
        this.apiService = apiService;
    }
    get contentApi() {
        var _a;
        this._contentApi = (_a = this._contentApi) !== null && _a !== void 0 ? _a : new ActivitiContentApi(this.apiService.getInstance());
        return this._contentApi;
    }
    getUploadPromise(file) {
        const opts = {
            isRelatedContent: true
        };
        const processInstanceId = file.options.parentId;
        const promise = this.contentApi.createRelatedContentOnProcessInstance(processInstanceId, file.file, opts);
        promise.catch((err) => this.handleError(err));
        return promise;
    }
    handleError(error) {
        return throwError(error || 'Server error');
    }
}
ProcessUploadService.ɵprov = i0.ɵɵdefineInjectable({ factory: function ProcessUploadService_Factory() { return new ProcessUploadService(i0.ɵɵinject(i1.AlfrescoApiService), i0.ɵɵinject(i1.AppConfigService), i0.ɵɵinject(i1.DiscoveryApiService)); }, token: ProcessUploadService, providedIn: "root" });
ProcessUploadService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
ProcessUploadService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: AppConfigService },
    { type: DiscoveryApiService }
];
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvY2Vzcy11cGxvYWQuc2VydmljZS5qcyIsInNvdXJjZVJvb3QiOiIvaG9tZS90cmF2aXMvYnVpbGQvQWxmcmVzY28vYWxmcmVzY28tbmcyLWNvbXBvbmVudHMvbGliL3Byb2Nlc3Mtc2VydmljZXMvc3JjLyIsInNvdXJjZXMiOlsibGliL3Rhc2stbGlzdC9zZXJ2aWNlcy9wcm9jZXNzLXVwbG9hZC5zZXJ2aWNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQWlCQSxPQUFPLEVBQUUsa0JBQWtCLEVBQUUsZ0JBQWdCLEVBQUUsbUJBQW1CLEVBQUUsYUFBYSxFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFDOUcsT0FBTyxFQUFFLGtCQUFrQixFQUFFLE1BQU0sa0JBQWtCLENBQUM7QUFDdEQsT0FBTyxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUMzQyxPQUFPLEVBQUUsVUFBVSxFQUFFLE1BQU0sTUFBTSxDQUFDOzs7QUFLbEMsTUFBTSxPQUFPLG9CQUFxQixTQUFRLGFBQWE7SUFRbkQsWUFBc0IsVUFBOEIsRUFBRSxnQkFBa0MsRUFBRSxtQkFBd0M7UUFDOUgsS0FBSyxDQUFDLFVBQVUsRUFBRSxnQkFBZ0IsRUFBRSxtQkFBbUIsQ0FBQyxDQUFDO1FBRHZDLGVBQVUsR0FBVixVQUFVLENBQW9CO0lBRXBELENBQUM7SUFQRCxJQUFJLFVBQVU7O1FBQ1YsSUFBSSxDQUFDLFdBQVcsU0FBRyxJQUFJLENBQUMsV0FBVyxtQ0FBSSxJQUFJLGtCQUFrQixDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsV0FBVyxFQUFFLENBQUMsQ0FBQztRQUM3RixPQUFPLElBQUksQ0FBQyxXQUFXLENBQUM7SUFDNUIsQ0FBQztJQU1ELGdCQUFnQixDQUFDLElBQVM7UUFDdEIsTUFBTSxJQUFJLEdBQUc7WUFDVCxnQkFBZ0IsRUFBRSxJQUFJO1NBQ3pCLENBQUM7UUFDRixNQUFNLGlCQUFpQixHQUFHLElBQUksQ0FBQyxPQUFPLENBQUMsUUFBUSxDQUFDO1FBQ2hELE1BQU0sT0FBTyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMscUNBQXFDLENBQUMsaUJBQWlCLEVBQUUsSUFBSSxDQUFDLElBQUksRUFBRSxJQUFJLENBQUMsQ0FBQztRQUUxRyxPQUFPLENBQUMsS0FBSyxDQUFDLENBQUMsR0FBRyxFQUFFLEVBQUUsQ0FBQyxJQUFJLENBQUMsV0FBVyxDQUFDLEdBQUcsQ0FBQyxDQUFDLENBQUM7UUFFOUMsT0FBTyxPQUFPLENBQUM7SUFDbkIsQ0FBQztJQUVPLFdBQVcsQ0FBQyxLQUFVO1FBQzFCLE9BQU8sVUFBVSxDQUFDLEtBQUssSUFBSSxjQUFjLENBQUMsQ0FBQztJQUMvQyxDQUFDOzs7O1lBN0JKLFVBQVUsU0FBQztnQkFDUixVQUFVLEVBQUUsTUFBTTthQUNyQjs7O1lBUFEsa0JBQWtCO1lBQUUsZ0JBQWdCO1lBQUUsbUJBQW1CIiwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTkgQWxmcmVzY28gU29mdHdhcmUsIEx0ZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHsgQWxmcmVzY29BcGlTZXJ2aWNlLCBBcHBDb25maWdTZXJ2aWNlLCBEaXNjb3ZlcnlBcGlTZXJ2aWNlLCBVcGxvYWRTZXJ2aWNlIH0gZnJvbSAnQGFsZnJlc2NvL2FkZi1jb3JlJztcbmltcG9ydCB7IEFjdGl2aXRpQ29udGVudEFwaSB9IGZyb20gJ0BhbGZyZXNjby9qcy1hcGknO1xuaW1wb3J0IHsgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgdGhyb3dFcnJvciB9IGZyb20gJ3J4anMnO1xuXG5ASW5qZWN0YWJsZSh7XG4gICAgcHJvdmlkZWRJbjogJ3Jvb3QnXG59KVxuZXhwb3J0IGNsYXNzIFByb2Nlc3NVcGxvYWRTZXJ2aWNlIGV4dGVuZHMgVXBsb2FkU2VydmljZSB7XG5cbiAgICBwcml2YXRlIF9jb250ZW50QXBpO1xuICAgIGdldCBjb250ZW50QXBpKCk6IEFjdGl2aXRpQ29udGVudEFwaSB7XG4gICAgICAgIHRoaXMuX2NvbnRlbnRBcGkgPSB0aGlzLl9jb250ZW50QXBpID8/IG5ldyBBY3Rpdml0aUNvbnRlbnRBcGkodGhpcy5hcGlTZXJ2aWNlLmdldEluc3RhbmNlKCkpO1xuICAgICAgICByZXR1cm4gdGhpcy5fY29udGVudEFwaTtcbiAgICB9XG5cbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgYXBpU2VydmljZTogQWxmcmVzY29BcGlTZXJ2aWNlLCBhcHBDb25maWdTZXJ2aWNlOiBBcHBDb25maWdTZXJ2aWNlLCBkaXNjb3ZlcnlBcGlTZXJ2aWNlOiBEaXNjb3ZlcnlBcGlTZXJ2aWNlKSB7XG4gICAgICAgIHN1cGVyKGFwaVNlcnZpY2UsIGFwcENvbmZpZ1NlcnZpY2UsIGRpc2NvdmVyeUFwaVNlcnZpY2UpO1xuICAgIH1cblxuICAgIGdldFVwbG9hZFByb21pc2UoZmlsZTogYW55KTogYW55IHtcbiAgICAgICAgY29uc3Qgb3B0cyA9IHtcbiAgICAgICAgICAgIGlzUmVsYXRlZENvbnRlbnQ6IHRydWVcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcHJvY2Vzc0luc3RhbmNlSWQgPSBmaWxlLm9wdGlvbnMucGFyZW50SWQ7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLmNvbnRlbnRBcGkuY3JlYXRlUmVsYXRlZENvbnRlbnRPblByb2Nlc3NJbnN0YW5jZShwcm9jZXNzSW5zdGFuY2VJZCwgZmlsZS5maWxlLCBvcHRzKTtcblxuICAgICAgICBwcm9taXNlLmNhdGNoKChlcnIpID0+IHRoaXMuaGFuZGxlRXJyb3IoZXJyKSk7XG5cbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBoYW5kbGVFcnJvcihlcnJvcjogYW55KSB7XG4gICAgICAgIHJldHVybiB0aHJvd0Vycm9yKGVycm9yIHx8ICdTZXJ2ZXIgZXJyb3InKTtcbiAgICB9XG5cbn1cbiJdfQ==