import { AlfrescoApiService, AppsProcessService, CardViewTextItemModel, CardViewDateItemModel, TranslationService, AppConfigService, UserProcessModel, LogService, DataTableSchema, PaginationComponent, UserPreferenceValues, UserPreferencesService, CustomEmptyContentTemplateDirective, CustomLoadingContentTemplateDirective, CardViewIntItemModel, CardViewItemLengthValidator, CardViewMapItemModel, BpmUserService, AuthenticationService, PeopleProcessService, CardViewUpdateService, ContentService, MOMENT_DATE_FORMATS, FormFieldModel, FormModel, MomentDateAdapter, FormService, UploadService, DiscoveryApiService, CommentProcessService, CoreModule, ShowHeaderMode, DataColumnListComponent, SitesService, SearchService, ExternalAlfrescoApiService, UploadWidgetComponent, AppConfigValues, ThumbnailService, ProcessContentService, ActivitiContentService, DownloadService, WidgetComponent, NodesApiService, FormBaseComponent, FormOutcomeModel, EcmModelService, FormEvent, FormErrorEvent, FormOutcomeEvent, WidgetVisibilityService, NodeService, FormRenderingService, LocalizedDatePipe, EmptyListComponent, TRANSLATION_PROVIDER } from '@alfresco/adf-core';
import { ɵɵdefineInjectable, ɵɵinject, Injectable, EventEmitter, Component, ViewEncapsulation, Input, Output, ContentChild, ViewChild, Directive, TemplateRef, HostListener, NgModule, Inject, Pipe, NgZone } from '@angular/core';
import { from, Observable, forkJoin, throwError, of, Subject, BehaviorSubject, zip } from 'rxjs';
import { map, catchError, flatMap, filter, switchMap, takeUntil, finalize, share, defaultIfEmpty, debounceTime, mergeMap } from 'rxjs/operators';
import { UserFiltersApi, TasksApi, ProcessDefinitionsApi, ProcessInstancesApi, ProcessInstanceVariablesApi, UserTaskFilterRepresentation, TaskQueryRepresentation, ModelsApi, TaskActionsApi, ChecklistsApi, ActivitiContentApi, ContentApi } from '@alfresco/js-api';
import { DatePipe, CommonModule } from '@angular/common';
import { MatDialog, MatDialogModule, MAT_DIALOG_DATA, MatDialogRef } from '@angular/material/dialog';
import moment$1 from 'moment-es6';
import { __awaiter } from 'tslib';
import { DateAdapter, MAT_DATE_FORMATS, MatOptionModule, MatNativeDateModule, MatRippleModule } from '@angular/material/core';
import { FormControl, Validators, FormBuilder, FormsModule, ReactiveFormsModule } from '@angular/forms';
import { FlexLayoutModule } from '@angular/flex-layout';
import { MatAutocompleteModule, MatAutocompleteTrigger } from '@angular/material/autocomplete';
import { MatButtonModule } from '@angular/material/button';
import { MatCardModule } from '@angular/material/card';
import { MatCheckboxModule } from '@angular/material/checkbox';
import { MatChipsModule } from '@angular/material/chips';
import { MAT_FORM_FIELD_DEFAULT_OPTIONS } from '@angular/material/form-field';
import { MatDatepickerModule } from '@angular/material/datepicker';
import { MatGridListModule } from '@angular/material/grid-list';
import { MatIconModule } from '@angular/material/icon';
import { MatInputModule } from '@angular/material/input';
import { MatListModule } from '@angular/material/list';
import { MatMenuModule } from '@angular/material/menu';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { MatRadioModule } from '@angular/material/radio';
import { MatSelectModule } from '@angular/material/select';
import { MatSlideToggleModule } from '@angular/material/slide-toggle';
import { MatTableModule } from '@angular/material/table';
import { MatTabsModule } from '@angular/material/tabs';
import { MatTooltipModule } from '@angular/material/tooltip';
import { DocumentListService, ContentNodeDialogService, ContentNodeSelectorModule } from '@alfresco/adf-content-services';

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FilterProcessRepresentationModel {
    constructor(obj) {
        if (obj) {
            this.id = obj.id || null;
            this.appId = obj.appId || null;
            this.name = obj.name || null;
            this.recent = !!obj.recent;
            this.icon = obj.icon || null;
            this.filter = obj.filter || null;
            this.index = obj.index;
        }
    }
    hasFilter() {
        return !!this.filter;
    }
}
class ProcessFilterParamRepresentationModel {
    constructor(obj) {
        this.processDefinitionId = obj.processDefinitionId || null;
        this.appDefinitionId = obj.appDefinitionId || null;
        this.processInstanceId = obj.processInstanceId || null;
        this.state = obj.state || null;
        this.sort = obj.sort || null;
        this.page = obj.page || null;
        this.size = obj.size || null;
    }
}

class ProcessFilterService {
    constructor(alfrescoApiService) {
        this.alfrescoApiService = alfrescoApiService;
    }
    get userFiltersApi() {
        var _a;
        this._userFiltersApi = (_a = this._userFiltersApi) !== null && _a !== void 0 ? _a : new UserFiltersApi(this.alfrescoApiService.getInstance());
        return this._userFiltersApi;
    }
    getProcessFilters(appId) {
        return from(this.callApiProcessFilters(appId))
            .pipe(map((response) => {
            const filters = [];
            response.data.forEach((filter) => {
                const filterModel = new FilterProcessRepresentationModel(filter);
                filters.push(filterModel);
            });
            return filters;
        }), catchError((err) => this.handleProcessError(err)));
    }
    getProcessFilterById(filterId, appId) {
        return from(this.callApiProcessFilters(appId))
            .pipe(map((response) => {
            return response.data.find((filter) => filter.id === filterId);
        }), catchError((err) => this.handleProcessError(err)));
    }
    getProcessFilterByName(filterName, appId) {
        return from(this.callApiProcessFilters(appId))
            .pipe(map((response) => {
            return response.data.find((filter) => filter.name === filterName);
        }), catchError((err) => this.handleProcessError(err)));
    }
    createDefaultFilters(appId) {
        const runningFilter = this.getRunningFilterInstance(appId, 0);
        const runningObservable = this.addProcessFilter(runningFilter);
        const completedFilter = this.getCompletedFilterInstance(appId, 1);
        const completedObservable = this.addProcessFilter(completedFilter);
        const allFilter = this.getAllFilterInstance(appId, 2);
        const allObservable = this.addProcessFilter(allFilter);
        return new Observable((observer) => {
            forkJoin([
                runningObservable,
                completedObservable,
                allObservable
            ]).subscribe((res) => {
                const filters = [];
                res.forEach((filter) => {
                    if (filter.name === runningFilter.name) {
                        filters.push(new FilterProcessRepresentationModel(Object.assign(Object.assign({}, filter), { filter: runningFilter.filter, appId })));
                    }
                    else if (filter.name === completedFilter.name) {
                        filters.push(new FilterProcessRepresentationModel(Object.assign(Object.assign({}, filter), { filter: completedFilter.filter, appId })));
                    }
                    else if (filter.name === allFilter.name) {
                        filters.push(new FilterProcessRepresentationModel(Object.assign(Object.assign({}, filter), { filter: allFilter.filter, appId })));
                    }
                });
                observer.next(filters);
                observer.complete();
            }, (err) => {
                this.handleProcessError(err);
            });
        });
    }
    getRunningFilterInstance(appId, index) {
        return new FilterProcessRepresentationModel({
            'name': 'Running',
            'appId': appId,
            'recent': true,
            'icon': 'glyphicon-random',
            'filter': { 'sort': 'created-desc', 'name': '', 'state': 'running' },
            index
        });
    }
    getCompletedFilterInstance(appId, index) {
        return new FilterProcessRepresentationModel({
            'name': 'Completed',
            'appId': appId,
            'recent': false,
            'icon': 'glyphicon-ok-sign',
            'filter': { 'sort': 'created-desc', 'name': '', 'state': 'completed' },
            index
        });
    }
    getAllFilterInstance(appId, index) {
        return new FilterProcessRepresentationModel({
            'name': 'All',
            'appId': appId,
            'recent': true,
            'icon': 'glyphicon-th',
            'filter': { 'sort': 'created-desc', 'name': '', 'state': 'all' },
            index
        });
    }
    addProcessFilter(filter) {
        return from(this.userFiltersApi.createUserProcessInstanceFilter(filter))
            .pipe(map((response) => {
            return response;
        }), catchError((err) => this.handleProcessError(err)));
    }
    callApiProcessFilters(appId) {
        if (appId) {
            return this.userFiltersApi.getUserProcessInstanceFilters({ appId: appId });
        }
        else {
            return this.userFiltersApi.getUserProcessInstanceFilters();
        }
    }
    handleProcessError(error) {
        return throwError(error || 'Server error');
    }
}
ProcessFilterService.ɵprov = ɵɵdefineInjectable({ factory: function ProcessFilterService_Factory() { return new ProcessFilterService(ɵɵinject(AlfrescoApiService)); }, token: ProcessFilterService, providedIn: "root" });
ProcessFilterService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
ProcessFilterService.ctorParameters = () => [
    { type: AlfrescoApiService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class IconModel {
    constructor() {
        this.initIconsMDL();
    }
    mapGlyphiconToMaterialDesignIcons(icon) {
        return this.iconsMDL.get(icon) ? this.iconsMDL.get(icon) : IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON;
    }
    initIconsMDL() {
        this.iconsMDL = new Map();
        this.iconsMDL.set('glyphicon-asterisk', 'ac_unit');
        this.iconsMDL.set('glyphicon-plus', 'add');
        this.iconsMDL.set('glyphicon-euro', 'euro_symbol');
        this.iconsMDL.set('glyphicon-cloud', 'cloud');
        this.iconsMDL.set('glyphicon-envelope', 'mail');
        this.iconsMDL.set('glyphicon-pencil', 'create');
        this.iconsMDL.set('glyphicon-glass', 'local_bar');
        this.iconsMDL.set('glyphicon-music', 'music_note');
        this.iconsMDL.set('glyphicon-search', 'search');
        this.iconsMDL.set('glyphicon-heart', 'favorite');
        this.iconsMDL.set('glyphicon-heart-empty', 'favorite_border');
        this.iconsMDL.set('glyphicon-star', 'star');
        this.iconsMDL.set('glyphicon-star-empty', 'star_border');
        this.iconsMDL.set('glyphicon-user', 'person');
        this.iconsMDL.set('glyphicon-film', 'movie_creation');
        this.iconsMDL.set('glyphicon-th-large', 'view_comfy');
        this.iconsMDL.set('glyphicon-th', 'dashboard');
        this.iconsMDL.set('glyphicon-th-list', 'list');
        this.iconsMDL.set('glyphicon-ok', 'done');
        this.iconsMDL.set('glyphicon-remove', 'cancel');
        this.iconsMDL.set('glyphicon-zoom-in', 'zoom_in');
        this.iconsMDL.set('glyphicon-zoom-out', 'zoom_out');
        this.iconsMDL.set('glyphicon-off', 'highlight_off');
        this.iconsMDL.set('glyphicon-signal', 'signal_cellular_4_bar');
        this.iconsMDL.set('glyphicon-cog', 'settings');
        this.iconsMDL.set('glyphicon-trash', 'delete');
        this.iconsMDL.set('glyphicon-home', 'home');
        this.iconsMDL.set('glyphicon-file', 'insert_drive_file');
        this.iconsMDL.set('glyphicon-time', 'access_time');
        this.iconsMDL.set('glyphicon-road', 'map');
        this.iconsMDL.set('glyphicon-download-alt', 'file_download');
        this.iconsMDL.set('glyphicon-download', 'file_download');
        this.iconsMDL.set('glyphicon-upload', 'file_upload');
        this.iconsMDL.set('glyphicon-inbox', 'inbox');
        this.iconsMDL.set('glyphicon-play-circle', 'play_circle_outline');
        this.iconsMDL.set('glyphicon-repeat', 'refresh');
        this.iconsMDL.set('glyphicon-refresh', 'sync');
        this.iconsMDL.set('glyphicon-list-alt', 'event_note');
        this.iconsMDL.set('glyphicon-lock', 'lock_outline');
        this.iconsMDL.set('glyphicon-flag', 'assistant_photo');
        this.iconsMDL.set('glyphicon-headphones', 'headset');
        this.iconsMDL.set('glyphicon-volume-up', 'volume_up');
        this.iconsMDL.set('glyphicon-tag', 'local_offer');
        this.iconsMDL.set('glyphicon-tags', 'local_offer');
        this.iconsMDL.set('glyphicon-book', 'library_books');
        this.iconsMDL.set('glyphicon-bookmark', 'collections_bookmark');
        this.iconsMDL.set('glyphicon-print', 'local_printshop');
        this.iconsMDL.set('glyphicon-camera', 'local_see');
        this.iconsMDL.set('glyphicon-list', 'view_list');
        this.iconsMDL.set('glyphicon-facetime-video', 'video_call');
        this.iconsMDL.set('glyphicon-picture', 'photo');
        this.iconsMDL.set('glyphicon-map-marker', 'add_location');
        this.iconsMDL.set('glyphicon-adjust', 'brightness_4');
        this.iconsMDL.set('glyphicon-tint', 'invert_colors');
        this.iconsMDL.set('glyphicon-edit', 'edit');
        this.iconsMDL.set('glyphicon-share', 'share');
        this.iconsMDL.set('glyphicon-check', 'assignment_turned_in');
        this.iconsMDL.set('glyphicon-move', 'open_with');
        this.iconsMDL.set('glyphicon-play', 'play_arrow');
        this.iconsMDL.set('glyphicon-eject', 'eject');
        this.iconsMDL.set('glyphicon-plus-sign', 'add_circle');
        this.iconsMDL.set('glyphicon-minus-sign', 'remove_circle');
        this.iconsMDL.set('glyphicon-remove-sign', 'cancel');
        this.iconsMDL.set('glyphicon-ok-sign', 'check_circle');
        this.iconsMDL.set('glyphicon-question-sign', 'help');
        this.iconsMDL.set('glyphicon-info-sign', 'info');
        this.iconsMDL.set('glyphicon-screenshot', 'flare');
        this.iconsMDL.set('glyphicon-remove-circle', 'cancel');
        this.iconsMDL.set('glyphicon-ok-circle', 'add_circle');
        this.iconsMDL.set('glyphicon-ban-circle', 'block');
        this.iconsMDL.set('glyphicon-share-alt', 'redo');
        this.iconsMDL.set('glyphicon-exclamation-sign', 'error');
        this.iconsMDL.set('glyphicon-gift', 'giftcard');
        this.iconsMDL.set('glyphicon-leaf', 'spa');
        this.iconsMDL.set('glyphicon-fire', 'whatshot');
        this.iconsMDL.set('glyphicon-eye-open', 'remove_red_eye');
        this.iconsMDL.set('glyphicon-eye-close', 'remove_red_eye');
        this.iconsMDL.set('glyphicon-warning-sign', 'warning');
        this.iconsMDL.set('glyphicon-plane', 'airplanemode_active');
        this.iconsMDL.set('glyphicon-calendar', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-random', 'shuffle');
        this.iconsMDL.set('glyphicon-comment', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-magnet', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-retweet', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-shopping-cart', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-folder-close', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-folder-open', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-hdd', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-bullhorn', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-bell', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-certificate', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-thumbs-up', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-thumbs-down', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-hand-left', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-globe', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-wrench', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-tasks', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-filter', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-briefcase', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-dashboard', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-paperclip', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-link', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-phone', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-pushpin', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-usd', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-gbp', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-sort', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-flash', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-record', 'radio_button_checked');
        this.iconsMDL.set('glyphicon-save', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-open', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-saved', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-send', 'send');
        this.iconsMDL.set('glyphicon-floppy-disk', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-credit-card', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-cutlery', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-earphone', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-phone-alt', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-tower', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-stats', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-cloud-download', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-cloud-upload', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-tree-conifer', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-tree-deciduous', IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON);
        this.iconsMDL.set('glyphicon-align-left', 'format_align_left');
    }
}
IconModel.DEFAULT_TASKS_APP_MATERIAL_ICON = 'favorite_border';

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessFiltersComponent {
    constructor(processFilterService, appsProcessService) {
        this.processFilterService = processFilterService;
        this.appsProcessService = appsProcessService;
        this.filterClicked = new EventEmitter();
        this.success = new EventEmitter();
        this.error = new EventEmitter();
        this.showIcon = true;
        this.filterSelected = new EventEmitter();
        this.filters = [];
        this.active = false;
    }
    ngOnInit() {
        this.iconsMDL = new IconModel();
    }
    ngOnChanges(changes) {
        const appId = changes['appId'];
        const appName = changes['appName'];
        const filter = changes['filterParam'];
        if (appId && (appId.currentValue || appId.currentValue === null)) {
            this.getFiltersByAppId(appId.currentValue);
        }
        else if (appName && appName.currentValue) {
            this.getFiltersByAppName(appName.currentValue);
        }
        else if (filter && filter.currentValue !== filter.previousValue) {
            this.selectProcessFilter(filter.currentValue);
        }
    }
    getFiltersByAppId(appId) {
        this.processFilterService.getProcessFilters(appId).subscribe((res) => {
            if (res.length === 0 && this.isFilterListEmpty()) {
                this.processFilterService.createDefaultFilters(appId).subscribe((resDefault) => {
                    this.resetFilter();
                    this.filters = resDefault;
                    this.selectProcessFilter(this.filterParam);
                    this.success.emit(resDefault);
                }, (errDefault) => {
                    this.error.emit(errDefault);
                });
            }
            else {
                this.resetFilter();
                this.filters = res;
                this.selectProcessFilter(this.filterParam);
                this.success.emit(res);
            }
        }, (err) => {
            this.error.emit(err);
        });
    }
    getFiltersByAppName(appName) {
        this.appsProcessService.getDeployedApplicationsByName(appName).subscribe((application) => {
            this.getFiltersByAppId(application.id);
            this.selectProcessFilter(this.filterParam);
        }, (err) => {
            this.error.emit(err);
        });
    }
    selectFilter(filter) {
        this.currentFilter = filter;
        this.active = true;
        this.filterClicked.emit(filter);
    }
    selectProcessFilter(filterParam) {
        if (filterParam) {
            const newFilter = this.filters.find((processFilter, index) => filterParam.index === index ||
                filterParam.id === processFilter.id ||
                (filterParam.name &&
                    (filterParam.name.toLocaleLowerCase() === processFilter.name.toLocaleLowerCase())));
            this.currentFilter = newFilter;
            if (newFilter) {
                this.filterSelected.emit(newFilter);
            }
        }
    }
    selectRunningFilter() {
        this.selectProcessFilter(this.processFilterService.getRunningFilterInstance(null));
    }
    selectDefaultTaskFilter() {
        if (!this.isFilterListEmpty()) {
            this.currentFilter = this.filters[0];
            this.filterSelected.emit(this.filters[0]);
        }
    }
    getCurrentFilter() {
        return this.currentFilter;
    }
    isFilterListEmpty() {
        return this.filters === undefined || (this.filters && this.filters.length === 0);
    }
    resetFilter() {
        this.filters = [];
        this.currentFilter = undefined;
    }
    getFilterIcon(icon) {
        return this.iconsMDL.mapGlyphiconToMaterialDesignIcons(icon);
    }
}
ProcessFiltersComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-process-instance-filters',
                template: "<div *ngFor=\"let filter of filters\" class=\"adf-filters__entry\" [class.adf-active]=\"currentFilter === filter\">\n    <button (click)=\"selectFilter(filter)\"\n      [attr.aria-label]=\"filter.name | translate\"\n      [id]=\"filter.id\"\n      [attr.data-automation-id]=\"filter.name + '_filter'\"\n      mat-button\n      class=\"adf-filter-action-button adf-full-width\" fxLayout=\"row\" fxLayoutAlign=\"space-between center\">\n      <adf-icon data-automation-id=\"adf-filter-icon\" *ngIf=\"showIcon\" [value]=\"getFilterIcon(filter.icon)\"></adf-icon>\n      <span data-automation-id=\"adf-filter-label\" class=\"adf-filter-action-button__label\">{{ filter.name | translate }}</span>\n    </button>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-filters__entry{cursor:pointer;font-size:14px!important;font-weight:700;height:24px;opacity:.54;padding:12px 0!important;width:100%}.adf-filters__entry .adf-full-width{display:flex;width:100%}.adf-filters__entry .adf-filter-action-button .adf-filter-action-button__label{margin:0 8px!important;padding-left:20px}.adf-filters__entry.adf-active,.adf-filters__entry:hover{color:var(--theme-primary-color);opacity:1}"]
            },] }
];
ProcessFiltersComponent.ctorParameters = () => [
    { type: ProcessFilterService },
    { type: AppsProcessService }
];
ProcessFiltersComponent.propDecorators = {
    filterParam: [{ type: Input }],
    filterClicked: [{ type: Output }],
    success: [{ type: Output }],
    error: [{ type: Output }],
    appId: [{ type: Input }],
    appName: [{ type: Input }],
    showIcon: [{ type: Input }],
    filterSelected: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessDefinitionRepresentation {
    constructor(obj) {
        this.id = obj && obj.id || null;
        this.name = obj && obj.name || null;
        this.description = obj && obj.description || null;
        this.key = obj && obj.key || null;
        this.category = obj && obj.category || null;
        this.version = obj && obj.version || 0;
        this.deploymentId = obj && obj.deploymentId || null;
        this.tenantId = obj && obj.tenantId || null;
        this.metaDataValues = obj && obj.metaDataValues || [];
        this.hasStartForm = obj && obj.hasStartForm === true;
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessInstanceVariable {
    constructor(obj) {
        this.name = obj && obj.name !== undefined ? obj.name : null;
        this.scope = obj && obj.scope !== undefined ? obj.scope : null;
        this.value = obj && obj.value !== undefined ? obj.value : null;
        this.valueUrl = obj && obj.valueUrl !== undefined ? obj.valueUrl : null;
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessInstance {
    constructor(data) {
        this.businessKey = data && data.businessKey !== undefined ? data.businessKey : null;
        this.ended = data && data.ended !== undefined ? data.ended : null;
        this.graphicalNotationDefined = data && data.graphicalNotationDefined !== undefined ? data.graphicalNotationDefined : null;
        this.id = data && data.id !== undefined ? data.id : null;
        this.name = data && data.name !== undefined ? data.name : null;
        this.processDefinitionCategory = data && data.processDefinitionCategory !== undefined ? data.processDefinitionCategory : null;
        this.processDefinitionDeploymentId = data && data.processDefinitionDeploymentId !== undefined ? data.processDefinitionDeploymentId : null;
        this.processDefinitionDescription = data && data.processDefinitionDescription !== undefined ? data.processDefinitionDescription : null;
        this.processDefinitionId = data && data.processDefinitionId !== undefined ? data.processDefinitionId : null;
        this.processDefinitionKey = data && data.processDefinitionKey !== undefined ? data.processDefinitionKey : null;
        this.processDefinitionName = data && data.processDefinitionName !== undefined ? data.processDefinitionName : null;
        this.processDefinitionVersion = data && data.processDefinitionVersion !== undefined ? data.processDefinitionVersion : null;
        this.startFormDefined = data && data.startFormDefined !== undefined ? data.startFormDefined : null;
        this.started = data && data.started !== undefined ? data.started : null;
        this.startedBy = data && data.startedBy !== undefined ? data.startedBy : null;
        this.tenantId = data && data.tenantId !== undefined ? data.tenantId : null;
        this.variables = data && data.variables !== undefined ? data.variables : null;
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessListModel {
    constructor(obj) {
        if (obj) {
            this.size = obj.size || null;
            this.total = obj.total || null;
            this.start = obj.start || null;
            this.length = obj.length || null;
            this.data = obj.data || [];
        }
    }
}

class ProcessService {
    constructor(alfrescoApiService) {
        this.alfrescoApiService = alfrescoApiService;
    }
    get tasksApi() {
        var _a;
        this._tasksApi = (_a = this._tasksApi) !== null && _a !== void 0 ? _a : new TasksApi(this.alfrescoApiService.getInstance());
        return this._tasksApi;
    }
    get processDefinitionsApi() {
        var _a;
        this._processDefinitionsApi = (_a = this._processDefinitionsApi) !== null && _a !== void 0 ? _a : new ProcessDefinitionsApi(this.alfrescoApiService.getInstance());
        return this._processDefinitionsApi;
    }
    get processInstancesApi() {
        var _a;
        this._processInstancesApi = (_a = this._processInstancesApi) !== null && _a !== void 0 ? _a : new ProcessInstancesApi(this.alfrescoApiService.getInstance());
        return this._processInstancesApi;
    }
    get processInstanceVariablesApi() {
        var _a;
        this._processInstanceVariablesApi = (_a = this._processInstanceVariablesApi) !== null && _a !== void 0 ? _a : new ProcessInstanceVariablesApi(this.alfrescoApiService.getInstance());
        return this._processInstanceVariablesApi;
    }
    getProcessInstances(requestNode, processDefinitionKey) {
        return from(this.processInstancesApi.getProcessInstances(requestNode))
            .pipe(map((res) => {
            if (processDefinitionKey) {
                const filtered = res.data.filter((process) => process.processDefinitionKey === processDefinitionKey);
                res.data = filtered;
                return res;
            }
            else {
                return res;
            }
        }), catchError((err) => this.handleProcessError(err)));
    }
    getProcesses(requestNode, processDefinitionKey) {
        return this.getProcessInstances(requestNode, processDefinitionKey)
            .pipe(map(response => {
            return Object.assign(Object.assign({}, response), { data: (response.data || []).map(instance => {
                    instance.name = this.getProcessNameOrDescription(instance, 'medium');
                    return instance;
                }) });
        }), catchError(() => of(new ProcessListModel({}))));
    }
    getProcessNameOrDescription(processInstance, dateFormat) {
        let name = '';
        if (processInstance) {
            name = processInstance.name ||
                processInstance.processDefinitionName + ' - ' + this.getFormatDate(processInstance.started, dateFormat);
        }
        return name;
    }
    getFormatDate(value, format) {
        const datePipe = new DatePipe('en-US');
        try {
            return datePipe.transform(value, format);
        }
        catch (err) {
            return '';
        }
    }
    fetchProcessAuditPdfById(processId) {
        return from(this.processInstancesApi.getProcessAuditPdf(processId))
            .pipe(catchError((err) => this.handleProcessError(err)));
    }
    fetchProcessAuditJsonById(processId) {
        return from(this.processInstancesApi.getTaskAuditLog(processId))
            .pipe(catchError((err) => this.handleProcessError(err)));
    }
    getProcess(processInstanceId) {
        return from(this.processInstancesApi.getProcessInstance(processInstanceId))
            .pipe(catchError((err) => this.handleProcessError(err)));
    }
    getProcessTasks(processInstanceId, state) {
        const taskOpts = state ? {
            processInstanceId: processInstanceId,
            state: state
        } : {
            processInstanceId: processInstanceId
        };
        return from(this.tasksApi.listTasks(taskOpts))
            .pipe(map(this.extractData), map((tasks) => tasks.map((task) => {
            task.created = moment(task.created, 'YYYY-MM-DD').format();
            return task;
        })), catchError((err) => this.handleProcessError(err)));
    }
    getProcessDefinitions(appId) {
        const opts = appId ? {
            latest: true,
            appDefinitionId: appId
        } : {
            latest: true
        };
        return from(this.processDefinitionsApi.getProcessDefinitions(opts))
            .pipe(map(this.extractData), map((processDefs) => processDefs.map((pd) => new ProcessDefinitionRepresentation(pd))), catchError((err) => this.handleProcessError(err)));
    }
    startProcess(processDefinitionId, name, outcome, startFormValues, variables) {
        const startRequest = {
            name: name,
            processDefinitionId: processDefinitionId
        };
        if (outcome) {
            startRequest.outcome = outcome;
        }
        if (startFormValues) {
            startRequest.values = startFormValues;
        }
        if (variables) {
            startRequest.variables = variables;
        }
        return from(this.processInstancesApi.startNewProcessInstance(startRequest))
            .pipe(map((pd) => new ProcessInstance(pd)), catchError((err) => this.handleProcessError(err)));
    }
    cancelProcess(processInstanceId) {
        return from(this.processInstancesApi.deleteProcessInstance(processInstanceId))
            .pipe(catchError((err) => this.handleProcessError(err)));
    }
    getProcessInstanceVariables(processInstanceId) {
        return from(this.processInstanceVariablesApi.getProcessInstanceVariables(processInstanceId))
            .pipe(map((processVars) => processVars.map((currentProcessVar) => new ProcessInstanceVariable(currentProcessVar))), catchError((err) => this.handleProcessError(err)));
    }
    createOrUpdateProcessInstanceVariables(processInstanceId, variables) {
        return from(this.processInstanceVariablesApi.createOrUpdateProcessInstanceVariables(processInstanceId, variables)).pipe(catchError((err) => this.handleProcessError(err)));
    }
    deleteProcessInstanceVariable(processInstanceId, variableName) {
        return from(this.processInstanceVariablesApi.deleteProcessInstanceVariable(processInstanceId, variableName))
            .pipe(catchError((err) => this.handleProcessError(err)));
    }
    extractData(res) {
        return res.data || {};
    }
    handleProcessError(error) {
        return throwError(error || 'Server error');
    }
}
ProcessService.ɵprov = ɵɵdefineInjectable({ factory: function ProcessService_Factory() { return new ProcessService(ɵɵinject(AlfrescoApiService)); }, token: ProcessService, providedIn: "root" });
ProcessService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
ProcessService.ctorParameters = () => [
    { type: AlfrescoApiService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessInstanceHeaderComponent {
    constructor(translationService, appConfig) {
        this.translationService = translationService;
        this.appConfig = appConfig;
        this.dateFormat = this.appConfig.get('dateValues.defaultDateFormat');
        this.dateLocale = this.appConfig.get('dateValues.defaultDateLocale');
    }
    ngOnChanges() {
        this.refreshData();
    }
    refreshData() {
        if (this.processInstance) {
            const defaultProperties = this.initDefaultProperties();
            const filteredProperties = this.appConfig.get('adf-process-instance-header.presets.properties');
            this.properties = defaultProperties.filter((cardItem) => this.isValidSelection(filteredProperties, cardItem));
        }
    }
    initDefaultProperties() {
        return [
            new CardViewTextItemModel({
                label: 'ADF_PROCESS_LIST.PROPERTIES.STATUS',
                value: this.getProcessStatus(),
                key: 'status'
            }),
            new CardViewDateItemModel({
                label: 'ADF_PROCESS_LIST.PROPERTIES.END_DATE',
                value: this.processInstance.ended,
                format: this.dateFormat,
                locale: this.dateLocale,
                key: 'ended',
                default: this.translationService.instant('ADF_PROCESS_LIST.PROPERTIES.END_DATE_DEFAULT')
            }),
            new CardViewTextItemModel({
                label: 'ADF_PROCESS_LIST.PROPERTIES.CATEGORY',
                value: this.processInstance.processDefinitionCategory,
                key: 'category',
                default: this.translationService.instant('ADF_PROCESS_LIST.PROPERTIES.CATEGORY_DEFAULT')
            }),
            new CardViewTextItemModel({
                label: 'ADF_PROCESS_LIST.PROPERTIES.BUSINESS_KEY',
                value: this.processInstance.businessKey,
                key: 'businessKey',
                default: this.translationService.instant('ADF_PROCESS_LIST.PROPERTIES.BUSINESS_KEY_DEFAULT')
            }),
            new CardViewTextItemModel({
                label: 'ADF_PROCESS_LIST.PROPERTIES.CREATED_BY',
                value: this.getStartedByFullName(),
                key: 'createdBy',
                default: this.translationService.instant('ADF_PROCESS_LIST.PROPERTIES.CREATED_BY_DEFAULT')
            }),
            new CardViewDateItemModel({
                label: 'ADF_PROCESS_LIST.PROPERTIES.CREATED',
                value: this.processInstance.started,
                format: this.dateFormat,
                locale: this.dateLocale,
                key: 'created'
            }),
            new CardViewTextItemModel({ label: 'ADF_PROCESS_LIST.PROPERTIES.ID',
                value: this.processInstance.id,
                key: 'id'
            }),
            new CardViewTextItemModel({ label: 'ADF_PROCESS_LIST.PROPERTIES.DESCRIPTION',
                value: this.processInstance.processDefinitionDescription,
                key: 'description',
                default: this.translationService.instant('ADF_PROCESS_LIST.PROPERTIES.DESCRIPTION_DEFAULT')
            })
        ];
    }
    isValidSelection(filteredProperties, cardItem) {
        return filteredProperties ? filteredProperties.indexOf(cardItem.key) >= 0 : true;
    }
    getProcessStatus() {
        if (this.processInstance) {
            return this.isRunning() ? 'Running' : 'Completed';
        }
        return 'Unknown';
    }
    getStartedByFullName() {
        let fullName = '';
        if (this.processInstance && this.processInstance.startedBy) {
            fullName += this.processInstance.startedBy.firstName || '';
            fullName += fullName ? ' ' : '';
            fullName += this.processInstance.startedBy.lastName || '';
        }
        return fullName;
    }
    isRunning() {
        return this.processInstance && !this.processInstance.ended;
    }
}
ProcessInstanceHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-process-instance-header',
                template: "<mat-card *ngIf=\"processInstance\" class=\"adf-card-container\">\n    <mat-card-content>\n        <adf-card-view [properties]=\"properties\"></adf-card-view>\n    </mat-card-content>\n</mat-card>\n",
                styles: [":host{width:100%}.adf-card-container{font-family:inherit}"]
            },] }
];
ProcessInstanceHeaderComponent.ctorParameters = () => [
    { type: TranslationService },
    { type: AppConfigService }
];
ProcessInstanceHeaderComponent.propDecorators = {
    processInstance: [{ type: Input }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AppDefinitionRepresentationModel {
    constructor(obj) {
        if (obj) {
            this.defaultAppId = obj.defaultAppId ? obj.defaultAppId : null;
            this.deploymentId = obj.deploymentId ? obj.deploymentId : null;
            this.name = obj.name ? obj.name : null;
            this.description = obj.description ? obj.description : null;
            this.theme = obj.theme ? obj.theme : null;
            this.icon = obj.icon ? obj.icon : null;
            this.id = obj.id ? obj.id : null;
            this.modelId = obj.modelId ? obj.modelId : null;
            this.tenantId = obj.tenantId ? obj.tenantId : null;
        }
    }
}
class FilterParamsModel {
    constructor(obj) {
        if (obj) {
            this.id = obj.id || null;
            this.name = obj.name || null;
            this.index = obj.index;
        }
    }
}
class FilterRepresentationModel {
    constructor(obj) {
        if (obj) {
            this.id = obj.id || null;
            this.appId = obj.appId || null;
            this.name = obj.name || null;
            this.recent = !!obj.recent;
            this.icon = obj.icon || null;
            this.filter = new UserTaskFilterRepresentation(obj.filter);
            this.index = obj.index;
        }
    }
    hasFilter() {
        return !!this.filter;
    }
}
class TaskQueryRequestRepresentationModel extends TaskQueryRepresentation {
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let taskPresetsDefaultModel = {
    'default': [
        {
            'key': 'name',
            'type': 'text',
            'title': 'ADF_TASK_LIST.PROPERTIES.NAME',
            'sortable': true
        },
        {
            'key': 'created',
            'type': 'text',
            'title': 'ADF_TASK_LIST.PROPERTIES.CREATED',
            'cssClass': 'hidden',
            'sortable': true
        },
        {
            'key': 'assignee',
            'type': 'text',
            'title': 'ADF_TASK_LIST.PROPERTIES.ASSIGNEE',
            'cssClass': 'hidden',
            'sortable': true
        }
    ]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class Form {
    constructor(id, name) {
        this.name = name;
        this.id = id;
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TaskDetailsModel {
    constructor(obj) {
        this.processDefinitionVersion = 0;
        if (obj) {
            this.id = obj.id || null;
            this.name = obj.name || null;
            this.priority = obj.priority;
            this.assignee = obj.assignee ? new UserProcessModel(obj.assignee) : null;
            this.adhocTaskCanBeReassigned = obj.adhocTaskCanBeReassigned;
            this.category = obj.category || null;
            this.created = obj.created || null;
            this.description = obj.description || null;
            this.dueDate = obj.dueDate || null;
            this.duration = obj.duration || null;
            this.endDate = obj.endDate || null;
            this.executionId = obj.executionId || null;
            this.formKey = obj.formKey || null;
            this.initiatorCanCompleteTask = !!obj.initiatorCanCompleteTask;
            this.managerOfCandidateGroup = !!obj.managerOfCandidateGroup;
            this.memberOfCandidateGroup = !!obj.memberOfCandidateGroup;
            this.memberOfCandidateUsers = !!obj.memberOfCandidateUsers;
            this.involvedGroups = obj.involvedGroups;
            this.involvedPeople = obj.involvedPeople;
            this.parentTaskId = obj.parentTaskId || null;
            this.parentTaskName = obj.parentTaskName || null;
            this.processDefinitionCategory = obj.processDefinitionCategory || null;
            this.processDefinitionDeploymentId = obj.processDefinitionDeploymentId || null;
            this.processDefinitionDescription = obj.processDefinitionDescription || null;
            this.processDefinitionId = obj.processDefinitionId || null;
            this.processDefinitionKey = obj.processDefinitionKey || null;
            this.processDefinitionName = obj.processDefinitionName || null;
            this.processDefinitionVersion = obj.processDefinitionVersion || 0;
            this.processInstanceId = obj.processInstanceId || null;
            this.processInstanceName = obj.processInstanceName || null;
            this.processInstanceStartUserId = obj.processInstanceStartUserId || null;
            this.taskDefinitionKey = obj.taskDefinitionKey || null;
        }
    }
    getFullName() {
        let fullName = '';
        if (this.assignee) {
            const firstName = this.assignee.firstName ? this.assignee.firstName : '';
            const lastName = this.assignee.lastName ? this.assignee.lastName : '';
            fullName = `${firstName} ${lastName}`;
        }
        return fullName.trim();
    }
    isCompleted() {
        return !!this.endDate;
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TaskListModel {
    constructor(input) {
        this.data = [];
        if (input) {
            Object.assign(this, input);
            if (input.data) {
                this.data = input.data.map((item) => {
                    return new TaskDetailsModel(item);
                });
            }
        }
    }
}

class TaskListService {
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
    }
    get modelsApi() {
        var _a;
        this._modelsApi = (_a = this._modelsApi) !== null && _a !== void 0 ? _a : new ModelsApi(this.apiService.getInstance());
        return this._modelsApi;
    }
    get tasksApi() {
        var _a;
        this._tasksApi = (_a = this._tasksApi) !== null && _a !== void 0 ? _a : new TasksApi(this.apiService.getInstance());
        return this._tasksApi;
    }
    get taskActionsApi() {
        var _a;
        this._taskActionsApi = (_a = this._taskActionsApi) !== null && _a !== void 0 ? _a : new TaskActionsApi(this.apiService.getInstance());
        return this._taskActionsApi;
    }
    get checklistsApi() {
        var _a;
        this._checklistsApi = (_a = this._checklistsApi) !== null && _a !== void 0 ? _a : new ChecklistsApi(this.apiService.getInstance());
        return this._checklistsApi;
    }
    getFilterForTaskById(taskId, filterList) {
        return from(filterList)
            .pipe(flatMap((data) => this.isTaskRelatedToFilter(taskId, data)), filter((data) => data != null));
    }
    generateTaskRequestNodeFromFilter(filterModel) {
        const requestNode = {
            appDefinitionId: filterModel.appId,
            assignment: filterModel.filter.assignment,
            state: filterModel.filter.state,
            sort: filterModel.filter.sort
        };
        return new TaskQueryRequestRepresentationModel(requestNode);
    }
    isTaskRelatedToFilter(taskId, filterModel) {
        const requestNodeForFilter = this.generateTaskRequestNodeFromFilter(filterModel);
        return from(this.callApiTasksFiltered(requestNodeForFilter))
            .pipe(map(res => {
            return res.data.find((element) => element.id === taskId) ? filterModel : null;
        }), catchError((err) => this.handleError(err)));
    }
    getTasks(requestNode) {
        return from(this.callApiTasksFiltered(requestNode))
            .pipe(catchError((err) => this.handleError(err)));
    }
    findTasksByState(requestNode, state) {
        if (state) {
            requestNode.state = state;
        }
        return this.getTasks(requestNode)
            .pipe(catchError(() => of(new TaskListModel())));
    }
    findAllTaskByState(requestNode, state) {
        if (state) {
            requestNode.state = state;
        }
        return this.getTotalTasks(requestNode)
            .pipe(switchMap((res) => {
            requestNode.size = res.total;
            return this.getTasks(requestNode);
        }));
    }
    findAllTasksWithoutState(requestNode) {
        return forkJoin(this.findTasksByState(requestNode, 'open'), this.findAllTaskByState(requestNode, 'completed'), (activeTasks, completedTasks) => {
            const tasks = Object.assign({}, activeTasks);
            tasks.total += completedTasks.total;
            tasks.data = tasks.data.concat(completedTasks.data);
            return tasks;
        });
    }
    getTaskDetails(taskId) {
        return from(this.callApiTaskDetails(taskId))
            .pipe(map(details => {
            return new TaskDetailsModel(details);
        }), catchError((err) => this.handleError(err)));
    }
    getTaskChecklist(id) {
        return from(this.callApiTaskChecklist(id))
            .pipe(map(response => {
            const checklists = [];
            response.data.forEach((checklist) => {
                checklists.push(new TaskDetailsModel(checklist));
            });
            return checklists;
        }), catchError((err) => this.handleError(err)));
    }
    getFormList() {
        const opts = {
            'filter': 'myReusableForms',
            'sort': 'modifiedDesc',
            'modelType': 2
        };
        return from(this.modelsApi.getModels(opts))
            .pipe(map(response => {
            const forms = [];
            response.data.forEach((form) => {
                forms.push(new Form(form.id, form.name));
            });
            return forms;
        }), catchError((err) => this.handleError(err)));
    }
    attachFormToATask(taskId, formId) {
        return from(this.taskActionsApi.attachForm(taskId, { 'formId': formId }))
            .pipe(catchError((err) => this.handleError(err)));
    }
    addTask(task) {
        return from(this.callApiAddTask(task))
            .pipe(map((response) => {
            return new TaskDetailsModel(response);
        }), catchError((err) => this.handleError(err)));
    }
    deleteTask(taskId) {
        return from(this.callApiDeleteTask(taskId))
            .pipe(catchError((err) => this.handleError(err)));
    }
    deleteForm(taskId) {
        return from(this.callApiDeleteForm(taskId))
            .pipe(catchError((err) => this.handleError(err)));
    }
    completeTask(taskId) {
        return from(this.taskActionsApi.completeTask(taskId))
            .pipe(catchError((err) => this.handleError(err)));
    }
    getTotalTasks(requestNode) {
        requestNode.size = 0;
        return from(this.callApiTasksFiltered(requestNode))
            .pipe(catchError((err) => this.handleError(err)));
    }
    createNewTask(task) {
        return from(this.callApiCreateTask(task))
            .pipe(map((response) => {
            return new TaskDetailsModel(response);
        }), catchError((err) => this.handleError(err)));
    }
    assignTask(taskId, requestNode) {
        const assignee = { assignee: requestNode.id };
        return from(this.callApiAssignTask(taskId, assignee))
            .pipe(map((response) => {
            return new TaskDetailsModel(response);
        }), catchError((err) => this.handleError(err)));
    }
    assignTaskByUserId(taskId, userId) {
        const assignee = { assignee: userId };
        return from(this.callApiAssignTask(taskId, assignee))
            .pipe(map((response) => {
            return new TaskDetailsModel(response);
        }), catchError((err) => this.handleError(err)));
    }
    claimTask(taskId) {
        return from(this.taskActionsApi.claimTask(taskId))
            .pipe(catchError((err) => this.handleError(err)));
    }
    unclaimTask(taskId) {
        return from(this.taskActionsApi.unclaimTask(taskId))
            .pipe(catchError((err) => this.handleError(err)));
    }
    updateTask(taskId, updated) {
        return from(this.tasksApi.updateTask(taskId, updated))
            .pipe(map((result) => result), catchError((err) => this.handleError(err)));
    }
    fetchTaskAuditPdfById(taskId) {
        return from(this.tasksApi.getTaskAuditPdf(taskId))
            .pipe(map((data) => data), catchError((err) => this.handleError(err)));
    }
    fetchTaskAuditJsonById(taskId) {
        return from(this.tasksApi.getTaskAuditLog(taskId))
            .pipe(catchError((err) => this.handleError(err)));
    }
    callApiTasksFiltered(requestNode) {
        return this.tasksApi.listTasks(requestNode);
    }
    callApiTaskDetails(taskId) {
        return this.tasksApi.getTask(taskId);
    }
    callApiAddTask(task) {
        return this.checklistsApi.addSubtask(task.parentTaskId, task);
    }
    callApiDeleteTask(taskId) {
        return this.tasksApi.deleteTask(taskId);
    }
    callApiDeleteForm(taskId) {
        return this.taskActionsApi.removeForm(taskId);
    }
    callApiTaskChecklist(taskId) {
        return this.checklistsApi.getChecklist(taskId);
    }
    callApiCreateTask(task) {
        return this.tasksApi.createNewTask(task);
    }
    callApiAssignTask(taskId, requestNode) {
        return this.taskActionsApi.assignTask(taskId, requestNode);
    }
    handleError(error) {
        this.logService.error(error);
        return throwError(error || 'Server error');
    }
}
TaskListService.ɵprov = ɵɵdefineInjectable({ factory: function TaskListService_Factory() { return new TaskListService(ɵɵinject(AlfrescoApiService), ɵɵinject(LogService)); }, token: TaskListService, providedIn: "root" });
TaskListService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
TaskListService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: LogService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TaskListComponent extends DataTableSchema {
    constructor(taskListService, appConfigService, userPreferences) {
        super(appConfigService, TaskListComponent.PRESET_KEY, taskPresetsDefaultModel);
        this.taskListService = taskListService;
        this.userPreferences = userPreferences;
        this.selectionMode = 'single';
        this.multiselect = false;
        this.selectFirstRow = true;
        this.showContextMenu = false;
        this.stickyHeader = false;
        this.showRowContextMenu = new EventEmitter();
        this.rowClick = new EventEmitter();
        this.rowsSelected = new EventEmitter();
        this.success = new EventEmitter();
        this.error = new EventEmitter();
        this.page = 0;
        this.size = PaginationComponent.DEFAULT_PAGINATION.maxItems;
        this.rows = [];
        this.isLoading = true;
        this.sorting = ['created', 'desc'];
        this.hasCustomDataSource = false;
        this.onDestroy$ = new Subject();
        this.pagination = new BehaviorSubject({
            maxItems: this.size,
            skipCount: 0,
            totalItems: 0
        });
    }
    ngAfterContentInit() {
        this.createDatatableSchema();
        if (this.data && this.data.getColumns().length === 0) {
            this.data.setColumns(this.columns);
        }
        if (this.appId) {
            this.reload();
        }
    }
    ngOnInit() {
        this.userPreferences
            .select(UserPreferenceValues.PaginationSize)
            .pipe(takeUntil(this.onDestroy$))
            .subscribe(pageSize => this.size = pageSize);
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
    setCustomDataSource(rows) {
        if (rows) {
            this.rows = rows;
            this.hasCustomDataSource = true;
        }
    }
    ngOnChanges(changes) {
        if (this.isPropertyChanged(changes)) {
            if (this.isSortChanged(changes)) {
                this.sorting = this.sort ? this.sort.split('-') : this.sorting;
            }
            this.reload();
        }
        const presetColumnChanges = changes['presetColumn'];
        if (presetColumnChanges && !presetColumnChanges.firstChange) {
            this.columns = this.mergeJsonAndHtmlSchema();
        }
    }
    isSortChanged(changes) {
        const actualSort = changes['sort'];
        return actualSort && actualSort.currentValue && actualSort.currentValue !== actualSort.previousValue;
    }
    isPropertyChanged(changes) {
        let changed = true;
        const landingTaskId = changes['landingTaskId'];
        const page = changes['page'];
        const size = changes['size'];
        if (landingTaskId && landingTaskId.currentValue && this.isEqualToCurrentId(landingTaskId.currentValue)) {
            changed = false;
        }
        else if (page && page.currentValue !== page.previousValue) {
            changed = true;
        }
        else if (size && size.currentValue !== size.previousValue) {
            changed = true;
        }
        return changed;
    }
    reload() {
        if (!this.hasCustomDataSource) {
            this.requestNode = this.createRequestNode();
            this.load();
        }
        else {
            this.isLoading = false;
        }
    }
    load() {
        this.isLoading = true;
        this.loadTasksByState()
            .pipe(finalize(() => this.isLoading = false))
            .subscribe(tasks => {
            this.rows = this.optimizeTaskDetails(tasks.data);
            this.selectTask(this.landingTaskId);
            this.success.emit(tasks);
            this.pagination.next({
                count: tasks.data.length,
                maxItems: this.size,
                skipCount: this.page * this.size,
                totalItems: tasks.total
            });
        }, error => {
            this.error.emit(error);
        });
    }
    loadTasksByState() {
        return this.requestNode.state === 'all'
            ? this.taskListService.findAllTasksWithoutState(this.requestNode)
            : this.taskListService.findTasksByState(this.requestNode);
    }
    selectTask(taskIdSelected) {
        if (!this.isListEmpty()) {
            let dataRow = null;
            if (taskIdSelected) {
                dataRow = this.rows.find((currentRow) => {
                    return currentRow['id'] === taskIdSelected;
                });
            }
            if (!dataRow && this.selectFirstRow) {
                dataRow = this.rows[0];
            }
            if (dataRow) {
                dataRow.isSelected = true;
                this.currentInstanceId = dataRow['id'];
            }
        }
        else {
            this.currentInstanceId = null;
        }
    }
    getCurrentId() {
        return this.currentInstanceId;
    }
    isEqualToCurrentId(taskId) {
        return this.currentInstanceId === taskId;
    }
    isListEmpty() {
        return !this.rows || this.rows.length === 0;
    }
    onRowClick(item) {
        this.currentInstanceId = item.value.getValue('id');
        this.rowClick.emit(this.currentInstanceId);
    }
    onRowSelect(event) {
        this.selectedInstances = [...event.detail.selection];
        this.rowsSelected.emit(this.selectedInstances);
    }
    onRowUnselect(event) {
        this.selectedInstances = [...event.detail.selection];
        this.rowsSelected.emit(this.selectedInstances);
    }
    onRowKeyUp(event) {
        if (event.detail.keyboardEvent.key === 'Enter') {
            event.preventDefault();
            this.currentInstanceId = event.detail.row.getValue('id');
            this.rowClick.emit(this.currentInstanceId);
        }
    }
    onShowRowContextMenu(event) {
        this.showRowContextMenu.emit(event);
    }
    optimizeTaskDetails(instances) {
        instances = instances.map((task) => {
            if (!task.name) {
                task.name = 'No name';
            }
            return task;
        });
        return instances;
    }
    createRequestNode() {
        const requestNode = {
            appDefinitionId: this.appId,
            dueAfter: this.dueAfter ? moment$1(this.dueAfter).toDate() : null,
            dueBefore: this.dueBefore ? moment$1(this.dueBefore).toDate() : null,
            processInstanceId: this.processInstanceId,
            processDefinitionId: this.processDefinitionId,
            text: this.name,
            assignment: this.assignment,
            state: this.state,
            sort: this.sort,
            page: this.page,
            size: this.size,
            start: this.start,
            taskId: this.taskId,
            includeProcessInstance: this.includeProcessInstance
        };
        return new TaskQueryRequestRepresentationModel(requestNode);
    }
    updatePagination(params) {
        const needsReload = params.maxItems || params.skipCount;
        this.size = params.maxItems;
        this.page = this.currentPage(params.skipCount, params.maxItems);
        if (needsReload) {
            this.reload();
        }
    }
    currentPage(skipCount, maxItems) {
        return (skipCount && maxItems) ? Math.floor(skipCount / maxItems) : 0;
    }
}
TaskListComponent.PRESET_KEY = 'adf-task-list.presets';
TaskListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-tasklist',
                template: "<div *ngIf=\"!requestNode\">{{ 'ADF_TASK_LIST.FILTERS.MESSAGES.NONE' | translate }}</div>\n<ng-container *ngIf=\"requestNode\">\n        <adf-datatable\n            [data]=\"data\"\n            [rows]=\"rows\"\n            [columns]=\"columns\"\n            [sorting]=\"sorting\"\n            [loading]=\"isLoading\"\n            [stickyHeader]=\"stickyHeader\"\n            [multiselect]=\"multiselect\"\n            [selectionMode]=\"selectionMode\"\n            [contextMenu]=\"showContextMenu\"\n            (showRowContextMenu)=\"onShowRowContextMenu($event)\"\n            (row-select)=\"onRowSelect($any($event))\"\n            (row-unselect)=\"onRowUnselect($any($event))\"\n            (rowClick)=\"onRowClick($any($event))\"\n            (row-keyup)=\"onRowKeyUp($any($event))\">\n            <adf-loading-content-template>\n                <ng-template>\n                    <!--Add your custom loading template here-->\n                    <mat-progress-spinner\n                        *ngIf=\"!customLoadingContent\"\n                        class=\"adf-task-list-loading-margin\"\n                        color=\"primary\"\n                        mode=\"indeterminate\">\n                    </mat-progress-spinner>\n                    <ng-content select=\"adf-custom-loading-content-template\"></ng-content>\n                </ng-template>\n            </adf-loading-content-template>\n            <adf-no-content-template>\n                <ng-template>\n                    <adf-empty-content *ngIf=\"!customEmptyContent\"\n                        icon=\"assignment\"\n                        [title]=\"'ADF_TASK_LIST.LIST.MESSAGES.TITLE' | translate\"\n                        [subtitle]=\"'ADF_TASK_LIST.LIST.MESSAGES.SUBTITLE' | translate\">\n                    </adf-empty-content>\n                    <ng-content select=\"adf-custom-empty-content-template\"></ng-content>\n                </ng-template>\n            </adf-no-content-template>\n        </adf-datatable>\n</ng-container>\n",
                styles: [".adf-task-list-loading-margin{margin-left:calc(50% - 50px);margin-right:calc(50% - 50px)}"]
            },] }
];
TaskListComponent.ctorParameters = () => [
    { type: TaskListService },
    { type: AppConfigService },
    { type: UserPreferencesService }
];
TaskListComponent.propDecorators = {
    customEmptyContent: [{ type: ContentChild, args: [CustomEmptyContentTemplateDirective,] }],
    customLoadingContent: [{ type: ContentChild, args: [CustomLoadingContentTemplateDirective,] }],
    appId: [{ type: Input }],
    processInstanceId: [{ type: Input }],
    processDefinitionId: [{ type: Input }],
    state: [{ type: Input }],
    assignment: [{ type: Input }],
    sort: [{ type: Input }],
    name: [{ type: Input }],
    landingTaskId: [{ type: Input }],
    data: [{ type: Input }],
    selectionMode: [{ type: Input }],
    multiselect: [{ type: Input }],
    selectFirstRow: [{ type: Input }],
    taskId: [{ type: Input }],
    includeProcessInstance: [{ type: Input }],
    start: [{ type: Input }],
    showContextMenu: [{ type: Input }],
    stickyHeader: [{ type: Input }],
    showRowContextMenu: [{ type: Output }],
    rowClick: [{ type: Output }],
    rowsSelected: [{ type: Output }],
    success: [{ type: Output }],
    error: [{ type: Output }],
    page: [{ type: Input }],
    size: [{ type: Input }],
    dueAfter: [{ type: Input }],
    dueBefore: [{ type: Input }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ChecklistComponent {
    constructor(activitiTaskList, dialog) {
        this.activitiTaskList = activitiTaskList;
        this.dialog = dialog;
        this.readOnly = false;
        this.checklistTaskCreated = new EventEmitter();
        this.checklistTaskDeleted = new EventEmitter();
        this.error = new EventEmitter();
        this.checklist = [];
    }
    ngOnChanges(changes) {
        const taskId = changes['taskId'];
        if (taskId && taskId.currentValue) {
            this.getTaskChecklist();
            return;
        }
    }
    getTaskChecklist() {
        this.checklist = [];
        if (this.taskId) {
            this.activitiTaskList.getTaskChecklist(this.taskId).subscribe((taskDetailsModel) => {
                taskDetailsModel.forEach((task) => {
                    this.checklist.push(task);
                });
            }, (error) => {
                this.error.emit(error);
            });
        }
        else {
            this.checklist = [];
        }
    }
    showDialog() {
        this.dialog.open(this.addNewDialog, { width: '350px' });
    }
    add() {
        const newTask = new TaskDetailsModel({
            name: this.taskName,
            parentTaskId: this.taskId,
            assignee: { id: this.assignee }
        });
        this.activitiTaskList.addTask(newTask).subscribe((taskDetailsModel) => {
            this.checklist.push(taskDetailsModel);
            this.checklistTaskCreated.emit(taskDetailsModel);
            this.taskName = '';
        }, (error) => {
            this.error.emit(error);
        });
        this.cancel();
    }
    delete(taskId) {
        this.activitiTaskList.deleteTask(taskId).subscribe(() => {
            this.checklist = this.checklist.filter((check) => check.id !== taskId);
            this.checklistTaskDeleted.emit(taskId);
        }, (error) => {
            this.error.emit(error);
        });
    }
    cancel() {
        this.dialog.closeAll();
        this.taskName = '';
    }
}
ChecklistComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-checklist',
                template: "<div class=\"adf-checklist-control\">\n    <mat-chip-list data-automation-id=\"checklist-label\">\n        <span class=\"adf-activiti-label\">{{ 'ADF_TASK_LIST.DETAILS.LABELS.CHECKLIST' | translate }}</span>\n        <mat-chip class=\"adf-process-badge\" color=\"accent\" selected=\"true\">{{checklist?.length}}</mat-chip>\n    </mat-chip-list>\n\n\n    <button mat-icon-button *ngIf=\"!readOnly\" matTooltip=\"Add a checklist\" [matTooltipPosition]=\"'before'\"\n            id=\"add-checklist\" class=\"adf-add-to-checklist-button\" (click)=\"showDialog()\">\n        <mat-icon>add</mat-icon>\n    </button>\n</div>\n\n<div class=\"adf-checklist-menu-container\" *ngIf=\"checklist?.length > 0\">\n    <mat-chip-list class=\"mat-chip-list-stacked\">\n        <mat-chip id=\"check-{{check.id}}\" class=\"adf-checklist-chip\" *ngFor=\"let check of checklist\"\n                  (removed)=\"delete(check.id)\">\n            <span>{{check.name}}</span>\n            <mat-icon *ngIf=\"!readOnly && !check.endDate\" id=\"remove-{{check.id}}\" matChipRemove>cancel\n            </mat-icon>\n        </mat-chip>\n    </mat-chip-list>\n\n</div>\n<div *ngIf=\"checklist?.length === 0\" id=\"checklist-none-message\" class=\"adf-checklist-none-message\">\n    {{ 'ADF_TASK_LIST.DETAILS.CHECKLIST.NONE' | translate }}\n</div>\n\n<ng-template #dialog>\n    <div class=\"adf-checklist-dialog\" id=\"checklist-dialog\">\n        <h4 matDialogTitle id=\"add-checklist-title\">{{ 'ADF_TASK_LIST.DETAILS.CHECKLIST.DIALOG.TITLE' | translate }}</h4>\n        <mat-dialog-content>\n            <mat-form-field>\n                <input matInput placeholder=\"{{ 'ADF_TASK_LIST.DETAILS.CHECKLIST.DIALOG.PLACEHOLDER' | translate }}\" [(ngModel)]=\"taskName\" id=\"checklist-name\"\n                       data-automation-id=\"checklist-name\">\n            </mat-form-field>\n        </mat-dialog-content>\n        <mat-dialog-actions class=\"adf-checklist-dialog-actions\">\n            <button mat-button type=\"button\" id=\"close-check-dialog\" (click)=\"cancel()\">{{ 'ADF_TASK_LIST.DETAILS.CHECKLIST.DIALOG.CANCEL-BUTTON' | translate | uppercase }}</button>\n            <button mat-button type=\"button\" id=\"add-check\" (click)=\"add()\">{{ 'ADF_TASK_LIST.DETAILS.CHECKLIST.DIALOG.ADD-BUTTON' | translate | uppercase  }}</button>\n        </mat-dialog-actions>\n    </div>\n</ng-template>\n",
                styles: [":host{width:100%}.adf-activiti-label{font-weight:bolder}.mat-form-field{width:100%}.adf-checklist-cancel-button{float:right;margin-right:-13px;margin-top:-13px}.adf-checklist-chip{outline:none}.adf-checklist-menu-container,.adf-checklist-none-message{margin-top:10px}.adf-checklist-control{display:flex;justify-content:space-between}.adf-checklist-control .adfactiviti-label{margin-right:10px;margin-top:6px}.adf-checklist-control .adf-add-to-checklist-button{float:right}.adf-checklist-dialog-actions{display:flex;justify-content:flex-end}"]
            },] }
];
ChecklistComponent.ctorParameters = () => [
    { type: TaskListService },
    { type: MatDialog }
];
ChecklistComponent.propDecorators = {
    taskId: [{ type: Input }],
    readOnly: [{ type: Input }],
    assignee: [{ type: Input }],
    checklistTaskCreated: [{ type: Output }],
    checklistTaskDeleted: [{ type: Output }],
    error: [{ type: Output }],
    addNewDialog: [{ type: ViewChild, args: ['dialog', { static: true },] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TaskDescriptionValidator {
    constructor() {
        this.message = 'ADF_CLOUD_TASK_HEADER.FORM_VALIDATION.INVALID_FIELD';
    }
    isValid(value) {
        const isWhitespace = (value || '').trim().length === 0;
        return value.length === 0 || !isWhitespace;
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TaskHeaderComponent {
    constructor(bpmUserService, translationService, appConfig) {
        this.bpmUserService = bpmUserService;
        this.translationService = translationService;
        this.appConfig = appConfig;
        this.formName = null;
        this.showClaimRelease = true;
        this.claim = new EventEmitter();
        this.unclaim = new EventEmitter();
        this.properties = [];
        this.inEdit = false;
        this.displayDateClearAction = false;
        this.dateFormat = this.appConfig.get('dateValues.defaultDateFormat');
        this.dateLocale = this.appConfig.get('dateValues.defaultDateLocale');
    }
    ngOnInit() {
        this.loadCurrentBpmUserId();
        this.initData();
    }
    ngOnChanges(changes) {
        var _a, _b;
        const taskDetailsChange = changes['taskDetails'];
        if (((_a = taskDetailsChange === null || taskDetailsChange === void 0 ? void 0 : taskDetailsChange.currentValue) === null || _a === void 0 ? void 0 : _a.id) !== ((_b = taskDetailsChange === null || taskDetailsChange === void 0 ? void 0 : taskDetailsChange.previousValue) === null || _b === void 0 ? void 0 : _b.id)) {
            this.initData();
        }
        else {
            this.refreshData();
        }
    }
    initDefaultProperties(parentInfoMap) {
        return [
            new CardViewTextItemModel({
                label: 'ADF_TASK_LIST.PROPERTIES.ASSIGNEE',
                value: this.taskDetails.getFullName(),
                key: 'assignee',
                default: this.translationService.instant('ADF_TASK_LIST.PROPERTIES.ASSIGNEE_DEFAULT'),
                clickable: !this.isCompleted(),
                icon: 'create'
            }),
            new CardViewTextItemModel({
                label: 'ADF_TASK_LIST.PROPERTIES.STATUS',
                value: this.getTaskStatus(),
                key: 'status'
            }),
            new CardViewIntItemModel({
                label: 'ADF_TASK_LIST.PROPERTIES.PRIORITY',
                value: this.taskDetails.priority,
                key: 'priority',
                editable: true,
                validators: [new CardViewItemLengthValidator(1, 10)]
            }),
            new CardViewDateItemModel({
                label: 'ADF_TASK_LIST.PROPERTIES.DUE_DATE',
                value: this.taskDetails.dueDate,
                key: 'dueDate',
                default: this.translationService.instant('ADF_TASK_LIST.PROPERTIES.DUE_DATE_DEFAULT'),
                editable: true,
                format: this.dateFormat,
                locale: this.dateLocale
            }),
            new CardViewTextItemModel({
                label: 'ADF_TASK_LIST.PROPERTIES.CATEGORY',
                value: this.taskDetails.category,
                key: 'category',
                default: this.translationService.instant('ADF_TASK_LIST.PROPERTIES.CATEGORY_DEFAULT')
            }),
            new CardViewMapItemModel({
                label: 'ADF_TASK_LIST.PROPERTIES.PARENT_NAME',
                value: parentInfoMap,
                key: 'parentName',
                default: this.translationService.instant('ADF_TASK_LIST.PROPERTIES.PARENT_NAME_DEFAULT'),
                clickable: true
            }),
            new CardViewDateItemModel({
                label: 'ADF_TASK_LIST.PROPERTIES.CREATED',
                value: this.taskDetails.created,
                key: 'created',
                format: this.dateFormat,
                locale: this.dateLocale
            }),
            new CardViewTextItemModel({
                label: 'ADF_TASK_LIST.PROPERTIES.DURATION',
                value: this.getTaskDuration(),
                key: 'duration'
            }),
            new CardViewTextItemModel({
                label: 'ADF_TASK_LIST.PROPERTIES.PARENT_TASK_ID',
                value: this.taskDetails.parentTaskId,
                key: 'parentTaskId'
            }),
            new CardViewDateItemModel({
                label: 'ADF_TASK_LIST.PROPERTIES.END_DATE',
                value: this.taskDetails.endDate,
                key: 'endDate',
                format: this.dateFormat,
                locale: this.dateLocale
            }),
            new CardViewTextItemModel({
                label: 'ADF_TASK_LIST.PROPERTIES.ID',
                value: this.taskDetails.id,
                key: 'id'
            }),
            new CardViewTextItemModel({
                label: 'ADF_TASK_LIST.PROPERTIES.DESCRIPTION',
                value: this.taskDetails.description,
                key: 'description',
                default: this.translationService.instant('ADF_TASK_LIST.PROPERTIES.DESCRIPTION_DEFAULT'),
                multiline: true,
                editable: true,
                validators: [new TaskDescriptionValidator()]
            }),
            new CardViewTextItemModel({
                label: 'ADF_TASK_LIST.PROPERTIES.FORM_NAME',
                value: this.formName,
                key: 'formName',
                default: this.translationService.instant('ADF_TASK_LIST.PROPERTIES.FORM_NAME_DEFAULT'),
                clickable: this.isFormClickable(),
                icon: 'create'
            })
        ];
    }
    initData() {
        if (this.taskDetails) {
            const parentInfoMap = this.getParentInfo();
            const defaultProperties = this.initDefaultProperties(parentInfoMap);
            const filteredProperties = this.appConfig.get('adf-task-header.presets.properties');
            this.properties = defaultProperties.filter((cardItem) => this.isValidSelection(filteredProperties, cardItem));
        }
    }
    refreshData() {
        this.properties = this.properties.map((cardItem) => {
            if (cardItem.key === 'formName' && cardItem.value !== this.formName) {
                return new CardViewTextItemModel({
                    label: 'ADF_TASK_LIST.PROPERTIES.FORM_NAME',
                    value: this.formName,
                    key: 'formName',
                    default: this.translationService.instant('ADF_TASK_LIST.PROPERTIES.FORM_NAME_DEFAULT'),
                    clickable: this.isFormClickable(),
                    icon: 'create'
                });
            }
            else {
                return cardItem;
            }
        });
    }
    isValidSelection(filteredProperties, cardItem) {
        return filteredProperties ? filteredProperties.indexOf(cardItem.key) >= 0 : true;
    }
    loadCurrentBpmUserId() {
        this.bpmUserService.getCurrentUserInfo().subscribe((res) => {
            this.currentUserId = res ? +res.id : null;
        });
    }
    getParentInfo() {
        if (this.taskDetails.processInstanceId && this.taskDetails.processDefinitionName) {
            return new Map([[this.taskDetails.processInstanceId, this.taskDetails.processDefinitionName]]);
        }
        return new Map();
    }
    hasAssignee() {
        return !!this.taskDetails.assignee;
    }
    isAssignedTo(userId) {
        return this.hasAssignee() ? this.taskDetails.assignee.id === userId : false;
    }
    isAssignedToCurrentUser() {
        return this.hasAssignee() && this.isAssignedTo(this.currentUserId);
    }
    isCandidateMember() {
        return this.taskDetails.managerOfCandidateGroup || this.taskDetails.memberOfCandidateGroup || this.taskDetails.memberOfCandidateUsers;
    }
    isTaskClaimable() {
        return !this.hasAssignee() && this.isCandidateMember();
    }
    isTaskClaimedByCandidateMember() {
        return this.isCandidateMember() && this.isAssignedToCurrentUser() && !this.isCompleted();
    }
    getTaskStatus() {
        return (this.taskDetails && this.taskDetails.isCompleted()) ? 'Completed' : 'Running';
    }
    onClaimTask(taskId) {
        this.claim.emit(taskId);
    }
    onUnclaimTask(taskId) {
        this.unclaim.emit(taskId);
    }
    isCompleted() {
        return this.taskDetails && !!this.taskDetails.endDate;
    }
    isFormClickable() {
        return !!this.formName && !this.isCompleted();
    }
    getTaskDuration() {
        return this.taskDetails.duration ? `${this.taskDetails.duration} ms` : '';
    }
}
TaskHeaderComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-task-header',
                template: "<mat-card *ngIf=\"taskDetails\" class=\"adf-card-container\">\n    <mat-card-content>\n        <adf-card-view [properties]=\"properties\" [editable]=\"!isCompleted()\" [displayClearAction]=\"displayDateClearAction\"></adf-card-view>\n    </mat-card-content>\n\n    <mat-card-actions class=\"adf-controls\" *ngIf=\"showClaimRelease\">\n        <button *ngIf=\"isTaskClaimedByCandidateMember()\" \n            mat-button \n            data-automation-id=\"header-unclaim-button\" \n            id=\"unclaim-task\" \n            class=\"adf-claim-controls\"\n            adf-unclaim-task\n            [taskId]=\"taskDetails.id\"\n            (success)=\"onUnclaimTask($event)\">\n            {{ 'ADF_TASK_LIST.DETAILS.BUTTON.UNCLAIM' | translate }}\n        </button>\n        <button *ngIf=\"isTaskClaimable()\" \n            mat-button \n            data-automation-id=\"header-claim-button\" \n            id=\"claim-task\" \n            class=\"adf-claim-controls\"\n            adf-claim-task\n            [taskId]=\"taskDetails.id\"\n            (success)=\"onClaimTask($event)\">\n            {{ 'ADF_TASK_LIST.DETAILS.BUTTON.CLAIM' | translate }}\n        </button>\n    </mat-card-actions>\n</mat-card>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-controls{display:flex;justify-content:space-between}.adf-edit-controls{display:flex;justify-content:flex-end;margin-left:auto}.adf-save-edit-mode,.adf-switch-to-edit-mode{color:var(--theme-primary-color)}.adf-cancel-edit-mode,.adf-claim-controls{color:#838383}.adf-card-container{font-family:inherit}@media screen and (max-width:959px){adf-card-view .adf-property-value{overflow:hidden;text-overflow:ellipsis;white-space:nowrap}}"]
            },] }
];
TaskHeaderComponent.ctorParameters = () => [
    { type: BpmUserService },
    { type: TranslationService },
    { type: AppConfigService }
];
TaskHeaderComponent.propDecorators = {
    formName: [{ type: Input }],
    taskDetails: [{ type: Input }],
    showClaimRelease: [{ type: Input }],
    claim: [{ type: Output }],
    unclaim: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TaskFormComponent {
    constructor(taskListService, authService, translationService) {
        this.taskListService = taskListService;
        this.authService = authService;
        this.translationService = translationService;
        this.showFormTitle = false;
        this.showFormCompleteButton = true;
        this.showFormSaveButton = true;
        this.showCancelButton = true;
        this.readOnlyForm = false;
        this.showFormRefreshButton = true;
        this.showFormValidationIcon = true;
        this.fieldValidators = [];
        this.formSaved = new EventEmitter();
        this.formCompleted = new EventEmitter();
        this.formContentClicked = new EventEmitter();
        this.formLoaded = new EventEmitter();
        this.showAttachForm = new EventEmitter();
        this.executeOutcome = new EventEmitter();
        this.completed = new EventEmitter();
        this.formError = new EventEmitter();
        this.error = new EventEmitter();
        this.cancel = new EventEmitter();
        this.taskClaimed = new EventEmitter();
        this.taskUnclaimed = new EventEmitter();
        this.loading = false;
        this.internalReadOnlyForm = false;
    }
    ngOnInit() {
        this.authService.getBpmLoggedUser().subscribe(user => {
            this.currentLoggedUser = user;
        });
        this.loadTask(this.taskId);
    }
    ngOnChanges(changes) {
        const taskId = changes['taskId'];
        if (taskId && taskId.currentValue) {
            this.loadTask(this.taskId);
            return;
        }
    }
    loadTask(taskId) {
        this.loading = true;
        if (taskId) {
            this.taskListService.getTaskDetails(taskId).subscribe((res) => {
                this.taskDetails = res;
                if (!this.taskDetails.name) {
                    this.taskDetails.name = 'No name';
                }
                const endDate = res.endDate;
                if (endDate && !isNaN(endDate.getTime())) {
                    this.internalReadOnlyForm = true;
                }
                else {
                    this.internalReadOnlyForm = this.readOnlyForm;
                }
                this.loading = false;
            });
        }
    }
    onFormSaved(savedForm) {
        this.formSaved.emit(savedForm);
    }
    onFormCompleted(form) {
        this.formCompleted.emit(form);
    }
    onFormLoaded(form) {
        this.formLoaded.emit(form);
    }
    onFormContentClick(content) {
        this.formContentClicked.emit(content);
    }
    onFormExecuteOutcome(outcome) {
        this.executeOutcome.emit(outcome);
    }
    onFormError(error) {
        this.formError.emit(error);
    }
    onError(error) {
        this.error.emit(error);
    }
    onCompleteTask() {
        this.taskListService.completeTask(this.taskDetails.id).subscribe(() => this.completed.emit(), (error) => this.error.emit(error));
    }
    onCancel() {
        this.cancel.emit();
    }
    onShowAttachForm() {
        this.showAttachForm.emit();
    }
    hasFormKey() {
        return (this.taskDetails && (!!this.taskDetails.formKey));
    }
    isStandaloneTask() {
        return !(this.taskDetails && (!!this.taskDetails.processDefinitionId));
    }
    isTaskLoaded() {
        return !!this.taskDetails;
    }
    isCompletedTask() {
        return this.taskDetails && this.taskDetails.endDate !== undefined && this.taskDetails.endDate !== null;
    }
    isCompleteButtonVisible() {
        return !this.hasFormKey() && this.isTaskActive() && this.isCompleteButtonEnabled();
    }
    isTaskActive() {
        return this.taskDetails && this.taskDetails.duration === null;
    }
    isAssigned() {
        return !!this.taskDetails.assignee;
    }
    hasEmailAddress() {
        return this.taskDetails.assignee.email ? true : false;
    }
    isAssignedToMe() {
        return this.isAssigned() && this.hasEmailAddress() ?
            this.isEmailEqual() :
            this.isExternalIdEqual();
    }
    isEmailEqual() {
        return (this.taskDetails.assignee && this.currentLoggedUser) && (this.taskDetails.assignee.email.toLocaleLowerCase() === this.currentLoggedUser.email.toLocaleLowerCase());
    }
    isExternalIdEqual() {
        return (this.taskDetails.assignee && this.currentLoggedUser) && (this.taskDetails.assignee.externalId === this.currentLoggedUser.externalId);
    }
    isCompleteButtonEnabled() {
        return this.isAssignedToMe() || this.canInitiatorComplete();
    }
    canInitiatorComplete() {
        return this.taskDetails.initiatorCanCompleteTask;
    }
    isReadOnlyForm() {
        let readOnlyForm;
        if (this.isCandidateMember()) {
            readOnlyForm = this.internalReadOnlyForm || !this.isAssignedToMe();
        }
        else {
            readOnlyForm = this.internalReadOnlyForm || !(this.isAssignedToMe() || this.canCurrentUserAsInitiatorComplete() || this.isCurrentUserInvolved());
        }
        return readOnlyForm;
    }
    isCurrentUserInvolved() {
        var _a, _b;
        let isInvolved = false;
        if (this.taskDetails.involvedPeople && this.currentLoggedUser) {
            const userInvolved = this.taskDetails.involvedPeople.find((involvedUser) => involvedUser.email.toLocaleLowerCase() === this.currentLoggedUser.email.toLocaleLowerCase() ||
                involvedUser.id + '' === this.currentLoggedUser.externalId);
            isInvolved = !!userInvolved;
        }
        if (((_a = this.taskDetails.involvedGroups) === null || _a === void 0 ? void 0 : _a.length) && ((_b = this.currentLoggedUser.groups) === null || _b === void 0 ? void 0 : _b.length) && !isInvolved) {
            const userGroup = this.taskDetails.involvedGroups.find((involvedGroup) => this.currentLoggedUser.groups.find(group => group.name === involvedGroup.name.toLocaleLowerCase() || group.id === involvedGroup.id));
            isInvolved = !!userGroup;
        }
        return isInvolved;
    }
    canCurrentUserAsInitiatorComplete() {
        return this.canInitiatorComplete() && this.isProcessInitiator();
    }
    isProcessInitiator() {
        return this.currentLoggedUser && (this.currentLoggedUser.id === +this.taskDetails.processInstanceStartUserId);
    }
    isSaveButtonVisible() {
        return this.showFormSaveButton && (!this.canInitiatorComplete() || this.isAssignedToMe() || this.isCurrentUserInvolved());
    }
    canCompleteNoFormTask() {
        return this.isReadOnlyForm();
    }
    getCompletedTaskTranslatedMessage() {
        return this.translationService.get('ADF_TASK_FORM.COMPLETED_TASK.TITLE', { taskName: this.taskDetails.name });
    }
    isCandidateMember() {
        return this.taskDetails.managerOfCandidateGroup || this.taskDetails.memberOfCandidateGroup || this.taskDetails.memberOfCandidateUsers;
    }
    isTaskClaimable() {
        return this.isCandidateMember() && !this.isAssigned();
    }
    isTaskClaimedByCandidateMember() {
        return this.isCandidateMember() && this.isAssignedToMe() && !this.isCompletedTask();
    }
    reloadTask() {
        this.loadTask(this.taskId);
    }
    onClaimTask(taskId) {
        this.taskClaimed.emit(taskId);
    }
    onClaimTaskError(error) {
        this.error.emit(error);
    }
    onUnclaimTask(taskId) {
        this.taskUnclaimed.emit(taskId);
    }
    onUnclaimTaskError(error) {
        this.error.emit(error);
    }
}
TaskFormComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-task-form',
                template: "<ng-container *ngIf=\"!loading; else loadingTemplate\">\n  <adf-form *ngIf=\"hasFormKey(); else withoutForm\"\n    [taskId]=\"taskDetails?.id\"\n    [showTitle]=\"showFormTitle\"\n    [showValidationIcon]=\"showFormValidationIcon\"\n    [showRefreshButton]=\"showFormRefreshButton\"\n    [showCompleteButton]=\"showFormCompleteButton\"\n    [showSaveButton]=\"isSaveButtonVisible()\"\n    [disableCompleteButton]=\"!isCompleteButtonEnabled()\"\n    [readOnly]=\"isReadOnlyForm()\"\n    [fieldValidators]=\"fieldValidators\"\n    (formSaved)='onFormSaved($event)'\n    (formCompleted)='onFormCompleted($event)'\n    (formContentClicked)='onFormContentClick($event)'\n    (formLoaded)='onFormLoaded($event)'\n    (formError)='onFormError($event)'\n    (error)='onError($event)'\n    (executeOutcome)='onFormExecuteOutcome($event)'>\n    <adf-form-custom-outcomes>\n        <ng-template [ngTemplateOutlet]=\"taskFormButtons\">\n        </ng-template>\n    </adf-form-custom-outcomes>\n  </adf-form>\n  <ng-template #withoutForm>\n    <adf-task-standalone *ngIf=\"isStandaloneTask(); else emptyFormMessage\"\n        [taskName]=\"taskDetails.name\"\n        [taskId]=\"taskDetails.id\"\n        [isCompleted]=\"isCompletedTask()\"\n        [hasCompletePermission]=\"isCompleteButtonVisible()\"\n        [hideCancelButton]=\"showCancelButton\"\n        (complete)=\"onCompleteTask()\"\n        (showAttachForm)=\"onShowAttachForm()\">\n    </adf-task-standalone>\n      <ng-template #emptyFormMessage>\n        <mat-card class=\"adf-task-form-container\">\n            <mat-card-header>\n                <mat-card-title>\n                    <h4>\n                        <span class=\"adf-form-title\">\n                            {{taskDetails.name}}\n                            <ng-container *ngIf=\"!taskDetails.name\">\n                                {{'FORM.FORM_RENDERER.NAMELESS_TASK' | translate}}\n                            </ng-container>\n                        </span>\n                    </h4>\n                </mat-card-title>\n            </mat-card-header>\n            <mat-card-content>\n                <adf-empty-content *ngIf=\"isCompletedTask(); else emptyFormTemplate\"\n                    [icon]=\"'description'\"\n                    [title]=\"getCompletedTaskTranslatedMessage() | async\"\n                    [subtitle]=\"'ADF_TASK_FORM.COMPLETED_TASK.SUBTITLE'\">\n                </adf-empty-content>\n                <ng-template #emptyFormTemplate>\n                    <adf-empty-content\n                        [icon]=\"'description'\"\n                        [title]=\"'ADF_TASK_LIST.STANDALONE_TASK.NO_FORM_MESSAGE'\"\n                        [subtitle]=\"'ADF_TASK_FORM.EMPTY_FORM.SUBTITLE'\">\n                    </adf-empty-content>\n                </ng-template>\n            </mat-card-content>\n            <mat-card-actions class=\"adf-task-form-actions\">\n                <ng-template [ngTemplateOutlet]=\"taskFormButtons\"></ng-template>\n                <button mat-button\n                    *ngIf=\"!isCompletedTask()\" id=\"adf-no-form-complete-button\"\n                    color=\"primary\"\n                    [disabled]=\"canCompleteNoFormTask()\"\n                    (click)=\"onCompleteTask()\">\n                    {{'ADF_TASK_FORM.EMPTY_FORM.BUTTONS.COMPLETE' | translate}}\n                </button>\n            </mat-card-actions>\n        </mat-card>\n      </ng-template>\n  </ng-template>\n\n  <ng-template #taskFormButtons>\n        <button mat-button id=\"adf-no-form-cancel-button\"\n            *ngIf=\"showCancelButton\"\n            (click)=\"onCancel()\">\n            {{'ADF_TASK_FORM.EMPTY_FORM.BUTTONS.CANCEL' | translate}}\n        </button>\n        <button mat-button data-automation-id=\"adf-task-form-claim-button\"\n            *ngIf=\"isTaskClaimable()\"\n            adf-claim-task\n            [taskId]=\"taskId\"\n            (success)=\"onClaimTask($event)\"\n            (error)=\"onClaimTaskError($event)\">\n            {{ 'ADF_TASK_FORM.EMPTY_FORM.BUTTONS.CLAIM' | translate }}\n        </button>\n        <button mat-button data-automation-id=\"adf-task-form-unclaim-button\"\n            *ngIf=\"isTaskClaimedByCandidateMember()\"\n            adf-unclaim-task\n            [taskId]=\"taskId\"\n            (success)=\"onUnclaimTask($event)\"\n            (error)=\"onUnclaimTaskError($event)\">\n            {{ 'ADF_TASK_FORM.EMPTY_FORM.BUTTONS.UNCLAIM' | translate }}\n        </button>\n  </ng-template>\n</ng-container>\n<ng-template #loadingTemplate>\n  <div fxLayout=\"row\" fxLayoutAlign=\"center stretch\">\n      <mat-spinner></mat-spinner>\n  </div>\n</ng-template>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-task-form-container{overflow:hidden}.adf-task-form-actions{float:right;padding-bottom:25px!important;padding-right:25px!important}.adf-task-form-actions .mat-button{border-radius:5px;height:36px}.adf-task-form-actions .mat-button-wrapper{font-size:var(--theme-body-2-font-size);font-weight:700;height:20px;opacity:.54;width:58px}"]
            },] }
];
TaskFormComponent.ctorParameters = () => [
    { type: TaskListService },
    { type: AuthenticationService },
    { type: TranslationService }
];
TaskFormComponent.propDecorators = {
    taskId: [{ type: Input }],
    showFormTitle: [{ type: Input }],
    showFormCompleteButton: [{ type: Input }],
    showFormSaveButton: [{ type: Input }],
    showCancelButton: [{ type: Input }],
    readOnlyForm: [{ type: Input }],
    showFormRefreshButton: [{ type: Input }],
    showFormValidationIcon: [{ type: Input }],
    fieldValidators: [{ type: Input }],
    formSaved: [{ type: Output }],
    formCompleted: [{ type: Output }],
    formContentClicked: [{ type: Output }],
    formLoaded: [{ type: Output }],
    showAttachForm: [{ type: Output }],
    executeOutcome: [{ type: Output }],
    completed: [{ type: Output }],
    formError: [{ type: Output }],
    error: [{ type: Output }],
    cancel: [{ type: Output }],
    taskClaimed: [{ type: Output }],
    taskUnclaimed: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TaskDetailsComponent {
    constructor(taskListService, peopleProcessService, logService, cardViewUpdateService, dialog) {
        this.taskListService = taskListService;
        this.peopleProcessService = peopleProcessService;
        this.logService = logService;
        this.cardViewUpdateService = cardViewUpdateService;
        this.dialog = dialog;
        this.debugMode = false;
        this.showNextTask = true;
        this.showHeader = true;
        this.showHeaderContent = true;
        this.showInvolvePeople = true;
        this.showComments = true;
        this.showChecklist = true;
        this.showFormTitle = false;
        this.showFormCompleteButton = true;
        this.showFormSaveButton = true;
        this.readOnlyForm = false;
        this.showFormRefreshButton = true;
        this.fieldValidators = [];
        this.formSaved = new EventEmitter();
        this.formCompleted = new EventEmitter();
        this.formContentClicked = new EventEmitter();
        this.formLoaded = new EventEmitter();
        this.taskCreated = new EventEmitter();
        this.taskDeleted = new EventEmitter();
        this.error = new EventEmitter();
        this.executeOutcome = new EventEmitter();
        this.assignTask = new EventEmitter();
        this.claimedTask = new EventEmitter();
        this.unClaimedTask = new EventEmitter();
        this.taskFormName = null;
        this.taskPeople = [];
        this.showAssignee = false;
        this.showAttachForm = false;
        this.internalReadOnlyForm = false;
        this.onDestroy$ = new Subject();
    }
    ngOnInit() {
        this.peopleSearch = new Observable((observer) => this.peopleSearchObserver = observer).pipe(share());
        if (this.taskId) {
            this.loadDetails(this.taskId);
        }
        this.cardViewUpdateService.itemUpdated$
            .pipe(takeUntil(this.onDestroy$))
            .subscribe(this.updateTaskDetails.bind(this));
        this.cardViewUpdateService.itemClicked$
            .pipe(takeUntil(this.onDestroy$))
            .subscribe(this.clickTaskDetails.bind(this));
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
    ngOnChanges(changes) {
        const taskId = changes.taskId;
        this.showAssignee = false;
        if (taskId && !taskId.currentValue) {
            this.reset();
        }
        else if (taskId && taskId.currentValue) {
            this.loadDetails(taskId.currentValue);
        }
    }
    isShowAttachForm() {
        return this.showAttachForm;
    }
    reset() {
        this.taskDetails = null;
    }
    isTaskActive() {
        return this.taskDetails && this.taskDetails.duration === null;
    }
    updateTaskDetails(updateNotification) {
        this.taskListService
            .updateTask(this.taskId, updateNotification.changed)
            .pipe(catchError(() => {
            this.cardViewUpdateService.updateElement(updateNotification.target);
            return of(null);
        }))
            .subscribe(() => this.loadDetails(this.taskId));
    }
    clickTaskDetails(clickNotification) {
        if (clickNotification.target.key === 'assignee') {
            this.showAssignee = true;
        }
        if (clickNotification.target.key === 'formName') {
            this.showAttachForm = true;
        }
    }
    loadDetails(taskId) {
        this.taskPeople = [];
        if (taskId) {
            this.taskListService.getTaskDetails(taskId).subscribe((res) => {
                this.showAttachForm = false;
                this.taskDetails = res;
                if (this.taskDetails.name === 'null') {
                    this.taskDetails.name = 'No name';
                }
                const endDate = res.endDate;
                if (endDate && !isNaN(endDate.getTime())) {
                    this.internalReadOnlyForm = true;
                }
                else {
                    this.internalReadOnlyForm = this.readOnlyForm;
                }
                if (this.taskDetails && this.taskDetails.involvedPeople) {
                    this.taskDetails.involvedPeople.forEach((user) => {
                        this.taskPeople.push(new UserProcessModel(user));
                    });
                }
            });
        }
    }
    isAssigned() {
        return !!this.taskDetails.assignee;
    }
    loadNextTask(processInstanceId, processDefinitionId) {
        const requestNode = new TaskQueryRequestRepresentationModel({
            processInstanceId: processInstanceId,
            processDefinitionId: processDefinitionId
        });
        this.taskListService.getTasks(requestNode).subscribe((response) => {
            if (response && response.length > 0) {
                this.taskDetails = new TaskDetailsModel(response[0]);
            }
            else {
                this.reset();
            }
        }, (error) => {
            this.error.emit(error);
        });
    }
    onComplete() {
        this.onFormCompleted(null);
    }
    onShowAttachForm() {
        this.showAttachForm = true;
    }
    onCancelAttachForm() {
        this.showAttachForm = false;
    }
    onCompleteAttachForm() {
        this.taskFormName = null;
        this.showAttachForm = false;
        this.taskFormComponent.loadTask(this.taskId);
        this.loadDetails(this.taskId);
    }
    onFormContentClick(content) {
        this.formContentClicked.emit(content);
    }
    onFormSaved(form) {
        this.formSaved.emit(form);
    }
    onFormCompleted(form) {
        this.formCompleted.emit(form);
        if (this.showNextTask && (this.taskDetails.processInstanceId || this.taskDetails.processDefinitionId)) {
            this.loadNextTask(this.taskDetails.processInstanceId, this.taskDetails.processDefinitionId);
        }
    }
    onFormLoaded(form) {
        this.taskFormName = (form && form.name ? form.name : null);
        this.formLoaded.emit(form);
    }
    onChecklistTaskCreated(task) {
        this.taskCreated.emit(task);
    }
    onChecklistTaskDeleted(taskId) {
        this.taskDeleted.emit(taskId);
    }
    onFormError(error) {
        this.errorDialogRef = this.dialog.open(this.errorDialog, { width: '500px' });
        this.error.emit(error);
    }
    onFormExecuteOutcome(event) {
        this.executeOutcome.emit(event);
    }
    closeErrorDialog() {
        this.dialog.closeAll();
    }
    onClaimAction(taskId) {
        this.claimedTask.emit(taskId);
        this.loadDetails(taskId);
    }
    onUnclaimAction(taskId) {
        this.unClaimedTask.emit(taskId);
        this.loadDetails(taskId);
    }
    searchUser(searchedWord) {
        this.peopleProcessService.getWorkflowUsers(null, searchedWord)
            .subscribe(users => {
            users = users.filter((user) => user.id !== this.taskDetails.assignee.id);
            this.peopleSearchObserver.next(users);
        }, () => this.logService.error('Could not load users'));
    }
    onCloseSearch() {
        this.showAssignee = false;
    }
    assignTaskToUser(selectedUser) {
        this.taskListService
            .assignTask(this.taskDetails.id, selectedUser)
            .subscribe(() => {
            this.logService.info('Task Assigned to ' + selectedUser.email);
            this.assignTask.emit();
        });
        this.showAssignee = false;
    }
    getTaskHeaderViewClass() {
        if (this.showAssignee) {
            return 'assign-edit-view';
        }
        else {
            return 'default-view';
        }
    }
    isReadOnlyComment() {
        return (this.taskDetails && this.taskDetails.isCompleted()) && (this.taskPeople && this.taskPeople.length === 0);
    }
}
TaskDetailsComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-task-details',
                template: "<div *ngIf=\"!taskDetails\" data-automation-id=\"adf-tasks-details--empty\">\n    <ng-template *ngIf=\"noTaskDetailsTemplateComponent\" ngFor [ngForOf]=\"[data]\"\n                 [ngForTemplate]=\"noTaskDetailsTemplateComponent\">\n        {{ 'ADF_TASK_LIST.DETAILS.MESSAGES.NONE' | translate }}\n    </ng-template>\n    <div *ngIf=\"!noTaskDetailsTemplateComponent\">\n        {{ 'ADF_TASK_LIST.DETAILS.MESSAGES.NONE' | translate }}\n    </div>\n</div>\n<div *ngIf=\"taskDetails\" class=\"adf-task-details\">\n\n    <div *ngIf=\"showHeader\" class=\"adf-task-details-header\">\n        <h2 class=\"adf-activiti-task-details__header\">\n            <span>{{taskDetails.name || 'No name'}}</span>\n        </h2>\n    </div>\n\n    <div class=\"adf-task-details-core\"\n        fxLayout=\"column\"\n        fxLayoutGap=\"8px\"\n        fxLayout.lt-lg=\"column\">\n\n        <div class=\"adf-task-details-core-form\">\n            <div *ngIf=\"isAssigned()\">\n                <adf-task-form\n                          [taskId]=\"taskDetails.id\"\n                          [showFormTitle]=\"showFormTitle\"\n                          [showFormRefreshButton]=\"showFormRefreshButton\"\n                          [showCancelButton]=\"true\"\n                          [fieldValidators]=\"fieldValidators\"\n                          (formSaved)='onFormSaved($event)'\n                          (formCompleted)='onFormCompleted($event)'\n                          (formContentClicked)='onFormContentClick($event)'\n                          (formLoaded)='onFormLoaded($event)'\n                          (completed)=\"onComplete()\"\n                          (showAttachForm)=\"onShowAttachForm()\"\n                          (executeOutcome)='onFormExecuteOutcome($event)'\n                          (taskClaimed)=\"onClaimAction($event)\"\n                          (taskUnclaimed)=\"onUnclaimAction($event)\"\n                          (error)=\"onFormError($event)\" #activitiTaskForm>\n                </adf-task-form>\n                <adf-attach-form *ngIf=\"isShowAttachForm()\"\n                                 [taskId]=\"taskDetails.id\"\n                                 [formKey]=\"taskDetails.formKey\"\n                                 (cancelAttachForm)=\"onCancelAttachForm()\"\n                                 (success)=\"onCompleteAttachForm()\">\n                </adf-attach-form>\n            </div>\n            <div *ngIf=\"!isAssigned()\" id=\"claim-message-id\">\n                {{ 'ADF_TASK_LIST.DETAILS.MESSAGES.CLAIM' | translate }}\n            </div>\n        </div>\n        <div class=\"adf-task-details-core-sidebar\">\n            <adf-info-drawer *ngIf=\"showHeaderContent\" title=\"ADF_TASK_LIST.DETAILS.LABELS.INFO_DRAWER_TITLE\" id=\"adf-task-details-core-sidebar-drawer\" class=\"adf-task-details-core-sidebar-drawer\">\n                <adf-info-drawer-tab label=\"ADF_TASK_LIST.DETAILS.LABELS.INFO_DRAWER_TAB_DETAILS_TITLE\">\n                    <div class=\"adf-assignment-container\" *ngIf=\"showAssignee\">\n                        <adf-people-search\n                            (searchPeople)=\"searchUser($event)\"\n                            (success)=\"assignTaskToUser($event)\"\n                            (closeSearch)=\"onCloseSearch()\"\n                            [results]=\"peopleSearch\">\n                            <ng-container adf-people-search-title>{{ 'ADF_TASK_LIST.DETAILS.LABELS.ADD_ASSIGNEE' | translate }}\n                            </ng-container>\n                            <ng-container adf-people-search-action-label>{{ 'ADF_TASK_LIST.PEOPLE.ADD_ASSIGNEE' | translate }}\n                            </ng-container>\n                        </adf-people-search>\n                    </div>\n                    <adf-task-header\n                        [class]=\"getTaskHeaderViewClass()\"\n                        [taskDetails]=\"taskDetails\"\n                        [formName]=\"taskFormName\"\n                        (claim)=\"onClaimAction($event)\"\n                        (unclaim)=\"onUnclaimAction($event)\">\n                    </adf-task-header>\n                    <adf-people *ngIf=\"showInvolvePeople\" #people\n                                [people]=\"taskPeople\"\n                                [readOnly]=\"internalReadOnlyForm\"\n                                [taskId]=\"taskDetails.id\">\n                    </adf-people>\n                </adf-info-drawer-tab>\n\n                <adf-info-drawer-tab label=\"ADF_TASK_LIST.DETAILS.LABELS.INFO_DRAWER_TAB_ACTIVITY_TITLE\">\n                    <mat-card *ngIf=\"showComments\">\n                        <mat-card-content>\n                            <adf-comments #activitiComments\n                                          [readOnly]=\"isReadOnlyComment()\"\n                                          [taskId]=\"taskDetails.id\">\n                            </adf-comments>\n                        </mat-card-content>\n                    </mat-card>\n                </adf-info-drawer-tab>\n\n            </adf-info-drawer>\n\n            <div *ngIf=\"showHeaderContent\" class=\"adf-task-details-core-sidebar-checklist\">\n                <div *ngIf=\"showChecklist\">\n                    <adf-checklist #activitiChecklist\n                                   [readOnly]=\"internalReadOnlyForm\"\n                                   [taskId]=\"taskDetails.id\"\n                                   [assignee]=\"$any(taskDetails)?.assignee?.id\"\n                                   (checklistTaskCreated)=\"onChecklistTaskCreated($event)\"\n                                   (checklistTaskDeleted)=\"onChecklistTaskDeleted($event)\">\n                    </adf-checklist>\n                </div>\n            </div>\n        </div>\n    </div>\n\n    <ng-template #errorDialog>\n        <h3 matDialogTitle>{{'ADF_TASK_LIST.DETAILS.ERROR.TITLE'|translate}}</h3>\n        <mat-dialog-content>\n            <p>{{'ADF_TASK_LIST.DETAILS.ERROR.DESCRIPTION'|translate}}</p>\n        </mat-dialog-content>\n        <mat-dialog-actions>\n            <button mat-button type=\"button\" (click)=\"closeErrorDialog()\">{{'ADF_TASK_LIST.DETAILS.ERROR.CLOSE'|translate}}\n            </button>\n        </mat-dialog-actions>\n    </ng-template>\n\n</div>\n",
                styles: [":host{width:100%}.adf-error-dialog h3{margin:16px 0}.adf-activiti-task-details__header{-moz-user-select:none;-ms-user-select:none;-webkit-user-select:none;align-self:flex-end;cursor:pointer;display:flex;font-size:24px;font-weight:300;line-height:normal;margin:8px 0 16px;overflow:hidden;user-select:none}.adf-activiti-task-details__action-button{text-transform:uppercase}.adf-assignment-container{padding:10px 20px;width:auto}adf-task-header.adf-assign-edit-view ::ng-deep adf-card-view ::ng-deep .adf-property[data-automation-id=header-assignee]{display:none}.adf-task-details-header{display:flex;justify-content:space-between}.adf-task-details-header-toggle{-moz-user-select:none;-ms-user-select:none;-webkit-user-select:none;cursor:pointer;height:23px;margin-right:2px;position:relative;top:10px;user-select:none}.adf-task-details-toggle{position:relative}.adf-task-details-core{display:flex;justify-content:space-between}@media screen and (max-width:1279px){.adf-task-details-core-sidebar-drawer{margin-left:0}}.adf-task-details-core-sidebar-checklist{margin-top:30px;padding-left:20px;padding-right:20px}.adf-task-details-core-form{flex-grow:1}.adf-task-details-core-form ::ng-deep .adf-form-debug-container{display:flex;flex-direction:column;padding:20px 0}.adf-task-details-core-form ::ng-deep .adf-form-debug-container .mat-slide-toggle{margin-left:auto}.adf-task-details-core-form ::ng-deep .adf-form-debug-container .mat-slide-toggle+div{background-color:#000;clear:both;color:#fff;margin-top:30px;padding:20px}.adf-task-details-core-form ::ng-deep .mat-tab-label{flex-grow:1}"]
            },] }
];
TaskDetailsComponent.ctorParameters = () => [
    { type: TaskListService },
    { type: PeopleProcessService },
    { type: LogService },
    { type: CardViewUpdateService },
    { type: MatDialog }
];
TaskDetailsComponent.propDecorators = {
    activitiComments: [{ type: ViewChild, args: ['activitiComments',] }],
    activitiChecklist: [{ type: ViewChild, args: ['activitiChecklist',] }],
    errorDialog: [{ type: ViewChild, args: ['errorDialog',] }],
    taskFormComponent: [{ type: ViewChild, args: ['activitiTaskForm',] }],
    debugMode: [{ type: Input }],
    taskId: [{ type: Input }],
    showNextTask: [{ type: Input }],
    showHeader: [{ type: Input }],
    showHeaderContent: [{ type: Input }],
    showInvolvePeople: [{ type: Input }],
    showComments: [{ type: Input }],
    showChecklist: [{ type: Input }],
    showFormTitle: [{ type: Input }],
    showFormCompleteButton: [{ type: Input }],
    showFormSaveButton: [{ type: Input }],
    readOnlyForm: [{ type: Input }],
    showFormRefreshButton: [{ type: Input }],
    fieldValidators: [{ type: Input }],
    formSaved: [{ type: Output }],
    formCompleted: [{ type: Output }],
    formContentClicked: [{ type: Output }],
    formLoaded: [{ type: Output }],
    taskCreated: [{ type: Output }],
    taskDeleted: [{ type: Output }],
    error: [{ type: Output }],
    executeOutcome: [{ type: Output }],
    assignTask: [{ type: Output }],
    claimedTask: [{ type: Output }],
    unClaimedTask: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class NoTaskDetailsTemplateDirective {
    constructor(activitiTaskDetails) {
        this.activitiTaskDetails = activitiTaskDetails;
    }
    ngAfterContentInit() {
        this.activitiTaskDetails.noTaskDetailsTemplateComponent = this.template;
    }
}
NoTaskDetailsTemplateDirective.decorators = [
    { type: Directive, args: [{
                selector: 'adf-no-task-details-template, no-task-details-template'
            },] }
];
NoTaskDetailsTemplateDirective.ctorParameters = () => [
    { type: TaskDetailsComponent }
];
NoTaskDetailsTemplateDirective.propDecorators = {
    template: [{ type: ContentChild, args: [TemplateRef,] }]
};

class TaskFilterService {
    constructor(apiService, logService) {
        this.apiService = apiService;
        this.logService = logService;
    }
    get userFiltersApi() {
        var _a;
        this._userFiltersApi = (_a = this._userFiltersApi) !== null && _a !== void 0 ? _a : new UserFiltersApi(this.apiService.getInstance());
        return this._userFiltersApi;
    }
    createDefaultFilters(appId) {
        const myTasksFilter = this.getMyTasksFilterInstance(appId, 0);
        const myTaskObservable = this.addFilter(myTasksFilter);
        const involvedTasksFilter = this.getInvolvedTasksFilterInstance(appId, 1);
        const involvedObservable = this.addFilter(involvedTasksFilter);
        const queuedTasksFilter = this.getQueuedTasksFilterInstance(appId, 2);
        const queuedObservable = this.addFilter(queuedTasksFilter);
        const completedTasksFilter = this.getCompletedTasksFilterInstance(appId, 3);
        const completeObservable = this.addFilter(completedTasksFilter);
        return new Observable((observer) => {
            forkJoin([
                myTaskObservable,
                involvedObservable,
                queuedObservable,
                completeObservable
            ]).subscribe((res) => {
                const filters = [];
                res.forEach((filter) => {
                    if (filter.name === involvedTasksFilter.name) {
                        filters.push(new FilterRepresentationModel(Object.assign(Object.assign({}, filter), { filter: involvedTasksFilter.filter, appId })));
                    }
                    else if (filter.name === myTasksFilter.name) {
                        filters.push(new FilterRepresentationModel(Object.assign(Object.assign({}, filter), { filter: myTasksFilter.filter, appId })));
                    }
                    else if (filter.name === queuedTasksFilter.name) {
                        filters.push(new FilterRepresentationModel(Object.assign(Object.assign({}, filter), { filter: queuedTasksFilter.filter, appId })));
                    }
                    else if (filter.name === completedTasksFilter.name) {
                        filters.push(new FilterRepresentationModel(Object.assign(Object.assign({}, filter), { filter: completedTasksFilter.filter, appId })));
                    }
                });
                observer.next(filters);
                observer.complete();
            }, (err) => {
                this.logService.error(err);
            });
        });
    }
    getTaskListFilters(appId) {
        return from(this.callApiTaskFilters(appId))
            .pipe(map((response) => {
            const filters = [];
            response.data.forEach((filter) => {
                const filterModel = new FilterRepresentationModel(filter);
                filters.push(filterModel);
            });
            return filters;
        }), catchError((err) => this.handleError(err)));
    }
    getTaskFilterById(filterId, appId) {
        return from(this.callApiTaskFilters(appId)).pipe(map((response) => response.data.find((filter) => filter.id === filterId)), catchError((err) => this.handleError(err)));
    }
    getTaskFilterByName(taskName, appId) {
        return from(this.callApiTaskFilters(appId)).pipe(map((response) => response.data.find((filter) => filter.name === taskName)), catchError((err) => this.handleError(err)));
    }
    addFilter(filter) {
        return from(this.userFiltersApi.createUserTaskFilter(filter))
            .pipe(map((response) => {
            return response;
        }), catchError((err) => this.handleError(err)));
    }
    callApiTaskFilters(appId) {
        if (appId) {
            return this.userFiltersApi.getUserTaskFilters({ appId: appId });
        }
        else {
            return this.userFiltersApi.getUserTaskFilters();
        }
    }
    getMyTasksFilterInstance(appId, index) {
        return new FilterRepresentationModel({
            'name': 'My Tasks',
            'appId': appId,
            'recent': false,
            'icon': 'glyphicon-inbox',
            'filter': { 'sort': 'created-desc', 'name': '', 'state': 'open', 'assignment': 'assignee' },
            index
        });
    }
    getInvolvedTasksFilterInstance(appId, index) {
        return new FilterRepresentationModel({
            'name': 'Involved Tasks',
            'appId': appId,
            'recent': false,
            'icon': 'glyphicon-align-left',
            'filter': { 'sort': 'created-desc', 'name': '', 'state': 'open', 'assignment': 'involved' },
            index
        });
    }
    getQueuedTasksFilterInstance(appId, index) {
        return new FilterRepresentationModel({
            'name': 'Queued Tasks',
            'appId': appId,
            'recent': false,
            'icon': 'glyphicon-record',
            'filter': { 'sort': 'created-desc', 'name': '', 'state': 'open', 'assignment': 'candidate' },
            index
        });
    }
    getCompletedTasksFilterInstance(appId, index) {
        return new FilterRepresentationModel({
            'name': 'Completed Tasks',
            'appId': appId,
            'recent': true,
            'icon': 'glyphicon-ok-sign',
            'filter': { 'sort': 'created-desc', 'name': '', 'state': 'completed', 'assignment': 'involved' },
            index
        });
    }
    handleError(error) {
        this.logService.error(error);
        return throwError(error || 'Server error');
    }
}
TaskFilterService.ɵprov = ɵɵdefineInjectable({ factory: function TaskFilterService_Factory() { return new TaskFilterService(ɵɵinject(AlfrescoApiService), ɵɵinject(LogService)); }, token: TaskFilterService, providedIn: "root" });
TaskFilterService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
TaskFilterService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: LogService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TaskFiltersComponent {
    constructor(taskFilterService, taskListService, appsProcessService) {
        this.taskFilterService = taskFilterService;
        this.taskListService = taskListService;
        this.appsProcessService = appsProcessService;
        this.filterClicked = new EventEmitter();
        this.filterSelected = new EventEmitter();
        this.success = new EventEmitter();
        this.error = new EventEmitter();
        this.filters = [];
    }
    ngOnInit() {
        this.iconsMDL = new IconModel();
    }
    ngOnChanges(changes) {
        const appName = changes['appName'];
        const appId = changes['appId'];
        const filter = changes['filterParam'];
        if (appName && appName.currentValue) {
            this.getFiltersByAppName(appName.currentValue);
        }
        else if (appId && appId.currentValue !== appId.previousValue) {
            this.getFiltersByAppId(appId.currentValue);
        }
        else if (filter && filter.currentValue !== filter.previousValue) {
            this.selectFilterAndEmit(filter.currentValue);
        }
    }
    getFilters(appId, appName) {
        appName ? this.getFiltersByAppName(appName) : this.getFiltersByAppId(appId);
    }
    getFiltersByAppId(appId) {
        this.taskFilterService.getTaskListFilters(appId).subscribe((res) => {
            if (res.length === 0 && this.isFilterListEmpty()) {
                this.createFiltersByAppId(appId);
            }
            else {
                this.resetFilter();
                this.filters = res;
                this.selectFilter(this.filterParam);
                this.success.emit(res);
            }
        }, (err) => {
            this.error.emit(err);
        });
    }
    getFiltersByAppName(appName) {
        this.appsProcessService.getDeployedApplicationsByName(appName).subscribe((application) => {
            this.getFiltersByAppId(application.id);
        }, (err) => {
            this.error.emit(err);
        });
    }
    createFiltersByAppId(appId) {
        this.taskFilterService.createDefaultFilters(appId).subscribe((resDefault) => {
            this.resetFilter();
            this.filters = resDefault;
            this.selectFilter(this.filterParam);
            this.success.emit(resDefault);
        }, (errDefault) => {
            this.error.emit(errDefault);
        });
    }
    selectFilter(newFilter) {
        if (newFilter) {
            this.currentFilter = this.filters.find((filter, index) => newFilter.index === index ||
                newFilter.id === filter.id ||
                (newFilter.name &&
                    (newFilter.name.toLocaleLowerCase() === filter.name.toLocaleLowerCase())));
        }
    }
    selectFilterAndEmit(newFilter) {
        this.selectFilter(newFilter);
        this.filterSelected.emit(this.currentFilter);
    }
    onFilterClick(filter) {
        this.selectFilter(filter);
        this.filterClicked.emit(this.currentFilter);
    }
    selectFilterWithTask(taskId) {
        const filteredFilterList = [];
        this.taskListService.getFilterForTaskById(taskId, this.filters).subscribe((filter) => {
            filteredFilterList.push(filter);
        }, (err) => {
            this.error.emit(err);
        }, () => {
            if (filteredFilterList.length > 0) {
                this.selectFilter(filteredFilterList[0]);
                this.filterSelected.emit(this.currentFilter);
            }
        });
    }
    selectDefaultTaskFilter() {
        if (!this.isFilterListEmpty()) {
            this.currentFilter = this.filters[0];
        }
    }
    getCurrentFilter() {
        return this.currentFilter;
    }
    isFilterListEmpty() {
        return this.filters === undefined || (this.filters && this.filters.length === 0);
    }
    resetFilter() {
        this.filters = [];
        this.currentFilter = undefined;
    }
    getFilterIcon(icon) {
        return this.iconsMDL.mapGlyphiconToMaterialDesignIcons(icon);
    }
}
TaskFiltersComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-task-filters',
                template: "<div *ngFor=\"let filter of filters\" class=\"adf-filters__entry\" [class.adf-active]=\"currentFilter === filter\">\n    <button (click)=\"onFilterClick(filter)\"\n      [attr.aria-label]=\"filter.name | translate\"\n      [id]=\"filter.id\"\n      [attr.data-automation-id]=\"filter.name + '_filter'\"\n      mat-button\n      class=\"adf-filter-action-button adf-full-width\" fxLayout=\"row\" fxLayoutAlign=\"space-between center\">\n      <ng-container *ngIf=\"showIcon\">\n        <adf-icon data-automation-id=\"adf-filter-icon\" [value]=\"getFilterIcon(filter.icon)\"></adf-icon>\n      </ng-container>\n      <span data-automation-id=\"adf-filter-label\" class=\"adf-filter-action-button__label\">{{ filter.name | translate }}</span>\n    </button>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-filters__entry{cursor:pointer;font-size:14px!important;font-weight:700;height:24px;opacity:.54;padding:12px 0!important;width:100%}.adf-filters__entry .adf-full-width{display:flex;width:100%}.adf-filters__entry .adf-filter-action-button .adf-filter-action-button__label{margin:0 8px!important;padding-left:20px}.adf-filters__entry.adf-active,.adf-filters__entry:hover{color:var(--theme-primary-color);opacity:1}"]
            },] }
];
TaskFiltersComponent.ctorParameters = () => [
    { type: TaskFilterService },
    { type: TaskListService },
    { type: AppsProcessService }
];
TaskFiltersComponent.propDecorators = {
    filterParam: [{ type: Input }],
    filterClicked: [{ type: Output }],
    filterSelected: [{ type: Output }],
    success: [{ type: Output }],
    error: [{ type: Output }],
    appId: [{ type: Input }],
    appName: [{ type: Input }],
    showIcon: [{ type: Input }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ClaimTaskDirective {
    constructor(taskListService, logService) {
        this.taskListService = taskListService;
        this.logService = logService;
        this.success = new EventEmitter();
        this.error = new EventEmitter();
        this.invalidParams = [];
    }
    ngOnInit() {
        this.validateInputs();
    }
    validateInputs() {
        if (!this.isTaskValid()) {
            this.invalidParams.push('taskId');
        }
        if (this.invalidParams.length) {
            throw new Error(`Attribute ${this.invalidParams.join(', ')} is required`);
        }
    }
    isTaskValid() {
        return this.taskId && this.taskId.length > 0;
    }
    onClick() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.claimTask();
            }
            catch (error) {
                this.error.emit(error);
            }
        });
    }
    claimTask() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.taskListService.claimTask(this.taskId).subscribe(() => {
                this.logService.info('Task claimed');
                this.success.emit(this.taskId);
            }, error => this.error.emit(error));
        });
    }
}
ClaimTaskDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-claim-task]'
            },] }
];
ClaimTaskDirective.ctorParameters = () => [
    { type: TaskListService },
    { type: LogService }
];
ClaimTaskDirective.propDecorators = {
    taskId: [{ type: Input }],
    success: [{ type: Output }],
    error: [{ type: Output }],
    onClick: [{ type: HostListener, args: ['click',] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class UnclaimTaskDirective {
    constructor(taskListService, logService) {
        this.taskListService = taskListService;
        this.logService = logService;
        this.success = new EventEmitter();
        this.error = new EventEmitter();
        this.invalidParams = [];
    }
    ngOnInit() {
        this.validateInputs();
    }
    validateInputs() {
        if (!this.isTaskValid()) {
            this.invalidParams.push('taskId');
        }
        if (this.invalidParams.length) {
            throw new Error(`Attribute ${this.invalidParams.join(', ')} is required`);
        }
    }
    isTaskValid() {
        return this.taskId && this.taskId.length > 0;
    }
    onClick() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                yield this.unclaimTask();
            }
            catch (error) {
                this.error.emit(error);
            }
        });
    }
    unclaimTask() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.taskListService.unclaimTask(this.taskId).subscribe(() => {
                this.logService.info('Task unclaimed');
                this.success.emit(this.taskId);
            }, error => this.error.emit(error));
        });
    }
}
UnclaimTaskDirective.decorators = [
    { type: Directive, args: [{
                selector: '[adf-unclaim-task]'
            },] }
];
UnclaimTaskDirective.ctorParameters = () => [
    { type: TaskListService },
    { type: LogService }
];
UnclaimTaskDirective.propDecorators = {
    taskId: [{ type: Input }],
    success: [{ type: Output }],
    error: [{ type: Output }],
    onClick: [{ type: HostListener, args: ['click',] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const JSON_FORMAT = 'json';
const PDF_FORMAT = 'pdf';
class TaskAuditDirective {
    constructor(contentService, taskListService) {
        this.contentService = contentService;
        this.taskListService = taskListService;
        this.fileName = 'Audit';
        this.format = 'pdf';
        this.download = true;
        this.clicked = new EventEmitter();
        this.error = new EventEmitter();
    }
    ngOnChanges() {
        if (!this.isValidType()) {
            this.setDefaultFormatType();
        }
    }
    isValidType() {
        return this.format && (this.isJsonFormat() || this.isPdfFormat());
    }
    setDefaultFormatType() {
        this.format = PDF_FORMAT;
    }
    fetchAuditInfo() {
        if (this.isPdfFormat()) {
            this.taskListService.fetchTaskAuditPdfById(this.taskId).subscribe((blob) => {
                this.audit = blob;
                if (this.download) {
                    this.contentService.downloadBlob(this.audit, this.fileName + '.pdf');
                }
                this.clicked.emit({ format: this.format, value: this.audit, fileName: this.fileName });
            }, (err) => {
                this.error.emit(err);
            });
        }
        else {
            this.taskListService.fetchTaskAuditJsonById(this.taskId).subscribe((res) => {
                this.audit = res;
                this.clicked.emit({ format: this.format, value: this.audit, fileName: this.fileName });
            }, (err) => {
                this.error.emit(err);
            });
        }
    }
    onClickAudit() {
        this.fetchAuditInfo();
    }
    isJsonFormat() {
        return this.format === JSON_FORMAT;
    }
    isPdfFormat() {
        return this.format === PDF_FORMAT;
    }
}
TaskAuditDirective.decorators = [
    { type: Directive, args: [{
                selector: 'button[adf-task-audit]',
                host: {
                    'role': 'button',
                    '(click)': 'onClickAudit()'
                }
            },] }
];
TaskAuditDirective.ctorParameters = () => [
    { type: ContentService },
    { type: TaskListService }
];
TaskAuditDirective.propDecorators = {
    taskId: [{ type: Input, args: ['task-id',] }],
    fileName: [{ type: Input }],
    format: [{ type: Input }],
    download: [{ type: Input }],
    clicked: [{ type: Output }],
    error: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ɵ0 = MOMENT_DATE_FORMATS;
class StartTaskComponent {
    constructor(taskService, dateAdapter, userPreferencesService, formBuilder, logService) {
        this.taskService = taskService;
        this.dateAdapter = dateAdapter;
        this.userPreferencesService = userPreferencesService;
        this.formBuilder = formBuilder;
        this.logService = logService;
        this.FORMAT_DATE = 'DD/MM/YYYY';
        this.MAX_LENGTH = 255;
        this.name = '';
        this.success = new EventEmitter();
        this.cancel = new EventEmitter();
        this.error = new EventEmitter();
        this.taskDetailsModel = new TaskDetailsModel();
        this.dateError = false;
        this.maxTaskNameLength = this.MAX_LENGTH;
        this.loading = false;
        this.onDestroy$ = new Subject();
    }
    ngOnInit() {
        if (this.name) {
            this.taskDetailsModel.name = this.name;
        }
        this.validateMaxTaskNameLength();
        this.field = new FormFieldModel(new FormModel(), { id: this.assigneeId, value: this.assigneeId, placeholder: 'Assignee' });
        this.userPreferencesService
            .select(UserPreferenceValues.Locale)
            .pipe(takeUntil(this.onDestroy$))
            .subscribe(locale => this.dateAdapter.setLocale(locale));
        this.loadFormsTask();
        this.buildForm();
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
    buildForm() {
        this.taskForm = this.formBuilder.group({
            name: new FormControl(this.taskDetailsModel.name, [Validators.required, Validators.maxLength(this.maxTaskNameLength), this.whitespaceValidator]),
            description: new FormControl('', [this.whitespaceValidator]),
            formKey: new FormControl('')
        });
        this.taskForm.valueChanges
            .pipe(takeUntil(this.onDestroy$))
            .subscribe(taskFormValues => this.setTaskDetails(taskFormValues));
    }
    whitespaceValidator(control) {
        if (control.value) {
            const isWhitespace = (control.value || '').trim().length === 0;
            const isValid = control.value.length === 0 || !isWhitespace;
            return isValid ? null : { 'whitespace': true };
        }
        return null;
    }
    setTaskDetails(form) {
        this.taskDetailsModel.name = form.name;
        this.taskDetailsModel.description = form.description;
        this.taskDetailsModel.formKey = form.formKey ? form.formKey.toString() : null;
    }
    isFormValid() {
        return this.taskForm.valid && !this.dateError && !this.loading;
    }
    saveTask() {
        this.loading = true;
        if (this.appId) {
            this.taskDetailsModel.category = this.appId.toString();
        }
        this.taskService.createNewTask(this.taskDetailsModel)
            .pipe(switchMap((createRes) => this.attachForm(createRes.id, this.taskDetailsModel.formKey).pipe(defaultIfEmpty(createRes), switchMap((attachRes) => this.assignTaskByUserId(createRes.id, this.assigneeId).pipe(defaultIfEmpty(attachRes ? attachRes : createRes))))))
            .subscribe((res) => {
            this.loading = false;
            this.success.emit(res);
        }, (err) => {
            this.loading = false;
            this.error.emit(err);
            this.logService.error('An error occurred while creating new task');
        });
    }
    getAssigneeId(userId) {
        this.assigneeId = userId;
    }
    attachForm(taskId, formKey) {
        let response = of();
        if (taskId && formKey) {
            response = this.taskService.attachFormToATask(taskId, parseInt(formKey, 10));
        }
        return response;
    }
    assignTaskByUserId(taskId, userId) {
        let response = of();
        if (taskId && userId) {
            response = this.taskService.assignTaskByUserId(taskId, userId);
        }
        return response;
    }
    onCancel() {
        this.cancel.emit();
    }
    loadFormsTask() {
        this.forms$ = this.taskService.getFormList();
    }
    isUserNameEmpty(user) {
        return !user || (this.isEmpty(user.firstName) && this.isEmpty(user.lastName));
    }
    isEmpty(data) {
        return data === undefined || data === null || data.trim().length === 0;
    }
    getDisplayUser(firstName, lastName, delimiter = '-') {
        firstName = (firstName !== null ? firstName : '');
        lastName = (lastName !== null ? lastName : '');
        return firstName + delimiter + lastName;
    }
    onDateChanged(newDateValue) {
        this.dateError = false;
        if (newDateValue) {
            let momentDate;
            if (typeof newDateValue === 'string') {
                momentDate = moment$1(newDateValue, this.FORMAT_DATE, true);
            }
            else {
                momentDate = newDateValue;
            }
            if (momentDate.isValid()) {
                this.taskDetailsModel.dueDate = momentDate.toDate();
            }
            else {
                this.dateError = true;
                this.taskDetailsModel.dueDate = null;
            }
        }
        else {
            this.taskDetailsModel.dueDate = null;
        }
    }
    validateMaxTaskNameLength() {
        if (this.maxTaskNameLength > this.MAX_LENGTH) {
            this.maxTaskNameLength = this.MAX_LENGTH;
            this.logService.log(`the task name length cannot be greater than ${this.MAX_LENGTH}`);
        }
    }
    get nameController() {
        return this.taskForm.get('name');
    }
    get descriptionController() {
        return this.taskForm.get('description');
    }
    get formKeyController() {
        return this.taskForm.get('formKey');
    }
}
StartTaskComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-start-task',
                template: "<mat-card fxFlex=\"70%\" class=\"adf-new-task-layout-card\">\n    <mat-card-header fxLayout=\"row\" fxLayoutAlign=\"start center\" fxLayoutGap=\"10px\" class=\"adf-new-task-heading\">\n        <mat-card-title>{{'ADF_TASK_LIST.START_TASK.FORM.TITLE' | translate}}</mat-card-title>\n    </mat-card-header>\n    <mat-card-content>\n        <form [formGroup]=\"taskForm\" fxLayout=\"column\" fxLayoutGap=\"10px\">\n            <div class=\"adf-task-name\">\n                <mat-form-field fxFlex>\n                    <mat-label>{{'ADF_TASK_LIST.START_TASK.FORM.LABEL.NAME' | translate}}</mat-label>\n                    <input\n                        matInput\n                        id=\"name_id\"\n                        formControlName=\"name\">\n                        <mat-error *ngIf=\"nameController.hasError('required') || nameController.hasError('whitespace')\">\n                            {{ 'ADF_TASK_LIST.START_TASK.FORM.ERROR.REQUIRED' | translate }}\n                        </mat-error>\n                        <mat-error *ngIf=\"nameController.hasError('maxlength')\">\n                            {{ 'ADF_TASK_LIST.START_TASK.FORM.ERROR.MAXIMUM_LENGTH' | translate : { characters : maxTaskNameLength } }}\n                        </mat-error>\n                </mat-form-field>\n            </div>\n            <div class=\"adf-task-description\">\n                <mat-form-field fxFlex>\n                    <mat-label>{{'ADF_TASK_LIST.START_TASK.FORM.LABEL.DESCRIPTION' | translate}}</mat-label>\n                    <textarea\n                        matInput\n                        rows=\"1\"\n                        id=\"description_id\"\n                        formControlName=\"description\">\n                    </textarea>\n                    <mat-error *ngIf=\"descriptionController.hasError('whitespace')\">\n                        {{ 'ADF_TASK_LIST.START_TASK.FORM.ERROR.MESSAGE' | translate }}\n                    </mat-error>\n                </mat-form-field>\n            </div>\n            <div class=\"input-row\" fxLayout=\"row\" fxLayout.lt-md=\"column\" fxLayoutGap=\"20px\" fxLayoutGap.lt-md=\"0px\">\n                <mat-form-field fxFlex>\n                    <input\n                        matInput\n                        (keyup)=\"onDateChanged($any($event).srcElement.value)\"\n                        (dateInput)=\"onDateChanged($any($event).value)\"\n                        [matDatepicker]=\"taskDatePicker\"\n                        placeholder=\"{{'ADF_TASK_LIST.START_TASK.FORM.LABEL.DATE'|translate}}\"\n                        id=\"date_id\">\n                    <mat-datepicker-toggle\n                        matSuffix\n                        [for]=\"taskDatePicker\"></mat-datepicker-toggle>\n                    <mat-datepicker\n                        #taskDatePicker\n                        [touchUi]=\"true\">\n                    </mat-datepicker>\n                    <div class=\"adf-error-text-container\">\n                        <div *ngIf=\"dateError\">\n                            <div class=\"adf-error-text\">{{'ADF_TASK_LIST.START_TASK.FORM.ERROR.DATE'|translate}}</div>\n                            <mat-icon class=\"adf-error-icon\">warning</mat-icon>\n                        </div>\n                    </div>\n                </mat-form-field>\n                <div fxFlex>\n                    <people-widget\n                        (peopleSelected)=\"getAssigneeId($event)\"\n                        [field]=\"field\"\n                        class=\"adf-people-widget-content\"></people-widget>\n                </div>\n            </div>\n            <div class=\"adf-task-form\">\n                <mat-form-field fxFlex=\"48%\" fxFlex.xs=\"100%\">\n                    <mat-label id=\"form_label\">{{'ADF_TASK_LIST.START_TASK.FORM.LABEL.FORM'|translate}}</mat-label>\n                    <mat-select\n                        id=\"form_id\"\n                        class=\"form-control\"\n                        formControlName=\"formKey\">\n                    <mat-option>{{'ADF_TASK_LIST.START_TASK.FORM.LABEL.NONE'|translate}}</mat-option>\n                    <mat-option *ngFor=\"let form of forms$ | async\" [value]=\"form.id\">{{ form.name }}</mat-option>\n                    </mat-select>\n                </mat-form-field>\n            </div>\n        </form>\n    </mat-card-content>\n    <mat-card-actions>\n        <div class=\"adf-new-task-footer\" fxLayout=\"row\" fxLayoutAlign=\"end end\">\n            <button\n                mat-button\n                class=\"adf-uppercase\"\n                (click)=\"onCancel()\"\n                id=\"button-cancel\">\n                {{ 'ADF_TASK_LIST.START_TASK.FORM.ACTION.CANCEL' | translate }}\n            </button>\n            <button\n                color=\"primary\"\n                mat-button\n                class=\"adf-uppercase\"\n                [disabled]=\"!isFormValid()\"\n                (click)=\"saveTask()\"\n                id=\"button-start\">\n                {{ 'ADF_TASK_LIST.START_TASK.FORM.ACTION.START' | translate }}\n            </button>\n        </div>\n    </mat-card-actions>\n</mat-card>\n",
                providers: [
                    { provide: DateAdapter, useClass: MomentDateAdapter },
                    { provide: MAT_DATE_FORMATS, useValue: ɵ0 }
                ],
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-new-task-heading{border-bottom:1px solid var(--theme-fg-divider);padding-top:12px}.adf-new-task-heading .mat-card-title{font-size:18px;font-weight:700}.adf-new-task-form{width:100%}.adf-new-task-layout-card{margin:10px auto}.adf-new-task-footer{border-top:1px solid #eee;font-size:18px;padding:4px}.adf-mat-select{padding-top:0}adf-start-task .mat-button.adf-uppercase{text-transform:uppercase}adf-start-task people-widget{width:100%}adf-start-task people-widget .mat-form-field-label-wrapper{top:-14px!important}adf-start-task .adf-people-widget-content .mat-form-field{width:100%}adf-start-task .adf-people-widget-content .adf-label{line-height:0}adf-start-task .adf-people-widget-content .adf-error-text-container{margin-top:-10px}adf-start-task .adf-start-task-input-container .mat-form-field-wrapper{padding-top:8px}adf-start-task .adf-error-text-container{height:20px;margin-top:12px;position:absolute;width:100%}adf-start-task .adf-error-text-container>div{display:flex;flex-flow:row;justify-content:flex-start}adf-start-task .adf-error-text{color:var(--theme-warn-color);font-size:12px;height:16px;line-height:1.33;padding-right:8px;width:auto}adf-start-task .adf-error-icon{color:var(--theme-warn-color);font-size:17px}adf-start-task .adf-label{color:#bababa}adf-start-task .adf-invalid .mat-form-field-underline{background-color:#f44336!important}adf-start-task .adf-invalid .adf-file{border-color:var(--theme-warn-color)}adf-start-task .adf-invalid .mat-form-field-prefix{color:var(--theme-warn-color)}adf-start-task .adf-invalid .adf-input{border-color:var(--theme-warn-color)}adf-start-task .adf-invalid .adf-label{color:var(--theme-warn-color)}adf-start-task .adf-invalid .adf-label:after{background-color:var(--theme-warn-color)}"]
            },] }
];
StartTaskComponent.ctorParameters = () => [
    { type: TaskListService },
    { type: DateAdapter },
    { type: UserPreferencesService },
    { type: FormBuilder },
    { type: LogService }
];
StartTaskComponent.propDecorators = {
    appId: [{ type: Input }],
    name: [{ type: Input }],
    success: [{ type: Output }],
    cancel: [{ type: Output }],
    error: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TaskStandaloneComponent {
    constructor() {
        this.isCompleted = false;
        this.hasCompletePermission = true;
        this.hideCancelButton = true;
        this.cancel = new EventEmitter();
        this.complete = new EventEmitter();
        this.showAttachForm = new EventEmitter();
    }
    onCancelButtonClick() {
        this.cancel.emit();
    }
    onCompleteButtonClick() {
        this.complete.emit();
    }
    hasCompleteButton() {
        return this.hasCompletePermission && !this.isCompleted;
    }
    hasCancelButton() {
        return !this.hideCancelButton && !this.isCompleted;
    }
    hasAttachFormButton() {
        return !this.isCompleted;
    }
    onShowAttachForm() {
        this.showAttachForm.emit();
    }
}
TaskStandaloneComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-task-standalone',
                template: "<mat-card class=\"adf-message-card\">\n    <mat-card-content>\n        <div class=\"adf-no-form-message-container\">\n            <div class=\"adf-no-form-message-list\">\n                <div *ngIf=\"!isCompleted; else completedMessage\" class=\"adf-no-form-message\">\n                    <span id=\"adf-no-form-message\">{{'ADF_TASK_LIST.STANDALONE_TASK.NO_FORM_MESSAGE' | translate}}</span>\n                </div>\n                <ng-template #completedMessage>\n                    <div id=\"adf-completed-form-message\" class=\"adf-no-form-message\">\n                        <p>{{'ADF_TASK_LIST.STANDALONE_TASK.COMPLETE_TASK_MESSAGE' | translate : {taskName : taskName} }}</p>\n                    </div>\n                    <div class=\"adf-no-form-submessage\">\n                        {{'ADF_TASK_LIST.STANDALONE_TASK.COMPLETE_TASK_SUB_MESSAGE' | translate}}\n                    </div>\n                </ng-template>\n            </div>\n        </div>\n    </mat-card-content>\n\n    <mat-card-actions class=\"adf-no-form-mat-card-actions\">\n        <button mat-button *ngIf=\"hasAttachFormButton()\" id=\"adf-no-form-attach-form-button\" (click)=\"onShowAttachForm()\">{{ 'ADF_TASK_LIST.START_TASK.FORM.LABEL.ATTACHFORM' | translate }}</button>\n        <div>\n            <button mat-button *ngIf=\"hasCancelButton()\" id=\"adf-no-form-cancel-button\" (click)=\"onCancelButtonClick()\">{{ 'ADF_TASK_LIST.START_TASK.FORM.ACTION.CANCEL' | translate }}</button>\n            <button mat-button *ngIf=\"hasCompleteButton()\" id=\"adf-no-form-complete-button\" color=\"primary\" (click)=\"onCompleteButtonClick()\">{{ 'ADF_TASK_LIST.DETAILS.BUTTON.COMPLETE' | translate }}</button>\n        </div>\n    </mat-card-actions>\n</mat-card>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-message-card{box-sizing:border-box;margin:16px auto;width:60%}.adf-message-card .mat-card-actions{border-top:1px solid var(--theme-status-bar-bg-color)}.adf-no-form-message-container{display:table;height:256px;width:100%}.adf-no-form-message-list{display:table-cell;text-align:center!important;vertical-align:middle}.adf-no-form-message{font-size:var(--theme-display-1-font-size);letter-spacing:-1.3px;line-height:36px;padding-bottom:10px}.adf-no-form-message,.adf-no-form-submessage{margin:auto;opacity:.54;width:-webkit-fit-content!important;width:-moz-fit-content!important;width:fit-content!important}.adf-no-form-submessage{font-size:var(--theme-subheading-2-font-size)}.adf-no-form-mat-card-actions.mat-card-actions{display:flex;justify-content:space-between}.adf-no-form-mat-card-actions.mat-card-actions .mat-button{border-radius:5px;text-transform:uppercase}.adf-no-form-mat-card-actions.mat-card-actions .mat-button-wrapper{font-size:var(--theme-button-font-size);font-weight:700;opacity:.54}"]
            },] }
];
TaskStandaloneComponent.ctorParameters = () => [];
TaskStandaloneComponent.propDecorators = {
    taskName: [{ type: Input }],
    taskId: [{ type: Input }],
    isCompleted: [{ type: Input }],
    hasCompletePermission: [{ type: Input }],
    hideCancelButton: [{ type: Input }],
    cancel: [{ type: Output }],
    complete: [{ type: Output }],
    showAttachForm: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AttachFormComponent {
    constructor(taskService, logService, formService) {
        this.taskService = taskService;
        this.logService = logService;
        this.formService = formService;
        this.cancelAttachForm = new EventEmitter();
        this.success = new EventEmitter();
        this.error = new EventEmitter();
        this.disableSubmit = true;
    }
    ngOnInit() {
        this.attachFormControl = new FormControl('', Validators.required);
        this.attachFormControl.valueChanges.subscribe((currentValue) => {
            if (this.attachFormControl.valid) {
                this.disableSubmit = this.formId === currentValue;
            }
        });
    }
    ngOnChanges() {
        this.formId = undefined;
        this.disableSubmit = true;
        this.loadFormsTask();
        if (this.formKey) {
            this.onFormAttached();
        }
    }
    onCancelButtonClick() {
        this.selectedFormId = this.formId;
        this.cancelAttachForm.emit();
    }
    onRemoveButtonClick() {
        this.taskService.deleteForm(this.taskId).subscribe(() => {
            this.formId = this.selectedFormId = null;
            this.success.emit();
        }, (err) => {
            this.error.emit(err);
            this.logService.error('An error occurred while trying to delete the form');
        });
    }
    onAttachFormButtonClick() {
        this.attachForm(this.taskId, this.selectedFormId);
    }
    loadFormsTask() {
        this.taskService.getFormList().subscribe((form) => {
            this.forms = form;
        }, (err) => {
            this.error.emit(err);
            this.logService.error('An error occurred while trying to get the forms');
        });
    }
    onFormAttached() {
        this.formService.getTaskForm(this.taskId)
            .subscribe((res) => {
            this.formService.getFormDefinitionByName(res.name).subscribe((formDef) => {
                this.formId = this.selectedFormId = formDef;
            });
        }, (err) => {
            this.error.emit(err);
            this.logService.error('Could not load forms');
        });
    }
    attachForm(taskId, formId) {
        if (taskId && formId) {
            this.taskService.attachFormToATask(taskId, formId)
                .subscribe(() => {
                this.success.emit();
            }, (err) => {
                this.error.emit(err);
                this.logService.error('Could not attach form');
            });
        }
    }
}
AttachFormComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-attach-form',
                template: "<div class=\"adf-attach-form\">\n    <mat-card>\n        <mat-card-content>\n            <div class=\"adf-attache-form-message-container\">\n                <mat-card-title class=\"mat-card-title\">\n                    <h4 class=\"adf-form-title\">{{ 'ADF_TASK_LIST.ATTACH_FORM.SELECT_FORM' | translate }}</h4>\n                </mat-card-title>\n                <div class=\"adf-attach-form-row\">\n                    <mat-form-field class=\"adf-grid-full-width\">\n                        <mat-select [formControl]=\"attachFormControl\" placeholder=\"{{ 'ADF_TASK_LIST.ATTACH_FORM.SELECT_OPTION' | translate }}\" id=\"form_id\" [(ngModel)]=\"selectedFormId\">\n                            <mat-option *ngFor=\"let form of forms\" [value]=\"form.id\">{{ form.name }}</mat-option>\n                        </mat-select>\n                    </mat-form-field>\n                </div>\n\n                <adf-form *ngIf=\"this.attachFormControl.valid\"\n                    [formId]=\"selectedFormId\"\n                    [readOnly]=\"true\"\n                    [showCompleteButton]=\"false\"\n                    [showRefreshButton]=\"false\"\n                    [showValidationIcon]=\"false\">\n                </adf-form>\n            </div>\n        </mat-card-content>\n\n        <mat-card-actions class=\"adf-attach-form-mat-card-actions\">\n            <div>\n                <button mat-button id=\"adf-attach-form-remove-button\" color=\"warn\" *ngIf=\"formKey\" (click)=\"onRemoveButtonClick()\">{{ 'ADF_TASK_LIST.ATTACH_FORM.REMOVE_FORM' | translate }}</button>\n            </div>\n            <div>\n                <button mat-button id=\"adf-attach-form-cancel-button\" (click)=\"onCancelButtonClick()\">{{ 'ADF_TASK_LIST.START_TASK.FORM.ACTION.CANCEL' | translate }}</button>\n                <button mat-button id=\"adf-attach-form-attach-button\" [disabled]=\"disableSubmit\" color=\"primary\" (click)=\"onAttachFormButtonClick()\">{{ 'ADF_TASK_LIST.START_TASK.FORM.LABEL.ATTACHFORM' | translate }}</button>\n            </div>\n        </mat-card-actions>\n    </mat-card>\n</div>\n",
                styles: [".adf-attach-form .mat-form-field{width:100%}.adf-attach-form-row{display:flex;justify-content:space-between;margin:20px 0}.adf-attach-form .adf-attach-form-mat-card-actions{justify-content:space-between;margin-top:30px;text-align:right}"]
            },] }
];
AttachFormComponent.ctorParameters = () => [
    { type: TaskListService },
    { type: LogService },
    { type: FormService }
];
AttachFormComponent.propDecorators = {
    taskId: [{ type: Input }],
    formKey: [{ type: Input }],
    cancelAttachForm: [{ type: Output }],
    success: [{ type: Output }],
    error: [{ type: Output }]
};

class ProcessUploadService extends UploadService {
    constructor(apiService, appConfigService, discoveryApiService) {
        super(apiService, appConfigService, discoveryApiService);
        this.apiService = apiService;
    }
    get contentApi() {
        var _a;
        this._contentApi = (_a = this._contentApi) !== null && _a !== void 0 ? _a : new ActivitiContentApi(this.apiService.getInstance());
        return this._contentApi;
    }
    getUploadPromise(file) {
        const opts = {
            isRelatedContent: true
        };
        const processInstanceId = file.options.parentId;
        const promise = this.contentApi.createRelatedContentOnProcessInstance(processInstanceId, file.file, opts);
        promise.catch((err) => this.handleError(err));
        return promise;
    }
    handleError(error) {
        return throwError(error || 'Server error');
    }
}
ProcessUploadService.ɵprov = ɵɵdefineInjectable({ factory: function ProcessUploadService_Factory() { return new ProcessUploadService(ɵɵinject(AlfrescoApiService), ɵɵinject(AppConfigService), ɵɵinject(DiscoveryApiService)); }, token: ProcessUploadService, providedIn: "root" });
ProcessUploadService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
ProcessUploadService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: AppConfigService },
    { type: DiscoveryApiService }
];

class TaskUploadService extends UploadService {
    constructor(apiService, appConfigService, discoveryApiService) {
        super(apiService, appConfigService, discoveryApiService);
        this.apiService = apiService;
    }
    get contentApi() {
        var _a;
        this._contentApi = (_a = this._contentApi) !== null && _a !== void 0 ? _a : new ActivitiContentApi(this.apiService.getInstance());
        return this._contentApi;
    }
    getUploadPromise(file) {
        const opts = {
            isRelatedContent: true
        };
        const taskId = file.options.parentId;
        const promise = this.contentApi.createRelatedContentOnTask(taskId, file.file, opts);
        promise.catch((err) => this.handleError(err));
        return promise;
    }
    handleError(error) {
        return throwError(error || 'Server error');
    }
}
TaskUploadService.ɵprov = ɵɵdefineInjectable({ factory: function TaskUploadService_Factory() { return new TaskUploadService(ɵɵinject(AlfrescoApiService), ɵɵinject(AppConfigService), ɵɵinject(DiscoveryApiService)); }, token: TaskUploadService, providedIn: "root" });
TaskUploadService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
TaskUploadService.ctorParameters = () => [
    { type: AlfrescoApiService },
    { type: AppConfigService },
    { type: DiscoveryApiService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class StartTaskModel {
    constructor(obj) {
        this.name = obj && obj.name || null;
        this.description = obj && obj.description || null;
        this.assignee = obj && obj.assignee ? new UserProcessModel(obj.assignee) : null;
        this.dueDate = obj && obj.dueDate || null;
        this.formKey = obj && obj.formKey || null;
        this.category = obj && obj.category || null;
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TaskDetailsEvent {
    constructor(value) {
        this._defaultPrevented = false;
        this._value = value;
    }
    get value() {
        return this._value;
    }
    get defaultPrevented() {
        return this._defaultPrevented;
    }
    preventDefault() {
        this._defaultPrevented = true;
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ɵ0$1 = { floatLabel: 'never' };
class MaterialModule {
}
MaterialModule.decorators = [
    { type: NgModule, args: [{
                providers: [
                    { provide: MAT_FORM_FIELD_DEFAULT_OPTIONS, useValue: ɵ0$1 }
                ],
                imports: [
                    MatAutocompleteModule, MatButtonModule, MatCardModule, MatDialogModule,
                    MatCheckboxModule, MatDatepickerModule, MatGridListModule, MatIconModule, MatInputModule,
                    MatListModule, MatOptionModule, MatRadioModule, MatSelectModule, MatSlideToggleModule, MatTableModule,
                    MatTabsModule, MatProgressSpinnerModule, MatNativeDateModule, MatRippleModule, MatTooltipModule,
                    MatChipsModule, MatMenuModule
                ],
                exports: [
                    MatAutocompleteModule, MatButtonModule, MatCardModule, MatDialogModule,
                    MatCheckboxModule, MatDatepickerModule, MatGridListModule, MatIconModule, MatInputModule,
                    MatListModule, MatOptionModule, MatRadioModule, MatSelectModule, MatSlideToggleModule, MatTableModule,
                    MatTabsModule, MatProgressSpinnerModule, MatNativeDateModule, MatRippleModule, MatTooltipModule,
                    MatChipsModule, MatMenuModule
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessCommentsComponent {
    constructor(commentProcessService) {
        this.commentProcessService = commentProcessService;
        this.readOnly = true;
        this.error = new EventEmitter();
        this.comments = [];
        this.onDestroy$ = new Subject();
        this.beingAdded = false;
        this.comment$ = new Observable(observer => this.commentObserver = observer).pipe(share());
        this.comment$
            .pipe(takeUntil(this.onDestroy$))
            .subscribe(comment => this.comments.push(comment));
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
    ngOnChanges(changes) {
        const processInstanceId = changes['processInstanceId'];
        if (processInstanceId) {
            if (processInstanceId.currentValue) {
                this.getProcessInstanceComments(processInstanceId.currentValue);
            }
            else {
                this.resetComments();
            }
        }
    }
    getProcessInstanceComments(processInstanceId) {
        this.resetComments();
        if (processInstanceId) {
            this.commentProcessService.getProcessInstanceComments(processInstanceId).subscribe((res) => {
                res = res.sort((comment1, comment2) => {
                    const date1 = new Date(comment1.created);
                    const date2 = new Date(comment2.created);
                    return date1 > date2 ? -1 : date1 < date2 ? 1 : 0;
                });
                res.forEach((comment) => {
                    this.commentObserver.next(comment);
                });
            }, (err) => {
                this.error.emit(err);
            });
        }
    }
    resetComments() {
        this.comments = [];
    }
    add() {
        if (this.message && this.message.trim() && !this.beingAdded) {
            this.beingAdded = true;
            this.commentProcessService.addProcessInstanceComment(this.processInstanceId, this.message)
                .subscribe((res) => {
                this.comments.unshift(res);
                this.message = '';
                this.beingAdded = false;
            }, (err) => {
                this.error.emit(err);
                this.beingAdded = false;
            });
        }
    }
    clear() {
        this.message = '';
    }
    isReadOnly() {
        return this.readOnly;
    }
    onError(error) {
        this.error.emit(error);
    }
}
ProcessCommentsComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-process-instance-comments',
                template: "<div class=\"adf-comments-container\">\n    <div id=\"comment-header\" class=\"adf-comments-header\">\n        {{'ADF_PROCESS_LIST.DETAILS.COMMENTS.HEADER' | translate: { count: comments?.length} }}\n    </div>\n    <div class=\"adf-comments-input-container\" *ngIf=\"!isReadOnly()\">\n        <mat-form-field class=\"adf-full-width\">\n            <input matInput id=\"comment-input\" placeholder=\"{{'ADF_PROCESS_LIST.DETAILS.COMMENTS.ADD' | translate}}\" [(ngModel)]=\"message\" (keyup.enter)=\"add()\" (keyup.esc)=\"clear()\">\n        </mat-form-field>\n    </div>\n\n    <div *ngIf=\"comments.length > 0\">\n        <adf-comment-list [comments]=\"comments\">\n        </adf-comment-list>\n    </div>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-process-instance-comments' },
                styles: [".adf-process-instance-comments{width:100%}.adf-activiti-label{font-weight:bolder;vertical-align:top}.adf-activiti-label+.adf-icon{position:relative;top:-2px}.adf-list-wrap{-o-hyphens:auto;-webkit-hyphens:auto;hyphens:auto;word-break:break-all;word-wrap:break-word}.adf-hide-long-names{overflow:auto}.adf-comments-container{height:100%;overflow:auto;width:100%}.adf-comments-header{border-bottom:1px solid var(--theme-fg-divider);font-size:14px;font-weight:600;padding:10px 20px}.adf-comments-input-container{border-bottom:1px solid var(--theme-fg-divider);padding:8px 15px 0;width:calc(100% - 30px)}.adf-full-width{width:100%}adf-comment-list{float:left;height:calc(100% - 101px);overflow:auto;width:100%}"]
            },] }
];
ProcessCommentsComponent.ctorParameters = () => [
    { type: CommentProcessService }
];
ProcessCommentsComponent.propDecorators = {
    processInstanceId: [{ type: Input }],
    readOnly: [{ type: Input }],
    error: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessCommentsModule {
}
ProcessCommentsModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    FormsModule,
                    ReactiveFormsModule,
                    MaterialModule,
                    CommonModule,
                    CoreModule
                ],
                declarations: [
                    ProcessCommentsComponent
                ],
                exports: [
                    ProcessCommentsComponent
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PeopleSearchComponent {
    constructor() {
        this.searchPeople = new EventEmitter();
        this.success = new EventEmitter();
        this.closeSearch = new EventEmitter();
        this.selectedUser = {};
    }
    ngOnInit() {
        this.filteredResults$ = this.results
            .pipe(map((users) => {
            return users.filter((user) => user.id !== this.selectedUser.id);
        }));
        this.performSearch = this.performSearchCallback.bind(this);
    }
    performSearchCallback(event) {
        this.searchPeople.emit(event);
        return this.filteredResults$;
    }
    onRowClick(user) {
        this.selectedUser = user;
    }
    closeSearchList() {
        this.closeSearch.emit();
    }
    involveUserAndClose() {
        this.involveUser();
        this.closeSearchList();
    }
    involveUser() {
        if (this.selectedUser === undefined) {
            return;
        }
        this.success.emit(this.selectedUser);
    }
}
PeopleSearchComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-people-search',
                template: "<div class=\"adf-search-text-header\">\n    <ng-content select=\"[adf-people-search-title], [people-search-title]\"></ng-content>\n</div>\n\n<adf-people-search-field [performSearch]=\"performSearch\" (rowClick)=\"onRowClick($event)\"></adf-people-search-field>\n\n<div class=\"search-list-action-container\">\n    <button mat-button type=\"button\" id=\"close-people-search\" (click)=\"closeSearchList()\">\n        {{'ADF_TASK_LIST.PEOPLE.DIALOG_CLOSE' | translate }}\n    </button>\n    <button mat-button type=\"button\" id=\"add-people\" (click)=\"involveUserAndClose()\">\n        <ng-content select=\"[adf-people-search-action-label], [people-search-action-label]\"></ng-content>\n    </button>\n</div>\n",
                host: {
                    'class': 'adf-people-search'
                },
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-people-search{width:100%}.adf-people-search .adf-activiti-label{font-weight:bolder}.adf-people-search .adf-fix-element-user-list{padding:0}.adf-people-search .adf-search-text-header{font-weight:700;opacity:.54}.adf-people-search .adf-search-list-action-container{border-top:1px solid #eee;margin-top:5px;padding:5px 0;text-align:right}.adf-people-search .adf-search-list-action-container>button{font-weight:bolder;opacity:.54}.adf-people-search .adf-search-list-action-container>button:hover{color:var(--theme-primary-color)}"]
            },] }
];
PeopleSearchComponent.ctorParameters = () => [];
PeopleSearchComponent.propDecorators = {
    results: [{ type: Input }],
    searchPeople: [{ type: Output }],
    success: [{ type: Output }],
    closeSearch: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PeopleComponent {
    constructor(logService, peopleProcessService) {
        this.logService = logService;
        this.peopleProcessService = peopleProcessService;
        this.people = [];
        this.taskId = '';
        this.readOnly = false;
        this.showAssignment = false;
        this.peopleSearch$ = new Observable((observer) => this.peopleSearchObserver = observer)
            .pipe(share());
    }
    involveUserAndCloseSearch() {
        if (this.peopleSearch) {
            this.peopleSearch.involveUserAndClose();
        }
    }
    involveUserWithoutCloseSearch() {
        if (this.peopleSearch) {
            this.peopleSearch.involveUser();
        }
    }
    searchUser(searchedWord) {
        this.peopleProcessService.getWorkflowUsers(this.taskId, searchedWord)
            .subscribe((users) => {
            this.peopleSearchObserver.next(users);
        }, (error) => this.logService.error(error));
    }
    involveUser(user) {
        if (user && user.id) {
            this.peopleProcessService
                .involveUserWithTask(this.taskId, user.id.toString())
                .subscribe(() => this.people = [...this.people, user], () => this.logService.error('Impossible to involve user with task'));
        }
    }
    removeInvolvedUser(user) {
        this.peopleProcessService
            .removeInvolvedUser(this.taskId, user.id.toString())
            .subscribe(() => {
            this.people = this.people.filter(involvedUser => involvedUser.id !== user.id);
        }, () => this.logService.error('Impossible to remove involved user from task'));
    }
    getDisplayUser(firstName, lastName, delimiter = '-') {
        firstName = (firstName !== null ? firstName : '');
        lastName = (lastName !== null ? lastName : '');
        return firstName + delimiter + lastName;
    }
    getInitialUserName(firstName, lastName) {
        firstName = (firstName !== null && firstName !== '' ? firstName[0] : '');
        lastName = (lastName !== null && lastName !== '' ? lastName[0] : '');
        return this.getDisplayUser(firstName, lastName, '');
    }
    onAddAssignment() {
        this.showAssignment = true;
    }
    onClickAction(event) {
        if (event && event.value && event.type === 'remove') {
            this.removeInvolvedUser(event.value);
        }
    }
    hasPeople() {
        return this.people && this.people.length > 0;
    }
    isEditMode() {
        return !this.readOnly;
    }
    onCloseSearch() {
        this.showAssignment = false;
    }
}
PeopleComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-people',
                template: "<mat-card class=\"adf-assignment-top-container\">\n    <div mat-card-content class=\"adf-assignment-top-container-content\">\n        <div class=\"assignment-header\">\n                <div *ngIf=\"hasPeople()\" class=\"adf-assignment-count\" id=\"people-title\">\n                    {{ 'ADF_TASK_LIST.DETAILS.LABELS.PEOPLE' | translate }} {{ ' (' + people.length + ')' }}\n                </div>\n                <div *ngIf=\"!hasPeople()\" class=\"adf-assignment-count\" id=\"no-people-label\">\n                    {{ 'ADF_TASK_LIST.DETAILS.PEOPLE.NONE' | translate }}\n                </div>\n                <div *ngIf=\"isEditMode()\" class=\"adf-add-people\" (click)=\"onAddAssignment()\">\n                    <mat-icon class=\"adf-add-person-icon\">person_add</mat-icon>\n                </div>\n            </div>\n            <div class=\"adf-assignment-container\" *ngIf=\"showAssignment\">\n                <adf-people-search\n                    #peopleSearch\n                    (searchPeople)=\"searchUser($event)\"\n                    (success)=\"involveUser($event)\"\n                    (closeSearch)=\"onCloseSearch()\"\n                    [results]=\"peopleSearch$\">\n                    <ng-container adf-people-search-title>{{ 'ADF_TASK_LIST.DETAILS.LABELS.ADD_PEOPLE' | translate }}</ng-container>\n                    <ng-container adf-people-search-action-label>{{ 'ADF_TASK_LIST.PEOPLE.ADD_USER' | translate }}</ng-container>\n                </adf-people-search>\n            </div>\n            <div class=\"adf-assignment-list-container\" id=\"assignment-people-list\" *ngIf=\"hasPeople()\">\n                <adf-people-list\n                [users]=\"people\"\n                [actions]=\"isEditMode()\"\n                (clickAction)=\"onClickAction($event)\">\n                    <data-columns>\n                        <data-column key=\"firstName\">\n                            <ng-template let-entry=\"$implicit\">\n                                <div *ngIf=\"!entry.row.obj.pictureId\" class=\"adf-people-search-people-pic\">\n                                    {{getInitialUserName(entry.row.obj.firstName, entry.row.obj.lastName)}}</div>\n                                <div>\n                                    <img [alt]=\"getDisplayUser(entry.row.obj.firstName, entry.row.obj.lastName, ' ')\" *ngIf=\"entry.row.obj.pictureId\" class=\"adf-people-img\"\n                                        [src]=\"peopleProcessService.getUserImage(entry.row.obj)\"/>\n                                </div>\n                            </ng-template>\n                        </data-column>\n                        <data-column key=\"email\" class=\"adf-full-width\">\n                            <ng-template let-entry=\"$implicit\">\n                                <div class=\"adf-people-user-info\">\n                                    <div [attr.data-automation-id]=\"'adf-people-full-name-'+ getDisplayUser(entry.row.obj.firstName, entry.row.obj.lastName, '-')\" class=\"adf-people-full-name\">{{ getDisplayUser(entry.row.obj.firstName, entry.row.obj.lastName, ' ') }}</div>\n                                    <div [attr.data-automation-id]=\"'adf-people-email-'+ getDisplayUser(entry.row.obj.firstName, entry.row.obj.lastName, '-')\"  class=\"adf-people-email\">{{ entry.row.obj.email }}</div>\n                                </div>\n                            </ng-template>\n                        </data-column>\n                    </data-columns>\n                </adf-people-list>\n            </div>\n    </div>\n</mat-card>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-assignment-header{border-bottom:1px solid var(--theme-fg-divider);padding:6px 20px}.adf-assignment-count{float:left;font-weight:bolder;margin:13px;opacity:.54;padding:10px 0}.adf-add-people{cursor:pointer;float:right;height:26px;margin:13px;opacity:.54;padding:8px}.adf-add-people:hover{color:var(--theme-primary-color)}.adf-assignment-top-container.mat-card{align-items:stretch;border-top:1px solid var(--theme-fg-divider);display:flex;flex-flow:row wrap;margin:0;padding:0}.adf-assignment-top-container-content{align-items:stretch;display:flex;flex:1 0 auto;flex-flow:column;max-width:100%}.adf-assignment-container{border-bottom:1px solid var(--theme-fg-divider);max-width:100%;padding:10px 20px}.adf-assignment-list-container{padding:0}adf-people-list adf-datatable thead{display:none}adf-people-list adf-datatable .adf-datatable-cell{margin:13px}adf-people-list adf-datatable .adf-datatable .adf-datatable-cell .adf-cell-container{align-items:left;flex-direction:column}adf-people-list adf-datatable .adf-people-email{opacity:.54}.adf-people-img{border-radius:90%;height:40px;vertical-align:middle;width:40px}.adf-people-search-people-pic{background:var(--theme-primary-color);border-radius:100px;color:#fff;font-size:18px;font-weight:bolder;padding:10px 5px;text-align:center;text-transform:uppercase;vertical-align:text-bottom;width:30px}.adf-people-user-info{flex-direction:column;text-align:center}"]
            },] }
];
PeopleComponent.ctorParameters = () => [
    { type: LogService },
    { type: PeopleProcessService }
];
PeopleComponent.propDecorators = {
    people: [{ type: Input }],
    taskId: [{ type: Input }],
    readOnly: [{ type: Input }],
    peopleSearch: [{ type: ViewChild, args: ['peopleSearch',] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PeopleListComponent {
    constructor() {
        this.actions = false;
        this.clickRow = new EventEmitter();
        this.clickAction = new EventEmitter();
        this.showHeader = ShowHeaderMode.Never;
    }
    ngAfterContentInit() {
        this.peopleDataTable.columnList = this.columnList;
    }
    selectUser(event) {
        this.user = event.value.obj;
        this.clickRow.emit(this.user);
    }
    hasActions() {
        return this.actions;
    }
    onShowRowActionsMenu(event) {
        const removeAction = {
            title: 'Remove',
            name: 'remove'
        };
        event.value.actions = [
            removeAction
        ];
    }
    onExecuteRowAction(event) {
        const args = event.value;
        const action = args.action;
        this.clickAction.emit({ type: action.name, value: args.row.obj });
    }
}
PeopleListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-people-list',
                template: "<adf-datatable\n    #dataTable\n    class=\"adf-task-people-list\"\n    [rows]=\"users\"\n    [actions]=\"hasActions()\"\n    [showHeader]=\"showHeader\"\n    (rowClick)=\"selectUser($event)\"\n    (rowDblClick)=\"selectUser($event)\"\n    (showRowActionsMenu)=\"onShowRowActionsMenu($event)\"\n    (executeRowAction)=\"onExecuteRowAction($event)\">\n</adf-datatable>\n",
                styles: [".adf-task-people-list .adf-datatable-list{width:100%}"]
            },] }
];
PeopleListComponent.propDecorators = {
    columnList: [{ type: ContentChild, args: [DataColumnListComponent,] }],
    peopleDataTable: [{ type: ViewChild, args: ['dataTable', { static: true },] }],
    users: [{ type: Input }],
    actions: [{ type: Input }],
    clickRow: [{ type: Output }],
    clickAction: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
function getDisplayUser(firstName, lastName, delimiter = '-') {
    firstName = (firstName !== null ? firstName : '');
    lastName = (lastName !== null ? lastName : '');
    return firstName + delimiter + lastName;
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PeopleSearchFieldComponent {
    constructor(peopleProcessService, translationService) {
        this.peopleProcessService = peopleProcessService;
        this.translationService = translationService;
        this.rowClick = new EventEmitter();
        this.searchUser = new FormControl();
        this.defaultPlaceholder = 'ADF_TASK_LIST.PEOPLE.SEARCH_USER';
        this.users$ = this.searchUser.valueChanges
            .pipe(debounceTime(200), switchMap((searchWord) => {
            if (searchWord && searchWord.trim()) {
                return this.performSearch(searchWord);
            }
            else {
                return of([]);
            }
        }));
        this.defaultPlaceholder = this.translationService.instant(this.defaultPlaceholder);
    }
    reset() {
        this.searchUser.reset();
    }
    get searchPlaceholder() {
        return this.placeholder || this.defaultPlaceholder;
    }
    onRowClick(model) {
        this.rowClick.emit(model);
    }
    getDisplayUser(firstName, lastName, delimiter = '-') {
        return getDisplayUser(firstName, lastName, delimiter);
    }
    getInitialUserName(firstName, lastName) {
        firstName = (firstName !== null && firstName !== '' ? firstName[0] : '');
        lastName = (lastName !== null && lastName !== '' ? lastName[0] : '');
        return this.getDisplayUser(firstName, lastName, '');
    }
}
PeopleSearchFieldComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-people-search-field',
                template: "<mat-form-field class=\"adf-search-text-container\">\n    <input\n        matInput\n        placeholder=\"{{ searchPlaceholder }}\"\n        type=\"text\"\n        id=\"userSearchText\"\n        [value]=\"\"\n        [formControl]=\"searchUser\"\n        data-automation-id=\"adf-people-search-input\">\n</mat-form-field>\n<ng-container *ngIf=\"users$ | async; let users\">\n    <div class=\"adf-search-list-container\" id=\"search-people-list\" *ngIf=\"users.length > 0\">\n        <adf-people-list [users]=\"users\" (clickRow)=\"onRowClick($event)\">\n            <data-columns>\n                <data-column key=\"firstName\">\n                    <ng-template let-entry=\"$implicit\">\n                            <div *ngIf=\"!entry.row.obj.pictureId\" class=\"adf-people-pic\">\n                                {{getInitialUserName(entry.row.obj.firstName, entry.row.obj.lastName)}}</div>\n                            <div>\n                                <img [alt]=\"getDisplayUser(entry.row.obj.firstName, entry.row.obj.lastName, ' ')\" *ngIf=\"entry.row.obj.pictureId\" class=\"adf-people-img\"\n                                    [src]=\"peopleProcessService.getUserImage(entry.row.obj)\"/>\n                            </div>\n                    </ng-template>\n                </data-column>\n                <data-column key=\"email\" class=\"adf-full-width\">\n                    <ng-template let-entry=\"$implicit\">\n                        <div [attr.data-automation-id]=\"'adf-people-full-name-'+ getDisplayUser(entry.row.obj.firstName, entry.row.obj.lastName, '-')\" class=\"adf-people-full-name\">{{ getDisplayUser(entry.row.obj.firstName, entry.row.obj.lastName, ' ') }}</div>\n                    </ng-template>\n                </data-column>\n            </data-columns>\n        </adf-people-list>\n    </div>\n</ng-container>\n",
                host: { 'class': 'adf-people-search-field' },
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-people-search-field,.adf-people-search-field .adf-search-text-container{width:100%}.adf-people-search-field .adf-search-text-container input{line-height:normal}.adf-people-search-field .adf-search-list-container{max-height:152px;overflow-y:auto;width:100%}.adf-people-search-field adf-people-list ::ng-deep adf-datatable ::ng-deep thead{display:none}.adf-people-search-field .adf-people-pic{background:var(--theme-primary-color);border-radius:90%;color:#fff;font-size:18px;font-weight:bolder;padding:10px 5px;text-align:center;text-transform:uppercase;vertical-align:text-bottom;width:30px}.adf-people-search-field .adf-people-img{border-radius:90%;height:40px;vertical-align:middle;width:40px}"]
            },] }
];
PeopleSearchFieldComponent.ctorParameters = () => [
    { type: PeopleProcessService },
    { type: TranslationService }
];
PeopleSearchFieldComponent.propDecorators = {
    performSearch: [{ type: Input }],
    placeholder: [{ type: Input }],
    rowClick: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const DEFAULT_ASSIGNEE_PLACEHOLDER = 'ADF_TASK_LIST.PEOPLE.ASSIGNEE';
class PeopleSelectorComponent {
    constructor(peopleProcessService, logService, translationService) {
        this.peopleProcessService = peopleProcessService;
        this.logService = logService;
        this.translationService = translationService;
        this.peopleIdChange = new EventEmitter();
        this.performSearch = this.searchUser.bind(this);
        this.defaultPlaceholder = this.translationService.instant(DEFAULT_ASSIGNEE_PLACEHOLDER);
    }
    searchUser(searchWord) {
        return this.peopleProcessService.getWorkflowUsers(undefined, searchWord)
            .pipe(catchError(this.onSearchUserError.bind(this)));
    }
    onSearchUserError() {
        this.logService.error('getWorkflowUsers threw error');
        return of([]);
    }
    userSelected(user) {
        this.updateUserSelection(user);
    }
    userDeselected() {
        this.updateUserSelection(undefined);
    }
    updateUserSelection(user) {
        this.selectedUser = user;
        this.peopleIdChange.emit(user && user.id || undefined);
        this.searchFieldComponent.reset();
    }
    get placeholder() {
        if (!this.selectedUser) {
            return this.defaultPlaceholder;
        }
        return getDisplayUser(this.selectedUser.firstName, this.selectedUser.lastName, ' ');
    }
}
PeopleSelectorComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-people-selector',
                template: "<adf-people-search-field\n    #peopleSearchField\n    class=\"adf-people-selector-field\"\n    [performSearch]=\"performSearch\"\n    [placeholder]=\"placeholder\"\n    (rowClick)=\"userSelected($event)\">\n</adf-people-search-field>\n<button\n    *ngIf=\"selectedUser\"\n    mat-icon-button\n    class=\"adf-people-selector-deselect\"\n    data-automation-id=\"adf-people-selector-deselect\"\n    (click)=\"userDeselected()\">\n        <mat-icon>cancel</mat-icon>\n</button>\n",
                host: { 'class': 'adf-people-selector' },
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-people-selector{display:flex;flex-flow:row;justify-content:space-between}.adf-people-selector-field{flex:1 1 auto}.adf-people-selector-deselect{flex:0 0 auto;right:5px;top:5px}"]
            },] }
];
PeopleSelectorComponent.ctorParameters = () => [
    { type: PeopleProcessService },
    { type: LogService },
    { type: TranslationService }
];
PeopleSelectorComponent.propDecorators = {
    peopleId: [{ type: Input }],
    peopleIdChange: [{ type: Output }],
    searchFieldComponent: [{ type: ViewChild, args: ['peopleSearchField', { static: true },] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PeopleSearchActionLabelDirective {
}
PeopleSearchActionLabelDirective.decorators = [
    { type: Directive, args: [{ selector: 'adf-people-search-action-label, people-search-action-label' },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PeopleSearchTitleDirective {
}
PeopleSearchTitleDirective.decorators = [
    { type: Directive, args: [{ selector: '[adf-people-search-title]' },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class PeopleModule {
}
PeopleModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    FormsModule,
                    ReactiveFormsModule,
                    MaterialModule,
                    CommonModule,
                    CoreModule
                ],
                declarations: [
                    PeopleComponent,
                    PeopleSearchComponent,
                    PeopleSearchFieldComponent,
                    PeopleSelectorComponent,
                    PeopleSearchTitleDirective,
                    PeopleSearchActionLabelDirective,
                    PeopleListComponent
                ],
                exports: [
                    PeopleComponent,
                    PeopleSearchComponent,
                    PeopleSearchFieldComponent,
                    PeopleSelectorComponent,
                    PeopleSearchTitleDirective,
                    PeopleSearchActionLabelDirective,
                    PeopleListComponent
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AttachFileWidgetDialogComponent {
    constructor(translation, data, externalApiService, authenticationService, matDialogRef) {
        this.translation = translation;
        this.data = data;
        this.externalApiService = externalApiService;
        this.authenticationService = authenticationService;
        this.matDialogRef = matDialogRef;
        externalApiService.init(data.ecmHost, data.context);
        this.action = data.actionName ? data.actionName.toUpperCase() : 'CHOOSE';
        this.buttonActionName = `ATTACH-FILE.ACTIONS.${this.action}`;
        this.updateTitle('DROPDOWN.MY_FILES_OPTION');
        this.updateExternalHost();
    }
    updateExternalHost() {
        this.authenticationService.onLogin.subscribe(() => this.registerAndClose());
        if (this.externalApiService.getInstance().isLoggedIn()) {
            this.registerAndClose();
        }
    }
    registerAndClose() {
        this.data.registerExternalHost(this.data.accountIdentifier, this.externalApiService);
        if (this.data.loginOnly) {
            this.data.selected.complete();
            this.matDialogRef.close();
        }
    }
    isLoggedIn() {
        return this.externalApiService.getInstance().isLoggedIn();
    }
    performLogin() {
        this.loginPanel.submitForm();
    }
    close() {
        this.data.selected.complete();
    }
    onSelect(nodeList) {
        this.chosenNode = nodeList;
    }
    onSiteChange(siteTitle) {
        this.updateTitle(siteTitle);
    }
    onClick() {
        this.data.selected.next(this.chosenNode);
        this.data.selected.complete();
    }
    updateTitle(siteTitle) {
        if (this.action === 'CHOOSE' && siteTitle) {
            this.title = this.getTitleTranslation(this.action, siteTitle);
        }
    }
    getTitleTranslation(action, name) {
        return this.translation.instant(`ATTACH-FILE.ACTIONS.${action}_ITEM`, { name: this.translation.instant(name) });
    }
    hasNodeSelected() {
        var _a;
        return ((_a = this.chosenNode) === null || _a === void 0 ? void 0 : _a.length) > 0;
    }
}
AttachFileWidgetDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-attach-file-widget-dialog',
                template: "<header\n    mat-dialog-title\n    data-automation-id=\"content-node-selector-title\">\n    <span *ngIf=\"isLoggedIn(); else loginTitle\">{{title}}</span>\n    <ng-template #loginTitle>{{data.title}}</ng-template>\n</header>\n\n<mat-dialog-content class=\"adf-login-dialog-content\">\n    <adf-login-dialog-panel id=\"attach-file-login-panel\" #adfLoginPanel *ngIf=\"!isLoggedIn()\">\n    </adf-login-dialog-panel>\n    <adf-content-node-selector-panel *ngIf=\"isLoggedIn()\"\n                                     id=\"attach-file-content-node\"\n                                     [currentFolderId]=\"data?.currentFolderId\"\n                                     [isSelectionValid]=\"data?.isSelectionValid\"\n                                     [showFilesInResult]=\"data?.showFilesInResult\"\n                                     (select)=\"onSelect($event)\"\n                                     (siteChange)=\"onSiteChange($event)\">\n    </adf-content-node-selector-panel>\n</mat-dialog-content>\n\n<mat-dialog-actions align=\"end\">\n    <button\n        mat-button\n        (click)=\"close()\"\n        data-automation-id=\"attach-file-dialog-actions-cancel\">{{ 'ATTACH-FILE.ACTIONS.CANCEL' | translate }}\n    </button>\n\n    <button *ngIf=\"!isLoggedIn()\"\n        mat-button\n        (click)=\"performLogin()\"\n        data-automation-id=\"attach-file-dialog-actions-login\">{{ 'ATTACH-FILE.ACTIONS.LOGIN' | translate }}\n    </button>\n\n    <button *ngIf=\"isLoggedIn()\"\n        mat-button\n        [disabled]=\"!hasNodeSelected()\"\n        class=\"adf-choose-action\"\n        (click)=\"onClick()\"\n        data-automation-id=\"attach-file-dialog-actions-choose\">{{ buttonActionName | translate }}\n    </button>\n\n</mat-dialog-actions>\n",
                encapsulation: ViewEncapsulation.None,
                providers: [
                    AuthenticationService,
                    DocumentListService,
                    SitesService,
                    SearchService,
                    { provide: AlfrescoApiService, useClass: ExternalAlfrescoApiService }
                ],
                styles: [".adf-attach-file-widget-dialog .mat-dialog-actions{background-color:var(--theme-background-color);color:var(--theme-foreground-text-color);display:flex;justify-content:flex-end}.adf-attach-file-widget-dialog .mat-dialog-actions button{font-weight:400;text-transform:uppercase}.adf-attach-file-widget-dialog .mat-dialog-actions .adf-choose-action[disabled]{color:var(--theme-secondary-text-color)}.adf-attach-file-widget-dialog .mat-dialog-actions .adf-choose-action:enabled{color:var(--theme-primary-color)}"]
            },] }
];
AttachFileWidgetDialogComponent.ctorParameters = () => [
    { type: TranslationService },
    { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] }] },
    { type: AlfrescoApiService },
    { type: AuthenticationService },
    { type: MatDialogRef }
];
AttachFileWidgetDialogComponent.propDecorators = {
    loginPanel: [{ type: ViewChild, args: ['adfLoginPanel',] }]
};

class AttachFileWidgetDialogService {
    constructor(dialog, translation) {
        this.dialog = dialog;
        this.translation = translation;
        this.externalApis = {};
        this.error = new EventEmitter();
    }
    openLogin(repository, currentFolderId = '-my-', accountIdentifier) {
        const { title, ecmHost, selected, registerExternalHost } = this.constructPayload(repository);
        const data = {
            title,
            selected,
            ecmHost,
            currentFolderId,
            isSelectionValid: (entry) => entry.isFile,
            showFilesInResult: true,
            registerExternalHost,
            accountIdentifier
        };
        this.openLoginDialog(data, 'adf-attach-file-widget-dialog', '630px');
        return selected;
    }
    openLoginDialog(data, currentPanelClass, chosenWidth) {
        this.dialog.open(AttachFileWidgetDialogComponent, { data, panelClass: currentPanelClass, width: chosenWidth });
    }
    showExternalHostLoginDialog(repository) {
        const data = Object.assign(Object.assign({}, this.constructPayload(repository)), { loginOnly: true });
        return this.dialog.open(AttachFileWidgetDialogComponent, { data, panelClass: 'adf-attach-file-widget-dialog', width: '630px' })
            .afterClosed();
    }
    downloadURL(repository, sourceId) {
        var _a;
        const { accountIdentifier } = this.constructPayload(repository);
        if ((_a = this.externalApis[accountIdentifier]) === null || _a === void 0 ? void 0 : _a.getInstance()) {
            const contentApi = new ContentApi(this.externalApis[accountIdentifier].getInstance());
            if (this.externalApis[accountIdentifier].getInstance().isLoggedIn()) {
                return of(contentApi.getContentUrl(sourceId));
            }
        }
        return this.showExternalHostLoginDialog(repository).pipe(switchMap(() => {
            const contentApi = new ContentApi(this.externalApis[accountIdentifier].getInstance());
            return of(contentApi.getContentUrl(sourceId));
        }));
    }
    constructPayload(repository) {
        const accountIdentifier = 'alfresco-' + repository.id + '-' + repository.name;
        const ecmHost = repository.repositoryUrl.replace('/alfresco', '');
        const selected = new Subject();
        selected.subscribe({
            complete: this.close.bind(this)
        });
        const title = this.getLoginTitleTranslation(ecmHost);
        const registerExternalHost = this.addService.bind(this);
        return { ecmHost, accountIdentifier, selected, title, registerExternalHost };
    }
    addService(accountIdentifier, apiService) {
        if (!this.externalApis[accountIdentifier]) {
            this.externalApis[accountIdentifier] = apiService;
        }
    }
    close() {
        this.dialog.closeAll();
    }
    getLoginTitleTranslation(ecmHost) {
        return this.translation.instant(`ATTACH-FILE.DIALOG.LOGIN`, { ecmHost });
    }
}
AttachFileWidgetDialogService.ɵprov = ɵɵdefineInjectable({ factory: function AttachFileWidgetDialogService_Factory() { return new AttachFileWidgetDialogService(ɵɵinject(MatDialog), ɵɵinject(TranslationService)); }, token: AttachFileWidgetDialogService, providedIn: "root" });
AttachFileWidgetDialogService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
AttachFileWidgetDialogService.ctorParameters = () => [
    { type: MatDialog },
    { type: TranslationService }
];
AttachFileWidgetDialogService.propDecorators = {
    error: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AttachFileWidgetComponent extends UploadWidgetComponent {
    constructor(formService, logger, thumbnails, processContentService, activitiContentService, contentService, contentDialog, appConfigService, downloadService, attachDialogService) {
        super(formService, logger, thumbnails, processContentService);
        this.formService = formService;
        this.logger = logger;
        this.thumbnails = thumbnails;
        this.processContentService = processContentService;
        this.activitiContentService = activitiContentService;
        this.contentService = contentService;
        this.contentDialog = contentDialog;
        this.appConfigService = appConfigService;
        this.downloadService = downloadService;
        this.attachDialogService = attachDialogService;
        this.typeId = 'AttachFileWidgetComponent';
        this.repositoryList = [];
        this.tempFilesList = [];
        this.onDestroy$ = new Subject();
    }
    ngOnInit() {
        super.ngOnInit();
        this.activitiContentService.getAlfrescoRepositories().subscribe((repoList) => {
            this.repositoryList = repoList;
        });
        this.formService.taskSaved
            .pipe(takeUntil(this.onDestroy$))
            .subscribe(formSaved => {
            if (formSaved.form.id === this.field.form.id) {
                this.tempFilesList = [];
            }
        });
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
    isFileSourceConfigured() {
        return !!this.field.params && !!this.field.params.fileSource;
    }
    isMultipleSourceUpload() {
        return !this.field.readOnly && this.isFileSourceConfigured() && !this.isOnlyLocalSourceSelected();
    }
    isAllFileSourceSelected() {
        return this.field.params &&
            this.field.params.fileSource &&
            this.field.params.fileSource.serviceId === 'all-file-sources' &&
            !this.field.params.link;
    }
    isOnlyLocalSourceSelected() {
        return this.field.params &&
            this.field.params.fileSource &&
            this.field.params.fileSource.serviceId === 'local-file';
    }
    isSimpleUploadButton() {
        return this.isUploadButtonVisible() &&
            !this.isFileSourceConfigured() ||
            this.isOnlyLocalSourceSelected();
    }
    isUploadButtonVisible() {
        return (!this.hasFile || this.multipleOption) && !this.field.readOnly;
    }
    isDefinedSourceFolder() {
        var _a, _b;
        return !!((_b = (_a = this.field.params) === null || _a === void 0 ? void 0 : _a.fileSource) === null || _b === void 0 ? void 0 : _b.selectedFolder);
    }
    isTemporaryFile(file) {
        return this.tempFilesList.findIndex((elem) => elem.name === file.name) >= 0;
    }
    getNodeFromTempFile(file) {
        return this.tempFilesList.find((elem) => elem.name === file.name);
    }
    openSelectDialogFromFileSource() {
        var _a, _b;
        const params = this.field.params;
        const repository = this.repositoryList.find((repo) => { var _a; return repo.name === ((_a = params === null || params === void 0 ? void 0 : params.fileSource) === null || _a === void 0 ? void 0 : _a.name); });
        if (repository && this.isExternalHost(repository)) {
            this.uploadFileFromExternalCS(repository, (_b = (_a = params === null || params === void 0 ? void 0 : params.fileSource) === null || _a === void 0 ? void 0 : _a.selectedFolder) === null || _b === void 0 ? void 0 : _b.pathId);
        }
        else {
            this.contentDialog.openFileBrowseDialogByFolderId(params.fileSource.selectedFolder.pathId).subscribe((selections) => {
                this.tempFilesList.push(...selections);
                this.uploadFileFromCS(selections, this.field.params.fileSource.selectedFolder.accountId, this.field.params.fileSource.selectedFolder.siteId);
            });
        }
    }
    onAttachFileChanged(event) {
        this.tempFilesList.push(...Array.from(event.target.files));
        this.onFileChanged(event);
    }
    onRemoveAttachFile(file) {
        if (this.isTemporaryFile(file)) {
            this.tempFilesList.splice(this.tempFilesList.indexOf(file.contentBlob), 1);
        }
        this.removeFile(file);
    }
    onAttachFileClicked(file) {
        if (file.isExternal || !file.contentAvailable) {
            this.logger.info(`The file ${file.name} comes from an external source and cannot be showed at this moment`);
            return;
        }
        if (this.isTemporaryFile(file)) {
            this.formService.formContentClicked.next(file);
        }
        else {
            this.fileClicked(file);
        }
    }
    downloadContent(file) {
        if (this.isTemporaryFile(file)) {
            const fileBlob = file.contentBlob;
            if (fileBlob) {
                this.downloadService.downloadBlob(fileBlob, file.name);
            }
            else {
                const nodeUploaded = this.getNodeFromTempFile(file);
                const nodeUrl = this.contentService.getContentUrl(nodeUploaded.id);
                this.downloadService.downloadUrl(nodeUrl, file.name);
            }
        }
        if (file.sourceId) {
            const sourceHost = this.findSource(file.source);
            if (sourceHost && this.isExternalHost(sourceHost)) {
                this.attachDialogService.downloadURL(sourceHost, file.sourceId).subscribe((nodeUrl) => {
                    this.downloadService.downloadUrl(nodeUrl, file.name);
                });
            }
            else {
                const nodeUrl = this.contentService.getContentUrl(file.sourceId);
                this.downloadService.downloadUrl(nodeUrl, file.name);
            }
        }
        else {
            this.processContentService.getFileRawContent(file.id).subscribe((blob) => {
                this.downloadService.downloadBlob(blob, file.name);
            }, () => {
                this.logger.error('Impossible retrieve content for download');
            });
        }
    }
    openSelectDialog(repository) {
        if (this.isExternalHost(repository)) {
            this.uploadFileFromExternalCS(repository);
        }
        else {
            this.contentDialog.openFileBrowseDialogByDefaultLocation().subscribe((selections) => {
                this.tempFilesList.push(...selections);
                this.uploadFileFromCS(selections, `alfresco-${repository.id}-${repository.name}`);
            });
        }
    }
    isExternalHost(repository) {
        const currentECMHost = this.getDomainHost(this.appConfigService.get(AppConfigValues.ECMHOST));
        const chosenRepositoryHost = this.getDomainHost(repository.repositoryUrl);
        return chosenRepositoryHost !== currentECMHost;
    }
    findSource(sourceIdentifier) {
        return this.repositoryList.find(repository => sourceIdentifier === `alfresco-${repository.id}-${repository.name}`);
    }
    uploadFileFromExternalCS(repository, currentFolderId) {
        const accountIdentifier = `alfresco-${repository.id}-${repository.name}`;
        this.attachDialogService.openLogin(repository, currentFolderId, accountIdentifier).subscribe((selections) => {
            selections.forEach((node) => node.isExternal = true);
            this.tempFilesList.push(...selections);
            this.uploadFileFromCS(selections, accountIdentifier);
        });
    }
    uploadFileFromCS(fileNodeList, accountId, siteId) {
        const filesSaved = [];
        fileNodeList.forEach(node => {
            node.isLink = this.field.params.link;
        });
        from(fileNodeList).pipe(mergeMap((node) => {
            var _a;
            return zip(of((_a = node === null || node === void 0 ? void 0 : node.content) === null || _a === void 0 ? void 0 : _a.mimeType), this.activitiContentService.applyAlfrescoNode(node, siteId, accountId), of(node.isExternal));
        }))
            .subscribe(([mimeType, res, isExternal]) => {
            res.mimeType = mimeType;
            res.isExternal = isExternal;
            filesSaved.push(res);
        }, (error) => {
            this.logger.error(error);
        }, () => {
            const previousFiles = this.field.value ? this.field.value : [];
            this.field.value = [...previousFiles, ...filesSaved];
            this.field.json.value = [...previousFiles, ...filesSaved];
            this.hasFile = true;
        });
    }
    getDomainHost(urlToCheck) {
        const result = urlToCheck.match('^(?:https?:\/\/)?(?:[^@\/\n]+@)?(?:www\.)?([^:\/?\n]+)');
        return result[1];
    }
}
AttachFileWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'attach-widget',
                template: "<div class=\"adf-attach-widget {{field.className}}\"\n    [class.adf-invalid]=\"!field.isValid\"\n    [class.adf-readonly]=\"field.readOnly\">\n    <label class=\"adf-label\" [attr.for]=\"field.id\">{{field.name | translate}}\n        <span *ngIf=\"isRequired()\">*</span>\n    </label>\n    <div class=\"adf-attach-widget-container\">\n        <div id=\"adf-attach-widget-simple-upload\" *ngIf=\"isSimpleUploadButton() && isUploadButtonVisible()\">\n            <a mat-raised-button color=\"primary\">\n                {{ 'FORM.FIELD.UPLOAD' | translate }}\n                <mat-icon>file_upload</mat-icon>\n                <input #uploadFiles\n                        [multiple]=\"multipleOption\"\n                        type=\"file\"\n                        [id]=\"field.id\"\n                        (change)=\"onAttachFileChanged($event)\" />\n            </a>\n        </div>\n        <div class=\"adf-attach-widget__menu-upload\" *ngIf=\"isUploadButtonVisible() && isMultipleSourceUpload()\">\n            <button mat-raised-button color=\"primary\" [matMenuTriggerFor]=\"menu\" [id]=\"field.id\">\n                    {{ 'FORM.FIELD.UPLOAD' | translate }}\n                    <mat-icon>attach_file</mat-icon>\n            </button>\n            <mat-menu #menu=\"matMenu\" class=\"adf-attach-widget__menu-content\">\n                <button mat-menu-item (click)=\"uploadFile.click()\"\n                        id=\"attach-local-file\"\n                        *ngIf=\"isAllFileSourceSelected()\">\n                    {{ 'FORM.FIELD.LOCALSTORAGE' | translate }}\n                    <mat-icon>file_upload</mat-icon>\n                    <input #uploadFile\n                            class=\"adf-attach-widget__input-type\"\n                            [multiple]=\"multipleOption\"\n                            type=\"file\"\n                            [id]=\"field.id\"\n                            (change)=\"onAttachFileChanged($event)\" />\n                </button>\n                <button mat-menu-item\n                        *ngIf=\"isDefinedSourceFolder()\"\n                        id=\"attach-{{field.params?.fileSource?.name}}\"\n                        (click)=\"openSelectDialogFromFileSource()\">\n                        {{field.params?.fileSource?.name}}\n                        <mat-icon>\n                            <img alt=\"alfresco\" class=\"adf-attach-widget__image-logo\" src=\"../assets/images/alfresco-flower.svg\">\n                        </mat-icon>\n                </button>\n                <div *ngIf=\"!isDefinedSourceFolder()\">\n                    <button mat-menu-item *ngFor=\"let repo of repositoryList\"\n                            id=\"attach-{{repo?.name}}\"\n                           (click)=\"openSelectDialog(repo)\">\n                            {{repo.name}}\n                            <mat-icon>\n                                <img alt=\"alfresco\" class=\"adf-attach-widget__image-logo\" src=\"../assets/images/alfresco-flower.svg\">\n                            </mat-icon>\n                    </button>\n                </div>\n            </mat-menu>\n        </div>\n    </div>\n</div>\n\n<div id=\"adf-attach-widget-readonly-list\">\n    <mat-list *ngIf=\"hasFile\">\n        <mat-list-item class=\"adf-attach-files-row\" *ngFor=\"let file of field.value\">\n            <img mat-list-icon class=\"adf-attach-widget__icon\"\n                 [id]=\"'file-'+file.id+'-icon'\"\n                 [src]=\"file.content ? getIcon(file.content.mimeType) : getIcon(file.mimeType)\"\n                 [alt]=\"mimeTypeIcon\"\n                 (click)=\"onAttachFileClicked(file)\"\n                 (keyup.enter)=\"onAttachFileClicked(file)\"\n                 role=\"button\"\n                 tabindex=\"0\"/>\n            <span matLine id=\"{{'file-'+file.id}}\" (click)=\"onAttachFileClicked(file)\" (keyup.enter)=\"onAttachFileClicked(file)\"\n                  role=\"button\" tabindex=\"0\" class=\"adf-file\">{{file.name}}</span>\n            <button id=\"{{'file-'+file.id+'-option-menu'}}\" mat-icon-button [matMenuTriggerFor]=\"fileActionMenu\">\n                <mat-icon>more_vert</mat-icon>\n            </button>\n            <mat-menu #fileActionMenu=\"matMenu\" xPosition=\"before\">\n                <button id=\"{{'file-'+file.id+'-show-file'}}\"\n                    [disabled]=\"file.isExternal || !file.contentAvailable || !file.mimeType\"\n                    mat-menu-item (click)=\"onAttachFileClicked(file)\">\n                    <mat-icon>visibility</mat-icon>\n                    <span>{{ 'FORM.FIELD.VIEW_FILE' | translate }}</span>\n                </button>\n                <button id=\"{{'file-'+file.id+'-download-file'}}\"\n                    [disabled]=\"file.isExternal || !file.mimeType\"\n                    mat-menu-item (click)=\"downloadContent(file)\">\n                    <mat-icon>file_download</mat-icon>\n                    <span>{{ 'FORM.FIELD.DOWNLOAD_FILE' | translate }}</span>\n                </button>\n                <button *ngIf=\"!field.readOnly\" id=\"{{'file-'+file.id+'-remove-file'}}\"\n                        mat-menu-item [id]=\"'file-'+file.id+'-remove'\"\n                        (click)=\"onRemoveAttachFile(file);\" (keyup.enter)=\"onRemoveAttachFile(file);\">\n                    <mat-icon class=\"mat-24\">highlight_off</mat-icon>\n                    <span>{{ 'FORM.FIELD.REMOVE_FILE' | translate }}</span>\n                </button>\n            </mat-menu>\n        </mat-list-item>\n    </mat-list>\n</div>\n\n<error-widget [error]=\"field.validationSummary\"></error-widget>\n<error-widget *ngIf=\"isInvalidFieldRequired()\" required=\"{{ 'FORM.FIELD.REQUIRED' | translate }}\"></error-widget>\n",
                host: {
                    '(click)': 'event($event)',
                    '(blur)': 'event($event)',
                    '(change)': 'event($event)',
                    '(focus)': 'event($event)',
                    '(focusin)': 'event($event)',
                    '(focusout)': 'event($event)',
                    '(input)': 'event($event)',
                    '(invalid)': 'event($event)',
                    '(select)': 'event($event)'
                },
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-attach-widget-container{align-items:center;display:flex;margin-bottom:15px}.adf-attach-widget-container input{cursor:pointer;height:100%;opacity:0;position:absolute;right:0;top:0;width:300px;z-index:4}.adf-attach-widget__menu-upload{align-items:center;display:flex}.adf-attach-widget__input-type{height:.1px;opacity:0;overflow:hidden;position:absolute;width:.1px;z-index:-1}.adf-attach-widget__image-logo{padding-left:5px}.adf-attach-widget-repo-button{padding-left:10px}.adf-attach-widget-repo-button .mat-button-wrapper{display:inline}.adf-attach-widget-repo-button .mat-mini-fab.mat-accent{background-color:inherit}.adf-attach-widget{border-top:.84375em solid transparent;padding:.4375em 0;width:100%;word-break:break-all}.adf-attach-widget__icon{cursor:pointer;float:left;padding:6px}.adf-attach-widget__reset{margin-top:-2px}.adf-attach-files-row .mat-line{margin-bottom:0}"]
            },] }
];
AttachFileWidgetComponent.ctorParameters = () => [
    { type: FormService },
    { type: LogService },
    { type: ThumbnailService },
    { type: ProcessContentService },
    { type: ActivitiContentService },
    { type: ContentService },
    { type: ContentNodeDialogService },
    { type: AppConfigService },
    { type: DownloadService },
    { type: AttachFileWidgetDialogService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AttachFolderWidgetComponent extends WidgetComponent {
    constructor(contentDialog, formService, nodeService) {
        super();
        this.contentDialog = contentDialog;
        this.formService = formService;
        this.nodeService = nodeService;
        this.typeId = 'AttachFolderWidgetComponent';
        this.hasFolder = false;
        this.selectedFolderName = '';
    }
    ngOnInit() {
        if (this.field &&
            this.field.value) {
            this.hasFolder = true;
            this.nodeService.getNode(this.field.value).subscribe((node) => {
                this.selectedFolderName = node.name;
            });
        }
    }
    isDefinedSourceFolder() {
        return !!this.field.params &&
            !!this.field.params.folderSource &&
            !!this.field.params.folderSource.selectedFolder;
    }
    openSelectDialogFromFileSource() {
        const params = this.field.params;
        if (this.isDefinedSourceFolder()) {
            this.contentDialog.openFolderBrowseDialogByFolderId(params.folderSource.selectedFolder.pathId).subscribe((selections) => {
                this.selectedFolderName = selections[0].name;
                this.field.value = selections[0].id;
                this.hasFolder = true;
            });
        }
        else {
            this.contentDialog.openFolderBrowseDialogBySite().subscribe((selections) => {
                this.selectedFolderName = selections[0].name;
                this.field.value = selections[0].id;
                this.hasFolder = true;
            });
        }
    }
    removeFolder() {
        this.field.value = null;
        this.selectedFolderName = '';
        this.hasFolder = false;
    }
}
AttachFolderWidgetComponent.decorators = [
    { type: Component, args: [{
                selector: 'attach-folder-widget',
                template: "<div class=\"adf-attach-folder-widget {{field.className}}\"\n     [class.adf-invalid]=\"!field.isValid\"\n     [class.adf-readonly]=\"field.readOnly\">\n    <label class=\"adf-label\" [attr.for]=\"field.id\">{{field.name | translate}}<span *ngIf=\"isRequired()\">*</span></label>\n    <div class=\"adf-attach-folder-widget-container\">\n        <div *ngIf=\"hasFolder\" class=\"adf-attach-folder-result\">\n            <mat-icon>folder</mat-icon>\n            <div class=\"adf-attach-folder-files-row\">\n                <span matLine id=\"{{'folder-'+field?.id}}\"\n                        role=\"button\" tabindex=\"0\" class=\"adf-folder\">{{selectedFolderName}}</span>\n                <button *ngIf=\"!field.readOnly\" mat-icon-button [id]=\"'folder-'+field?.id+'-remove'\"\n                        (click)=\"removeFolder();\">\n                    <mat-icon class=\"mat-24\">highlight_off</mat-icon>\n                </button>\n            </div>\n        </div>\n\n        <div *ngIf=\"!hasFolder && !field.readOnly\">\n            <button mat-raised-button\n                color=\"primary\"\n                (click)=\"openSelectDialogFromFileSource()\"\n                [id]=\"'folder-'+field?.id+'-button'\">\n                    {{ 'FORM.FIELD.UPLOAD' | translate }}\n                <mat-icon>cloud_upload</mat-icon>\n            </button>\n        </div>\n    </div>\n    <error-widget [error]=\"field.validationSummary\"></error-widget>\n    <error-widget *ngIf=\"isInvalidFieldRequired()\" required=\"{{ 'FORM.FIELD.REQUIRED' | translate }}\"></error-widget>\n</div>\n",
                host: {
                    '(click)': 'event($event)',
                    '(blur)': 'event($event)',
                    '(change)': 'event($event)',
                    '(focus)': 'event($event)',
                    '(focusin)': 'event($event)',
                    '(focusout)': 'event($event)',
                    '(input)': 'event($event)',
                    '(invalid)': 'event($event)',
                    '(select)': 'event($event)'
                },
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-attach-folder-widget-container{align-items:center;display:flex;margin-bottom:15px}.adf-attach-folder-widget-container input{cursor:pointer;height:100%;opacity:0;position:absolute;right:0;top:0;width:300px;z-index:4}.adf-attach-folder-widget{border-top:.84375em solid transparent;padding:.4375em 0;width:100%;word-break:break-all}.adf-attach-folder-files-row{padding-left:8px}.adf-attach-folder-files-row .mat-line{margin-bottom:0}.adf-attach-folder-result{align-items:center;display:flex}"]
            },] }
];
AttachFolderWidgetComponent.ctorParameters = () => [
    { type: ContentNodeDialogService },
    { type: FormService },
    { type: NodesApiService }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ContentWidgetModule {
}
ContentWidgetModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CoreModule,
                    ContentNodeSelectorModule,
                    MaterialModule
                ],
                declarations: [
                    AttachFileWidgetComponent,
                    AttachFolderWidgetComponent,
                    AttachFileWidgetDialogComponent
                ],
                exports: [
                    AttachFileWidgetComponent,
                    AttachFolderWidgetComponent,
                    AttachFileWidgetDialogComponent
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FormComponent extends FormBaseComponent {
    constructor(formService, visibilityService, ecmModelService, nodeService) {
        super();
        this.formService = formService;
        this.visibilityService = visibilityService;
        this.ecmModelService = ecmModelService;
        this.nodeService = nodeService;
        this.saveMetadata = false;
        this.enableFixedSpacedForm = true;
        this.formSaved = new EventEmitter();
        this.formCompleted = new EventEmitter();
        this.formContentClicked = new EventEmitter();
        this.formLoaded = new EventEmitter();
        this.formDataRefreshed = new EventEmitter();
        this.debugMode = false;
        this.onDestroy$ = new Subject();
    }
    ngOnInit() {
        this.formService.formContentClicked
            .pipe(takeUntil(this.onDestroy$))
            .subscribe(content => this.formContentClicked.emit(content));
        this.formService.validateForm
            .pipe(takeUntil(this.onDestroy$))
            .subscribe(validateFormEvent => {
            if (validateFormEvent.errorsField.length > 0) {
                this.formError.next(validateFormEvent.errorsField);
            }
        });
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
    ngOnChanges(changes) {
        const taskId = changes['taskId'];
        if (taskId && taskId.currentValue) {
            this.getFormByTaskId(taskId.currentValue);
            return;
        }
        const formId = changes['formId'];
        if (formId && formId.currentValue) {
            this.getFormDefinitionByFormId(formId.currentValue);
            return;
        }
        const formName = changes['formName'];
        if (formName && formName.currentValue) {
            this.getFormDefinitionByFormName(formName.currentValue);
            return;
        }
        const nodeId = changes['nodeId'];
        if (nodeId && nodeId.currentValue) {
            this.loadFormForEcmNode(nodeId.currentValue);
            return;
        }
        const data = changes['data'];
        if (data && data.currentValue) {
            this.refreshFormData();
            return;
        }
    }
    onRefreshClicked() {
        this.loadForm();
    }
    loadForm() {
        if (this.taskId) {
            this.getFormByTaskId(this.taskId);
            return;
        }
        if (this.formId) {
            this.getFormDefinitionByFormId(this.formId);
            return;
        }
        if (this.formName) {
            this.getFormDefinitionByFormName(this.formName);
            return;
        }
    }
    findProcessVariablesByTaskId(taskId) {
        return this.formService.getTask(taskId).pipe(switchMap((task) => {
            if (this.isAProcessTask(task)) {
                return this.visibilityService.getTaskProcessVariable(taskId);
            }
            else {
                return of({});
            }
        }));
    }
    isAProcessTask(taskRepresentation) {
        return taskRepresentation.processDefinitionId && taskRepresentation.processDefinitionDeploymentId !== 'null';
    }
    getFormByTaskId(taskId) {
        return new Promise(resolve => {
            this.findProcessVariablesByTaskId(taskId).subscribe(() => {
                this.formService
                    .getTaskForm(taskId)
                    .subscribe((form) => {
                    const parsedForm = this.parseForm(form);
                    this.visibilityService.refreshVisibility(parsedForm);
                    parsedForm.validateForm();
                    this.form = parsedForm;
                    this.onFormLoaded(this.form);
                    resolve(this.form);
                }, (error) => {
                    this.handleError(error);
                    resolve(null);
                });
            });
        });
    }
    getFormDefinitionByFormId(formId) {
        this.formService
            .getFormDefinitionById(formId)
            .subscribe((form) => {
            this.formName = form.name;
            this.form = this.parseForm(form);
            this.visibilityService.refreshVisibility(this.form);
            this.form.validateForm();
            this.onFormLoaded(this.form);
        }, (error) => {
            this.handleError(error);
        });
    }
    getFormDefinitionByFormName(formName) {
        this.formService
            .getFormDefinitionByName(formName)
            .subscribe((id) => {
            this.formService.getFormDefinitionById(id).subscribe((form) => {
                this.form = this.parseForm(form);
                this.visibilityService.refreshVisibility(this.form);
                this.form.validateForm();
                this.onFormLoaded(this.form);
            }, (error) => {
                this.handleError(error);
            });
        }, (error) => {
            this.handleError(error);
        });
    }
    saveTaskForm() {
        if (this.form && this.form.taskId) {
            this.formService
                .saveTaskForm(this.form.taskId, this.form.values)
                .subscribe(() => {
                this.onTaskSaved(this.form);
                this.storeFormAsMetadata();
            }, (error) => this.onTaskSavedError(this.form, error));
        }
    }
    completeTaskForm(outcome) {
        if (this.form && this.form.taskId) {
            this.formService
                .completeTaskForm(this.form.taskId, this.form.values, outcome)
                .subscribe(() => {
                this.onTaskCompleted(this.form);
                this.storeFormAsMetadata();
            }, (error) => this.onTaskCompletedError(this.form, error));
        }
    }
    handleError(err) {
        this.error.emit(err);
    }
    parseForm(formRepresentationJSON) {
        if (formRepresentationJSON) {
            const form = new FormModel(formRepresentationJSON, this.data, this.readOnly, this.formService, this.enableFixedSpacedForm);
            if (!formRepresentationJSON.fields) {
                form.outcomes = this.getFormDefinitionOutcomes(form);
            }
            if (this.fieldValidators && this.fieldValidators.length > 0) {
                form.fieldValidators = this.fieldValidators;
            }
            return form;
        }
        return null;
    }
    getFormDefinitionOutcomes(form) {
        return [
            new FormOutcomeModel(form, { id: '$save', name: FormOutcomeModel.SAVE_ACTION, isSystem: true })
        ];
    }
    checkVisibility(field) {
        if (field && field.form) {
            this.visibilityService.refreshVisibility(field.form);
        }
    }
    refreshFormData() {
        this.form = this.parseForm(this.form.json);
        this.onFormLoaded(this.form);
        this.onFormDataRefreshed(this.form);
    }
    loadFormForEcmNode(nodeId) {
        this.nodeService.getNodeMetadata(nodeId).subscribe((data) => {
            this.data = data.metadata;
            this.loadFormFromActiviti(data.nodeType);
        }, this.handleError);
    }
    loadFormFromActiviti(nodeType) {
        this.formService.searchFrom(nodeType).subscribe((form) => {
            if (!form) {
                this.formService.createFormFromANode(nodeType).subscribe((formMetadata) => {
                    this.loadFormFromFormId(formMetadata.id);
                });
            }
            else {
                this.loadFormFromFormId(form.id);
            }
        }, (error) => {
            this.handleError(error);
        });
    }
    loadFormFromFormId(formId) {
        this.formId = formId;
        this.loadForm();
    }
    storeFormAsMetadata() {
        if (this.saveMetadata) {
            this.ecmModelService.createEcmTypeForActivitiForm(this.formName, this.form).subscribe((type) => {
                this.nodeService.createNodeMetadata(type.nodeType || type.entry.prefixedName, EcmModelService.MODEL_NAMESPACE, this.form.values, this.path, this.nameNode);
            }, (error) => {
                this.handleError(error);
            });
        }
    }
    onFormLoaded(form) {
        this.formLoaded.emit(form);
        this.formService.formLoaded.next(new FormEvent(form));
    }
    onFormDataRefreshed(form) {
        this.formDataRefreshed.emit(form);
        this.formService.formDataRefreshed.next(new FormEvent(form));
    }
    onTaskSaved(form) {
        this.formSaved.emit(form);
        this.formService.taskSaved.next(new FormEvent(form));
    }
    onTaskSavedError(form, error) {
        this.handleError(error);
        this.formService.taskSavedError.next(new FormErrorEvent(form, error));
    }
    onTaskCompleted(form) {
        this.formCompleted.emit(form);
        this.formService.taskCompleted.next(new FormEvent(form));
    }
    onTaskCompletedError(form, error) {
        this.handleError(error);
        this.formService.taskCompletedError.next(new FormErrorEvent(form, error));
    }
    onExecuteOutcome(outcome) {
        const args = new FormOutcomeEvent(outcome);
        this.formService.executeOutcome.next(args);
        if (args.defaultPrevented) {
            return false;
        }
        this.executeOutcome.emit(args);
        return !args.defaultPrevented;
    }
}
FormComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-form',
                template: "<div *ngIf=\"!hasForm()\">\n    <ng-content select=\"[empty-form]\">\n    </ng-content>\n</div>\n\n<div *ngIf=\"hasForm()\" class=\"adf-form-container\">\n    <mat-card>\n        <mat-card-header>\n            <mat-card-title>\n                <h4>\n                    <div *ngIf=\"showValidationIcon\" class=\"adf-form-validation-button\">\n                        <i id=\"adf-valid-form-icon\" class=\"material-icons\"\n                            *ngIf=\"form.isValid; else no_valid_form\">check_circle</i>\n                        <ng-template #no_valid_form>\n                            <i id=\"adf-invalid-form-icon\" class=\"material-icons adf-invalid-color\">error</i>\n                        </ng-template>\n                    </div>\n                    <div *ngIf=\"showRefreshButton\" class=\"adf-form-reload-button\">\n                        <button mat-icon-button (click)=\"onRefreshClicked()\">\n                            <mat-icon>refresh</mat-icon>\n                        </button>\n                    </div>\n                    <span *ngIf=\"isTitleEnabled()\" class=\"adf-form-title\" [matTooltip]=\"form.taskName\">\n                        {{form.taskName}}\n                        <ng-container *ngIf=\"!form.taskName\">\n                            {{'FORM.FORM_RENDERER.NAMELESS_TASK' | translate}}\n                        </ng-container>\n                    </span>\n                </h4>\n            </mat-card-title>\n        </mat-card-header>\n        <mat-card-content>\n            <adf-form-renderer [formDefinition]=\"form\">\n            </adf-form-renderer>\n        </mat-card-content>\n        <mat-card-actions *ngIf=\"form.hasOutcomes()\" class=\"adf-form-mat-card-actions\">\n            <ng-content select=\"adf-form-custom-outcomes\"></ng-content>\n            <button [id]=\"'adf-form-'+ outcome.name  | formatSpace\" *ngFor=\"let outcome of form.outcomes\"\n                [color]=\"getColorForOutcome(outcome.name)\" mat-button [disabled]=\"!isOutcomeButtonEnabled(outcome)\"\n                [class.adf-form-hide-button]=\"!isOutcomeButtonVisible(outcome, form.readOnly)\"\n                (click)=\"onOutcomeClicked(outcome)\">\n                {{outcome.name | translate | uppercase }}\n            </button>\n        </mat-card-actions>\n    </mat-card>\n</div>\n",
                encapsulation: ViewEncapsulation.None
            },] }
];
FormComponent.ctorParameters = () => [
    { type: FormService },
    { type: WidgetVisibilityService },
    { type: EcmModelService },
    { type: NodeService }
];
FormComponent.propDecorators = {
    form: [{ type: Input }],
    taskId: [{ type: Input }],
    nodeId: [{ type: Input }],
    formId: [{ type: Input }],
    formName: [{ type: Input }],
    saveMetadata: [{ type: Input }],
    data: [{ type: Input }],
    enableFixedSpacedForm: [{ type: Input }],
    formSaved: [{ type: Output }],
    formCompleted: [{ type: Output }],
    formContentClicked: [{ type: Output }],
    formLoaded: [{ type: Output }],
    formDataRefreshed: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class StartFormComponent extends FormComponent {
    constructor(formService, visibilityService) {
        super(formService, visibilityService, null, null);
        this.showOutcomeButtons = true;
        this.showRefreshButton = true;
        this.readOnlyForm = false;
        this.outcomeClick = new EventEmitter();
        this.formContentClicked = new EventEmitter();
        this.outcomesContainer = null;
        this.showTitle = false;
    }
    ngOnChanges(changes) {
        const processDefinitionId = changes['processDefinitionId'];
        if (processDefinitionId && processDefinitionId.currentValue) {
            this.processDefinitionId = processDefinitionId.currentValue;
            this.visibilityService.cleanProcessVariable();
            this.getStartFormDefinition(this.processDefinitionId);
            return;
        }
        const data = changes['data'];
        if (data && data.currentValue) {
            this.parseRefreshVisibilityValidateForm(this.form.json);
            return;
        }
        const processId = changes['processId'];
        if (processId && processId.currentValue) {
            this.visibilityService.cleanProcessVariable();
            this.loadStartForm(processId.currentValue);
            return;
        }
    }
    loadStartForm(processId) {
        this.formService.getProcessInstance(processId)
            .subscribe((instance) => {
            this.formService
                .getStartFormInstance(processId)
                .subscribe((form) => {
                this.formName = form.name;
                if (instance.variables) {
                    form.processVariables = instance.variables;
                }
                this.parseRefreshVisibilityValidateForm(form);
            }, (error) => this.handleError(error));
        });
    }
    getStartFormDefinition(processId) {
        this.formService
            .getStartFormDefinition(processId)
            .subscribe((form) => {
            this.formName = form.processDefinitionName;
            this.parseRefreshVisibilityValidateForm(form);
        }, (error) => this.handleError(error));
    }
    parseRefreshVisibilityValidateForm(form) {
        this.form = this.parseForm(form);
        this.visibilityService.refreshVisibility(this.form);
        this.form.validateForm();
        this.form.readOnly = this.readOnlyForm;
        this.onFormLoaded(this.form);
    }
    isOutcomeButtonVisible(outcome, isFormReadOnly) {
        if (outcome && outcome.isSystem && (outcome.name === FormOutcomeModel.SAVE_ACTION ||
            outcome.name === FormOutcomeModel.COMPLETE_ACTION)) {
            return false;
        }
        else if (outcome && outcome.name === FormOutcomeModel.START_PROCESS_ACTION) {
            return true;
        }
        return super.isOutcomeButtonVisible(outcome, isFormReadOnly);
    }
    saveTaskForm() {
    }
    onRefreshClicked() {
        if (this.processDefinitionId) {
            this.visibilityService.cleanProcessVariable();
            this.getStartFormDefinition(this.processDefinitionId);
        }
        else if (this.processId) {
            this.visibilityService.cleanProcessVariable();
            this.loadStartForm(this.processId);
        }
    }
    completeTaskForm(outcome) {
        this.outcomeClick.emit(outcome);
    }
}
StartFormComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-start-form',
                template: "<div class=\"adf-start-form-container\" *ngIf=\"hasForm()\">\n    <mat-card>\n        <mat-card-header>\n            <mat-card-title>\n                <h2 *ngIf=\"isTitleEnabled()\" class=\"mdl-card__title-text\">{{form.taskName}}</h2>\n            </mat-card-title>\n        </mat-card-header>\n        <mat-card-content>\n            <div *ngIf=\"form.hasTabs()\">\n                <tabs-widget [tabs]=\"form.tabs\" (formTabChanged)=\"checkVisibility($event);\"></tabs-widget>\n            </div>\n\n            <div *ngIf=\"!form.hasTabs() && form.hasFields()\">\n                <div *ngFor=\"let field of form.fields\">\n                    <adf-form-field [field]=\"field.field\"></adf-form-field>\n                </div>\n            </div>\n        </mat-card-content>\n        <mat-card-content class=\"adf-start-form-actions\" *ngIf=\"showOutcomeButtons && form.hasOutcomes()\"\n                          #outcomesContainer>\n            <ng-content select=\"[adf-form-custom-button], [form-custom-button]\"></ng-content>\n\n            <button *ngFor=\"let outcome of form.outcomes\"\n                    mat-button\n                    [attr.data-automation-id]=\"'adf-form-' + outcome.name  | lowercase\"\n                    [disabled]=\"!isOutcomeButtonEnabled(outcome)\"\n                    [class.mdl-button--colored]=\"!outcome.isSystem\"\n                    [class.adf-form-hide-button]=\"!isOutcomeButtonVisible(outcome, form.readOnly)\"\n                    (click)=\"onOutcomeClicked(outcome)\">\n                {{ outcome.name | uppercase | translate | uppercase }}\n            </button>\n        </mat-card-content>\n        <mat-card-actions *ngIf=\"showRefreshButton\">\n            <button mat-button\n                    (click)=\"onRefreshClicked()\">\n                <mat-icon>refresh</mat-icon>\n            </button>\n        </mat-card-actions>\n    </mat-card>\n</div>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-form-container{max-height:100%!important;max-width:100%!important}.adf-form-container .mat-card{overflow:hidden;padding:16px 24px}.adf-form-container .mat-card-header-text{margin:0!important}.adf-form-container .mat-tab-body-content{overflow:hidden}.adf-form-container .mat-tab-label{color:var(--theme-text-color);font-size:var(--theme-subheading-2-font-size);letter-spacing:-.4px;line-height:var(--theme-headline-line-height);text-align:left;text-transform:uppercase}.adf-form-container .mat-ink-bar{height:4px}.adf-form-container .mat-form-field-wrapper{margin:0 12px 0 0}.adf-form-title{font-size:var(--theme-title-font-size)}.adf-form-debug-container{padding:10px}.adf-form-debug-container .adf-debug-toggle-text{cursor:pointer;padding-left:15px}.adf-form-debug-container .adf-debug-toggle-text:hover{font-weight:700}.adf-form-reload-button{position:absolute;right:12px;top:30px}.adf-form-validation-button{color:var(--theme-accent-color);position:absolute;right:50px;top:39px}.adf-form-validation-button .adf-invalid-color{color:var(--theme-warn-color)}.adf-form-hide-button{display:none!important}.adf-task-title{text-align:center}.adf-label{font-size:var(--theme-caption-font-size);height:16px;line-height:var(--theme-headline-line-height);text-align:left;white-space:nowrap;width:32px}.adf-form-mat-card-actions{float:right;padding-bottom:25px!important;padding-right:25px!important}.adf-form-mat-card-actions .mat-button{border-radius:5px;height:36px}.adf-form-mat-card-actions .mat-button-wrapper{font-size:var(--theme-body-2-font-size);font-weight:700;height:20px;opacity:.54;width:58px}form-field{width:100%}form-field .mat-input-element{font-size:var(--theme-body-2-font-size);line-height:normal;padding-top:8px}[dir=rtl] .adf-form-validation-button{left:50px;right:unset}"]
            },] }
];
StartFormComponent.ctorParameters = () => [
    { type: FormService },
    { type: WidgetVisibilityService }
];
StartFormComponent.propDecorators = {
    processDefinitionId: [{ type: Input }],
    processId: [{ type: Input }],
    showOutcomeButtons: [{ type: Input }],
    showRefreshButton: [{ type: Input }],
    readOnlyForm: [{ type: Input }],
    outcomeClick: [{ type: Output }],
    formContentClicked: [{ type: Output }],
    outcomesContainer: [{ type: ViewChild, args: ['outcomesContainer',] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FormCustomOutcomesComponent {
}
FormCustomOutcomesComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-form-custom-outcomes',
                template: '<ng-content></ng-content>'
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class FormModule {
}
FormModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CoreModule,
                    MaterialModule
                ],
                declarations: [
                    FormComponent,
                    StartFormComponent,
                    FormCustomOutcomesComponent
                ],
                exports: [
                    FormComponent,
                    StartFormComponent,
                    FormCustomOutcomesComponent
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TaskListModule {
}
TaskListModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    FlexLayoutModule,
                    MaterialModule,
                    FormsModule,
                    FormModule,
                    ReactiveFormsModule,
                    CoreModule,
                    PeopleModule,
                    ProcessCommentsModule,
                    ContentWidgetModule
                ],
                declarations: [
                    NoTaskDetailsTemplateDirective,
                    TaskFiltersComponent,
                    TaskListComponent,
                    TaskDetailsComponent,
                    TaskFormComponent,
                    TaskAuditDirective,
                    ChecklistComponent,
                    TaskHeaderComponent,
                    StartTaskComponent,
                    TaskStandaloneComponent,
                    AttachFormComponent,
                    ClaimTaskDirective,
                    UnclaimTaskDirective
                ],
                exports: [
                    NoTaskDetailsTemplateDirective,
                    TaskFiltersComponent,
                    TaskListComponent,
                    TaskDetailsComponent,
                    TaskFormComponent,
                    TaskAuditDirective,
                    ChecklistComponent,
                    TaskHeaderComponent,
                    StartTaskComponent,
                    TaskStandaloneComponent,
                    AttachFormComponent,
                    ClaimTaskDirective,
                    UnclaimTaskDirective
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessInstanceTasksComponent {
    constructor(activitiProcess, logService, dialog) {
        this.activitiProcess = activitiProcess;
        this.logService = logService;
        this.dialog = dialog;
        this.showRefreshButton = true;
        this.error = new EventEmitter();
        this.activeTasks = [];
        this.completedTasks = [];
        this.onDestroy$ = new Subject();
        this.taskClick = new EventEmitter();
        this.task$ = new Observable((observer) => this.taskObserver = observer)
            .pipe(share());
        this.completedTask$ = new Observable((observer) => this.completedTaskObserver = observer)
            .pipe(share());
    }
    ngOnInit() {
        this.task$
            .pipe(takeUntil(this.onDestroy$))
            .subscribe(task => this.activeTasks.push(task));
        this.completedTask$
            .pipe(takeUntil(this.onDestroy$))
            .subscribe(task => this.completedTasks.push(task));
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
    ngOnChanges(changes) {
        const processInstanceDetails = changes['processInstanceDetails'];
        if (processInstanceDetails && processInstanceDetails.currentValue) {
            this.load(processInstanceDetails.currentValue.id);
        }
    }
    load(processInstanceId) {
        this.loadActive(processInstanceId);
        this.loadCompleted(processInstanceId);
    }
    loadActive(processInstanceId) {
        this.activeTasks = [];
        if (processInstanceId) {
            this.activitiProcess.getProcessTasks(processInstanceId, null).subscribe((res) => {
                res.forEach((task) => {
                    this.taskObserver.next(task);
                });
            }, (err) => {
                this.error.emit(err);
            });
        }
        else {
            this.activeTasks = [];
        }
    }
    loadCompleted(processInstanceId) {
        this.completedTasks = [];
        if (processInstanceId) {
            this.activitiProcess.getProcessTasks(processInstanceId, 'completed').subscribe((res) => {
                res.forEach((task) => {
                    this.completedTaskObserver.next(task);
                });
            }, (err) => {
                this.error.emit(err);
            });
        }
        else {
            this.completedTasks = [];
        }
    }
    hasStartFormDefined() {
        return this.processInstanceDetails && this.processInstanceDetails.startFormDefined === true;
    }
    getUserFullName(user) {
        if (user) {
            return (user.firstName && user.firstName !== 'null'
                ? user.firstName + ' ' : '') +
                user.lastName;
        }
        return 'Nobody';
    }
    getFormatDate(value, format) {
        const datePipe = new DatePipe('en-US');
        try {
            return datePipe.transform(value, format);
        }
        catch (err) {
            this.logService.error(`ProcessListInstanceTask: error parsing date ${value} to format ${format}`);
            return value;
        }
    }
    clickTask(task) {
        const args = new TaskDetailsEvent(task);
        this.taskClick.emit(args);
    }
    clickStartTask() {
        this.processId = this.processInstanceDetails.id;
        this.showStartDialog();
    }
    showStartDialog() {
        this.dialog.open(this.startDialog, { height: '500px', width: '700px' });
    }
    closeStartDialog() {
        this.dialog.closeAll();
    }
    onRefreshClicked() {
        this.load(this.processInstanceDetails.id);
    }
    onFormContentClick() {
        this.closeStartDialog();
    }
}
ProcessInstanceTasksComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-process-instance-tasks',
                template: "<div  *ngIf=\"showRefreshButton\" class=\"process-tasks-refresh\" >\n    <button mat-icon-button (click)=\"onRefreshClicked()\">\n        <mat-icon class=\"md-24\" aria-label=\"Refresh\">refresh</mat-icon>\n    </button>\n</div>\n\n<!-- ACTIVE FORM -->\n\n<mat-chip-list>\n    <span class=\"adf-chip-label\">{{ 'ADF_PROCESS_LIST.DETAILS.LABELS.TASKS_ACTIVE'|translate }}</span>\n    <mat-chip class=\"adf-process-badge\" color=\"accent\" selected=\"true\">{{activeTasks?.length}}</mat-chip>\n</mat-chip-list>\n\n<div class=\"menu-container\" *ngIf=\"activeTasks?.length > 0\" data-automation-id=\"active-tasks\">\n    <mat-list>\n        <mat-list-item class=\"process-tasks__task-item\" *ngFor=\"let task of activeTasks\" (click)=\"clickTask(task)\">\n                <mat-icon mat-list-icon>assignment</mat-icon>\n                <h3 matLine>{{task.name || 'Nameless task'}}</h3>\n                <span matLine>\n                    {{ 'ADF_PROCESS_LIST.DETAILS.LABELS.TASK_SUBTITLE' | translate:{user: getUserFullName(task.assignee), created: getFormatDate(task.created, 'mediumDate') } }}\n                </span>\n        </mat-list-item>\n    </mat-list>\n</div>\n\n<!-- START FORM -->\n\n<div *ngIf=\"activeTasks?.length === 0\" data-automation-id=\"active-tasks-none\" class=\"no-results\">\n    {{ 'ADF_PROCESS_LIST.DETAILS.TASKS.NO_ACTIVE' | translate }}\n</div>\n\n<div *ngIf=\"hasStartFormDefined()\">\n    <span class=\"adf-activiti-label\">{{ 'ADF_PROCESS_LIST.DETAILS.LABELS.START_FORM'|translate }}</span>\n\n    <!--IF START TASK COMPLETED -->\n    <div class=\"menu-container\" data-automation-id=\"start-form\">\n        <mat-list>\n            <mat-list-item class=\"process-tasks__task-item\" (click)=\"clickStartTask()\">\n                <mat-icon mat-list-icon>assignment</mat-icon>\n                <h3 matLine>{{ 'ADF_PROCESS_LIST.DETAILS.LABELS.START_FORM'|translate }}</h3>\n                <span matLine>\n                    {{ 'ADF_PROCESS_LIST.DETAILS.LABELS.TASK_SUBTITLE' | translate:{user:getUserFullName(processInstanceDetails.startedBy), created: getFormatDate(processInstanceDetails.started, 'mediumDate') } }}\n                </span>\n            </mat-list-item>\n        </mat-list>\n    </div>\n\n</div>\n\n<!-- COMPLETED FORM -->\n<mat-chip-list>\n        <span class=\"adf-chip-label\">{{ 'ADF_PROCESS_LIST.DETAILS.LABELS.TASKS_COMPLETED'|translate }}</span>\n        <mat-chip class=\"adf-process-badge\" color=\"accent\" selected=\"true\">{{completedTasks?.length}}</mat-chip>\n</mat-chip-list>\n\n<div class=\"menu-container\" *ngIf=\"completedTasks?.length > 0\" data-automation-id=\"completed-tasks\">\n    <mat-list>\n        <mat-list-item class=\"process-tasks__task-item\" *ngFor=\"let task of completedTasks\" (click)=\"clickTask(task)\">\n            <mat-icon mat-list-icon>assignment</mat-icon>\n            <h3 matLine>{{task.name || 'Nameless task'}}</h3>\n            <span matLine>\n                {{ 'ADF_PROCESS_LIST.DETAILS.LABELS.TASK_SUBTITLE' | translate:{user:getUserFullName(task.assignee), created: getFormatDate(task.created, 'mediumDate') } }}\n            </span>\n        </mat-list-item>\n    </mat-list>\n</div>\n\n<div *ngIf=\"completedTasks?.length === 0\" data-automation-id=\"completed-tasks-none\" class=\"no-results\">\n    {{ 'ADF_PROCESS_LIST.DETAILS.TASKS.NO_COMPLETED' | translate }}\n</div>\n\n<ng-template *ngIf=\"hasStartFormDefined()\" #startDialog>\n    <div id=\"adf-start-process-dialog\" class=\"adf-start-process-dialog\">\n        <h4 matDialogTitle>{{ 'ADF_PROCESS_LIST.DETAILS.LABELS.START_FORM'|translate }}</h4>\n        <div mat-dialog-content class=\"adf-start-process-dialog-content\">\n            <adf-start-form [processId]=\"processId\"\n                                 [showRefreshButton]=\"false\" [readOnlyForm]=\"true\"\n                                 (formContentClicked)='onFormContentClick()'>\n            </adf-start-form>\n        </div>\n        <div mat-dialog-actions class=\"adf-start-process-dialog-actions\">\n            <button mat-button type=\"button\" (click)=\"closeStartDialog()\">{{ 'ADF_PROCESS_LIST.DETAILS.TASKS.TASK_CLOSE' | translate }}</button>\n        </div>\n    </div>\n</ng-template>\n",
                styles: [":host{width:100%}.activiti-label{font-weight:bolder;vertical-align:top}.adf-process-badge{outline:none;pointer-events:none}.adf-chip-label{font-weight:700;margin-right:8px;position:relative;top:5px}.menu-container{margin-bottom:32px}.activiti-label+.icon{position:relative;top:-2px}.task-details-dialog{position:fixed;top:50%;transform:translateY(-50%);width:40%}.process-tasks-refresh{float:right}.adf-start-process-dialog{display:flex;flex-direction:column;height:100%;width:100%}.adf-start-process-dialog-content{flex-grow:1}.adf-start-process-dialog-actions{display:flex;justify-content:flex-end}.no-results{color:rgba(0,0,0,.54);display:block;font-size:14px;font-weight:400;letter-spacing:0;line-height:18px;margin-left:9px;padding:12px}.process-tasks__task-item{cursor:pointer}"]
            },] }
];
ProcessInstanceTasksComponent.ctorParameters = () => [
    { type: ProcessService },
    { type: LogService },
    { type: MatDialog }
];
ProcessInstanceTasksComponent.propDecorators = {
    processInstanceDetails: [{ type: Input }],
    showRefreshButton: [{ type: Input }],
    error: [{ type: Output }],
    startDialog: [{ type: ViewChild, args: ['startDialog',] }],
    taskDetails: [{ type: ViewChild, args: ['taskDetails',] }],
    taskClick: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessInstanceDetailsComponent {
    constructor(activitiProcess, logService) {
        this.activitiProcess = activitiProcess;
        this.logService = logService;
        this.showTitle = true;
        this.showRefreshButton = true;
        this.processCancelled = new EventEmitter();
        this.error = new EventEmitter();
        this.taskClick = new EventEmitter();
        this.showProcessDiagram = new EventEmitter();
    }
    ngOnChanges(changes) {
        const processInstanceId = changes['processInstanceId'];
        if (processInstanceId && !processInstanceId.currentValue) {
            this.reset();
            return;
        }
        if (processInstanceId && processInstanceId.currentValue) {
            this.load(processInstanceId.currentValue);
            return;
        }
    }
    reset() {
        this.processInstanceDetails = null;
    }
    load(processId) {
        if (processId) {
            this.activitiProcess.getProcess(processId).subscribe((res) => {
                this.processInstanceDetails = res;
            });
        }
    }
    isRunning() {
        return this.processInstanceDetails && !this.processInstanceDetails.ended;
    }
    cancelProcess() {
        this.activitiProcess.cancelProcess(this.processInstanceId).subscribe((data) => {
            this.processCancelled.emit(data);
        }, (err) => {
            this.error.emit(err);
        });
    }
    onTaskClicked(event) {
        this.taskClick.emit(event);
    }
    getProcessNameOrDescription(dateFormat) {
        let name = '';
        if (this.processInstanceDetails) {
            name = this.processInstanceDetails.name ||
                this.processInstanceDetails.processDefinitionName + ' - ' + this.getFormatDate(this.processInstanceDetails.started, dateFormat);
        }
        return name;
    }
    getFormatDate(value, format) {
        const datePipe = new DatePipe('en-US');
        try {
            return datePipe.transform(value, format);
        }
        catch (err) {
            this.logService.error(`ProcessListInstanceHeader: error parsing date ${value} to format ${format}`);
        }
    }
    onShowProcessDiagram() {
        this.showProcessDiagram.emit({ value: this.processInstanceId });
    }
}
ProcessInstanceDetailsComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-process-instance-details',
                template: "<div *ngIf=\"!processInstanceDetails\">{{ 'ADF_PROCESS_LIST.DETAILS.MESSAGES.NONE'|translate }}</div>\n<mat-card *ngIf=\"processInstanceDetails\">\n    <mat-card-header>\n        <mat-card-title>{{ getProcessNameOrDescription('medium') }}</mat-card-title>\n    </mat-card-header>\n    <mat-card-content>\n        <adf-process-instance-header\n            #processInstanceHeader\n            [processInstance]=\"processInstanceDetails\"\n            (showProcessDiagram)=\"onShowProcessDiagram()\">\n        </adf-process-instance-header>\n\n        <button\n            class=\"adf-in-medias-res-button\"\n            mat-button id=\"show-diagram-button\"\n            type=\"button\"\n            mat-button mat-raised-button\n            [disabled]=\"!isRunning()\"\n            (click)=\"onShowProcessDiagram()\">{{ 'ADF_PROCESS_LIST.DETAILS.BUTTON.SHOW_DIAGRAM' | translate }}</button>\n\n        <mat-card>\n            <mat-card-content>\n                <adf-process-instance-tasks\n                    #processInstanceTasks\n                    [processInstanceDetails]=\"processInstanceDetails\"\n                    (taskClick)=\"onTaskClicked($event)\">\n                </adf-process-instance-tasks>\n            </mat-card-content>\n        </mat-card>\n\n        <div data-automation-id=\"header-status\" *ngIf=\"isRunning()\" class=\"adf-in-medias-res-button\">\n            <button mat-button type=\"button\" (click)=\"cancelProcess()\">{{ 'ADF_PROCESS_LIST.DETAILS.BUTTON.CANCEL' | translate }}</button>\n        </div>\n\n        <mat-card>\n            <mat-card-content>\n                <adf-process-instance-comments #activitiComments\n                    [readOnly]=\"false\"\n                    [processInstanceId]=\"processInstanceDetails.id\">\n                </adf-process-instance-comments>\n            </mat-card-content>\n        </mat-card>\n\n    </mat-card-content>\n</mat-card>\n",
                styles: [":host{width:100%}.activiti-process-container{min-height:100px;overflow:visible;padding:10px;width:100%}.adf-comments-dialog{position:fixed;top:50%;transform:translateY(-50%);width:40%}.adf-in-medias-res-button{margin:16px 0}"]
            },] }
];
ProcessInstanceDetailsComponent.ctorParameters = () => [
    { type: ProcessService },
    { type: LogService }
];
ProcessInstanceDetailsComponent.propDecorators = {
    processInstanceId: [{ type: Input }],
    processInstanceHeader: [{ type: ViewChild, args: ['processInstanceHeader',] }],
    tasksList: [{ type: ViewChild, args: ['processInstanceTasks',] }],
    showTitle: [{ type: Input }],
    showRefreshButton: [{ type: Input }],
    processCancelled: [{ type: Output }],
    error: [{ type: Output }],
    taskClick: [{ type: Output }],
    showProcessDiagram: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const JSON_FORMAT$1 = 'json';
const PDF_FORMAT$1 = 'pdf';
class ProcessAuditDirective {
    constructor(downloadService, processListService) {
        this.downloadService = downloadService;
        this.processListService = processListService;
        this.fileName = 'Audit';
        this.format = 'pdf';
        this.download = true;
        this.clicked = new EventEmitter();
        this.error = new EventEmitter();
    }
    ngOnChanges() {
        if (!this.isValidType()) {
            this.setDefaultFormatType();
        }
    }
    isValidType() {
        return this.format && (this.isJsonFormat() || this.isPdfFormat());
    }
    setDefaultFormatType() {
        this.format = PDF_FORMAT$1;
    }
    fetchAuditInfo() {
        if (this.isPdfFormat()) {
            this.processListService.fetchProcessAuditPdfById(this.processId).subscribe((blob) => {
                if (this.download) {
                    this.downloadService.downloadBlob(blob, this.fileName + '.pdf');
                }
                this.clicked.emit({ format: this.format, value: blob, fileName: this.fileName });
            }, (err) => this.error.emit(err));
        }
        else {
            this.processListService.fetchProcessAuditJsonById(this.processId).subscribe((res) => this.clicked.emit({ format: this.format, value: res, fileName: this.fileName }), (err) => this.error.emit(err));
        }
    }
    onClickAudit() {
        this.fetchAuditInfo();
    }
    isJsonFormat() {
        return this.format === JSON_FORMAT$1;
    }
    isPdfFormat() {
        return this.format === PDF_FORMAT$1;
    }
}
ProcessAuditDirective.decorators = [
    { type: Directive, args: [{
                selector: 'button[adf-process-audit]',
                host: {
                    'role': 'button',
                    '(click)': 'onClickAudit()'
                }
            },] }
];
ProcessAuditDirective.ctorParameters = () => [
    { type: DownloadService },
    { type: ProcessService }
];
ProcessAuditDirective.propDecorators = {
    processId: [{ type: Input, args: ['process-id',] }],
    fileName: [{ type: Input }],
    format: [{ type: Input }],
    download: [{ type: Input }],
    clicked: [{ type: Output }],
    error: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
let processPresetsDefaultModel = {
    'default': [
        {
            'key': 'name',
            'type': 'text',
            'title': 'ADF_PROCESS_LIST.PROPERTIES.NAME',
            'sortable': true
        },
        {
            'key': 'created',
            'type': 'text',
            'title': 'ADF_PROCESS_LIST.PROPERTIES.CREATED',
            'cssClass': 'hidden',
            'sortable': true
        }
    ]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessInstanceListComponent extends DataTableSchema {
    constructor(processService, userPreferences, appConfig) {
        super(appConfig, ProcessInstanceListComponent.PRESET_KEY, processPresetsDefaultModel);
        this.processService = processService;
        this.userPreferences = userPreferences;
        this.page = 0;
        this.size = PaginationComponent.DEFAULT_PAGINATION.maxItems;
        this.multiselect = false;
        this.selectionMode = 'single';
        this.selectFirstRow = true;
        this.stickyHeader = false;
        this.showContextMenu = false;
        this.showRowContextMenu = new EventEmitter();
        this.resolverFn = null;
        this.rowClick = new EventEmitter();
        this.success = new EventEmitter();
        this.error = new EventEmitter();
        this.isLoading = true;
        this.rows = [];
        this.sorting = ['created', 'desc'];
        this.size = this.userPreferences.paginationSize;
        this.pagination = new BehaviorSubject({
            maxItems: this.size,
            skipCount: 0,
            totalItems: 0
        });
    }
    ngAfterContentInit() {
        this.createDatatableSchema();
        if (this.data && this.data.getColumns().length === 0) {
            this.data.setColumns(this.columns);
        }
        if (this.appId != null) {
            this.reload();
        }
    }
    ngOnChanges(changes) {
        if (this.isPropertyChanged(changes)) {
            if (this.isSortChanged(changes)) {
                this.sorting = this.sort ? this.sort.split('-') : this.sorting;
            }
            this.reload();
        }
        const presetColumnChanges = changes['presetColumn'];
        if (presetColumnChanges && !presetColumnChanges.firstChange) {
            this.columns = this.mergeJsonAndHtmlSchema();
        }
    }
    isSortChanged(changes) {
        const actualSort = changes['sort'];
        return actualSort && actualSort.currentValue && actualSort.currentValue !== actualSort.previousValue;
    }
    isPropertyChanged(changes) {
        let changed = false;
        const appId = changes['appId'];
        const processDefinitionId = changes['processDefinitionId'];
        const processInstanceId = changes['processInstanceId'];
        const state = changes['state'];
        const sort = changes['sort'];
        const page = changes['page'];
        const size = changes['size'];
        if (appId && appId.currentValue) {
            changed = true;
        }
        else if (processDefinitionId) {
            changed = true;
        }
        else if (processInstanceId) {
            changed = true;
        }
        else if (state && state.currentValue) {
            changed = true;
        }
        else if (sort && sort.currentValue) {
            changed = true;
        }
        else if (page && page.currentValue !== page.previousValue) {
            changed = true;
        }
        else if (size && size.currentValue !== size.previousValue) {
            changed = true;
        }
        return changed;
    }
    reload() {
        this.requestNode = this.createRequestNode();
        this.load(this.requestNode);
    }
    load(requestNode) {
        this.isLoading = true;
        this.processService.getProcesses(requestNode)
            .pipe(finalize(() => this.isLoading = false))
            .subscribe(response => {
            this.rows = response.data;
            this.selectFirst();
            this.success.emit(response);
            this.pagination.next({
                count: response.data.length,
                maxItems: this.size,
                skipCount: this.page * this.size,
                totalItems: response.total
            });
        }, error => {
            this.error.emit(error);
        });
    }
    selectFirst() {
        if (this.selectFirstRow) {
            if (!this.isListEmpty()) {
                const dataRow = this.rows[0];
                dataRow.isSelected = true;
                this.currentInstanceId = dataRow['id'];
            }
            else {
                this.currentInstanceId = null;
            }
        }
    }
    getCurrentId() {
        return this.currentInstanceId;
    }
    isListEmpty() {
        return !this.rows || this.rows.length === 0;
    }
    onRowClick(event) {
        const item = event;
        this.currentInstanceId = item.value.getValue('id');
        this.rowClick.emit(this.currentInstanceId);
    }
    onRowKeyUp(event) {
        if (event.detail.keyboardEvent.key === 'Enter') {
            event.preventDefault();
            this.currentInstanceId = event.detail.row.getValue('id');
            this.rowClick.emit(this.currentInstanceId);
        }
    }
    onShowRowContextMenu(event) {
        this.showRowContextMenu.emit(event);
    }
    createRequestNode() {
        return new ProcessFilterParamRepresentationModel({
            appDefinitionId: this.appId,
            processDefinitionId: this.processDefinitionId,
            processInstanceId: this.processInstanceId,
            state: this.state,
            sort: this.sort,
            page: this.page,
            size: this.size,
            start: 0
        });
    }
    updatePagination(params) {
        const needsReload = params.maxItems || params.skipCount;
        this.size = params.maxItems;
        this.page = this.currentPage(params.skipCount, params.maxItems);
        if (needsReload) {
            this.reload();
        }
    }
    currentPage(skipCount, maxItems) {
        return (skipCount && maxItems) ? Math.floor(skipCount / maxItems) : 0;
    }
}
ProcessInstanceListComponent.PRESET_KEY = 'adf-process-list.presets';
ProcessInstanceListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-process-instance-list',
                template: "<adf-datatable #dataTable\n    [data]=\"data\"\n    [rows]=\"rows\"\n    [columns]=\"columns\"\n    [sorting]=\"sorting\"\n    [loading]=\"isLoading\"\n    [stickyHeader]=\"stickyHeader\"\n    [selectionMode]=\"selectionMode\"\n    [multiselect]=\"multiselect\"\n    [resolverFn]=\"resolverFn\"\n    [contextMenu]=\"showContextMenu\"\n    (showRowContextMenu)=\"onShowRowContextMenu($event)\"\n    (rowClick)=\"onRowClick($event)\"\n    (row-keyup)=\"onRowKeyUp($any($event))\">\n    <adf-loading-content-template>\n        <ng-template>\n            <mat-progress-spinner\n                *ngIf=\"!customLoadingContent\"\n                class=\"adf-process-list-loading-margin\"\n                color=\"primary\"\n                mode=\"indeterminate\">\n            </mat-progress-spinner>\n            <ng-content select=\"adf-custom-loading-content-template\"></ng-content>\n        </ng-template>\n    </adf-loading-content-template>\n    <adf-no-content-template>\n        <ng-template>\n                <adf-empty-content *ngIf=\"!customEmptyContent\"\n                    icon=\"assessment\"\n                    [title]=\"(requestNode ? 'ADF_PROCESS_LIST.LIST.TITLE' : 'ADF_PROCESS_LIST.FILTERS.MESSAGES.NONE') | translate\"\n                    [subtitle]=\"'ADF_PROCESS_LIST.LIST.SUBTITLE'| translate\">\n                </adf-empty-content>\n            <ng-content select=\"adf-custom-empty-content-template\"></ng-content>\n        </ng-template>\n    </adf-no-content-template>\n</adf-datatable>\n",
                styles: [".adf-process-list-loading-margin{margin-left:calc(50% - 50px);margin-right:calc(50% - 50px)}.no-content-message{color:#000;font-size:16px;font-weight:700;opacity:.54;text-align:center}"]
            },] }
];
ProcessInstanceListComponent.ctorParameters = () => [
    { type: ProcessService },
    { type: UserPreferencesService },
    { type: AppConfigService }
];
ProcessInstanceListComponent.propDecorators = {
    customEmptyContent: [{ type: ContentChild, args: [CustomEmptyContentTemplateDirective,] }],
    customLoadingContent: [{ type: ContentChild, args: [CustomLoadingContentTemplateDirective,] }],
    appId: [{ type: Input }],
    processDefinitionId: [{ type: Input }],
    processInstanceId: [{ type: Input }],
    state: [{ type: Input }],
    sort: [{ type: Input }],
    page: [{ type: Input }],
    size: [{ type: Input }],
    data: [{ type: Input }],
    multiselect: [{ type: Input }],
    selectionMode: [{ type: Input }],
    selectFirstRow: [{ type: Input }],
    stickyHeader: [{ type: Input }],
    showContextMenu: [{ type: Input }],
    showRowContextMenu: [{ type: Output }],
    resolverFn: [{ type: Input }],
    rowClick: [{ type: Output }],
    success: [{ type: Output }],
    error: [{ type: Output }]
};

class ProcessFormRenderingService extends FormRenderingService {
    constructor() {
        super();
        this.register({
            'upload': () => AttachFileWidgetComponent,
            'select-folder': () => AttachFolderWidgetComponent
        }, true);
    }
}
ProcessFormRenderingService.ɵprov = ɵɵdefineInjectable({ factory: function ProcessFormRenderingService_Factory() { return new ProcessFormRenderingService(); }, token: ProcessFormRenderingService, providedIn: "root" });
ProcessFormRenderingService.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
ProcessFormRenderingService.ctorParameters = () => [];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessNamePipe {
    constructor(localizedDatePipe) {
        this.localizedDatePipe = localizedDatePipe;
    }
    transform(processNameFormat, processInstance) {
        let processName = processNameFormat;
        if (processName.match(ProcessNamePipe.DATE_TIME_IDENTIFIER_REG_EXP)) {
            const presentDateTime = moment$1.now();
            processName = processName.replace(ProcessNamePipe.DATE_TIME_IDENTIFIER_REG_EXP, this.localizedDatePipe.transform(presentDateTime, 'medium'));
        }
        if (processName.match(ProcessNamePipe.PROCESS_DEFINITION_IDENTIFIER_REG_EXP)) {
            const selectedProcessDefinitionName = processInstance ? processInstance.processDefinitionName : '';
            processName = processName.replace(ProcessNamePipe.PROCESS_DEFINITION_IDENTIFIER_REG_EXP, selectedProcessDefinitionName);
        }
        return processName;
    }
}
ProcessNamePipe.DATE_TIME_IDENTIFIER_REG_EXP = new RegExp('%{datetime}', 'i');
ProcessNamePipe.PROCESS_DEFINITION_IDENTIFIER_REG_EXP = new RegExp('%{processdefinition}', 'i');
ProcessNamePipe.decorators = [
    { type: Pipe, args: [{ name: 'processName' },] }
];
ProcessNamePipe.ctorParameters = () => [
    { type: LocalizedDatePipe }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class StartProcessInstanceComponent {
    constructor(activitiProcess, activitiContentService, appsProcessService, appConfig, processNamePipe) {
        this.activitiProcess = activitiProcess;
        this.activitiContentService = activitiContentService;
        this.appsProcessService = appsProcessService;
        this.appConfig = appConfig;
        this.processNamePipe = processNamePipe;
        this.MAX_LENGTH = 255;
        this.name = '';
        this.showSelectProcessDropdown = true;
        this.showSelectApplicationDropdown = false;
        this.processFilterSelector = true;
        this.start = new EventEmitter();
        this.cancel = new EventEmitter();
        this.error = new EventEmitter();
        this.processDefinitionSelection = new EventEmitter();
        this.applicationSelection = new EventEmitter();
        this.processDefinitions = [];
        this.maxProcessNameLength = this.MAX_LENGTH;
        this.applications = [];
        this.isProcessDefinitionsLoading = true;
        this.isAppsLoading = true;
        this.onDestroy$ = new Subject();
    }
    ngOnInit() {
        this.processNameInput = new FormControl('', [Validators.required, Validators.maxLength(this.maxProcessNameLength), Validators.pattern('^[^\\s]+(\\s+[^\\s]+)*$')]);
        this.processDefinitionInput = new FormControl();
        this.load();
        this.filteredProcessesDefinitions$ = this.processDefinitionInput.valueChanges
            .pipe(map((value) => this._filter(value)), takeUntil(this.onDestroy$));
        this.activitiContentService.getAlfrescoRepositories().subscribe((repoList) => {
            if (repoList && repoList[0]) {
                const alfrescoRepository = repoList[0];
                this.alfrescoRepositoryName = `alfresco-${alfrescoRepository.id}-${alfrescoRepository.name}`;
            }
        });
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
    ngOnChanges(changes) {
        if (changes['values'] && changes['values'].currentValue) {
            this.moveNodeFromCStoPS();
        }
        if (this.isAppIdChanged(changes)) {
            this.appId = changes['appId'].currentValue;
            this.load();
        }
        if (this.isProcessDefinitionChanged(changes)) {
            this.processDefinitionName = changes['processDefinitionName'].currentValue;
            this.filterProcessDefinitionByName();
        }
    }
    isAppIdChanged(changes) {
        return changes['appId'] && changes['appId'].currentValue && changes['appId'].currentValue !== changes['appId'].previousValue;
    }
    isProcessDefinitionChanged(changes) {
        return changes['processDefinitionName'] && changes['processDefinitionName'].currentValue &&
            changes['processDefinitionName'].currentValue !== changes['processDefinitionName'].previousValue;
    }
    _filter(value) {
        if (value !== null && value !== undefined) {
            const filterValue = value.toLowerCase();
            const filteredProcess = this.processDefinitions.filter((option) => option.name.toLowerCase().includes(filterValue));
            if (this.processFilterSelector) {
                this.selectedProcessDef = this.getSelectedProcess(filterValue);
            }
            return filteredProcess;
        }
        return [];
    }
    getSelectedProcess(selectedProcess) {
        let processSelected = this.processDefinitions.find((process) => process.name.toLowerCase() === selectedProcess);
        if (!processSelected) {
            processSelected = new ProcessDefinitionRepresentation();
        }
        return processSelected;
    }
    load() {
        if (this.showSelectApplicationDropdown) {
            this.loadApps();
        }
        else {
            this.loadProcessDefinitions(this.appId);
        }
    }
    loadProcessDefinitions(appId) {
        this.isProcessDefinitionsLoading = true;
        this.resetSelectedProcessDefinition();
        this.activitiProcess.getProcessDefinitions(appId).pipe(map((processDefinitionRepresentations) => {
            let currentProcessDef;
            if (processDefinitionRepresentations.length === 1) {
                currentProcessDef = processDefinitionRepresentations[0];
            }
            if (this.processDefinitionName) {
                const filteredProcessDefinition = processDefinitionRepresentations.find((processDefinition) => {
                    return processDefinition.name === this.processDefinitionName;
                });
                if (filteredProcessDefinition) {
                    currentProcessDef = filteredProcessDefinition;
                }
            }
            return { currentProcessDef, processDefinitionRepresentations };
        })).subscribe((filteredProcessDefinitions) => {
            this.processDefinitions = filteredProcessDefinitions.processDefinitionRepresentations;
            this.processDefinitionSelectionChanged(filteredProcessDefinitions.currentProcessDef);
            this.processDefinitionInput.setValue(this.selectedProcessDef ? this.selectedProcessDef.name : '');
            this.isProcessDefinitionsLoading = false;
        }, (error) => {
            this.isProcessDefinitionsLoading = false;
            this.error.emit(error);
        });
    }
    filterProcessDefinitionByName() {
        if (this.processDefinitionName) {
            const filteredProcessDef = this.processDefinitions.find((processDefinition) => {
                return processDefinition.name === this.processDefinitionName;
            });
            if (filteredProcessDef) {
                this.processDefinitionSelectionChanged(filteredProcessDef);
                this.processDefinitionInput.setValue(this.selectedProcessDef ? this.selectedProcessDef.name : '');
            }
        }
    }
    loadApps() {
        this.isAppsLoading = true;
        this.appsProcessService
            .getDeployedApplications()
            .pipe(map((response) => {
            const applications = this.removeDefaultApps(response);
            let currentApplication;
            if (applications && applications.length === 1) {
                currentApplication = applications[0];
            }
            const filteredApp = applications.find(app => app.id === +this.appId);
            if (filteredApp) {
                currentApplication = filteredApp;
            }
            return { currentApplication, applications };
        }))
            .subscribe((filteredApps) => {
            this.applications = filteredApps.applications;
            this.selectedApplication = filteredApps.currentApplication;
            this.applicationSelection.emit(this.selectedApplication);
            this.toggleProcessNameAndDefinitionsDropdown();
            this.isAppsLoading = false;
            this.loadProcessDefinitionsBasedOnSelectedApp();
        }, (err) => {
            this.isAppsLoading = false;
            this.error.emit(err);
        });
    }
    loadProcessDefinitionsBasedOnSelectedApp() {
        if (this.selectedApplication && this.selectedApplication.id) {
            this.loadProcessDefinitions(this.selectedApplication ? this.selectedApplication.id : null);
        }
        else {
            this.isProcessDefinitionsLoading = false;
            this.resetProcessDefinitions();
        }
    }
    onAppSelectionChange(selectedApplication) {
        this.resetProcessDefinitions();
        this.selectedApplication = selectedApplication.value;
        this.applicationSelection.emit(this.selectedApplication);
        this.toggleProcessNameAndDefinitionsDropdown();
        this.loadProcessDefinitionsBasedOnSelectedApp();
    }
    isAppSelected() {
        return !!(this.selectedApplication && this.selectedApplication.id);
    }
    removeDefaultApps(apps) {
        return apps.filter((app) => app.id);
    }
    hasApplications() {
        return this.applications && this.applications.length > 0;
    }
    hasProcessDefinitions() {
        return this.processDefinitions && this.processDefinitions.length > 0;
    }
    isProcessDefinitionSelected() {
        return !!(this.selectedProcessDef && this.selectedProcessDef.id);
    }
    isProcessDefinitionsEmpty() {
        return this.processDefinitions.length === 0;
    }
    disableDropdownButton() {
        return this.showSelectApplicationDropdown && !this.isAppSelected();
    }
    getAlfrescoRepositoryName() {
        let alfrescoRepositoryName = this.appConfig.get(AppConfigValues.ALFRESCO_REPOSITORY_NAME);
        if (!alfrescoRepositoryName) {
            alfrescoRepositoryName = this.alfrescoRepositoryName;
        }
        return alfrescoRepositoryName + 'Alfresco';
    }
    moveNodeFromCStoPS() {
        const accountIdentifier = this.getAlfrescoRepositoryName();
        for (const key in this.values) {
            if (this.values.hasOwnProperty(key)) {
                const currentValue = Array.isArray(this.values[key]) ? this.values[key] : [this.values[key]];
                const contents = currentValue.filter((value) => value && value.isFile)
                    .map((content) => this.activitiContentService.applyAlfrescoNode(content, null, accountIdentifier));
                forkJoin(contents).subscribe((res) => {
                    this.movedNodeToPS = { [key]: [...res] };
                });
            }
        }
    }
    startProcess(outcome) {
        if (this.selectedProcessDef && this.selectedProcessDef.id && this.nameController.value) {
            const formValues = this.startForm ? this.startForm.form.values : undefined;
            this.activitiProcess.startProcess(this.selectedProcessDef.id, this.nameController.value, outcome, formValues, this.variables).subscribe((res) => {
                this.name = '';
                this.start.emit(res);
            }, (err) => {
                this.error.emit(err);
            });
        }
    }
    cancelStartProcess() {
        this.cancel.emit();
    }
    hasStartForm() {
        return this.selectedProcessDef && this.selectedProcessDef.hasStartForm;
    }
    isStartFormMissingOrValid() {
        if (this.startForm) {
            return this.startForm.form && this.startForm.form.isValid;
        }
        else {
            return true;
        }
    }
    validateForm() {
        return this.selectedProcessDef && this.selectedProcessDef.id && this.processNameInput.valid && this.isStartFormMissingOrValid();
    }
    resetSelectedProcessDefinition() {
        this.selectedProcessDef = undefined;
        if (this.processDefinitionInput) {
            this.processDefinitionInput.setValue('');
        }
    }
    resetProcessDefinitions() {
        this.processDefinitions = [];
        this.resetSelectedProcessDefinition();
    }
    onOutcomeClick(outcome) {
        this.startProcess(outcome);
    }
    reset() {
        this.resetSelectedProcessDefinition();
        this.name = '';
        if (this.startForm) {
            this.startForm.data = {};
        }
    }
    displayFn(process) {
        if (process) {
            let processName = process;
            if (typeof process !== 'string') {
                processName = process.name;
            }
            return processName;
        }
        return undefined;
    }
    displayDropdown(event) {
        event.stopPropagation();
        if (!this.inputAutocomplete.panelOpen) {
            this.processDefinitionInput.setValue('');
            this.inputAutocomplete.openPanel();
        }
        else {
            this.inputAutocomplete.closePanel();
        }
    }
    get nameController() {
        return this.processNameInput;
    }
    get processDefinitionController() {
        return this.processDefinitionInput;
    }
    toggleProcessNameAndDefinitionsDropdown() {
        if (!this.isAppSelected()) {
            this.processDefinitionController.disable();
            this.nameController.disable();
        }
        else {
            this.processDefinitionController.enable();
            this.nameController.enable();
        }
    }
    processDefinitionSelectionChanged(processDefinition) {
        if (processDefinition) {
            const processInstanceDetails = new ProcessInstance({ processDefinitionName: processDefinition.name });
            const processName = this.processNamePipe.transform(this.name, processInstanceDetails);
            this.processNameInput.setValue(processName);
            this.processNameInput.markAsDirty();
            this.processNameInput.markAsTouched();
            this.selectedProcessDef = processDefinition;
            this.processDefinitionSelection.emit(this.selectedProcessDef);
        }
        else {
            this.nameController.reset();
        }
    }
    isLoading() {
        return this.showSelectApplicationDropdown ? this.isAppsLoading : false;
    }
}
StartProcessInstanceComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-start-process',
                template: "\n<ng-container *ngIf=\"isLoading(); then showLoadingTemplate; else showStartProcessTemplate\"></ng-container>\n    <ng-template #showLoadingTemplate>\n        <mat-spinner class=\"adf-start-process-loading\"></mat-spinner>\n    </ng-template>\n<ng-template #showStartProcessTemplate>\n    <ng-container *ngIf=\"hasApplications() || hasProcessDefinitions() ; else showEmptyTemplate\">\n        <div class=\"adf-start-process\">\n            <div class=\"adf-title\" *ngIf=\"title\">{{ title | translate}}</div>\n            <div class=\"content\">\n                <div class=\"adf-start-process-definition-container\">\n                    <mat-form-field *ngIf=\"showSelectApplicationDropdown\" [floatLabel]=\"'always'\" class=\"adf-start-process-app-list\">\n                        <mat-select\n                            placeholder=\"{{ 'ADF_PROCESS_LIST.START_PROCESS.FORM.LABEL.SELECT_APPLICATION' | translate }}\"\n                            (selectionChange)=\"onAppSelectionChange($event)\"\n                            [(ngModel)]=\"selectedApplication\"\n                            data-automation-id=\"adf-start-process-apps-drop-down\">\n                            <mat-option \n                                *ngFor=\"let application of applications\"\n                                [value]=\"application\"\n                                [attr.data-automation-id]=\"'adf-start-process-apps-option-' + application.name\">\n                                {{ application.name }}\n                            </mat-option>\n                        </mat-select>\n                    </mat-form-field>\n                    <mat-form-field class=\"adf-process-input-container\" [floatLabel]=\"'always'\">\n                        <mat-label>{{'ADF_PROCESS_LIST.START_PROCESS.FORM.LABEL.TYPE' | translate}}</mat-label>\n                        <input\n                            type=\"text\"\n                            matInput\n                            [formControl]=\"processDefinitionInput\"\n                            [matAutocomplete]=\"auto\"\n                            id=\"processDefinitionName\"\n                            #inputAutocomplete>\n                        <div class=\"adf-process-input-autocomplete\">\n                            <mat-autocomplete\n                                #auto=\"matAutocomplete\"\n                                id=\"processDefinitionOptions\"\n                                [displayWith]=\"displayFn\">\n                                <mat-option *ngFor=\"let processDef of filteredProcessesDefinitions$ | async\" [value]=\"processDef.name\"\n                                (click)=\"processDefinitionSelectionChanged(processDef)\">\n                                    {{ processDef.name }}\n                                </mat-option>\n                            </mat-autocomplete>\n                            <ng-container *ngIf=\"!isProcessDefinitionsLoading ; else showProcessDefLoadingTemplate\">\n                                <button\n                                    id=\"adf-select-process-dropdown\"\n                                    *ngIf=\"showSelectProcessDropdown\"\n                                    mat-icon-button\n                                    (click)=\"displayDropdown($event)\"\n                                    [disabled]=\"disableDropdownButton()\">\n                                    <mat-icon>arrow_drop_down</mat-icon>\n                                </button>\n                            </ng-container>\n                            <ng-template #showProcessDefLoadingTemplate>\n                                <mat-spinner id=\"adf-select-process-spinner\" [diameter]=\"20\"></mat-spinner>\n                            </ng-template>\n                        </div>\n                    </mat-form-field>\n                </div>\n                <mat-form-field class=\"adf-process-input-container\" [floatLabel]=\"'always'\">\n                    <mat-label>{{'ADF_PROCESS_LIST.START_PROCESS.FORM.LABEL.NAME' | translate}}</mat-label>\n                    <input\n                        matInput\n                        [formControl]=\"processNameInput\"\n                        id=\"processName\"\n                        required/>\n                    <mat-error *ngIf=\"nameController.hasError('maxlength')\">\n                        {{ 'ADF_PROCESS_LIST.START_PROCESS.ERROR.MAXIMUM_LENGTH' | translate : { characters : maxProcessNameLength } }}\n                    </mat-error>\n                    <mat-error *ngIf=\"nameController.hasError('required')\">\n                        {{ 'ADF_PROCESS_LIST.START_PROCESS.ERROR.PROCESS_NAME_REQUIRED' | translate }}\n                    </mat-error>\n                    <mat-error *ngIf=\"nameController.hasError('pattern')\">\n                        {{ 'ADF_PROCESS_LIST.START_PROCESS.ERROR.SPACE_VALIDATOR' | translate }}\n                    </mat-error>\n                </mat-form-field>\n        \n                <ng-container *ngIf=\"!isProcessDefinitionsLoading ; else showStartFormLoadingTemplate\">\n                    <ng-container *ngIf=\"isProcessDefinitionSelected() ; else emptyProcessDefTemplate\">\n                        <ng-container  *ngIf=\"hasStartForm(); else noStartFormTemplate\">\n                            <adf-start-form\n                                #startForm\n                                [data]=\"movedNodeToPS\"\n                                [disableStartProcessButton]=\"processNameInput.invalid\"\n                                [processDefinitionId]=\"selectedProcessDef.id\"\n                                (outcomeClick)=\"onOutcomeClick($event)\"\n                                [showRefreshButton]=\"false\">\n                                <button\n                                    adf-form-custom-button\n                                    mat-button\n                                    (click)=\"cancelStartProcess()\"\n                                    id=\"cancel_process\">\n                                    {{'ADF_PROCESS_LIST.START_PROCESS.FORM.ACTION.CANCEL'| translate | uppercase}}\n                                </button>\n                            </adf-start-form>\n                        </ng-container>\n                        <ng-template #noStartFormTemplate>\n                            <adf-empty-content \n                                class=\"adf-start-process-empty-template\"\n                                [icon]=\"'assessment'\"\n                                [title]=\"'ADF_PROCESS_LIST.START_PROCESS.NO_START_FORM'  | translate\">\n                            </adf-empty-content>\n                        </ng-template>\n                    </ng-container>\n                    <ng-template #emptyProcessDefTemplate>\n                        <adf-empty-content class=\"adf-start-process-empty-template\"\n                            [icon]=\"'assessment'\"\n                            [title]=\"'ADF_PROCESS_LIST.START_PROCESS.NO_PROCESS_DEF_SELECTED'  | translate\">\n                        </adf-empty-content>\n                    </ng-template>\n                </ng-container>\n                <ng-template #showStartFormLoadingTemplate>\n                    <mat-spinner class=\"adf-start-process-loading\"></mat-spinner>\n                </ng-template>\n            </div>\n            <div class=\"mat-content-actions\" *ngIf=\"!hasStartForm()\">\n                <button\n                    mat-button\n                    *ngIf=\"!hasStartForm()\"\n                    (click)=\"cancelStartProcess()\"\n                    id=\"cancel_process\">\n                    {{'ADF_PROCESS_LIST.START_PROCESS.FORM.ACTION.CANCEL'| translate | uppercase}}\n                </button>\n                <button\n                    color=\"primary\"\n                    mat-button\n                    *ngIf=\"!hasStartForm()\"\n                    [disabled]=\"!validateForm()\"\n                    (click)=\"startProcess()\"\n                    data-automation-id=\"btn-start\"\n                    id=\"button-start\"\n                    class=\"btn-start\">\n                    {{'ADF_PROCESS_LIST.START_PROCESS.FORM.ACTION.START' | translate | uppercase}}\n                </button>\n            </div>\n        </div>\n    </ng-container>\n        <ng-template #showEmptyTemplate>\n            <adf-empty-content class=\"adf-start-process-empty-template\"\n                [icon]=\"'assessment'\"\n                [title]=\"'ADF_PROCESS_LIST.START_PROCESS.NO_PROCESS_DEFINITIONS' | translate\">\n            </adf-empty-content>\n        </ng-template>    \n</ng-template>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-start-process{margin-left:auto;margin-right:auto;margin-top:10px;width:96%}.adf-start-process mat-form-field{width:100%}.adf-start-process .mat-form-field-label{color:var(--theme-colors-mat-grey-dark)}.adf-start-process .mat-content-actions{text-align:right}.adf-start-process .mat-button{text-transform:uppercase!important}.adf-title{padding-bottom:1.25em}.adf-process-input-container mat-form-field{width:100%}.adf-process-input-autocomplete{display:flex}.adf-process-input-autocomplete button{position:absolute;right:-14px;top:0}.adf-process-input-autocomplete mat-spinner{position:absolute;right:-1px;top:0}.adf-start-form-container .mat-card{box-shadow:none!important;padding:0!important}.adf-start-form-actions{text-align:right!important}.adf-start-process-definition-container{align-items:baseline;display:flex;flex-direction:row;justify-content:space-around}.adf-start-process-app-list{margin-right:10px}@media (max-width:600px){.adf-start-process{margin-left:auto;margin-right:auto;width:90%}}.adf-start-process-loading{margin-left:calc(50% - 50px);margin-right:calc(50% - 50px)}"]
            },] }
];
StartProcessInstanceComponent.ctorParameters = () => [
    { type: ProcessService },
    { type: ActivitiContentService },
    { type: AppsProcessService },
    { type: AppConfigService },
    { type: ProcessNamePipe }
];
StartProcessInstanceComponent.propDecorators = {
    appId: [{ type: Input }],
    title: [{ type: Input }],
    processDefinitionName: [{ type: Input }],
    variables: [{ type: Input }],
    values: [{ type: Input }],
    name: [{ type: Input }],
    showSelectProcessDropdown: [{ type: Input }],
    showSelectApplicationDropdown: [{ type: Input }],
    processFilterSelector: [{ type: Input }],
    start: [{ type: Output }],
    cancel: [{ type: Output }],
    error: [{ type: Output }],
    processDefinitionSelection: [{ type: Output }],
    applicationSelection: [{ type: Output }],
    startForm: [{ type: ViewChild, args: ['startForm',] }],
    inputAutocomplete: [{ type: ViewChild, args: [MatAutocompleteTrigger,] }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessFilterRequestRepresentation {
    constructor(obj) {
        this.processDefinitionId = obj && obj.processDefinitionId || null;
        this.appDefinitionId = obj && obj.appDefinitionId || null;
        this.state = obj && obj.state || null;
        this.sort = obj && obj.sort || null;
        this.page = obj && obj.page || 0;
        this.size = obj && obj.size || 25;
    }
}

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessListModule {
}
ProcessListModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    FlexLayoutModule,
                    FormsModule,
                    ReactiveFormsModule,
                    CoreModule,
                    TaskListModule,
                    PeopleModule,
                    ContentWidgetModule,
                    ProcessCommentsModule,
                    FormModule
                ],
                declarations: [
                    ProcessInstanceListComponent,
                    ProcessFiltersComponent,
                    ProcessInstanceDetailsComponent,
                    ProcessAuditDirective,
                    ProcessInstanceHeaderComponent,
                    ProcessInstanceTasksComponent,
                    StartProcessInstanceComponent
                ],
                exports: [
                    ProcessInstanceListComponent,
                    ProcessFiltersComponent,
                    ProcessInstanceDetailsComponent,
                    ProcessAuditDirective,
                    ProcessInstanceHeaderComponent,
                    ProcessInstanceTasksComponent,
                    StartProcessInstanceComponent
                ],
                providers: [
                    ProcessNamePipe
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AppsListComponent {
    constructor(appsProcessService, translationService) {
        this.appsProcessService = appsProcessService;
        this.translationService = translationService;
        this.layoutType = AppsListComponent.LAYOUT_GRID;
        this.appClick = new EventEmitter();
        this.error = new EventEmitter();
        this.appList = [];
        this.loading = false;
        this.hasEmptyCustomContentTemplate = false;
        this.onDestroy$ = new Subject();
        this.apps$ = new Observable((observer) => this.appsObserver = observer)
            .pipe(share());
    }
    ngOnInit() {
        if (!this.isValidType()) {
            this.setDefaultLayoutType();
        }
        this.apps$
            .pipe(takeUntil(this.onDestroy$))
            .subscribe((app) => this.appList.push(app));
        this.iconsMDL = new IconModel();
        this.load();
    }
    ngOnDestroy() {
        this.onDestroy$.next(true);
        this.onDestroy$.complete();
    }
    ngAfterContentInit() {
        if (this.emptyCustomContent) {
            this.hasEmptyCustomContentTemplate = true;
        }
    }
    load() {
        this.loading = true;
        this.appsProcessService
            .getDeployedApplications()
            .pipe(finalize(() => this.loading = false))
            .subscribe((res) => {
            this.filterApps(res).forEach((app) => {
                if (this.isDefaultApp(app)) {
                    app.theme = AppsListComponent.DEFAULT_TASKS_APP_THEME;
                    app.icon = AppsListComponent.DEFAULT_TASKS_APP_ICON;
                    this.appsObserver.next(app);
                }
                else if (app.deploymentId) {
                    this.appsObserver.next(app);
                }
            });
        }, (err) => {
            this.error.emit(err);
        });
    }
    isDefaultApp(app) {
        return app.defaultAppId === AppsListComponent.DEFAULT_TASKS_APP;
    }
    getAppName(app) {
        return this.isDefaultApp(app)
            ? this.translationService.get(AppsListComponent.DEFAULT_TASKS_APP_NAME)
            : of(app.name);
    }
    selectApp(app) {
        this.currentApp = app;
        this.appClick.emit(app);
    }
    isSelected(appId) {
        return (this.currentApp !== undefined && appId === this.currentApp.id);
    }
    filterApps(apps) {
        const filteredApps = [];
        if (this.filtersAppId) {
            apps.filter((app) => {
                this.filtersAppId.forEach((filter) => {
                    if (app.defaultAppId === filter.defaultAppId ||
                        app.deploymentId === filter.deploymentId ||
                        app.name === filter.name ||
                        app.id === filter.id ||
                        app.modelId === filter.modelId ||
                        app.tenantId === filter.tenantId) {
                        filteredApps.push(app);
                    }
                });
            });
        }
        else {
            return apps;
        }
        return filteredApps;
    }
    isValidType() {
        return this.layoutType && (this.layoutType === AppsListComponent.LAYOUT_LIST || this.layoutType === AppsListComponent.LAYOUT_GRID);
    }
    setDefaultLayoutType() {
        this.layoutType = AppsListComponent.LAYOUT_GRID;
    }
    isList() {
        return this.layoutType === AppsListComponent.LAYOUT_LIST;
    }
    isGrid() {
        return this.layoutType === AppsListComponent.LAYOUT_GRID;
    }
    isEmpty() {
        return this.appList.length === 0;
    }
    isLoading() {
        return this.loading;
    }
    getTheme(app) {
        return app.theme ? app.theme : '';
    }
    getBackgroundIcon(app) {
        return this.iconsMDL.mapGlyphiconToMaterialDesignIcons(app.icon);
    }
}
AppsListComponent.LAYOUT_LIST = 'LIST';
AppsListComponent.LAYOUT_GRID = 'GRID';
AppsListComponent.DEFAULT_TASKS_APP = 'tasks';
AppsListComponent.DEFAULT_TASKS_APP_NAME = 'ADF_TASK_LIST.APPS.TASK_APP_NAME';
AppsListComponent.DEFAULT_TASKS_APP_THEME = 'theme-2';
AppsListComponent.DEFAULT_TASKS_APP_ICON = 'glyphicon-asterisk';
AppsListComponent.DEFAULT_TASKS_APP_MATERIAL_ICON = 'favorite_border';
AppsListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-apps',
                template: "<div class=\"menu-container\" *ngIf=\"!isEmpty()\">\n    <mat-list *ngIf=\"isList()\" class=\"adf-app-list\">\n        <mat-list-item class=\"adf-app-list-item\" (click)=\"selectApp(app)\" (keyup.enter)=\"selectApp(app)\" *ngFor=\"let app of appList\" tabindex=\"0\" role=\"button\" title=\"{{app.name}}\">\n            <mat-icon matListIcon>touch_app</mat-icon>\n            <span matLine>{{getAppName(app) | async}}</span>\n        </mat-list-item>\n    </mat-list>\n    <div fxLayout=\"row wrap\" *ngIf=\"isGrid()\" class=\"adf-app-listgrid\">\n        <div *ngFor=\"let app of appList\"\n            class=\"adf-app-listgrid-item\"\n            fxFlex=\"33.33333%\" fxFlex.lt-md=\"50%\" fxFlex.lt-sm=\"100%\">\n                <mat-card tabindex=\"0\"\n                    fxLayout=\"column\"\n                    role=\"button\"\n                    class=\"adf-app-listgrid-item-card\"\n                    title=\"{{getAppName(app) | async}}\"\n                    [ngClass]=\"[getTheme(app)]\"\n                    (click)=\"selectApp(app)\"\n                    (keyup.enter)=\"selectApp(app)\">\n                        <div class=\"adf-app-listgrid-item-card-logo\">\n                            <mat-icon class=\"adf-app-listgrid-item-card-logo-icon\">{{getBackgroundIcon(app)}}</mat-icon>\n                        </div>\n                        <div mat-card-title class=\"adf-app-listgrid-item-card-title\">\n                            <h1>{{getAppName(app) | async}}</h1>\n                        </div>\n                        <mat-card-subtitle class=\"adf-app-listgrid-item-card-subtitle\" fxFlex=\"1 0 auto\">\n                            <div class=\"adf-line-clamp\">{{app.description}}</div>\n                        </mat-card-subtitle>\n\n                        <mat-card-actions class=\"adf-app-listgrid-item-card-actions\">\n                            <mat-icon class=\"adf-app-listgrid-item-card-actions-icon\" *ngIf=\"isSelected(app.id)\">done</mat-icon>\n                        </mat-card-actions>\n                </mat-card>\n        </div>\n    </div>\n</div>\n\n<ng-container *ngIf=\"isLoading(); else empty\">\n    <div class=\"adf-app-list-spinner\">\n        <mat-spinner></mat-spinner>\n    </div>\n</ng-container>\n\n<ng-template #empty>\n    <div class=\"adf-app-list-empty\" *ngIf=\"isEmpty()\">\n        <ng-content select=\"adf-custom-empty-content-template\" *ngIf=\"hasEmptyCustomContentTemplate; else defaultEmptyTemplate\" class=\"adf-custom-empty-template\"></ng-content>\n\n        <ng-template #defaultEmptyTemplate>\n            <adf-empty-content\n                icon=\"apps\"\n                [title]=\"'ADF_TASK_LIST.APPS.TITLE' | translate\"\n                [subtitle]=\"'ADF_TASK_LIST.APPS.SUBTITLE' | translate\">\n            </adf-empty-content>\n        </ng-template>\n    </div>\n</ng-template>\n",
                encapsulation: ViewEncapsulation.None,
                host: { class: 'adf-apps' },
                styles: [".adf-apps{width:100%}.adf-app-list-item{cursor:pointer}.adf-app-list-empty,.adf-app-list-spinner{align-items:center;display:flex;flex-direction:column;height:85vh;justify-content:center}.adf-app-list-empty .mat-spinner,.adf-app-list-spinner .mat-spinner{margin:0 auto}.adf-app-listgrid{padding:8px}.adf-app-listgrid-item{box-sizing:border-box;outline:none;padding:8px}.adf-app-listgrid-item-card{min-height:200px;outline:none;padding:0!important;transition:transform .28s cubic-bezier(.4,0,.2,1),box-shadow .28s cubic-bezier(.4,0,.2,1)}.adf-app-listgrid-item-card.theme-1{background-color:#269abc}.adf-app-listgrid-item-card.theme-2{background-color:#7da9b0}.adf-app-listgrid-item-card.theme-3{background-color:#7689ab}.adf-app-listgrid-item-card.theme-4{background-color:#c74e3e}.adf-app-listgrid-item-card.theme-5{background-color:#fab96c}.adf-app-listgrid-item-card.theme-6{background-color:#759d4c}.adf-app-listgrid-item-card.theme-7{background-color:#b1b489}.adf-app-listgrid-item-card.theme-8{background-color:#a17299}.adf-app-listgrid-item-card.theme-9{background-color:#696c67}.adf-app-listgrid-item-card.theme-10{background-color:#cabb33}.adf-app-listgrid-item-card:hover{box-shadow:0 8px 10px 1px rgba(0,0,0,.14),0 3px 14px 2px rgba(0,0,0,.12),0 5px 5px -3px rgba(0,0,0,.2);cursor:pointer;transform:scale(1.015)}.adf-app-listgrid-item-card-logo{padding:16px;position:absolute;right:20px;top:20px;z-index:9}.adf-app-listgrid-item-card-logo-icon{font-size:70px;height:1em!important;width:1em!important}.theme-1 .adf-app-listgrid-item-card-logo-icon{color:#168aac}.theme-2 .adf-app-listgrid-item-card-logo-icon{color:#6d99a0}.theme-3 .adf-app-listgrid-item-card-logo-icon{color:#66799b}.theme-4 .adf-app-listgrid-item-card-logo-icon{color:#b73e2e}.theme-5 .adf-app-listgrid-item-card-logo-icon{color:#eaa95c}.theme-6 .adf-app-listgrid-item-card-logo-icon{color:#658d3c}.theme-7 .adf-app-listgrid-item-card-logo-icon{color:#a1a479}.theme-8 .adf-app-listgrid-item-card-logo-icon{color:#916289}.theme-9 .adf-app-listgrid-item-card-logo-icon{color:#595c57}.theme-10 .adf-app-listgrid-item-card-logo-icon{color:#baab23}.adf-app-listgrid-item-card-title{margin-bottom:0!important;padding:16px;z-index:9999}.adf-app-listgrid-item-card-title h1{color:#fff;font-size:24px;line-height:normal;margin:0;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:80%}.adf-app-listgrid-item-card-subtitle{color:#fff;padding:16px;z-index:9999}.adf-app-listgrid-item-card-subtitle .adf-line-clamp{line-height:1.25;overflow:hidden;padding:0!important;position:relative;text-overflow:ellipsis}@supports (-webkit-line-clamp:1){.adf-app-listgrid-item-card-subtitle .adf-line-clamp{-webkit-box-orient:vertical;-webkit-line-clamp:3;display:-webkit-box;height:3.7125em}}@supports not (-webkit-line-clamp:1){.adf-app-listgrid-item-card-subtitle .adf-line-clamp{white-space:nowrap;width:100%}}.adf-app-listgrid-item-card-actions{border-top:1px solid rgba(0,0,0,.1);box-sizing:border-box;min-height:48px;padding:0 16px 16px!important}.adf-app-listgrid-item-card-actions-icon{color:#e9f1f3}.adf-app-listgrid-item-card-actions.mat-card-actions{margin-left:0;margin-right:0}.adf-app-listgrid-item-card-actions.mat-card-actions:last-child{margin-bottom:0!important}"]
            },] }
];
AppsListComponent.ctorParameters = () => [
    { type: AppsProcessService },
    { type: TranslationService }
];
AppsListComponent.propDecorators = {
    emptyCustomContent: [{ type: ContentChild, args: [CustomEmptyContentTemplateDirective,] }],
    layoutType: [{ type: Input }],
    filtersAppId: [{ type: Input }],
    appClick: [{ type: Output }],
    error: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class SelectAppsDialogComponent {
    constructor(appsProcessService, dialogRef, data) {
        this.appsProcessService = appsProcessService;
        this.dialogRef = dialogRef;
        this.data = data;
        this.appsProcessService.getDeployedApplications().subscribe((apps) => {
            this.processApps = apps.filter((currentApp) => {
                return currentApp.id;
            });
        });
    }
    onStart() {
        this.dialogRef.close(this.selectedProcess);
    }
}
SelectAppsDialogComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-select-apps-dialog',
                template: "<header mat-dialog-title id=\"adf-select-app-dialog-title\">{{'APP.DIALOG.TITLE' | translate}}</header>\n<section mat-dialog-content>\n\n    <mat-select id=\"adf-select-app-dialog-dropdown\" placeholder=\"{{'APP.DIALOG.LIST' | translate}}\" [(value)]=\"selectedProcess\" >\n        <mat-option *ngFor=\"let currentProcessApp of processApps\" [value]=\"currentProcessApp\">\n            {{ currentProcessApp.name }}\n        </mat-option>\n    </mat-select>\n\n</section>\n<footer mat-dialog-actions fxLayout=\"row\" fxLayoutAlign=\"end center\">\n    <button mat-button (click)=\"onStart()\">{{'APP.DIALOG.START' | translate}}</button>\n</footer>\n"
            },] }
];
SelectAppsDialogComponent.ctorParameters = () => [
    { type: AppsProcessService },
    { type: MatDialogRef },
    { type: undefined, decorators: [{ type: Inject, args: [MAT_DIALOG_DATA,] }] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AppsListModule {
}
AppsListModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CommonModule,
                    MaterialModule,
                    FlexLayoutModule,
                    CoreModule
                ],
                declarations: [
                    AppsListComponent,
                    SelectAppsDialogComponent
                ],
                exports: [
                    AppsListComponent,
                    SelectAppsDialogComponent
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class TaskAttachmentListComponent {
    constructor(activitiContentService, contentService, thumbnailService, ngZone) {
        this.activitiContentService = activitiContentService;
        this.contentService = contentService;
        this.thumbnailService = thumbnailService;
        this.ngZone = ngZone;
        this.disabled = false;
        this.attachmentClick = new EventEmitter();
        this.success = new EventEmitter();
        this.error = new EventEmitter();
        this.hasCustomTemplate = false;
        this.attachments = [];
        this.isLoading = false;
    }
    ngOnChanges(changes) {
        if (changes['taskId'] && changes['taskId'].currentValue) {
            this.loadAttachmentsByTaskId(changes['taskId'].currentValue);
        }
    }
    ngAfterContentInit() {
        if (this.emptyTemplate) {
            this.hasCustomTemplate = true;
        }
    }
    reset() {
        this.attachments = [];
    }
    hasCustomEmptyTemplate() {
        return !!this.emptyTemplate;
    }
    reload() {
        this.ngZone.run(() => {
            this.loadAttachmentsByTaskId(this.taskId);
        });
    }
    add(content) {
        this.ngZone.run(() => {
            this.attachments.push({
                id: content.id,
                name: content.name,
                created: content.created,
                createdBy: content.createdBy.firstName + ' ' + content.createdBy.lastName,
                icon: this.thumbnailService.getMimeTypeIcon(content.mimeType)
            });
        });
    }
    loadAttachmentsByTaskId(taskId) {
        if (taskId) {
            this.isLoading = true;
            this.reset();
            const isRelatedContent = 'true';
            this.activitiContentService.getTaskRelatedContent(taskId, { isRelatedContent }).subscribe((res) => {
                const attachList = [];
                res.data.forEach((content) => {
                    attachList.push({
                        id: content.id,
                        name: content.name,
                        created: content.created,
                        createdBy: content.createdBy.firstName + ' ' + content.createdBy.lastName,
                        icon: this.thumbnailService.getMimeTypeIcon(content.mimeType)
                    });
                });
                this.attachments = attachList;
                this.success.emit(this.attachments);
                this.isLoading = false;
            }, (err) => {
                this.error.emit(err);
                this.isLoading = false;
            });
        }
    }
    deleteAttachmentById(contentId) {
        if (contentId) {
            this.activitiContentService.deleteRelatedContent(contentId).subscribe(() => {
                this.attachments = this.attachments.filter((content) => {
                    return content.id !== contentId;
                });
            }, (err) => {
                this.error.emit(err);
            });
        }
    }
    isEmpty() {
        return this.attachments && this.attachments.length === 0;
    }
    onShowRowActionsMenu(event) {
        const viewAction = {
            title: 'ADF_TASK_LIST.MENU_ACTIONS.VIEW_CONTENT',
            name: 'view'
        };
        const removeAction = {
            title: 'ADF_TASK_LIST.MENU_ACTIONS.REMOVE_CONTENT',
            name: 'remove'
        };
        const downloadAction = {
            title: 'ADF_TASK_LIST.MENU_ACTIONS.DOWNLOAD_CONTENT',
            name: 'download'
        };
        event.value.actions = [
            viewAction,
            downloadAction
        ];
        if (!this.disabled) {
            event.value.actions.splice(1, 0, removeAction);
        }
    }
    onExecuteRowAction(event) {
        const args = event.value;
        const action = args.action;
        if (action.name === 'view') {
            this.emitDocumentContent(args.row.obj);
        }
        else if (action.name === 'remove') {
            this.deleteAttachmentById(args.row.obj.id);
        }
        else if (action.name === 'download') {
            this.downloadContent(args.row.obj);
        }
    }
    openContent(event) {
        const content = event.value.obj;
        this.emitDocumentContent(content);
    }
    emitDocumentContent(content) {
        this.activitiContentService.getContentPreview(content.id).subscribe((blob) => {
            content.contentBlob = blob;
            this.attachmentClick.emit(content);
        }, (err) => {
            this.error.emit(err);
        });
    }
    downloadContent(content) {
        this.activitiContentService.getFileRawContent(content.id).subscribe((blob) => this.contentService.downloadBlob(blob, content.name), (err) => {
            this.error.emit(err);
        });
    }
    isDisabled() {
        return this.disabled;
    }
}
TaskAttachmentListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-task-attachment-list',
                template: "<adf-datatable [rows]=\"attachments\"\n               [actions]=\"true\"\n               [loading]=\"isLoading\"\n               (rowDblClick)=\"openContent($event)\"\n               (showRowActionsMenu)=\"onShowRowActionsMenu($event)\"\n               (executeRowAction)=\"onExecuteRowAction($event)\">\n            <adf-no-content-template>\n                <ng-template>\n                    <ng-content *ngIf=\"hasCustomTemplate; else defaulEmptyList\" class=\"adf-custom-empty-template\"></ng-content>\n                    <ng-template #defaulEmptyList>\n                        <adf-empty-list>\n                            <div adf-empty-list-header class=\"adf-empty-list-header\">\n                                {{'ADF_TASK_LIST.ATTACHMENT.EMPTY.HEADER' | translate}}\n                            </div>\n                        </adf-empty-list>\n                    </ng-template>\n                </ng-template>\n            </adf-no-content-template>\n\n            <data-columns>\n                <data-column key=\"icon\" type=\"image\" srTitle=\"ADF_TASK_LIST.PROPERTIES.THUMBNAIL\" [sortable]=\"false\"></data-column>\n                <data-column key=\"name\" type=\"text\" title=\"ADF_TASK_LIST.PROPERTIES.NAME\" class=\"adf-full-width adf-ellipsis-cell\" [sortable]=\"true\"></data-column>\n                <data-column key=\"created\" type=\"date\" format=\"shortDate\" title=\"ADF_TASK_LIST.PROPERTIES.CREATED\"></data-column>\n            </data-columns>\n            <adf-loading-content-template>\n                <ng-template>\n                <!--Add your custom loading template here-->\n                    <mat-progress-spinner class=\"adf-attachment-list-loading-margin\" [color]=\"'primary'\" [mode]=\"'indeterminate'\">\n                    </mat-progress-spinner>\n                </ng-template>\n            </adf-loading-content-template>\n</adf-datatable>\n",
                encapsulation: ViewEncapsulation.None,
                styles: ["adf-datatable .adf-data-cell{cursor:pointer!important}.adf-attachment-list-loading-margin{margin-left:calc(50% - 50px);margin-right:calc(50% - 50px)}.adf-empty-list-header{font-size:24px;height:32px;letter-spacing:-1px;line-height:1.33;opacity:.26}.adf-empty-list-drag_drop{font-size:56px;letter-spacing:-2px;line-height:1;margin-top:40px;min-height:56px;opacity:.54;white-space:pre-line;word-break:break-all}@media screen and (max-width:599px){.adf-empty-list-drag_drop{font-size:40px}}.adf-empty-list__any-files-here-to-add{font-size:16px;letter-spacing:-.4px;line-height:1.5;margin-top:17px;min-height:24px;opacity:.54;white-space:pre-line;word-break:break-all}.adf-empty-list__empty_doc_lib{height:161px;margin-top:17px;max-width:100%;object-fit:contain;width:565px}@media screen and (max-width:599px){.adf-empty-list__empty_doc_lib{width:250px}}"]
            },] }
];
TaskAttachmentListComponent.ctorParameters = () => [
    { type: ProcessContentService },
    { type: ContentService },
    { type: ThumbnailService },
    { type: NgZone }
];
TaskAttachmentListComponent.propDecorators = {
    emptyTemplate: [{ type: ContentChild, args: [EmptyListComponent,] }],
    taskId: [{ type: Input }],
    disabled: [{ type: Input }],
    attachmentClick: [{ type: Output }],
    success: [{ type: Output }],
    error: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessAttachmentListComponent {
    constructor(activitiContentService, contentService, thumbnailService, ngZone) {
        this.activitiContentService = activitiContentService;
        this.contentService = contentService;
        this.thumbnailService = thumbnailService;
        this.ngZone = ngZone;
        this.disabled = false;
        this.attachmentClick = new EventEmitter();
        this.success = new EventEmitter();
        this.error = new EventEmitter();
        this.hasCustomTemplate = false;
        this.attachments = [];
        this.isLoading = false;
    }
    ngOnChanges(changes) {
        if (changes['processInstanceId'] && changes['processInstanceId'].currentValue) {
            this.loadAttachmentsByProcessInstanceId(changes['processInstanceId'].currentValue);
        }
    }
    ngAfterContentInit() {
        if (this.emptyTemplate) {
            this.hasCustomTemplate = true;
        }
    }
    reset() {
        this.attachments = [];
    }
    reload() {
        this.ngZone.run(() => {
            this.loadAttachmentsByProcessInstanceId(this.processInstanceId);
        });
    }
    hasCustomEmptyTemplate() {
        return !!this.emptyTemplate;
    }
    add(content) {
        this.ngZone.run(() => {
            this.attachments.push({
                id: content.id,
                name: content.name,
                created: content.created,
                createdBy: content.createdBy.firstName + ' ' + content.createdBy.lastName,
                icon: this.thumbnailService.getMimeTypeIcon(content.mimeType)
            });
        });
    }
    loadAttachmentsByProcessInstanceId(processInstanceId) {
        if (processInstanceId) {
            this.reset();
            this.isLoading = true;
            const isRelatedContent = 'true';
            this.activitiContentService.getProcessRelatedContent(processInstanceId, { isRelatedContent }).subscribe((res) => {
                res.data.forEach((content) => {
                    this.attachments.push({
                        id: content.id,
                        name: content.name,
                        created: content.created,
                        createdBy: content.createdBy.firstName + ' ' + content.createdBy.lastName,
                        icon: this.thumbnailService.getMimeTypeIcon(content.mimeType)
                    });
                });
                this.success.emit(this.attachments);
                this.isLoading = false;
            }, (err) => {
                this.error.emit(err);
                this.isLoading = false;
            });
        }
    }
    deleteAttachmentById(contentId) {
        if (contentId) {
            this.activitiContentService.deleteRelatedContent(contentId).subscribe(() => {
                this.attachments = this.attachments.filter((content) => {
                    return content.id !== contentId;
                });
            }, (err) => {
                this.error.emit(err);
            });
        }
    }
    isEmpty() {
        return this.attachments && this.attachments.length === 0;
    }
    onShowRowActionsMenu(event) {
        const viewAction = {
            title: 'ADF_PROCESS_LIST.MENU_ACTIONS.VIEW_CONTENT',
            name: 'view'
        };
        const removeAction = {
            title: 'ADF_PROCESS_LIST.MENU_ACTIONS.REMOVE_CONTENT',
            name: 'remove'
        };
        const downloadAction = {
            title: 'ADF_PROCESS_LIST.MENU_ACTIONS.DOWNLOAD_CONTENT',
            name: 'download'
        };
        event.value.actions = [
            viewAction,
            downloadAction
        ];
        if (!this.disabled) {
            event.value.actions.splice(1, 0, removeAction);
        }
    }
    onExecuteRowAction(event) {
        const args = event.value;
        const action = args.action;
        if (action.name === 'view') {
            this.emitDocumentContent(args.row.obj);
        }
        else if (action.name === 'remove') {
            this.deleteAttachmentById(args.row.obj.id);
        }
        else if (action.name === 'download') {
            this.downloadContent(args.row.obj);
        }
    }
    openContent(event) {
        const content = event.value.obj;
        this.emitDocumentContent(content);
    }
    emitDocumentContent(content) {
        this.activitiContentService.getContentPreview(content.id).subscribe((blob) => {
            content.contentBlob = blob;
            this.attachmentClick.emit(content);
        }, (err) => {
            this.error.emit(err);
        });
    }
    downloadContent(content) {
        this.activitiContentService.getFileRawContent(content.id).subscribe((blob) => this.contentService.downloadBlob(blob, content.name), (err) => {
            this.error.emit(err);
        });
    }
    isDisabled() {
        return this.disabled;
    }
}
ProcessAttachmentListComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-process-attachment-list',
                template: "<adf-datatable  [rows]=\"attachments\"\n                [actions]=\"true\"\n                [loading]=\"isLoading\"\n                (rowDblClick)=\"openContent($event)\"\n                (showRowActionsMenu)=\"onShowRowActionsMenu($event)\"\n                (executeRowAction)=\"onExecuteRowAction($event)\">\n\n                <adf-no-content-template>\n                    <ng-template>\n                        <ng-content *ngIf=\"hasCustomTemplate; else defaulEmptyList\" class=\"adf-custom-empty-template\"></ng-content>\n                        <ng-template #defaulEmptyList>\n                            <adf-empty-list>\n                                <div adf-empty-list-header class=\"adf-empty-list-header\">\n                                    {{'ADF_PROCESS_LIST.PROCESS-ATTACHMENT.EMPTY.HEADER' | translate}}\n                                </div>\n                            </adf-empty-list>\n                        </ng-template>\n                    </ng-template>\n                </adf-no-content-template>\n\n    <data-columns>\n        <data-column key=\"icon\" type=\"image\" srTitle=\"ADF_PROCESS_LIST.PROPERTIES.THUMBNAIL\" [sortable]=\"false\"></data-column>\n        <data-column key=\"name\" type=\"text\" title=\"{{'ADF_PROCESS_LIST.PROPERTIES.NAME' | translate}}\" class=\"adf-full-width adf-ellipsis-cell\" [sortable]=\"true\"></data-column>\n        <data-column key=\"created\" type=\"date\" format=\"shortDate\" title=\"{{'ADF_PROCESS_LIST.PROPERTIES.CREATED' | translate}}\"></data-column>\n    </data-columns>\n\n    <adf-loading-content-template>\n        <ng-template>\n            <!--Add your custom loading template here-->\n            <mat-progress-spinner class=\"adf-attachment-list-loading-margin\" [color]=\"'primary'\" [mode]=\"'indeterminate'\">\n            </mat-progress-spinner>\n        </ng-template>\n    </adf-loading-content-template>\n\n</adf-datatable>\n",
                encapsulation: ViewEncapsulation.None,
                styles: [".adf-data-cell{cursor:pointer!important}.adf-attachment-list-loading-margin{margin-left:calc(50% - 50px);margin-right:calc(50% - 50px)}.adf-empty-list-header{font-size:24px;height:32px;letter-spacing:-1px;line-height:1.33;opacity:.26!important}.adf-empty-list-drag_drop{font-size:56px;letter-spacing:-2px;line-height:1;margin-top:40px!important;min-height:56px;opacity:.54;white-space:pre-line;word-break:break-all}.adf-empty-list__any-files-here-to-add{font-size:16px;letter-spacing:-.4px;line-height:1.5;margin-top:17px;min-height:24px;opacity:.54;white-space:pre-line;word-break:break-all}.adf-empty-list__empty_doc_lib{height:161px;margin-top:17px;object-fit:contain;width:565px}@media screen and (max-width:599px){.adf-empty-list__empty_doc_lib{width:250px}}"]
            },] }
];
ProcessAttachmentListComponent.ctorParameters = () => [
    { type: ProcessContentService },
    { type: ContentService },
    { type: ThumbnailService },
    { type: NgZone }
];
ProcessAttachmentListComponent.propDecorators = {
    emptyTemplate: [{ type: ContentChild, args: [EmptyListComponent,] }],
    processInstanceId: [{ type: Input }],
    disabled: [{ type: Input }],
    attachmentClick: [{ type: Output }],
    success: [{ type: Output }],
    error: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class CreateProcessAttachmentComponent {
    constructor(activitiContentService) {
        this.activitiContentService = activitiContentService;
        this.error = new EventEmitter();
        this.success = new EventEmitter();
    }
    ngOnChanges(changes) {
        if (changes['processInstanceId'] && changes['processInstanceId'].currentValue) {
            this.processInstanceId = changes['processInstanceId'].currentValue;
        }
    }
    onFileUpload(event) {
        const filesList = event.detail.files.map((obj) => obj.file);
        for (const fileInfoObj of filesList) {
            const file = fileInfoObj;
            const opts = {
                isRelatedContent: true
            };
            this.activitiContentService.createProcessRelatedContent(this.processInstanceId, file, opts).subscribe((res) => {
                this.success.emit(res);
            }, (err) => {
                this.error.emit(err);
            });
        }
    }
}
CreateProcessAttachmentComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-create-process-attachment',
                template: "<button\n    id=\"add_new_process_content_button\"\n    color=\"primary\"\n    mat-button\n    mat-raised-button\n    mat-icon-button\n    class=\"adf-create-attachment\"\n    [adf-upload]=\"true\"\n    [mode]=\"['click']\"\n    [multiple]=\"true\"\n    (upload-files)=\"onFileUpload($event)\">\n    <mat-icon>add</mat-icon>\n</button>\n",
                styles: [".adf-create-attachment{display:inline-block;line-height:0;vertical-align:middle}"]
            },] }
];
CreateProcessAttachmentComponent.ctorParameters = () => [
    { type: ProcessContentService }
];
CreateProcessAttachmentComponent.propDecorators = {
    processInstanceId: [{ type: Input }],
    error: [{ type: Output }],
    success: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AttachmentComponent {
    constructor(activitiContentService) {
        this.activitiContentService = activitiContentService;
        this.error = new EventEmitter();
        this.success = new EventEmitter();
    }
    ngOnChanges(changes) {
        if (changes['taskId'] && changes['taskId'].currentValue) {
            this.taskId = changes['taskId'].currentValue;
        }
    }
    onFileUpload(event) {
        const filesList = event.detail.files.map((obj) => obj.file);
        for (const fileInfoObj of filesList) {
            const file = fileInfoObj;
            const opts = {
                isRelatedContent: true
            };
            this.activitiContentService.createTaskRelatedContent(this.taskId, file, opts).subscribe((res) => {
                this.success.emit(res);
            }, (err) => {
                this.error.emit(err);
            });
        }
    }
}
AttachmentComponent.decorators = [
    { type: Component, args: [{
                selector: 'adf-create-task-attachment',
                template: "<button\n    color=\"primary\"\n    mat-button\n    mat-raised-button\n    mat-icon-button\n    class=\"adf-create-attachment\"\n    [adf-upload]=\"true\"\n    [mode]=\"['click']\"\n    [multiple]=\"true\"\n    (upload-files)=\"onFileUpload($event)\">\n    <mat-icon>add</mat-icon>\n</button>\n",
                styles: [".adf-create-attachment{display:inline-block;line-height:0;vertical-align:middle}"]
            },] }
];
AttachmentComponent.ctorParameters = () => [
    { type: ProcessContentService }
];
AttachmentComponent.propDecorators = {
    taskId: [{ type: Input }],
    error: [{ type: Output }],
    success: [{ type: Output }]
};

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class AttachmentModule {
}
AttachmentModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CoreModule,
                    MaterialModule
                ],
                declarations: [
                    TaskAttachmentListComponent,
                    ProcessAttachmentListComponent,
                    CreateProcessAttachmentComponent,
                    CreateProcessAttachmentComponent,
                    AttachmentComponent
                ],
                exports: [
                    TaskAttachmentListComponent,
                    ProcessAttachmentListComponent,
                    CreateProcessAttachmentComponent,
                    CreateProcessAttachmentComponent,
                    AttachmentComponent
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
class ProcessServicesPipeModule {
}
ProcessServicesPipeModule.decorators = [
    { type: NgModule, args: [{
                declarations: [
                    ProcessNamePipe
                ],
                exports: [
                    ProcessNamePipe
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
const ɵ0$2 = {
    name: 'adf-process-services',
    source: 'assets/adf-process-services'
};
class ProcessModule {
    static forRoot() {
        return {
            ngModule: ProcessModule,
            providers: [
                {
                    provide: TRANSLATION_PROVIDER,
                    multi: true,
                    useValue: {
                        name: 'adf-process-services',
                        source: 'assets/adf-process-services'
                    }
                },
                FormRenderingService,
                { provide: FormRenderingService, useClass: ProcessFormRenderingService }
            ]
        };
    }
    static forChild() {
        return {
            ngModule: ProcessModule
        };
    }
}
ProcessModule.decorators = [
    { type: NgModule, args: [{
                imports: [
                    CoreModule,
                    CommonModule,
                    ProcessCommentsModule,
                    FormsModule,
                    ReactiveFormsModule,
                    MaterialModule,
                    ProcessListModule,
                    TaskListModule,
                    AppsListModule,
                    AttachmentModule,
                    PeopleModule,
                    FormModule,
                    ProcessServicesPipeModule
                ],
                providers: [
                    {
                        provide: TRANSLATION_PROVIDER,
                        multi: true,
                        useValue: ɵ0$2
                    }
                ],
                exports: [
                    CommonModule,
                    ProcessCommentsModule,
                    FormsModule,
                    ReactiveFormsModule,
                    ProcessListModule,
                    TaskListModule,
                    AppsListModule,
                    AttachmentModule,
                    PeopleModule,
                    FormModule,
                    ProcessServicesPipeModule
                ]
            },] }
];

/*!
 * @license
 * Copyright 2019 Alfresco Software, Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

export { AppDefinitionRepresentationModel, AppsListComponent, AppsListModule, AttachFileWidgetComponent, AttachFileWidgetDialogComponent, AttachFileWidgetDialogService, AttachFolderWidgetComponent, AttachFormComponent, AttachmentComponent, AttachmentModule, ChecklistComponent, ClaimTaskDirective, ContentWidgetModule, CreateProcessAttachmentComponent, FilterParamsModel, FilterProcessRepresentationModel, FilterRepresentationModel, Form, FormComponent, FormCustomOutcomesComponent, FormModule, MaterialModule, NoTaskDetailsTemplateDirective, PeopleComponent, PeopleListComponent, PeopleModule, PeopleSearchActionLabelDirective, PeopleSearchComponent, PeopleSearchFieldComponent, PeopleSearchTitleDirective, PeopleSelectorComponent, ProcessAttachmentListComponent, ProcessAuditDirective, ProcessCommentsComponent, ProcessCommentsModule, ProcessDefinitionRepresentation, ProcessFilterParamRepresentationModel, ProcessFilterRequestRepresentation, ProcessFilterService, ProcessFiltersComponent, ProcessFormRenderingService, ProcessInstance, ProcessInstanceDetailsComponent, ProcessInstanceHeaderComponent, ProcessInstanceListComponent, ProcessInstanceTasksComponent, ProcessInstanceVariable, ProcessListModule, ProcessModule, ProcessNamePipe, ProcessService, ProcessServicesPipeModule, ProcessUploadService, SelectAppsDialogComponent, StartFormComponent, StartProcessInstanceComponent, StartTaskComponent, StartTaskModel, TaskAttachmentListComponent, TaskAuditDirective, TaskDetailsComponent, TaskDetailsEvent, TaskDetailsModel, TaskFilterService, TaskFiltersComponent, TaskFormComponent, TaskHeaderComponent, TaskListComponent, TaskListModel, TaskListModule, TaskListService, TaskQueryRequestRepresentationModel, TaskStandaloneComponent, TaskUploadService, UnclaimTaskDirective, ɵ0 };
//# sourceMappingURL=adf-process-services.js.map
